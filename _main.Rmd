---
knit: "bookdown::render_book"
title: "Cẩm nang dịch tễ học với R"  
description: "The Epi R Handbook is a R reference manual for applied epidemiology and public health."
author: "the handbook team"
date: "`r Sys.Date()`"
#url: 'https://github.com/nsbatra/Epi_R_handbook'
#twitter-handle: 
#cover-image: images/R_Handbook_Logo.png
site: bookdown::bookdown_site
# output: bookdown::gitbook:
#      config:
#           sharing:
#                twitter: yes
#                facebook: yes
#                whatsapp: yes
#                github: yes
documentclass: book
---

#  {.unnumbered}

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Epi R Handbook Banner Vietnamese 1500x500.png"))
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<meta name="description" content="The Epi R Handbook is an R reference manual for applied epidemiology and public health.">

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<!-- <span style="color: red;">**THIS IS A DRAFT.  REVIEWERS GIVE FEEDBACK AT THIS [LINK](https://forms.gle/4RNdRRLGx67xW9yq9)**.</span> -->

<!-- <span style="color: darkgreen;">**DO YOU LIKE THIS HANDBOOK? SHOULD SOMETHING BE CHANGED? PLEASE TELL US!**</span> -->

<!-- <form target="_blank" action="https://forms.gle/A5SnRVws7tPD15Js9"> -->

<!--     <input type="submit" value="FEEDBACK" /> -->

<!-- </form> -->

<!-- ======================================================= -->

<!-- ## An R reference manual for applied epidemiology and public health {.unnumbered} -->

<!-- <span style="color: brown;">**The Epi R Handbook is an R reference manual for applied epidemiology and public health.**</span> -->

<!-- ## About this handbook   -->

## Dịch tễ học ứng dụng và y tế công cộng với R {.unnumbered}

**Sổ tay này hướng tới:**

-   Là một tài liệu tham khảo R một cách nhanh chóng\
-   Cung cấp các ví dụ tập trung vào nhiệm vụ giải quyết các vấn đề dịch tễ học phổ biến\
-   Hỗ trợ các nhà dịch tễ học chuyển sang sử dụng R\
-   Có thể sử dụng trong các tình huống có kết nối internet thấp thông qua **[phiên bản ngoại tuyến][Tải sách và dữ liệu]**

<!-- * Use practical epi examples - cleaning case linelists, making transmission chains and epidemic curves, automated reports and dashboards, modeling incidence and making projections, demographic pyramids and rate standardization, record matching, outbreak detection, survey analysis, survival analysis, GIS basics, contact tracing, phylogenetic trees...   -->

<!-- **How is this different than other R books?**   -->

<!-- * It is community-driven - *written for epidemiologists by epidemiologists* in their spare time and leveraging experience in local, national, academic, and emergency settings   -->

<!-- Dual-column created based on the rmarkdown cookbook here: https://bookdown.org/yihui/rmarkdown-cookbook/multi-column.html -->

<br>

::: {style="display: flex;"}
<div>

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "epiRhandbook_HexSticker_500x500.png"))
```

</div>

::: {.col data-latex="{0.05\\textwidth}"}
  <!-- an empty Div (with a white space), serving as
a column separator -->
:::

<div>

[**Được viết bởi các nhà dịch tễ học, dành cho các nhà dịch tễ học**]{style="color: black;"}

Chúng tôi là những nhà dịch tễ học đến từ khắp mọi nơi trên thế giới, viết trong thời gian rảnh của mình để cung cấp tài liệu này tới cộng đồng. Sự động viên và góp ý của bạn luôn được chào đón thông qua:

-   Gửi [**biểu mẫu phản hồi**](https://forms.gle/A5SnRVws7tPD15Js9)\
-   Email tới [**epiRhandbook\@gmail.com**](mailto:epiRhandbook@gmail.com){.email} hoặc tweet [**\@epiRhandbook**](https://twitter.com/epirhandbook)\
-   Gửi các vấn đề cho chúng tôi tại [**Github repository**](https://github.com/appliedepi/epirhandbook_eng)

</div>
:::

<!-- ======================================================= -->

## Sổ tay này được sử dụng như thế nào {.unnumbered}

-   Truy cập các trang trong phần Mục lục, hoặc sử dụng ô tìm kiếm
-   Nhấn biểu tượng "copy" để sao chép code\
-   Kết hợp theo dõi cùng với các bộ [dữ liệu minh họa][Tải sách và dữ liệu]\
-   Xem phần "Tài nguyên" trong từng chương để tìm thêm tài liệu

**Phiên bản ngoại tuyến**

Xem hướng dẫn tại trang [Tải sách và dữ liệu].

<!-- ======================================================= -->

## Lời cảm ơn {.unnumbered}

Sổ tay này được tạo ra bởi sự hợp tác của các nhà dịch tễ học từ khắp nơi trên thế giới, đúc kết kinh nghiệm cùng với các tổ chức khác bao gồm các cơ quan y tế địa phương, tiểu bang, tỉnh và quốc gia, Tổ chức Y tế Thế giới (WHO), Tổ chức Bác sỹ không biên giới (MSF), hệ thống các bệnh viện, và các đơn vị nghiên cứu.

Sổ tay này **không phải** là sản phẩm đã được phê duyệt của bất kỳ tổ chức cụ thể nào. Mặc dù chúng tôi cố gắng đảm bảo tính chính xác, nhưng chúng tôi không chịu trách nhiệm về nội dung trong cuốn sách này.

### Những người đóng góp {.unnumbered}

**Chủ biên:** [Neale Batra](https://www.linkedin.com/in/neale-batra/)

**Nhóm nòng cốt dự án:** [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Amrish Baidjoe](https://twitter.com/Ammer_B), Pat Keating, [Henry Laurenson-Schafer](https://github.com/henryls1), [Finlay Campbell](https://github.com/finlaycampbell)

**Nhóm tác giả**: [Neale Batra](https://www.linkedin.com/in/neale-batra/), [Alex Spina](https://github.com/aspina7), [Paula Blomquist](https://www.linkedin.com/in/paula-bianca-blomquist-53188186/), [Finlay Campbell](https://github.com/finlaycampbell), [Henry Laurenson-Schafer](https://github.com/henryls1), [Isaac Florence](www.Twitter.com/isaacatflorence), [Natalie Fischer](https://www.linkedin.com/in/nataliefischer211/), [Aminata Ndiaye](https://twitter.com/aminata_fadl), [Liza Coyer](https://www.linkedin.com/in/liza-coyer-86022040/), [Jonathan Polonsky](https://twitter.com/jonny_polonsky), [Yurie Izawa](https://ch.linkedin.com/in/yurie-izawa-a1590319), [Chris Bailey](https://twitter.com/cbailey_58?lang=en), [Daniel Molling](https://www.linkedin.com/in/daniel-molling-4005716a/), [Isha Berry](https://twitter.com/ishaberry2), [Emma Buajitti](https://twitter.com/buajitti), [Mathilde Mousset](https://mathildemousset.wordpress.com/research/), [Sara Hollis](https://www.linkedin.com/in/saramhollis/), Wen Lin

**Nhóm dịch giả**: [Nguyễn Thanh Lương](https://www.linkedin.com/in/ntluong95/), [Nguyễn Thị Khánh Huyền](https://www.linkedin.com/in/huyen-nguyen-3920b51a6/), Võ Hữu Thuận, Nguyễn Trung Thành, Vũ Thu Hà, [Hồ Hoàng Dung](https://www.linkedin.com/in/dzunggg/)

**Nhóm phản biện**: Pat Keating, Annick Lenglet, Margot Charette, Danielly Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Kate Kelsey, [Berhe Etsay](https://www.linkedin.com/in/berhe-etsay-5752b1154/), John Rossow, Mackenzie Zendt, James Wright, Laura Haskins, [Flavio Finger](ffinger.github.io), Tim Taylor, [Jae Hyoung Tim Lee](https://www.linkedin.com/in/jaehyoungtlee/), [Brianna Bradley](https://www.linkedin.com/in/brianna-bradley-bb8658155), [Wayne Enanoria](https://www.linkedin.com/in/wenanoria), Manual Albela Miranda, [Molly Mantus](https://www.linkedin.com/in/molly-mantus-174550150/), Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga

**Hình minh họa**: Calder Fong

<!-- **Editor-in-Chief:** Neale Batra  -->

<!-- **Project core team:** Neale Batra, Alex Spina, Amrish Baidjoe, Pat Keating, Henry Laurenson-Schafer, Finlay Campbell   -->

<!-- **Authors**: Neale Batra, Alex Spina, Paula Blomquist, Finlay Campbell, Henry Laurenson-Schafer, [Isaac Florence](www.Twitter.com/isaacatflorence), Natalie Fischer, Aminata Ndiaye, Liza Coyer, Jonathan Polonsky, Yurie Izawa, Chris Bailey, Daniel Molling, Isha Berry, Emma Buajitti, Mathilde Mousset, Sara Hollis, Wen Lin   -->

<!-- **Reviewers**: Pat Keating, Mathilde Mousset, Annick Lenglet, Margot Charette, Isha Berry, Paula Blomquist, Natalie Fischer, Daniely Xavier, Esther Kukielka, Michelle Sloan, Aybüke Koyuncu, Rachel Burke, Daniel Molling, Kate Kelsey, Berhe Etsay, John Rossow, Mackenzie Zendt, James Wright, Wayne Enanoria, Laura Haskins, Flavio Finger, Tim Taylor, Jae Hyoung Tim Lee, Brianna Bradley, Manual Albela Miranda, Molly Mantus, Priscilla Spencer, Pattama Ulrich, Joseph Timothy, Adam Vaughan, Olivia Varsaneux, Lionel Monteiro, Joao Muianga   -->

### Tài trợ và hỗ trợ {.unnumbered}

Sổ tay này nhận được tài trợ thông qua kinh phí hỗ trợ trợ xây dựng năng lực khẩn cấp COVID-19 từ [TEPHINET](https://www.tephinet.org/), mạng lưới toàn cầu của các Chương trình Đào tạo Dịch tễ học Thực địa (FETPs).

Các hỗ trợ hành chính được cung cấp bởi mạng lưới cựu sinh EPIET ([EAN](https://epietalumni.net/)), với lời cảm ơn đặc biệt tới Annika Wendland. EPIET là Chương trình đào tạo Dịch tễ học can thiệp tại Châu Âu.

Đặc biệt gửi lời cảm ơn tới Trung tâm Điều hành Amsterdam (OCA) của Tổ chức Bác sỹ không biên giới (MSF) cho những sự hỗ trợ của họ trong quá trình phát triển cuốn sổ tay này.

*Ấn phẩm này được hỗ trợ bởi Hợp đồng Hợp tác số NU2GGH001873, được tài trợ bởi Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh thông qua TEPHINET, một chương trình của Lực lượng đặc nhiệm về sức khỏe toàn cầu. Nội dung của sổ tay hoàn toàn do tác giả chịu trách nhiệm và đại diện cho quan điểm chính thức của Trung tâm Kiểm soát và Phòng ngừa Dịch bệnh, Bộ Y tế và Dịch vụ Nhân sinh, Lực lượng Đặc nhiệm về Sức khỏe Toàn cầu, hoặc TEPHINET*

### Cảm hứng {.unnumbered}

Rất nhiều các hướng dẫn và tóm tắt cung cấp kiến thức sử dụng để phát triển nội dung sổ tay này được tham khảo trong các trang nội dung tương ứng.

Một cách tổng quát hơn, các nguồn sau đây đã truyền nguồn cảm hứng cho cuốn sổ tay này:\
[The "R4Epis" project](https://r4epis.netlify.app/) (một sự hợp tác giữa MSF và RECON)\
[R Epidemics Consortium (RECON)](https://www.repidemicsconsortium.org/)\
[R for Data Science book (R4DS)](https://r4ds.had.co.nz/)\
[bookdown: Authoring Books and Technical Documents with R Markdown](https://bookdown.org/yihui/bookdown/)\
[Netlify](https://www.netlify.com) để lưu trữ trang web này

<!-- ### Image credits {-}   -->

<!-- Images in logo from US CDC Public Health Image Library) include [2013 Yemen looking for mosquito breeding sites](https://phil.cdc.gov/Details.aspx?pid=19623), [Ebola virus](https://phil.cdc.gov/Details.aspx?pid=23186), and [Survey in Rajasthan](https://phil.cdc.gov/Details.aspx?pid=19838).   -->

## Điều khoản sử dụng và đóng góp {.unnumbered}

### Giấy phép {.unnumbered}

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" alt="Creative Commons License" style="border-width:0"/></a><br />Sổ tay này được cấp phép theo <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License</a>.

Chúng tôi khuyến khích các khóa học và các chương trình đào tạo dịch tễ sử dụng cuốn sổ tay này cho sinh viên của mình. Nếu bạn có thắc mắc về mục đích sử dụng của mình, hãy gửi email tới [**epiRhandbook\@gmail.com**](mailto:epiRhandbook@gmail.com){.email}.

### Trích dẫn {.unnumbered}

Neale Batra và cộng sự, Cẩm nang Dịch tễ học với R. <a rel="license" href="https://zenodo.org/badge/231610102.svg"><img src="https://zenodo.org/badge/231610102.svg" alt="DOI" style="border-width:0"/></a><br />

### Đóng góp {.unnumbered}

Nếu bạn muốn đóng góp nội dung, vui lòng liên hệ với chúng tôi thông qua Github hoặc email. Chúng tôi đang triển khai lịch trình cập nhật cho cuốn sách cũng như xây dựng hướng dẫn dành cho cộng tác viên.

Xin lưu ý rằng dự án epiRhandbook được phát hành cùng với bộ [Quy tắc ứng xử của cộng tác viên](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). Bằng cách đóng góp cho dự án này, bạn đồng ý tuân theo các điều khoản của nó.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:index.Rmd-->

# (PART) Về cuốn sách này {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_about_book.Rmd-->

# Biên tập và ghi chú kỹ thuật {#editorial-style}

Trong chương này, chúng tôi sẽ mô tả triết lý và phong cách viết code, cũng như các quyết định biên tập cụ thể được thực hiện trong việc tạo ra cuốn sổ tay này.

## Cách tiếp cận và phong cách

Độc giả tiềm năng của cuốn sách này là rất lớn, bao gồm những người hoàn toàn mới đối với R, và cả những người dùng R có kinh nghiệm đang tìm kiếm cho mình các phương pháp và mẹo hay nhất. Vì vậy, cuốn sách cần phải vừa dễ tiếp cận vừa ngắn gọn. Do đó, cách tiếp cận của chúng tôi là cung cấp lượng văn bản giải thích *vừa đủ* để một người mới sử dụng R cũng có thể áp dụng code và hiểu code đang làm gì.

Một vài điểm lưu ý:

-   Đây là cuốn sách tham khảo về code đi kèm với những ví dụ tương đối ngắn gọn - *không phải* một cuốn sách giáo khoa về R hay khoa học dữ liệu\
-   Đây là một cuốn *sổ tay về R* sử dụng trong dịch tễ học ứng dụng - không phải là một hướng dẫn về các phương pháp của dịch tễ học ứng dụng\
-   Cuốn sách dự kiến sẽ luôn được thay đổi và cập nhập do các R packages tối ưu cho một nhiệm vụ luôn được thay đổi thường xuyên, vì vậy chúng tôi hoan nghênh những thảo luận về những điều được nhấn mạnh trong cuốn sách này

### R packages {.unnumbered}

**Quá nhiều lựa chọn**

Một trong những khía cạnh thách thức nhất của việc học R là bạn biết package nào được sử dụng trong trường hợp nào. Việc vật lộn với một công việc mà chỉ sau này bạn nhận ra là có một package R giúp bạn thực hiện tất cả những điều đó trong một dòng lệnh là điều không hề hiếm gặp!

Trong sổ tay này, chúng tôi cố gắng cung cấp cho bạn ít nhất hai cách để hoàn thành công việc: một phương pháp đã thử và đúng (có thể là **base** R hoặc **tidyverse**) và một R package đặc biệt được thiết kế riêng cho mục đích đó. Chúng tôi muốn bạn có một số tùy chọn trong trường hợp bạn không thể tải xuống một package nhất định hoặc package đó không hoạt động với bạn.

Khi lựa chọn package để làm việc, chúng tôi ưu tiên các R package và phương pháp tiếp cận đã được cộng đồng thử nghiệm và hiệu chỉnh, giảm thiểu số lượng package được sử dụng trong một phiên làm việc điển hình, bao gồm sự ổn định (không thay đổi thường xuyên) và giúp hoàn thành nhiệm vụ một cách đơn giản và gọn gàng

Cuốn sách này ưu tiện các package và câu lệnh từ thư viện **tidyverse**. Tidyverse là một tuyển tập các R package được thiết kế dành riêng cho khoa học dữ liệu, trong đó các package này chia sẻ nền tảng ngữ pháp và cấu trúc dữ liệu chung. Tất cả các package từ thư viện tidyverse có thể được cài đặt hoặc gọi thông qua thư viện **tidyverse**. Đọc thêm tại [tidyverse website](https://www.tidyverse.org/).

Khi thích hợp, chúng tôi cũng cung cấp các tùy chọn code sử dụng **base** R - là các packages và hàm có sẵn của R khi cài đặt. Điều này là do chúng tôi nhận thấy rằng một số độc giả của cuốn sách này có thể không có Internet tốt để tải xuống các package bổ sung.

**Liên kết các hàm và packages một cách rõ ràng**

Trong các hướng dẫn về R thường rất khó chịu khi một hàm được hiển thị trong code, nhưng bạn không biết hàm đó đến từ package nào! Chúng tôi cố gắng tránh tình trạng này.

Trong các đoạn văn bản trần thuật, tên các package được viết in đậm (ví dụ: **dplyr**) và các hàm được viết như sau: `mutate()`. Chúng tôi cố gắng nói rõ ràng về một hàm đến từ package nào, bằng cách tham chiếu package đó trong đoạn văn bản gần đó hoặc nhấn mạnh package đó một cách rõ ràng trong đoạn code như sau: `dplyr::mutate()`. Điều này nhìn có vẻ thừa thãi, nhưng chúng tôi làm điều đó là có mục đích.

Tham khảo thêm chương [R cơ bản] để hiểu thêm về package và hàm.

### Phong cách viết code {.unnumbered}

Trong sổ tay này, chúng tôi thường viết theo phong cách "thêm dòng mới", điều này làm cho code trông có vẻ "dài hơn". Chúng tôi làm vậy vì một vài lý do sau đây:

-   Chúng tôi có thể viết các giải thích bằng `#` bên cạnh mỗi phần nhỏ của code\
-   Nhìn chung, code dài hơn (theo chiều dọc) thì dễ đọc hơn\
-   Nó cũng dễ đọc hơn trong một diện tích màn hình hẹp (không cần kéo thanh điều hướng trái phải)\
-   Từ việc thụt lề, có thể dễ dàng hơn để biết arguments nào thuộc về hàm nào

Kết quả là, code *lẽ ra* sẽ được viết trông như thế này:

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>%  # group rows by hospital
  slice_max(date, n = 1, with_ties = F) # if there's a tie (of date), take the first row
```

...bây giờ sẽ được viết như thế này:

```{r, eval=F}
linelist %>% 
  group_by(hospital) %>% # group rows by hospital
  slice_max(
    date,                # keep row per group with maximum date value 
    n = 1,               # keep only the single highest row 
    with_ties = F)       # if there's a tie (of date), take the first row
```

Code R thường không bị ảnh hưởng bởi thêm các dòng mới hoặc thụt lề. Khi viết code, nếu bạn xuống dòng ngay sau dấu phẩy thì R sẽ tự động thụt lề cho bạn.

Chúng tôi cũng sử dụng rất nhiều những khoảng cách (ví dụ `n = 1` thay vì `n=1`) vì nó giúp dễ đọc hơn. Hãy văn minh với những người đang đọc code của bạn!

### Danh pháp {.unnumbered}

Trong sổ tay này, chúng tôi thường đề cập đến "cột" và "hàng" thay vì dùng "biến" và "quan sát". Như đã giải thích trong phần sơ lược về ["tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html), hầu hết các bộ dữ liệu thống kê dịch tễ học bao gồm các hàng, cột và giá trị theo cấu trúc

*Biến số* chứa các giá trị đo lường của cùng một thuộc tính (như nhóm tuổi, kết cục hoặc ngày khởi phát). *Các quan sát* bao gồm tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó được định nghĩa một cách cụ thể.

Trong một bộ dữ liệu "tidy", mỗi cột là một biến số, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, bạn có thể gặp một số bộ dữ liệu không phù hợp với quy luật này - bộ dữ liệu định dạng "ngang" có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương Pivoting dữ liệu). Tương tự như vậy, các quan sát có thể được trải thành nhiều hàng.

Phần lớn cuốn sách này tập trung vào quản lý và biến đổi dữ liệu, vì vậy việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ liên quan hơn là đề cập tới các khái niệm trừu tượng như các quan sát và biến. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, ở đó chúng tôi đề cập nhiều hơn đến các biến số và quan sát.

### Lưu ý {.unnumbered}

Dưới đây là một vài lưu ý bạn có thể gặp trong cuốn sách:

[***GHI CHÚ:*** Đây là ghi chú]{style="color: black;"}\
[***MẸO:*** Đây là mẹo.]{style="color: darkgreen;"}\
[***CẨN TRỌNG:*** Đây là ghi chú cẩn trọng.]{style="color: orange;"}\
[***NGUY HIỂM:*** Đây là một cảnh báo.]{style="color: red;"}

## Quyết định biên tập

Dưới đây, chúng tôi ghi lại các quyết định biên tập quan trọng về việc lựa chọn package và hàm. Nếu bạn không đồng ý hoặc muốn đưa ra một công cụ mới để xem xét, vui lòng tham gia/bắt đầu cuộc thảo luận trên [Trang Github](https://github.com/appliedepi/epirhandbook_eng) của chúng tôi.

**Bảng các package, hàm, và các quyết định biên tập khác**

+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Chủ đề                    | Cân nhắc                                                                       | Lựa chọn                                                                                                           | Lý do ngắn gọn                                                                       |
+===========================+================================================================================+====================================================================================================================+======================================================================================+
| Phương pháp code chung    | **tidyverse**, **data.table**, **base**                                        | **tidyverse**, với 1 chương về **data.table**, các giải pháp thay thế từ **base** R cho người đọc không có internet | **tidyverse** dễ đọc, phổ biến, được dạy nhiều nhất                                  |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Gọi Package               | `library()`,`install.packages()`, `require()`, **pacman**                      | **pacman**                                                                                                         | Rút ngắn và đơn giản hóa code cho hầu hết các trường hợp cài đặt / tải nhiều package |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Nhập và xuất              | **rio**, và các package khác                                                   | **rio**                                                                                                            | Dễ dàng cho nhiều kiểu file                                                          |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Nhóm để tổng hợp thống kê | **dplyr** `group_by()`, **stats** `aggregate()`                                | **dplyr** `group_by()`                                                                                             | Thống nhất với **tidyverse**                                                         |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Pivoting                  | **tidyr** (các hàm pivot), **reshape2** (melt/cast), **tidyr** (spread/gather) | **tidyr** (các hàm pivot)                                                                                          | **reshape2** đã nghỉ hưu **tidyr** sử dụng các hàm pivot ở phiên bản v1.0.0          |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Làm sạch tên cột          | **linelist**, **janitor**                                                      | **janitor**                                                                                                        | Hợp nhất các package được nhắc đến                                                   |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Epiweeks                  | **lubridate**, **aweek**, **tsibble**, **zoo**                                 | thông thường là **lubridate** ,các package khác tùy trường hợp cụ thể                                             | **lubridate** dễ đọc, có tính nhất quán, và triển vọng bảo trì gói                  |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Nhãn ggplot               | `labs()`, `ggtitle()`/`ylab()`/`xlab()`                                        | `labs()`                                                                                                           | tất cả các nhãn ở một nơi, đơn giản                                                  |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Chuyển sang factor        | `factor()`, **forcats**                                                        | **forcats**                                                                                                        | các hàm khác nhau của nó cũng chuyển đổi thành factor trong cùng một lệnh            |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Đường cong dịch bệnh      | **incidence**, **ggplot2**, **EpiCurve**                                       | **incidence2** thì nhanh, **ggplot2** thì chi tiết                                                                 | tùy theo                                                                             |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+
| Sự kết hợp                | `paste()`, `paste0()`, `str_glue()`, `glue()`                                  | `str_glue()`                                                                                                       | Nhiều cú pháp đơn giản hơn hàm paste; nằm bên trong **stringr**                      |
+---------------------------+--------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------+

## Các bản sửa đổi chính

| Ngày              | Thay đổi chính            |
|-------------------|---------------------------|
| 10 Tháng Năm 2021 | Phát hành phiên bản 1.0.0 |

## Thông tin phiên làm việc (R, RStudio, packages)

Dưới đây là thông tin về các phiên bản của các R package, RStudio và R được sử dụng trong quá trình rendering cuốn sách này.

```{r}
sessioninfo::session_info()
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/editorial_style.Rmd-->

# Tải sách và dữ liệu {#data-used}

<!-- Note to self: If you want to create a download link to Github, right-click the "View Raw" button on Github, copy the address, and use that in the HTML below. -->

## Tải sách ngoại tuyến

Bạn có thể tải xuống phiên bản ngoại tuyến của sổ tay này dưới dạng tệp HTML để có thể xem trong trình duyệt web của mình ngay cả khi bạn không có kết nối internet. Nếu bạn đang cân nhắc việc sử dụng ngoại tuyến Sổ tay Epi R, dưới đây là một số điều bạn cần cân nhắc:

-   Khi bạn mở tệp, có thể mất một đến hai phút để tải các hình ảnh và mục lục\
-   Phiên bản ngoại tuyến có bố cục hơi khác so với phiên bản trực tuyến - là một trang rất dài với Mục lục ở phía bên trái. Để tìm kiếm các cụm từ cụ thể, hãy sử dụng Ctrl + F (Cmd-f)\
-   Xem chương [Package đề xuất] để hỗ trợ bạn cài đặt các R package thích hợp trước khi bạn mất kết nối internet\
-   Cài đặt package **epirhandbook** của chúng tôi trong đó chứa tất cả các dữ liệu minh họa (quy trình cài đặt được mô tả bên dưới)

**Có hai cách bạn có thể tải xuống sổ tay:**

### Sử dụng link download {.unnumbered}

Để truy cập nhanh, **nháy phải chuột** vào [link này](https://github.com/appliedepi/epirhandbook_eng/raw/master/offline_long/Epi_R_Handbook_offline.html) **và lựa chọn "Save link as"**.

Nếu trên máy Mac, hãy sử dụng Cmd + Nhấp chuột. Nếu trên điện thoại di động, hãy bấm và giữ liên kết và chọn "Save link". Sổ tay sẽ tải xuống thiết bị của bạn. Nếu trên màn hình xuất hiện mã HTML gốc, hãy đảm bảo bạn đã làm đúng theo các hướng dẫn bên trên hoặc thử Phương án 2.

### Sử dụng package của chúng tôi {.unnumbered}

Chúng tôi cung cấp một R package có tên là **epirhandbook**. Nó bao gồm một hàm có tên `download_book()` giúp bạn tải xuống sổ tay này từ kho Github của chúng tôi vào máy tính của bạn.

Package này cũng chứa hàm `get_data()` giúp tải xuống toàn bộ các dữ liệu minh họa vào máy tính của bạn.

Chạy dòng code sau để cài đặt package **epirhandbook** từ [Github repository *appliedepi*](https://github.com/appliedepi/epirhandbook). Đây không phải là package thuộc CRAN, do đó cần sử dụng hàm đặc biệt `p_install_gh()` để cài đặt nó từ Github.

```{r, eval=F}
# install the latest version of the Epi R Handbook package
pacman::p_install_gh("appliedepi/epirhandbook")
```

Bây giờ, bạn gọi package để sử dụng cho phiên làm việc R hiện tại:

```{r, eval=F}
# load the package for use
pacman::p_load(epirhandbook)
```

Tiếp theo, bạn chạy hàm `download_book()` (phần trong ngoặc bỏ trống) để tải sổ tay vào máy tính của bạn. Nếu bạn sử dụng RStudio, một cửa sổ sẽ xuất hiện cho phép bạn lựa chọn thư mục lưu trữ.

```{r, eval=F}
# download the offline handbook to your computer
download_book()
```

## Tải dữ liệu xuống để tiện theo dõi

Để "tiện theo dõi" cùng với sổ tay này, bạn có thể tải xuống các bộ dữ liệu minh họa và các kết quả.

### Sử dụng package của chúng tôi {.unnumbered}

Cách dễ nhất để tải xuống tất cả dữ liệu là cài đặt package **epirhandbook** của chúng tôi. Nó chứa hàm `get_data()` giúp lưu toàn bộ dữ liệu minh họa vào một thư mục bạn chọn trên máy tính của mình.

Để cài đặt package **epirhandbook**, bạn chạy theo code dưới đây. Lưu ý là package này không từ CRAN, do đó cần sử dụng hàm `p_install_gh()` để cài đặt. Thông tin đầu vào sẽ được chuyển tới trang Github của chúng tôi ("*appliedepi*") và package **epirhandbook**.

```{r, eval=F}
# install the latest version of the Epi R Handbook package
pacman::p_install_gh("appliedepi/epirhandbook")
```

Bây giờ, bạn gọi package để sử dụng cho phiên làm việc hiện tại:

```{r, eval=F}
# load the package for use
pacman::p_load(epirhandbook)
```

Tiếp theo, sử dụng hàm `get_data()` trong package để tải dữ liệu minh họa và máy tính của bạn. Chạy hàm `get_data("all")` để tải *toàn bộ* dữ liệu minh họa, hoặc bạn có thể nêu tên một tệp cụ thể và phần mở rộng bên trong dấu ngoặc kép để tải một tệp duy nhất.

Dữ liệu sẽ được tải xuống cùng với package và bạn đơn giản chỉ cần lưu nó vào một thư mục trên máy tính của bạn. Một cửa sổ sẽ xuất hiện, cho phép bạn chọn vị trí lưu thư mục. Chúng tôi khuyên bạn nên tạo một thư mục mới tên là "data" vì có khoảng 30 tệp (bao gồm các bộ dữ liệu minh họa và kết quả).

```{r, eval=F}
# download all the example data into a folder on your computer
get_data("all")

# download only the linelist example data into a folder on your computer
get_data(file = "linelist_cleaned.rds")

```

```{r, eval=F}
# download a specific file into a folder on your computer
get_data("linelist_cleaned.rds")
```

Khi bạn dùng hàm `get_data()` để lưu tệp dữ liệu vào máy tính của mình, bạn sẽ vẫn cần nhập dữ liệu vào R. Xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết.

Nếu bạn muốn, bạn có thể xem toàn bộ dữ liệu sử dụng trong cuốn sách này ở [**thư mục "dữ liệu"**](https://github.com/appliedepi/epirhandbook_eng/tree/master/data) trong kho Github của chúng tôi.

### Tải từng thứ một {.unnumbered}

Tùy chọn này liên quan đến việc tải xuống từng tệp dữ liệu từ kho lưu trữ Github của chúng tôi thông qua liên kết hoặc lệnh R dành riêng cho từng tệp. Một số loại tệp cho phép nút tải xuống, trong khi những loại khác có thể được tải xuống thông qua lệnh R.

#### Dữ liệu linelist {.unnumbered}

Đây là số liệu bùng phát Ebola giả định, được nhóm tác giả cẩm nang mở rộng từ bộ dữ liệu thực hành `ebola_sim` trong package **outbreaks**.

-   <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>Bấm để tải xuống dữ liệu "thô" linelist (.xlsx)</span></a>. Bộ dữ liệu "thô" là một trang tính Excel với dữ liệu lộn xộn. Sử dụng số liệu này trong chương [Làm sạch số liệu và các hàm quan trọng].

-   <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>Bấm để tải xuống dữ liệu "đã làm sạch" linelist (.rds)</a>. Sử dụng tệp này cho tất cả các chương khác trong sổ tay có sử dụng bộ dữ liệu linelist. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.

*Các tệp liên quan khác:*

-   <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.xlsx' class='download-button'>Bấm để tải xuống dữ liệu "đã làm sạch" linelist dưới dạng tệp Excel</a>

-   Một phần của chương làm sạch sử dụng "từ điển làm sạch" (tệp .csv). Bạn có thể tải nó trực tiếp vào R bằng cách chạy các lệnh sau:

```{r, eval=F}
pacman::p_load(rio) # install/load the rio package

# import the file directly from Github
cleaning_dict <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/cleaning_dict.csv")
```

#### Dữ liệu số trường hợp sốt rét {#data_malaria .unnumbered}

Đây là số liệu giả định về số lượng trường hợp sốt rét theo nhóm tuổi, cơ sở điều trị và ngày. Tệp mở rộng .rds là một kiểu file của R có khả năng lưu trữ các thông tin cột. Điều này đảm bảo bạn sẽ có ít việc phải làm khi làm sạch số liệu sau khi nhập số liệu vào R.

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'> Bấm để tải file dữ liệu sốt rét (.rds file) </a>

#### Dữ liệu thang đo Likert {.unnumbered}

Đây là dữ liệu giả định từ một cuộc khảo sát sử dụng thang đo Likert, được sử dụng trong chương [Tháp dân số và thang đo Likert]. Bạn có thể tải những dữ liệu này trực tiếp vào R bằng cách chạy các lệnh sau:

```{r, eval=F}
pacman::p_load(rio) # install/load the rio package

# import the file directly from Github
likert_data <- import("https://raw.githubusercontent.com/nsbatra/Epi_R_handbook/master/data/likert_data.csv")
```

#### Flexdashboard {.unnumbered}

Dưới đây là các liên kết đến tệp được dùng trong chương [Dashboards với R Markdown]:

-   Để tải xuống R Markdown dashboard về một đợt bùng phát dịch, bấm phải chuột vào [link](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/flexdashboard/outbreak_dashboard.Rmd) này (Cmd+click đối với Mac) và chọn "Save link as".\
-   Để tải xuống HTML dashboard, bấm phải chuột vào [link](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/flexdashboard/outbreak_dashboard_test.html) này (Cmd+click đối với Mac) và chọn "Save link as".

#### Truy vết tiếp xúc {.unnumbered}

Chương [Truy vết tiếp xúc] trình bày phân tích dữ liệu truy vết tiếp xúc, sử dụng dữ liệu minh họa từ [Go.Data](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting). Dữ liệu được sử dụng trong chương này có thể được tải xuống dưới dạng tệp .rds bằng cách bấm vào các liên kết sau:

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true' class='download-button'> Bấm để tải xuống dữ liệu điều tra trường hợp (.rds file) </a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true' class='download-button'> Bấm để tải xuống dữ liệu ghi nhận tiếp xúc (.rds file) </a>

<a href='https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true' class='download-button'> Bấm để tải xuống dữ liệu theo dõi liên hệ (.rds file) </a>

[***LƯU Ý:*** Dữ liệu truy vết tiếp xúc có cấu trúc từ phần mềm khác (ví dụ: KoBo, DHIS2 Tracker, CommCare) có thể sẽ khác. Nếu bạn muốn đóng góp dữ liệu hoặc nội dung mẫu thay thế cho trang này, vui lòng [liên hệ chúng tôi](#contact_us).]{style="color: black;"}

[***MẸO:*** Nếu bạn đang triển khai Go.Data và muốn kết nối với API phiên bản của bạn, vui lòng xem chương Nhập xuất dữ liệu [(mục API)](#import_api) và [Go.Data Cộng đồng thực hành](https://community-godata.who.int/).]{style="color: darkgreen;"}

#### GIS {.unnumbered}

Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng tệp khác nhau. Một tệp sẽ có phần mở rộng ".shp", nhưng những tệp khác có thể là ".dbf", ".prj", v.v.

Chương [GIS cơ bản] cung cấp các liên kết đến trang web *Humanitarian Data Exchange*, nơi bạn có thể tải xuống trực tiếp các shapefiles dưới dạng tệp nén.

Ví dụ, dữ liệu phân bố của các cơ sở y tế có thể được tải xuống [tại đây](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities). Bạn tải tệp "hotosm_sierra_leone_health_facilities_points_shp.zip". Sau khi được lưu vào máy tính của bạn, hãy “giải nén” thư mục. Bạn sẽ thấy một số tệp có các phần mở rộng khác nhau (ví dụ: “.shp”, “.prj”, “.shx”) - tất cả những tệp này phải được lưu vào cùng một thư mục trên máy tính của bạn. Sau đó, để nhập vào R, hãy cung cấp đường dẫn đến tệp và tên của tệp “.shp” bằng hàm `st_read()` từ package **sf** (đã được mô tả trong chương [GIS cơ bản]).

Nếu bạn làm theo Cách 1 để tải xuống tất cả dữ liệu minh họa (thông qua package **epirhandbook** của chúng tôi), tất cả các shapefiles đã được bao gồm.

Ngoài ra, bạn có thể tải xuống các shapefiles từ thư mục "data" trên trang R Handbook Github (xem thư mục con "gis"). Tuy nhiên, cần lưu ý rằng bạn sẽ phải tải *từng* tệp con xuống máy tính của mình. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút “Download”. Xem hình minh họa dưới đây, bạn có thể thấy shapefile “sl_adm3” bao gồm nhiều tệp con như thế nào - và mỗi tệp đều cần được tải xuống từ Github.

```{r out.height = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```

#### Cây phả hệ {.unnumbered}

Xem chương [Cây phả hệ]. Tệp có tên Newick về cây phả hệ được xây dựng từ việc giải trình tự toàn bộ bộ gen của 299 mẫu Shigella sonnei và dữ liệu mẫu tương ứng (được chuyển đổi thành tệp văn bản). Các mẫu và kết quả từ nước Bỉ được cung cấp thông qua Trung tâm tham khảo quốc gia về Salmonella và Shigella (NRC Bỉ) trong phạm vi dự án do EUPHEM Fellow của ECDC thực hiện, và cũng sẽ được xuất bản dưới dạng bản thảo. Dữ liệu quốc tế được cung cấp công khai trên cơ sở dữ liệu công cộng (ncbi) và đã được xuất bản trước đó.

-   Để tải xuống file cây phả hệ “Shigella_tree.txt”, nhấn chuột phải vào [link này](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/Shigella_tree.txt) (Cmd+click đối với Mac) và chọn "Save link as".\
-   Để tải xuống file "sample_data_Shigella_tree.csv" với thông tin bổ sung cho từng mẫu, nhấn chuột phải vào [link này](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/sample_data_Shigella_tree.csv) (Cmd+click đối với Mac) và chọn "Save link as".\
-   Để xem subset-tree mới được tạo, nhấn chuột phải vào [link này](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/phylo/Shigella_subtree_2.txt) (Cmd+click đối với Mac) và chọn "Save link as". Tệp .txt sẽ được tải xuống máy tính của bạn.

Sau đó bạn có thể nhập tệp .txt files bằng hàm `read.tree()` từ **ape** package, như đã được trình bày trong chương này.

```{r, eval=F}
ape::read.tree("Shigella_tree.txt")
```

#### Chuẩn hóa {.unnumbered}

Xem trong chương [Tỷ lệ chuẩn hóa]. Bạn có thể tải dữ liệu trực tiếp từ kho lưu trữ Github của chúng tôi trên internet vào phiên làm việc R của bạn bằng các lệnh sau :

```{r, eval=F}
# install/load the rio package
pacman::p_load(rio) 

##############
# Country A
##############
# import demographics for country A directly from Github
A_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv")

# import deaths for country A directly from Github
A_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv")

##############
# Country B
##############
# import demographics for country B directly from Github
B_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv")

# import deaths for country B directly from Github
B_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryB.csv")


###############
# Reference Pop
###############
# import demographics for country B directly from Github
standard_pop_data <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/world_standard_population_by_sex.csv")
```

#### Chuỗi thời gian và phát hiện ổ dịch {#data_outbreak .unnumbered}

Xem trong chương [Chuỗi thời gian và phát hiện ổ dịch](#data_outbreak). Chúng tôi sử dụng các trường hợp campylobacter được báo cáo ở Đức từ 2002-2011, có sẵn từ package **surveillance** của R. (*lưu ý.* tập dữ liệu này đã được điều chỉnh từ bản gốc, trong đó 3 tháng dữ liệu cuối năm 2011 đã bị xóa để dùng với mục đích minh họa)

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/campylobacter_germany.xlsx' class='download-button'> Bấm để tải xuống dữ liệu Campylobacter ở Đức (.xlsx) </a>

Chúng tôi cũng sử dụng dữ liệu khí hậu ở Đức từ 2002-2011 (nhiệt độ tính bằng độ C và lượng mưa tính bằng milimet). Dữ liệu được tải xuống từ tập dữ liệu phân tích vệ tinh Copernicus của EU bằng cách sử dụng package **ecmwfr** . Bạn sẽ cần tải xuống tất cả những thứ này và nhập chúng vào R bằng hàm `stars::read_stars()` như đã được giải thích trong chương chuỗi thời gian.

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2002.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2002 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2003.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2003 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2004.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2004 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2005.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2005 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2006.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2006 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2007.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2007 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2008.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2008 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2009.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2009 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2010.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2010 (.nc file) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/time_series/weather/germany_weather2011.nc' class='download-button'> Bấm để tải dữ liệu thời tiết ở Đức 2011 (.nc file) </a>

#### Phân tích sống còn {#data_survey .unnumbered}

Đối với chương [phân tích sống còn](https://epirhandbook.com/survey-analysis.html), chúng tôi sử dụng dữ liệu khảo sát tử vong giả định dựa trên mẫu khảo sát của MSF OCA. Dữ liệu giả định này là một phần của [Dự án "R4Epis"](https://r4epis.netlify.app/).

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/survey_data.xlsx' class='download-button'> Bấm để tài xuống dữ liệu khảo sát giả định (.xlsx) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/survey_dict.xlsx' class='download-button'> Bấm để tài xuống từ điển dữ liệu khảo sát giả định (.xlsx) </a>

<a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/surveys/population.xlsx' class='download-button'> Bấm để tài xuống dữ liệu khảo sát quần thể giả định (.xlsx) </a>

#### Shiny {#data_shiny .unnumbered}

Chương [Dashboards với Shiny] trình diễn việc xây dựng một ứng dụng đơn giản để hiển thị dữ liệu bệnh sốt rét.

Để tải xuống các tệp R dùng để tạo thành ứng dụng Shiny:

Bạn có thể <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_app/app.R' class='download-button'> bấm vào đây để tải xuống tệp app.R trong đó chứa code của cả UI và Server của ứng dụng Shiny.</a>

Bạn có thể <a href='https://github.com/appliedepi/epirhandbook_eng/blob/master/data/malaria_app/data/facility_count_data.rds' class='download-button'> bấm vào đây để tải tệp facility_count_data.rds<span></a> có chứa dữ liệu sốt rét cho ứng dụng Shiny. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “data” để các đường dẫn tệp here () hoạt động chính xác.

Bạn có thể <a href='https://github.com/appliedepi/epirhandbook_eng/blob/master/data/malaria_app/global.R' class='download-button'> bấm vào đây để tải tệp global.R<span></a> mà sẽ được chạy trước khi mở ứng dụng, như đã được giải thích trong chương.

Bạn có thể <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_app/funcs/plot_epicurve.R' class='download-button'> bấm vào đây để tải tệp plot_epicurve.R<span></a> có nguồn từ tệp global.R. Lưu ý rằng bạn có thể cần phải lưu trữ nó trong thư mục “funcs” để các đường dẫn tệp here () hoạt động chính xác.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/data_used.Rmd-->

# (PART) Nhập môn về R {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_basics.Rmd-->

# R Cơ bản {#basics}

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "basics_header_close.png"))
```

Chào mừng bạn!

Chương này sẽ mô tả những kỹ thuật cơ bản của R. Đây không phải là hướng dẫn sử dụng toàn diện, nhưng sẽ cung cấp những kiến thức cơ bản và có thể hữu ích trong việc làm mới hiểu biết của bạn. Phần [Tài nguyên học liệu](#learning) sẽ liên kết đến những hướng dẫn sử dụng R bao quát hơn.

Các phần của chương này đã được điều chỉnh dưới sự cho phép của [Dự án R4Epis](https://r4epis.netlify.app/).

Xem chương [Chuyển đổi sang R] để biết các mẹo khi chuyển đổi từ STATA, SAS hoặc Excel sang R.

```{r, echo=F}
# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
pacman::p_load(apyramid)
```

<!-- ======================================================= -->

## Tại sao sử dụng R?

Như đã được công bố trên [trang web dự án R](https://www.r-project.org/about.html), R là một ngôn ngữ và môi trường lập trình cho tính toán và đồ họa thống kê. Nó rất linh hoạt, có khả năng mở rộng và hướng tới cộng đồng.

**Chi phí**

R được sử dụng miễn phí! Có sự tồn tại mạnh mẽ về đạo đức trong cộng đồng người sử dụng nguồn tài nguyên mở và miễn phí.

**Khả năng tái lập**

Thực hiện quản lý và phân tích dữ liệu của bạn thông qua một ngôn ngữ lập trình (so sánh với Excel hoặc công cụ khác mà thao tác chính là nhấp chuột/thao tác thủ công) giúp nâng cao **khả năng tái lập**, giúp **phát hiện lỗi** dễ dàng hơn và giảm bớt khối lượng công việc của bạn.

**Cộng đồng**

R có cộng đồng người dùng khổng lồ và có tính hợp tác. Các package và công cụ mới nhằm giải quyết các vấn đề thực tế được phát triển hàng ngày và được kiểm tra bởi cộng đồng người dùng. Ví dụ, [R-Ladies](https://rladies.org/) là một tổ chức toàn cầu có sứ mệnh thúc đẩy sự đa dạng giới trong cộng đồng R và là một trong những tổ chức người dùng R lớn nhất. Thậm chí có thể có một phần của nhóm này đang ở gần bạn!

## Các thuật ngữ chính

**RStudio** - RStudio là Giao diện đồ họa người dùng (GUI) giúp sử dụng **R** dễ dàng hơn. Đọc thêm [trong mục RStudio](#rstudio).

**Đối tượng** - Bao gồm mọi thứ bạn lưu trữ trong R - bộ dữ liệu, biến, danh sách tên làng, quy mô dân số, thậm chí cả các kết quả đầu ra như đồ thị - là các *đối tượng* được *gán tên* và *có thể được tham chiếu* trong các lệnh sau này. Đọc thêm [trong mục Đối tượng](#objects).

**Hàm** - Mỗi hàm là một code hoạt động mà chấp nhận dữ liệu đầu vào và trả về kết quả đầu ra đã được biến đổi. Đọc thêm [trong mục Các hàm](#functions).

**Packages** - Mỗi package R là một gói câu lệnh có khả năng chia sẻ. Đọc thêm [trong mục Packages](#packages).

**Scripts** - Mỗi script là một tệp tài liệu chứa các lệnh của bạn. Đọc thêm [trong mục Scripts](#scripts)

## Tài nguyên học liệu {#learning}

### Tài nguyên trong RStudio {.unnumbered}

**Tài liệu trợ giúp**

Tìm kiếm tab "Help" của RStudio về tài liệu liên quan đến package R và các hàm cụ thể. Tab này nằm trong cửa sổ chứa các tab Files, Plots và Packages (thường ở cửa sổ phía dưới bên phải). Như một lối tắt, bạn cũng có thể nhập tên của một package hoặc câu lệnh vào R Console sau dấu hỏi chấm và không bao gồm dấu ngoặc đơn để mở trang trợ giúp liên quan.

Ví dụ: `?filter` hoặc `?diagrammeR`.

**Các hướng dẫn có sự tương tác**

R có thể được học thông qua một số tương tác *trong* RStudio.

RStudio cung cấp một cửa sổ Tutorial được hỗ trợ bởi package [**learnr**](https://blog.rstudio.com/2020/02/25/rstudio-1-3-integrated-tutorials/). Chỉ cần cài đặt package này và mở hướng dẫn qua tab "Tutorial" trong cửa sổ RStudio phía trên bên phải (cũng chứa các tab Environment và History).

Package [**swirl**](https://swirlstats.com/) cung cấp các nội dung học tương tác trong R Console. Cài đặt và tải package này, rồi chạy lệnh `swirl()` (dấu ngoặc đơn trống) trong R Console. Bạn sẽ thấy các thông báo xuất hiện trong cửa sổ Console. Phản hồi bằng cách nhập vào Console. Nó sẽ hướng dẫn bạn qua một nội dung học do bạn lựa chọn.

### Cheatsheets {.unnumbered}

Có rất nhiều "cheatsheets" PDF có sẵn trên [trang web của RStudio](https://rstudio.com/resources/cheatsheets/), ví dụ như:

-   Factors với package **forcats**\
-   Ngày và thời gian với package **lubridate**\
-   Chuỗi với package **stringr**\
-   Các vòng lặp với package **purrr**\
-   Nhập dữ liệu\
-   Cheatsheet biến đổi dữ liệu với package **dplyr**\
-   R Markdown (để tạo các tài liệu như PDF, Word, Powerpoint...)\
-   Shiny (để xây dựng các ứng dụng web tương tác)\
-   Trực quan hóa dữ liệu với package **ggplot2**\
-   Bản đồ học (GIS)\
-   Package **leaflet** (bản đồ tương tác)\
-   Python với R (package **reticulate**)

Đây là tài nguyên R trực tuyến dành riêng cho [Người dùng Excel](https://jules32.github.io/r-for-excel-users/)

### Twitter {.unnumbered}

R có một cộng đồng twitter sôi động, nơi bạn có thể tìm hiểu các mẹo, lối tắt và tin tức - hãy theo dõi các tài khoản sau:

-   Theo dõi chúng tôi: [\@epiRhandbook](https://twitter.com/epirhandbook)\
-   R Function A Day [\@rfuntionaday](https://twitter.com/rfunctionaday) là một nguồn tài nguyên *tuyệt vời*
-   R for Data Science [\@rstats4ds](https://twitter.com/rstats4ds?lang=en)\
-   RStudio [\@RStudio](https://twitter.com/rstudio?lang=en)\
-   RStudio Tips [\@rstudiotips](https://twitter.com/rstudiotips)\
-   R-Bloggers [\@Rbloggers](https://twitter.com/Rbloggers)\
-   R-ladies [\@RLadiesGlobal](https://twitter.com/RLadiesGlobal)\
-   Hadley Wickham [\@hadleywickham](https://twitter.com/hadleywickham?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor)

Cũng như:

**\#epitwitter** và **\#rstats**

### Nguồn tài nguyên trực tuyến miễn phí {.unnumbered}

Cuốn sách [R for Data Science](https://r4ds.had.co.nz/) (R dành cho Khoa học Dữ liệu) của Garrett Grolemund và Hadley Wickham

Trang web của dự án [R4Epis](https://r4epis.netlify.app/) nhằm mục đích "phát triển các công cụ làm sạch, phân tích và báo cáo dữ liệu được chuẩn hóa dùng trong các trường hợp bùng phát dịch phổ biến và các cuộc điều tra dựa trên dân số mà sẽ được tiến hành trong các ứng phó khẩn cấp của Tổ chức Bác sỹ không biên giới" Bạn có thể tìm thấy tài liệu đào tạo cơ bản về R, các mẫu báo cáo RMarkdown và khảo sát về các đợt bùng phát dịch, cũng như các hướng dẫn để giúp bạn thiết lập chúng.

### Các ngôn ngữ khác ngoài Tiếng Anh {.unnumbered}

[Tài liệu RStudio bằng tiếng Tây Ban Nha](https://www.rstudio.com/collections/espanol/)

[Giới thiệu cơ bản về R (tiếng Pháp)](https://juba.github.io/tidyverse/index.html)

<!-- ======================================================= -->

## Cài đặt

### R và RStudio {.unnumbered}

**Làm thế nào để cài đặt R**

Truy cập vào trang web <https://www.r-project.org/> và tải phiên bản mới nhất của R phù hợp với máy tính của bạn.

**Làm thế nào để cài đặt RStudio**

Truy cập vào trang web <https://rstudio.com/products/rstudio/download/> và tải phiên bản Desktop mới nhất của RStudio phù hợp với máy tính của bạn.

**Quyền truy cập**\
Lưu ý rằng bạn nên cài đặt R và RStudio vào một ổ đĩa mà bạn có quyền đọc và ghi lại. Nếu không, khả năng cài đặt các package R (thường xuyên xảy ra) của bạn sẽ bị ảnh hưởng. Nếu bạn gặp sự cố, hãy thử mở RStudio bằng cách nhấp chuột phải vào biểu tượng và chọn "Run as administrator". Các mẹo khác có thể được tìm thấy trong chương [R trên ổ cứng mạng].

**Làm thế nào để cập nhật R và RStudio**

Phiên bản R của bạn được in ra R Console khi khởi động. Bạn cũng có thể chạy lệnh `sessionInfo()`.

Để cập nhật R, truy cập đến trang web được nhắc đến ở trên và cài đặt lại R. Ngoài ra, bạn có thể sử dụng package **installr** (trên Windows) bằng cách chạy câu lệnh `installr::updateR()`. Thao tác này sẽ mở ra các hộp thoại giúp bạn tải xuống phiên bản R mới nhất và cập nhật các package của bạn lên phiên bản R mới. Có thể tìm thấy thêm chi tiết trong [tài liệu](https://www.r-project.org/nosvn/pandoc/installr.html) **installr** .

Lưu ý rằng phiên bản R cũ sẽ vẫn tồn tại trong máy tính của bạn. Bạn có thể tạm thời chạy phiên bản cũ hơn ("installation" cũ hơn) của R bằng cách nhấp vào "Tools" -\> "Global Options" trong RStudio và chọn một phiên bản R. Điều này có thể hữu ích nếu bạn muốn sử dụng một package chưa được cập nhật để hoạt động trên phiên bản R mới nhất.

Để cập nhật RStudio, truy cập đến trang web được nhắc đến ở trên và cài đặt lại RStudio. Một tùy chọn khác là nhấp vào "Help" -\> "Check for Updates" trong RStudio, nhưng điều này có thể dẫn đến việc không hiển thị các bản cập nhật mới nhất.

Để xem phiên bản R, RStudio hoặc package nào đã được sử dụng khi viết Sổ tay này, hãy xem chương [Biên tập và ghi chú kỹ thuật].

### Những phần mềm khác bạn *có thể* cần cài đặt {.unnumbered}

-   TinyTeX (*để biên dịch tài liệu RMarkdown sang PDF*)\
-   Pandoc (*để biên dịch tài liệu RMarkdown*)\
-   RTools (*để xây dựng các package cho R*)\
-   phantomjs (*để lưu ảnh tĩnh của mạng động, chẳng hạn như chuỗi lây truyền*)

#### TinyTex {.unnumbered}

TinyTex là một bản phân phối LaTeX tùy chỉnh, hữu ích khi tạo các tệp PDF từ R.\
Truy cập <https://yihui.org/tinytex/> để tìm hiểu thêm thông tin.

Để cài đặt TinyTex từ R:

```{r, eval=F}
install.packages('tinytex')
tinytex::install_tinytex()
# to uninstall TinyTeX, run tinytex::uninstall_tinytex()
```

#### Pandoc {.unnumbered}

Pandoc là một công cụ chuyển đổi văn bản, một phần mềm tách biệt với R. **Nó đi kèm với RStudio và không cần phải tải xuống.** Nó hỗ trợ quá trình chuyển đổi văn bản từ Rmarkdown sang các định dạng như .pdf và có bổ sung thêm một số tính năng phức tạp.

#### RTools {.unnumbered}

RTools là một phần mềm được sử dụng để xây dựng package cho R

Cài đặt từ trang web: <https://cran.r-project.org/bin/windows/Rtools/>

#### phantomjs {.unnumbered}

Phần mềm này thường được sử dụng để chụp "chụp ảnh màn hình" trang web. Ví dụ khi bạn tạo một chuỗi lây truyền với package **epicontacts**, một tệp HTML có thể tương tác và chuyển động được tạo ra. Nếu bạn muốn có hình ảnh tĩnh, sử dụng package [**webshot**](https://wch.github.io/webshot/articles/intro.html) để tự động hóa quá trình này. Việc này sẽ yêu cầu chương trình bên ngoài "phantomjs". Bạn có thể cài đặt phantomjs thông qua package **webshot** bằng lệnh `webshot::install_phantomjs()`.

<!-- ======================================================= -->

## RStudio {#rstudio}

### Làm quen {.unnumbered}

**Đầu tiên, mở RStudio.** Biểu tượng của chúng có sự tương đồng, hãy chắc chắn bạn đang mở *RStudio* chứ không phải R.

Để RStudio hoạt động bạn cũng cần phải cài đặt R trên máy tính (xem hướng dẫn cài đặt ở bên trên).

**RStudio** là một giao diện người dùng (GUI) giúp sử dụng **R** dễ dàng hơn. Bạn có thể coi R như một động cơ đang đảm đương công việc chính của một phương tiện và RStudio là phần thân của phương tiện (với ghế ngồi, các phụ kiện,...) giúp bạn sử dụng động cơ tiến về phía trước. Bạn có thể xem toàn bộ cheatsheet giao diện người dùng của RStudio (PDF) tại [đây](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf)

RStudio mặc định hiển thị bốn cửa sổ hình chữ nhật.

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "RStudio_overview.png"))
```

[***MẸO:*** Nếu RStudio của bạn chỉ hiển thị một cửa sổ bên trái thì đó là do bạn chưa mở scripts nào.]{style="color: black;"}

**Cửa sổ mã nguồn**\
Cửa sổ này, mặc định hiển thị phía trên bên trái, là một khoảng trống để chỉnh sửa, chạy và lưu các [scripts](#scripts) của bạn. Script chứa các lệnh mà bạn muốn chạy. Cửa sổ này cũng có thể hiển thị thông tin dữ liệu (data frames).

Đối với người dùng Stata, cửa sổ này tương tự với các cửa sổ Do-file và Data Editor.

**Cửa sổ R Console**

R Console, mặc định ở cửa sổ bên trái hoặc phía dưới bên trái của RStudio, là ngôi nhà của "động cơ" R. Đây là nơi các lệnh thực sự được chạy, các kết quả đầu ra không phải là đồ họa và các thông báo lỗi/cảnh báo sẽ xuất hiện. Bạn có thể nhập và chạy các lệnh trực tiếp trong R Console, nhưng sẽ sớm nhận ra các lệnh này không được lưu như khi chạy lệnh từ một script.

Nếu bạn đã quen thuộc với Stata, R Console giống như cửa sổ Command Window và Results Window.

**Cửa sổ Environment**\
Cửa sổ này, mặc định ở phía trên bên phải, thường được sử dụng để xem tóm tắt ngắn gọn về các [đối tượng](#objects) itrong R Environment ở phiên hiện tại. Các đối tượng này có thể bao gồm các tập dữ liệu đã được nhập, chỉnh sửa hoặc tạo mới, các tham số bạn đã xác định (ví dụ: một tuần dịch tễ cụ thể để phân tích), vectơ hoặc các danh sách bạn đã xác định trong quá trình phân tích (ví dụ: tên các vùng). Bạn có thể nhấp vào mũi tên bên cạnh tên của data frames để xem các biến số của nó.

Cửa sổ này gần giống với cửa sổ Variables Manager trong Stata.

Cửa sổ này cũng chứa *History* - nơi mà bạn có thể xem các lệnh đã làm trước đó. Nó cũng có một tab "Tutorial" - là nơi mà bạn có thể hoàn thành các hướng dẫn tương tác với R nếu bạn đã cài đặt package **learnr**. Nó cũng chứa một tab "Connections" cho phép các kết nối bên ngoài và có thể có cửa sổ "Git" nếu bạn chọn giao diện với Github.

**Cửa sổ Plots, Viewer, Packages, và Help**\
Cửa sổ phía dưới bên phải bao gồm một số tab quan trọng. Các đồ họa chính điển hình bao gồm bản đồ sẽ được hiển thị trong Cửa sổ Plot. Các kết quả đầu ra tương tác hoặc HTML sẽ được hiển thị trong cửa sổ Viewer. Cửa sổ File là một trình duyệt có thể được sử dụng để mở hoặc xóa tệp. Cửa sổ Packages cho phép bạn xem, cài đặt, cập nhật, xóa, tải/dỡ các package R và xem bạn có phiên bản package nào. Để tìm hiểu thêm về các package hãy xem [mục packages](#packages) bên dưới.

Cửa sổ này chứa các nội dung tương đương với các cửa sổ Plots Manager và Project Manager trong Stata.

### Các cài đặt của RStudio {.unnumbered}

Thay đổi các cài đặt và giao diện của RStudio trong thanh menu thả xuống *Tools*, bằng cách chọn *Global Options*. Ở đó, bạn có thể thay đổi cài đặt mặc định, bao gồm cả màu giao diện/nền.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "RStudio_tools_options_1.png"))

knitr::include_graphics(here::here("images", "RStudio_tools_options.png"))
```

**Khởi động lại**

Nếu R của bạn bị treo, bạn có thể khởi động lại R bằng cách di chuột đến menu Session và nhấp vào "Restart R". Thao tác này giúp tránh rắc rối khi đóng và mở RStudio. Mọi thứ trong môi trường R của bạn sẽ bị xóa khi thực hiện thao tác này.

### Các phím tắt {.unnumbered}

Dưới đây là một vài phím tắt rất hữu dụng. Tất cả các phím tắt cho Windows, Max và Linux nằm ở chương 2 [cheatsheet giao diện người dùng](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) của RStudio.

+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Windows/Linux                    | Mac                    | Hành động                                                                                                                             |
+==================================+========================+=======================================================================================================================================+
| Esc                              | Esc                    | Ngắt lệnh hiện tại (hữu ích nếu bạn vô tình chạy một lệnh chưa hoàn chỉnh và không thể thoát khỏi việc nhìn thấy "+" trong R console) |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl+s                           | Cmd+s                  | Lưu (script)                                                                                                                          |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Tab                              | Tab                    | Tự động điền                                                                                                                          |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Enter                     | Cmd + Enter            | Chạy (các) dòng/phần code đang được chọn                                                                                              |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + C                 | Cmd + Shift + c        | Bình luận/bỏ bình luận các dòng được đánh dấu                                                                                         |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Alt + -                          | Option + -             | Chèn `<-`                                                                                                                             |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + m                 | Cmd + Shift + m        | Chèn `%>%`                                                                                                                            |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + l                         | Cmd + l                | Dọn dẹp R console                                                                                                                     |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + b                   | Cmd + Option + b       | Chạy từ đầu đến dòng hiện tại                                                                                                         |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + t                   | Cmd + Option + t       | Chạy code chunk hiện tại (R Markdown)                                                                                                 |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + i                   | Cmd + Shift + r        | Chèn code chunk (vào R Markdown)                                                                                                      |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Alt + c                   | Cmd + Option + c       | Chạy code chunk hiện tại (R Markdown)                                                                                                 |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| up/down arrows in R console      | Tương tự               | Chuyển đổi qua các lệnh đã chạy gần đây                                                                                               |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Shift + up/down arrows in script | Tương tự               | Chọn nhiều dòng code                                                                                                                  |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + f                         | Cmd + f                | Tìm và thay thế trong script hiện tại                                                                                                 |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Ctrl + Shift + f                 | Cmd + Shift + f        | Tìm trong các tệp (tìm/thay thế trên nhiều script)                                                                                    |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Alt + l                          | Cmd + Option + l       | Thu gọn code đã chọn                                                                                                                  |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+
| Shift + Alt + l                  | Cmd + Shift + Option+l | Mở rộng code đã chọn                                                                                                                  |
+----------------------------------+------------------------+---------------------------------------------------------------------------------------------------------------------------------------+

[***MẸO:*** Sử dụng phím Tab của bạn khi nhập để sử dụng chức năng tự động hoàn thành của RStudio. Điều này có thể giúp ngăn ngừa các lỗi chính tả. Nhấn Tab trong khi nhập để hiện ra menu thả xuống gồm các hàm và đối tượng có thể có, dựa trên những gì bạn đã nhập.]{style="color: darkgreen;"}

<!-- ======================================================= -->

## Hàm {#functions}

Các hàm là phần cốt lõi của việc sử dụng R. Hàm là cách bạn thực hiện các tác vụ và hoạt động. Nhiều hàm được cài đặt sẵn với R, nhiều hàm khác sẵn sàng để tải xuống trong các *packages* (giải thích trong phần [packages](#packages)), và bạn thậm chí có thể viết các hàm tùy chỉnh của riêng mình!

Phần khái niệm cơ bản của hàm giải thích:

-   Thế nào là một hàm và cách mà chúng hoạt động\
-   Thế nào là *đối số* của hàm\
-   Làm cách nào để nhận được sự trợ giúp khi tìm hiểu một hàm

*Lưu ý nhanh về cú pháp:* Trong cuốn sổ tay này, các hàm được viết dưới dạng code văn bản với dấu mở ngoặc đơn như sau: `filter()`. Như đã giải thích trong phần [packages](#packages), các hàm được tải xuống có sẵn trong các *packages*. Trong sổ tay này, tên các package được **in đậm**, ví dụ như **dplyr**. Đôi khi trong code ví dụ, bạn có thể thấy tên hàm được liên kết rõ ràng với tên package của chính hàm đó bằng hai dấu hai chấm (`::`) như thế này: `dplyr::filter()`. Mục đích của việc liên kết này sẽ được giải thích trong phần package.

<!-- ======================================================= -->

### Các hàm cơ bản {.unnumbered}

**Một hàm giống như một cỗ máy nhận các dữ liệu đầu vào, thực hiện một số thao tác với dữ liệu đó và sản xuất kết quả đầu ra.** Kết quả đầu ra như thế nào phụ thuộc vào hàm mà bạn sử dụng.

**Các hàm thường hoạt động dựa trên các đối tượng được đặt trong dấu ngoặc đơn của hàm**. Ví dụ, hàm `sqrt()` tính căn bậc hai của một số:

```{r basics_function_sqrt}
sqrt(49)
```

Đối tượng được dùng cho một hàm cũng có thể là một cột trong tập dữ liệu (xem phần [Đối tượng](#objects) để biết chi tiết về tất cả các loại đối tượng). Vì R có thể lưu trữ nhiều tập dữ liệu, bạn sẽ cần xác định cả tập dữ liệu và cột. Một cách để làm điều này là sử dụng ký hiệu `$` để liên kết tên của tập dữ liệu và tên của cột (`dataset$column`). Trong ví dụ dưới đây, hàm `summary()` được áp dụng cho cột `age` trong tập dữ liệu `linelist`, và kết quả đầu ra là bản tóm tắt các giá trị số và giá trị missing của cột.

```{r basics_functions_summary}
# Print summary statistics of column 'age' in the dataset 'linelist'
summary(linelist$age)
```

[***LƯU Ý:*** Đằng sau một hàm là hệ thống code bổ sung phức tạp đã được gói gọn cho người dùng thành một lệnh đơn giản.]{style="color: black;"}

<!-- ======================================================= -->

### Hàm với nhiều đối số {.unnumbered}

Các hàm thường yêu cầu một số dữ liệu đầu vào, được gọi là ***đối số***, đặt trong dấu ngoặc đơn của hàm, thường được phân tách bằng dấu phẩy.

-   Một vài đối số là bắt buộc để hàm hoạt động chính xác, những đối số khác là tùy chọn\
-   Những đối số tùy chọn có thiết lập mặc định\
-   Các đối số có thể nhận ký tự, số, logic (TRUE / FALSE) và các dữ liệu đầu vào khác

Dưới đây là một hàm giả định thú vị, được gọi là `oven_bake()`, là ví dụ về một hàm điển hình. Hàm này nhận một đối tượng đầu vào (ví dụ: một tập dữ liệu, hoặc trong ví dụ này là "bột") và thực hiện các hoạt động được xác định bởi các đối số bổ sung (`minutes =` and `temperature =`). Kết quả đầu ra có thể được in ra cửa sổ console hoặc được lưu dưới dạng một đối tượng bằng cách sử dụng toán tử gán `<-`.

```{r basics_functions_image, echo=F, out.width = "75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Function_Bread_Example.png"))
```

**Trong một ví dụ thực tế hơn**, hàm `age_pyramid()` dưới đây tạo một biểu đồ tháp tuổi dựa trên nhóm tuổi đã xác định và cột phân tách nhị phân, ví dụ như `giới tính`. Hàm được cung cấp bởi ba đối số trong dấu ngoặc đơn và được phân tách nhau bằng dấu phẩy. Các giá trị được cung cấp cho các đối số thiết lập `linelist` là dataframe được sử dụng, `age_cat5` là cột để đếm và `giới tính` là cột nhị phân để sử dụng chia kim tự tháp theo màu.

```{r basics_functions_arguments, include=FALSE, results='hide', message=FALSE, warning=FALSE,}
## create an age group variable by specifying categorical breaks
linelist$age_group <- cut(linelist$age, breaks = c(0, 5, 10, 15, 20, 30, 45, 60))
```

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# Create an age pyramid
age_pyramid(data = linelist, age_group = "age_cat5", split_by = "gender")
```

Lệnh trên có thể được viết tương tự như bên dưới, theo cách dài hơn với một dòng mới cho mỗi đối số. Phong cách này có thể dễ đọc và dễ viết "bình luận" hơn với `#` để giải thích từng phần (bình luận mở rộng là một thực hành tốt!). Để chạy lệnh dài hơn này, bạn có thể bôi đen toàn bộ lệnh và nhấp vào "Run" hoặc chỉ cần đặt con trỏ vào dòng đầu tiên rồi nhấn đồng thời phím Ctrl và phím Enter.

```{r message=FALSE, warning=FALSE,  out.width = "75%", out.height="75%"}
# Create an age pyramid
age_pyramid(
  data = linelist,        # use case linelist
  age_group = "age_cat5", # provide age group column
  split_by = "gender"     # use gender column for two sides of pyramid
  )
```

Không cần xác định nửa đầu của phép gán đối số (ví dụ: `data =`) nếu các đối số được viết theo một thứ tự cụ thể (được chỉ định trong tài liệu của hàm). Đoạn code dưới đây tạo ra cùng một kim tự tháp như ở trên, bởi vì hàm kì vọng thứ tự đối số là: data frame, biến `age_group`, biến `split_by`.

```{r, basics_functions_pyramid2, eval = FALSE, warning=FALSE, message=FALSE, , out.width = "75%", out.height="75%", eval=F}
# This command will produce the exact same graphic as above
age_pyramid(linelist, "age_cat5", "gender")
```

**Một lệnh `age_pyramid()` phức tạp hơn có thể bao gồm các đối số *tùy chọn* để:**

-   Hiển thị tỷ lệ thay vì số lượng (đặt `proportional = TRUE` khi giá trị mặc định là `FALSE`)\
-   Chỉ định hai màu để sử dụng (`pal =` là viết tắt của "bảng màu" và được cung cấp với một vectơ gồm hai tên màu. Xem chương [đối tượng](#objectstructure) để biết cách hàm `c()` tạo ra một vectơ)

[***LƯU Ý:*** Đối với các đối số mà bạn xác định với cả hai phần của đối số (ví dụ: `proportional = TRUE`), thứ tự của chúng trong tất cả các đối số không quan trọng.]{style="color: black;"}

```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
age_pyramid(
  linelist,                    # use case linelist
  "age_cat5",                  # age group column
  "gender",                    # split by gender
  proportional = TRUE,         # percents instead of counts
  pal = c("orange", "purple")  # colors
  )
```

<!-- ======================================================= -->

### Viết hàm {.unnumbered}

R là một ngôn ngữ được định hướng xung quanh hàm, vì thế bạn nên cảm thấy được trao quyền để tự viết các hàm của riêng mình. Việc tạo ra hàm mang đến một vài lợi thế:

-   Tạo điều kiện thuận lợi cho lập trình mô-đun - tách code thành các phần độc lập và có thể quản lý\
-   Thay thế việc copy-and-paste lặp đi lặp lại, điều mà có thể dễ xảy ra lỗi\
-   Đặt tên dễ nhớ cho các đoạn code

Cách viết một hàm được trình bày cụ thể trong chương [Viết hàm].

<!-- A function is given a name and defined with the assignment operator `<-` to a special **base** R function called `function()`. Within the parentheses, the arguments that the function will accept are defined. This is followed by curly brackets `{ }`, within which the actual code of the function is written.     -->

```{r, eval=F, echo=F}
my_function <- function( ARGUMENTS HERE ){ CODE HERE }
```

<!-- The arguments should be provided in the syntax `argument = default`, separated by commas.   -->

<!-- Here is an example where we create a function `staff_calc()` to serve as a staffing calculator for COVID-19 case investigation and contact tracing calls.   -->

<!-- The arguments (inputs) and their default values will be:   -->

<!-- * `daily_cases = NULL` The number of new COVID-19 cases per day   -->

<!-- * `contacts_each = 5` The number contacts enumerated for each case   -->

<!-- * `time_case = 0.5`  Number of hours to complete a case investigaton by phone   -->

<!-- * `time_contact = 0.25`  Number of hours to complete a contact follow-up by phone   -->

<!-- * `time_day = 8` The number of hours one staff works per day   -->

<!-- Below, the function is created. The code ends with the special function `return()`, which is what the function produces.    -->

<!-- ```{r message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"} -->

<!-- staff_calc <- function(daily_cases = NULL, contacts_each = 5, -->

<!--                        time_case = 0.5, time_contact = 0.25, time_day = 8){ -->

<!--   # Define total daily hours for calling cases -->

<!--   case_hours <- daily_cases * time_case  -->

<!--   # Define total daily hours for calling contacts -->

<!--   contact_hours <- daily_cases * contacts_each * time_contact -->

<!--   # Calculate number of staff required -->

<!--   staff_required <- (case_hours + contact_hours)/time_day -->

<!--   return(staff_required) -->

<!-- } -->

<!-- ``` -->

<!-- Once this code is run, the function will be defined and will appear in the R Environment. We can run the function. Below all the default values are used and the `daily_cases = ` is set to 150.   -->

```{r eval=F, echo=F, message=FALSE, warning=FALSE, out.width = "75%", out.height="75%"}
staff_calc(daily_cases = 150)
```

```{r, eval=F, echo=F}
case_incidence <- tibble(
  dates = seq.Date(from = as.Date("2020-05-01"), to = as.Date("2020-05-21"), by = 1),
  projected_incidence = c(102,110,50,37,106,190,146,138,135,111,60,43,189,184,185,80,44,97,254,291,288),
  staff_needed = staff_calc(projected_incidence)
)

ggplot(case_incidence, aes(x = dates))+
  geom_line(aes(y = projected_incidence))+
  geom_line(aes(y = staff_needed))
```

<!-- There are many other nuances to understand when writing functions, as discussed in the page [Writing functions].   -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Packages {#packages}

**Packages chứa các hàm.**

Một package trong phần mềm R là một gói code và các tài liệu hướng dẫn có thể chia sẻ được chứa các hàm được định nghĩa trước. Cộng đồng người dùng phần mềm R luôn phát triển những package giúp giải quyết các vấn đề cụ thể, điều này có thể sẽ giúp bạn trong công việc của mình! Bạn sẽ có thể cần cài đặt và sử dụng hàng trăm package trong quá trình sử dụng phần mềm R.

Khi cài đặt, R đã có sẵn các package và hàm **"cơ bản"** giúp thực hiện các nhiệm vụ đơn giản. Nhưng nhiều người dùng R tạo ra các hàm chuyên biệt, được cộng đồng R kiểm chứng và bạn có thể tải xuống dưới dạng **package** để sử dụng theo cách của riêng mình. Trong sách này, tên package được viết **in đậm**. Một trong những khía cạnh thách thức hơn cả của R đó là thường có nhiều hàm hoặc package để lựa chọn nhằm hoàn thành một nhiệm vụ nhất định.

### Cài đặt và Gọi {.unnumbered}

*Các hàm* được chứa trong **packages** có thể được tải ("cài đặt") về máy tính của bạn từ internet. Khi một package được tải xuống, package đó sẽ được lưu trữ trong "thư viện" của bạn. Sau đó, bạn có thể truy cập các hàm mà nó chứa trong phiên làm việc hiện tại trên R của bạn bằng cách "Gọi" package.

*Hãy coi R là thư viện cá nhân của bạn*: Khi bạn tải xuống một package, thư viện của bạn nhận được một cuốn sách mới gồm các hàm, nhưng mỗi lần bạn muốn sử dụng một hàm trong cuốn sách đó, bạn phải mượn ("gọi") cuốn sách đó từ thư viện của mình.

Tóm lại: để sử dụng các hàm có sẵn trong package R, phải thực hiện 2 bước:

1)  Package phải được **cài đặt** (một lần), *và*\
2)  Package phải được **gọi** (trong mỗi phiên làm việc của R)

#### Thư viện của bạn {.unnumbered}

"Thư viện" của bạn thực ra là một thư mục trên máy tính của bạn, bao gồm các thư mục chứa các package đã được cài đặt. Hãy tìm nơi R được cài đặt trong máy tính của bạn và tìm kiếm một thư mục có tên "win-library". Ví dụ: `R\win-library\4.0` (4.0 là phiên bản R - bạn sẽ có các thư viện khác nhau tùy theo phiên bản R mà bạn đã tải xuống).

Bạn có thể in ra đường dẫn tệp đến thư viện của mình bằng cách gõ lệnh `.libPaths()` (dấu ngoặc bỏ trống). Điều này trở nên đặc biệt quan trọng nếu làm việc với [R trên ổ cứng mạng].

#### Cài đặt từ CRAN {.unnumbered}

Thông thường, người dùng R tải các package xuống từ CRAN. CRAN (Comprehensive R Archive Network - Mạng lưu trữ R toàn diện) là một kho công cộng trực tuyến gồm các package R đã được xuất bản bởi các thành viên cộng đồng R.

Bạn có cần lo lắng về vi-rút và bảo mật khi tải xuống một package từ CRAN? Đọc [bài viết sau](https://support.rstudio.com/hc/en-us/articles/360042593974-R-and-R-Package-Security) để hiểm thêm về chủ đề này.

#### Làm thế nào để cài đặt và gọi {.unnumbered}

Trong sách này, chúng tôi khuyên bạn nên sử dụng package **pacman** (viết tắt của "package manager"). Nó cung cấp một hàm thuận tiện `p_load()` mà sẽ cài đặt một package nếu cần *và* gọi nó để sử dụng trong phiên làm việc hiện tại.

Cú pháp khá đơn giản. Chỉ cần liệt kê tên của các package trong dấu ngoặc đơn của hàm `p_load()` và phân tách chúng bằng dấu phẩy. Lệnh dưới đây sẽ cài đặt các package sau **rio**, **tidyverse**, và **here** nếu chúng chưa được cài đặt và sẽ gọi chúng ra để sử dụng. Điều này làm cho cách tiếp cận `p_load()` trở nên thuận tiện và ngắn gọn nếu chia sẻ scripts với người khác. Lưu ý rằng tên package có phân biệt chữ hoa chữ thường.

```{r}
# Install (if necessary) and load packages for use
pacman::p_load(rio, tidyverse, here)
```

Lưu ý rằng chúng ta đã sử dụng cú pháp `pacman::p_load()` để viết rõ ràng tên package (**pacman**) trước tên hàm (`p_load()`), được nối với nhau bằng hai dấu hai chấm `::`. Cú pháp này tiện dụng vì nó cũng gọi package **pacman** (giả sử package này đã được cài đặt).

Ngoài ra còn có các hàm **base** R thay thế mà bạn sẽ gặp thường xuyên. Hàm **base** R để cài đặt một package là `install.packages()`. Tên của package muốn cài đặt phải được đặt trong dấu ngoặc đơn bên trong *dấu ngoặc kép*. Nếu bạn muốn cài đặt nhiều package trong một lệnh, chúng phải được liệt kê trong một vectơ dạng ký tự `c()`.

Lưu ý: lệnh này *cài đặt* một package, nhưng *không* gọi nó ra để sử dụng trong phiên làm việc hiện tại.

```{r, eval=F}
# install a single package with base R
install.packages("tidyverse")

# install multiple packages with base R
install.packages(c("tidyverse", "rio", "here"))
```

Việc cài đặt cũng có thể được thực hiện bằng cách chọn và nhấp chuột vào cửa sổ RStudio "Package" và chọn "Install", sau đó tìm kiếm tên package mong muốn cài đặt.

Hàm **base** R để **gọi** một package ra sử dụng (sau khi nó đã được cài đặt) là `library()`. Hàm này chỉ có thể gọi một package tại một thời điểm (cách khác của lệnh `p_load()`). Bạn có thể nhập tên package có hoặc không có dấu ngoặc kép.

```{r, eval=F}
# load packages for use, with base R
library(tidyverse)
library(rio)
library(here)
```

Để kiểm tra xem một package đã được cài đặt và/hoặc đã được gọi hay chưa, bạn có thể xem Cửa số Package trong RStudio. Nếu package được cài đặt, nó sẽ hiển thị ở đó với số phiên bản. Nếu checkbox của nó được đánh dấu nghĩa là nó đã được gọi cho phiên làm việc hiện tại.

**Cài đặt từ Github**

Đôi khi, bạn cần cài đặt một package chưa có sẵn từ CRAN. Hoặc có lẽ package đã có sẵn trên CRAN nhưng bạn muốn *phiên bản mới hơn* với các tính năng mới chưa được cung cấp trong phiên bản cũ. Chúng thường được lưu trữ trên trang web [github.com](https://github.com/) trong một "kho lưu trữ (repository)" code công khai và miễn phí. Đọc thêm về Github trong chương [Version control với Git và Github].

Để download packages R từ Github, bạn có thể dụng hàm `p_load_gh()` từ **pacman**, hàm này sẽ cài đặt package nếu cần và gọi nó để sử dụng cho phiên làm việc R hiện tại. Cách khác để cài đặt bao gồm sử dụng package **remotes** hoặc **devtools**. Đọc thêm về các hàm của **pacman** tại [Tài liệu về package](https://cran.r-project.org/web/packages/pacman/pacman.pdf).

Để cài đặt từ Github, bạn phải cung cấp thêm các thông tin sau:

1)  Github ID của chủ sở hữu
2)  Tên của repository chứa package\
3)  *(Tùy chọn) Tên của "nhánh" (phiên bản phát triển cụ thể) mà bạn muốn tải xuống*

Trong các ví dụ dưới đây, từ đầu tiên trong dấu ngoặc kép là Github ID của chủ sở hữu kho lưu trữ, sau dấu gạch chéo là tên của kho lưu trữ (tên của package).

```{r, eval=F}
# install/load the epicontacts package from its Github repository
p_load_gh("reconhub/epicontacts")
```

Nếu bạn muốn cài đặt từ một "nhánh" (phiên bản) khác với nhánh chính, hãy thêm tên nhánh sau dấu "\@", được đặt phía sau tên kho lưu trữ.

```{r, eval=F}
# install the "timeline" branch of the epicontacts package from Github
p_load_gh("reconhub/epicontacts@timeline")
```

Nếu không có sự khác biệt giữa phiên bản Github và phiên bản trên máy tính của bạn, bạn không cần thực hiện thao tác này. Thay vào đó, bạn có thể "buộc" phải cài đặt lại bằng cách sử dụng `p_load_current_gh()` với đối số `update = TRUE`. Đọc thêm về **pacman** tại [Minh họa trực tuyến](http://trinker.github.io/pacman/vignettes/Introduction_to_pacman.html)

**Cài đặt từ ZIP hoặc TAR**

Bạn có thể cài đặt package từ một URL:

```{r, eval=F}
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

Hoặc, tải xuống máy tính của bạn dưới dạng tệp nén:

Cách 1: sử dụng lệnh `install_local()` từ package **remotes**

```{r, eval=F}
remotes::install_local("~/Downloads/dplyr-master.zip")
```

Cách 2: sử dụng lệnh `install.packages()` của **base** R, cung cấp đường dẫn tệp đến tệp ZIP và thiết lập `type = "source` và `repos = NULL`.

```{r, eval=F}
install.packages("~/Downloads/dplyr-master.zip", repos=NULL, type="source")
```

### Cú pháp code {.unnumbered}

Để tăng sự tường minh trong cuốn sách này, các hàm đôi khi sẽ được đặt sau tên package của chúng bằng cách sử dụng ký hiệu `::` theo cách sau: `package_name::function_name()`

Khi một package được gọi cho một phiên làm việc, việc làm này là không cần thiết. Bạn chỉ cần sử dụng `function_name()`. Tuy nhiên, việc viết tên package sẽ hữu ích khi một tên hàm phổ biến và có thể tồn tại trong nhiều package (ví dụ: `plot()`). Việc viết tên package sẽ giúp gọi package trong trường hợp nó chưa được gọi ra.

```{r eval=FALSE}
# This command uses the package "rio" and its function "import()" to import a dataset
linelist <- rio::import("linelist.xlsx", which = "Sheet1")
```

### Trợ giúp về hàm {.unnumbered}

Để đọc thêm thông tin về một hàm, bạn có thể tìm kiếm hàm đó trong cửa sổ Help của RStudio nằm ở góc dưới bên phải. Hoặc bạn cũng có thể chạy một lệnh chẳng hạn như `?thefunctionname` (đặt tên của hàm sau dấu chấm hỏi) và trang Trợ giúp sẽ xuất hiện trong cửa sổ Help. Cuối cùng, hãy thử tìm kiếm trên internet.

### Cập nhật packages {.unnumbered}

Bạn có thể cập nhật các packages bằng cách cài đặt lại chúng. Bạn cũng có thể bấm vào nút "Update" màu xanh lá cây trong cửa sổ packages của RStudio để xem packages nào có phiên bản mới để cài đặt. Lưu ý rằng code cũ của bạn có thể cần được cập nhật nếu có một bản sửa đổi lớn về cách hoạt động của một hàm!

### Xóa packages {.unnumbered}

Sử dụng `p_delete()` từ **pacman**, hoặc `remove.packages()` từ **base** R. Ngoài ra, hãy tìm thư mục chứa thư viện của bạn và xóa thư mục theo cách thủ công.

### Sự phụ thuộc {.unnumbered}

Các packages thường phụ thuộc vào các packages khác để hoạt động. Chúng được gọi là sự phụ thuộc. Nếu một package không cài đặt được, thì package phụ thuộc vào nó có khả năng cũng không thể cài đặt được.

Xem sự phụ thuộc của một package với lệnh `p_depends()`, và xem package nào phụ thuộc vào nó với `p_depends_reverse()`

### Hàm bị che giấu {.unnumbered}

Không có gì lạ nếu hai hoặc nhiều packages chứa cùng một tên hàm. Ví dụ: packages **dplyr** có hàm `filter()`, nhưng package **stats** cũng vậy. Hàm `filter()` mặc định phụ thuộc vào thứ tự các package này được gọi lên trong phiên làm việc R - packages được gọi ra sau sẽ là mặc định cho hàm `filter()`.

Bạn có thể kiểm tra thứ tự của chúng trong cửa sổ Environment của R Studio - nhấp vào menu thả xuống "Global Environment" và xem thứ tự của các packages. Các hàm thuộc các packages *ở vị trí thấp hơn* trong danh sách thả xuống đó sẽ che giấu các hàm cùng tên trong các packages xuất hiện ở vị trí bên trên trong danh sách thả xuống. Khi bạn vừa gọi một package, R sẽ cảnh báo bạn trong bảng điều khiển nếu xảy ra hiện tượng này, nhưng điều này rất hay bị bỏ quên.

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "masking_functions.png"))
```

Dưới đây là những cách bạn có thể sửa lỗi hàm bị che giấu:

1)  Ghi rõ tên package trong lệnh. Ví dụ, sử dụng `dplyr::filter()`\
2)  Sắp xếp lại thứ tự mà các package được tải (ví dụ trong `p_load()`), và **bắt đầu một phiên làm việc R mới**

### Gỡ package {.unnumbered}

Để gỡ (detach) một package, hãy sử dụng lệnh dưới đây, với tên package chính xác và chỉ có một dấu hai chấm. Lưu ý rằng điều này có thể không giải quyết được việc hàm bị che giấu.

```{r, eval=F}
detach(package:PACKAGE_NAME_HERE, unload=TRUE)
```

### Cài đặt phiên bản cũ hơn {.unnumbered}

Xem [hướng dẫn](https://support.rstudio.com/hc/en-us/articles/219949047-Installing-older-versions-of-packages) này để cài đặt phiên bản cũ hơn của một package cụ thể.

### Packages đề xuất {.unnumbered}

Xem chương [Package đề xuất] để biết danh sách các packages thường được sử dụng trong dịch tễ học.

<!-- ======================================================= -->

## Scripts {#scripts}

Scripts là một phần cơ bản của lập trình. Chúng là các tài liệu chứa các câu lệnh của bạn (ví dụ: các hàm để tạo và chỉnh sửa bộ số liệu, các hàm để in các biểu đồ trực quan hóa số liệu, v.v.). Bạn có thể lưu một scripts và chạy lại sau này. Có nhiều lợi ích để lưu trữ và chạy các lệnh của bạn từ một scripts (so với nhập "từng lệnh" vào R console):

-   Tiện dụng - bạn có thể chia sẻ công việc của mình với người khác bằng cách gửi cho họ các tập lệnh của bạn\
-   Khả năng tái lập - để bạn và những người khác biết chính xác những gì bạn đã làm\
-   Kiểm soát phiên bản - để bạn có thể theo dõi các thay đổi do chính bạn hoặc đồng nghiệp thực hiện\
-   Dễ dàng nhận xét/chú thích - để giải thích cho đồng nghiệp của bạn những gì bạn đã làm

### Bình luận {.unnumbered}

Khi viết script, bạn có thể thêm các chú thích ("bình luận") xung quanh code R của bạn. Bình luận là cần thiết để giải thích cho chính bạn và những người đọc khác hiểu những gì bạn đang làm. Bạn có thể thêm bình luận bằng cách nhập dấu thăng (\#) và viết bình luận của bạn sau đó. Nội dung bình luận sẽ xuất hiện với màu khác với code R.

Bất kỳ code nào được viết sau dấu \# sẽ không được chạy. Do đó, đặt dấu \# trước dòng code cũng là một cách hữu ích để tạm thời vô hiệu hóa một dòng code ("comment out") nếu bạn không muốn xóa nó). Bạn có thể comment out/in nhiều dòng cùng một lúc bằng cách bôi đen chúng và nhấn Ctrl + Shift + c (Cmd + Shift + c trong Mac).

```{r, eval = F}
# A comment can be on a line by itself
# import data
linelist <- import("linelist_raw.xlsx") %>%   # a comment can also come after code
# filter(age > 50)                          # It can also be used to deactivate / remove a line of code
  count()

```

-   Bình luận *những gì* bạn đang làm *và **tại sao** bạn làm như vậy*.\
-   Chia code của bạn thành các phần hợp lý\
-   Kèm theo code của bạn với mô tả từng bước về những gì đang được thực hiện (ví dụ: các bước được đánh số)

### Phong cách viết code {.unnumbered}

Phong cách viết code của bạn rất quan trọng - đặc biệt là khi làm việc theo nhóm. Chúng tôi khuyên bạn nên tuân theo [hướng dẫn](https://style.tidyverse.org/) phong cách viết code **tidyverse** . Bên cạnh đó còn có các packages khác như **styler** và **lintr** để giúp bạn tuân theo phong cách này.

Một vài điểm rất cơ bản để làm cho code của bạn dễ dàng đọc được đối với người khác:\
\* Khi đặt tên cho các đối tượng, chỉ sử dụng các chữ cái viết thường, số và dấu gạch dưới `_`, ví dụ: `my_data`\
\* Thường xuyên sử dụng dấu cách, bao gồm cả xung quanh các toán tử, ví dụ: `n = 1` và `age_new <- age_old + 3`

### Ví dụ về Script {.unnumbered}

Dưới đây là một ví dụ về một đoạn ngắn R script. Hãy nhớ rằng, bạn càng giải thích ngắn gọn lệnh code của mình trong phần bình luận, thì đồng nghiệp của bạn sẽ càng thích bạn!

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "example_script.png"))
```

<!-- ======================================================= -->

### R markdown {.unnumbered}

R markdown là một dạng của R script và có khả năng *xuất* thành các tệp đầu ra (PDF, Word, HTML, Powerpoint, v.v.). Đây là những công cụ vô cùng hữu ích và linh hoạt thường được sử dụng để tạo các báo cáo tự động. Ngay cả trang web và cuốn sách này cũng được viết bằng R markdown!

Bạn cần biết rằng những người mới bắt đầu dùng R cũng có thể sử dụng R Markdown - do đó đừng sợ! Để tìm hiểu thêm, hãy xem chương [Báo cáo với R Markdown] trong cuốn sách này.

<!-- ======================================================= -->

### R notebooks {.unnumbered}

Không có sự khác biệt trong cách viết giữa R markdown và R notebook. Tuy nhiên, việc thực thi của hai loại file này hơi khác nhau một chút. Xem trang [Web](http://uc-r.github.io/r_notebook) này để biết thêm chi tiết.

<!-- ======================================================= -->

### Shiny {.unnumbered}

Shiny apps/websites được chứa trong một script có tên `app.R`. Tệp này có ba thành phần:

1)  Giao diện người dùng (ui)\
2)  Một hàm máy chú\
3)  Một lệng gọi hàm `shinyApp`

Xem thêm trong cuốn sách này tại chương [Dashboards với Shiny], hoặc hướng dẫn trực tuyến này: [Shiny tutorial](https://shiny.rstudio.com/tutorial/written-tutorial/lesson1/)

*Trước đây, tệp bên trên được chia thành 2 tệp con (`ui.R` và `server.R`)*

### Thu gọn Code {.unnumbered}

Bạn có thể thu gọn các đoạn code để làm cho script của bạn dễ đọc hơn.

Để làm điều này, hãy tạo tiêu đề văn bản bằng dấu thăng \#, viết tiêu đề của bạn và thêm vào phía sau nó ít nhất hoặc là 4 dấu gạch ngang (-), dấu thăng (\#) hoặc dấu bằng (=). Ngay sau đó, một mũi tên nhỏ sẽ xuất bên cạnh ở bên phải số thự tự của dòng lệnh. Bạn có thể nhấp vào mũi tên này và phần code bên dưới sẽ được thu gọn cho đến trước tiêu đề tiếp theo và một mũi tên hai chiều xuất hiện ở đây.

Để mở rộng lại đoạn code đã thu gọn, hãy nhấp lại vào mũi tên hoặc biểu tượng mũi tên hai chiều. Ngoài ra còn có thể sử dụng thêm các phím tắt như đã được giải thích trong [mục RStudio](#rstudio) của chương này.

Bằng cách tạo tiêu đề bằng \#, bạn cũng sẽ kích hoạt Mục lục ở cuối tập lệnh của mình (xem bên dưới) mà bạn có thể sử dụng để điều hướng tập lệnh của mình. Bạn có thể tạo tiêu đề phụ bằng cách thêm các ký hiệu \#, ví dụ: \# \# cho tiêu đề chính, \#\# fcho tiêu đề thứ hai, và \#\#\# cho tiêu đề thứ ba.

Dưới đây là hai phiên bản của một ví dụ cho script. Ở bên trái là bản gốc với các tiêu đề được chú thích. Ở bên phải, bốn dấu gạch ngang đã được viết sau mỗi tiêu đề, làm cho chúng có thể thu gọn được. Hai trong số chúng đã được thu gọn và bạn có thể thấy Mục lục ở dưới cùng hiện hiển thị từng phần.

```{r, out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "code_folding1.png"))
knitr::include_graphics(here::here("images", "code_folding2.png"))
```

Các phần code khác mặc định đủ điều kiện để thu gọn bao gồm các phần "nằm giữa" hai dấu ngoặc nhọn `{ }`, chẳng hạn như định nghĩa hàm hoặc các khối điều kiện (câu lệnh if else). Bạn có thể đọc thêm về cách thu gọn code tại [trang của Rstudio](https://support.rstudio.com/hc/en-us/articles/200484568-Code-Folding-and-Sections).

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Thư mục làm việc

Thư mục làm việc là vị trí thư mục gốc được R sử dụng cho công việc của bạn - nơi R tìm kiếm và lưu các tệp theo mặc định. Mặc định là, R sẽ lưu các tệp mới và xuất tệp vào vị trí này, đồng thời sẽ tìm kiếm các tệp để nhập dữ liệu (ví dụ: bộ dữ liệu) tại đây.

Thư mục làm việc xuất hiện bằng dòng chữ màu xám ở phía trên cửa sổ Rstudio Console. Bạn cũng có thể in thư mục làm việc hiện tại bằng cách chạy lệnh `getwd()` (để trống dấu ngoặc đơn).

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "working_directory_1.png"))
```

### Gợi ý cách tiếp cận {.unnumbered}

**Xem thêm tại chương [Dự án R] để biết chi tiết về gợi ý các cách tiếp cận của chúng tôi trong việc quản lý thư mục làm việc của bạn.**\
Một cách phổ biến, hiệu quả và không gặp sự cố khi quản lý thư mục làm việc và đường dẫn tệp là kết hợp 3 yếu tố này trong một quy trình làm việc với [Dự án R] có định hướng :

1)  Một dự án R để lưu trữ tất cả tệp của bạn (xem chương [Dự án R])\
2)  Package **here** để định vị tệp (xem chương [Nhập xuất dữ liệu])\
3)  Packge **rio** để nhập/xuất tệp (xem chương [Nhập xuất dữ liệu])

<!-- ======================================================= -->

### Thiết lập bằng lệnh {.unnumbered}

Cho tới gần đây, nhiều người học R đã được dạy để bắt đầu script của họ bằng lệnh `setwd()`. Hãy thay đổi thói quen đó bằng cách sử dụng [Dự án R] và đọc thêm tài liệu sau để hiểu [lý do không nên sử dụng `setwd()`](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/). Một cách ngắn gọn là, công việc của bạn chỉ thực hiện được trên máy tính của bạn, các đường dẫn tệp được sử dụng để nhập và xuất tệp trở nên "dễ lỗi" và điều này cản trở nghiêm trọng đến việc cộng tác và sử dụng code của bạn trên bất kỳ máy tính nào khác. Bạn có những lựa chọn khác dễ dàng hơn!

Như đã nói ở trên, mặc dù chúng tôi không khuyến nghị phương pháp này trong hầu hết các trường hợp, bạn vẫn có thể sử dụng lệnh `setwd()` với đường dẫn tệp thư mục mong muốn trong dấu ngoặc kép, ví dụ:

```{r, eval=F}
setwd("C:/Documents/R Files/My analysis")
```

[***NGUY HIỂM:*** thiết lập một thư mục làm việc với `setwd()` *có thể* dẫn đến "lỗi" nếu đường dẫn tệp dành riêng cho một máy tính. Thay vào đó, hãy sử dụng đường dẫn tệp liên quan đến thư mục gốc Dự án R (với package **here**).]{style="color: red;"}

<!-- ======================================================= -->

### Thiết lập thủ công {.unnumbered}

Để thiết lập thư mục làm việc một cách thủ công (trỏ và nhấp tương đương với `setwd()`), hãy chọn mục Session trên thanh công cụ và chọn "Set Working Directory", sau đó chọn "Choose Directory". Chú ý: nếu sử dụng phương pháp này, bạn sẽ phải thực hiện việc này theo cách thủ công mỗi khi mở RStudio.

<!-- ======================================================= -->

### Thiết lập bên trong một dự án R {.unnumbered}

Nếu bạn đang mở một dự án R, thư mục làm việc sẽ mặc định là thư mục gốc của dự án R có chứa tệp ".rproj". Điều này sẽ áp dụng nếu bạn mở RStudio bằng cách nhấp vào mở R Project (tệp có phần mở rộng ".rproj").

<!-- ======================================================= -->

### Thư mục làm việc với R markdown {.unnumbered}

Trong script ở R markdown, thư mục làm việc mặc định là thư mục chứa tệp R markdown (`.Rmd`). Nếu sử dụng dự án R và package **here**, điều này sẽ không được áp dụng. Để biết thư mục làm việc là gì, sử dụng lệnh `here()` như đã được giải thích tại chương [Dự án R].

Nếu bạn muốn thay đổi thư mục làm việc của một tệp độc lập ở R markdown (không phải ở dự án R), nếu bạn sử dụng `setwd()` điều này sẽ chỉ áp dụng chỉ cho đoạn code đó. Để thực hiện thay đổi cho tất cả các đoạn code trong R markdown, hãy điều chỉnh ở bước thiết lập để thêm tham số `root.dir =`, như bên dưới:

```{r, eval=F}
knitr::opts_knit$set(root.dir = 'desired/directorypath')
```

Cách này dễ hơn nhiều so với chỉ sử dụng R markdown bên trong một dự án R và sử dụng package **here**.

<!-- ======================================================= -->

### Cung cấp đường dẫn tệp {.unnumbered}

Có lẽ điều khiến những người mới bắt đầu với R cảm thấy nản nhất (ít nhất là với người dùng máy tính Windows) đó là gõ đường dẫn tệp để nhập xuất dữ liệu. Chúng tôi có giải thích cặn kẽ về cách tạo đường dẫn tệp đầu vào tốt nhất trong chương [Nhập xuất dữ liệu], nhưng dưới đây là một số điểm chính:

**Đường dẫn tệp bị lỗi**

Dưới đây là ví dụ về đường dẫn tệp "tuyệt đối" hoặc "địa chỉ đầy đủ". Chúng có thể bị lỗi nếu được sử dụng bởi một máy tính khác. Một ngoại lệ là nếu bạn đang sử dụng ổ đĩa chia sẻ/mạng.

    C:/Users/Name/Document/Analytic Software/R/Projects/Analysis2019/data/March2019.csv  

**Đường dẫn với dấu gạch chéo**

*Nếu nhập đường dẫn tệp, hãy lưu ý hướng của các dấu gạch chéo.* Sử dụng dấu *gạch chéo xuôi* (`/`) để tách các thành phần ("data/provincial.csv"). Đối với người dùng Windows, cách mặc định mà đường dẫn tệp được hiển thị là dấu *gạch chéo ngược* (\\) - vì vậy bạn sẽ cần phải thay đổi hướng của mỗi dấu gạch chéo. Nếu bạn sử dụng package **here** được miêu tả ở [Dự án R] thì dấu gạch chéo không còn là vấn đề với bạn nữa.

**Đường dẫn tệp tương đối**

Nói chung, chúng tôi khuyên bạn nên cung cấp các đường dẫn tệp theo cách "tương đối" - nghĩa là, đường dẫn *liên quan đến* thư mục gốc Dự án R của bạn. Bạn có thể thực hiện việc này bằng cách sử dụng package **here** như được giải thích trong chương [Dự án R]. Một đường dẫn tệp tương đối sẽ trông như thế này:

```{r, eval=F}
# Import csv linelist from the data/linelist/clean/ sub-folders of an R project
linelist <- import(here("data", "clean", "linelists", "marin_country.csv"))
```

Ngay cả khi sử dụng đường dẫn tệp tương đối trong dự án R, bạn vẫn có thể sử dụng đường dẫn tuyệt đối để nhập/xuất dữ liệu ở bên ngoài dự án R của bạn.

<!-- ======================================================= -->

## Đối tượng {#objects}

Mọi thứ trong R đều là một đối tượng, và R là một ngôn ngữ "lập trình hướng đối tượng". Các phần dưới đây sẽ giải thích:

-   Cách tạo ra các đối tượng (`<-`)
-   Các loại đối tượng (ví dụ: data frames, vectors..)\
-   Cách truy cập các tập con của đối tượng (ví dụ: các biến số trong một bộ dữ liệu)\
-   Các loại đối tượng (ví dụ: numeric, logical, integer, double, character, factor)

<!-- ======================================================= -->

### Mọi thứ đều là một đối tượng {.unnumbered}

*Phần này được dựa theo sách [R4Epis project](https://r4epis.netlify.app/training/r_basics/objects/).*\
Mọi thứ bạn lưu trữ trong R - bao gồm bộ dữ liệu, biến số, danh sách tên làng, tổng số dân, thậm chí cả kết quả đầu ra như biểu đồ - đều là **các đối tượng**, được **gán tên** và **có thể được tham chiếu** trong các lệnh sau đó.

Một đối tượng tồn tại khi bạn đã gán giá trị cho nó (xem phần gán bên dưới). Khi nó được gán một giá trị, đối tượng sẽ xuất hiện trong cửa sổ Environment (xem cửa sổ phía trên bên phải của RStudio). Sau đó, nó có thể được sử dụng, thao tác, thay đổi và định nghĩa lại.

<!-- ======================================================= -->

### Định nghĩa một đối tượng (`<-`) {.unnumbered}

**Tạo ra một đối tượng *bằng cách gán cho chúng một giá trị* bằng toán tử \<-.**\
Bạn có thể nghĩ về toán tử gán `<-` tương đương với từ "được định nghĩa là". Các lệnh gán thường tuân theo một trật tự quy định:

**tên đối tượng** \<- **giá trị của đối tượng** (hoặc quy trình / tính toán tạo ra giá trị)

Ví dụ: bạn muốn ghi nhận một báo cáo tuần dịch tễ học hiện tại dưới dạng một đối tượng để tham chiếu tới code của bạn sau này. Trong ví dụ này, đối tượng `current_week` được tạo khi nó được gán giá trị `"2018-W10"` (dấu ngoặc kép sẽ quy định đây là giá trị dạng chữ). Đối tượng `current_week` sẽ xuất hiện trong cửa sổ RStudio Environment (phía trên bên phải) và có thể được tham chiếu tới các lệnh sau này.

Xem các lệnh R và kết quả của chúng như dưới đây.

```{r basics_objects_assignment}
current_week <- "2018-W10"   # this command creates the object current_week by assigning it a value
current_week                 # this command prints the current value of current_week object in the console
```

[***CHÚ Ý:*** Lưu ý rằng số `[1]` trong kết quả ở R console đơn giản là chỉ ra rằng bạn đang xem mục đầu tiên của đầu ra]{style="color: black;"}

[***THẬN TRỌNG:*** **Giá trị của một đối tượng có thể bị ghi đè** bất kỳ lúc nào bằng cách chạy lệnh gán để định nghĩa lại giá trị của nó. Do đó, **thứ tự của các lệnh được chạy rất quan trọng**.]{style="color: orange;"}

Lệnh sau sẽ định nghĩa lại giá trị của đối tượng `current_week`:

```{r basics_objects_reassignment}
current_week <- "2018-W51"   # assigns a NEW value to the object current_week
current_week                 # prints the current value of current_week in the console
```

**Dấu bằng `=`**

Bạn cũng sẽ thấy các dấu bằng trong R code:

-   Hai dấu bằng `==` giữa hai đối tượng hoặc giá trị dùng để đặt một *câu hỏi* logic: "cái này có bằng cái kia không?".\
-   Bạn cũng sẽ thấy các dấu bằng trong các hàm được sử dụng để xác định giá trị của các đối số của hàm (đọc thêm ở các phần bên dưới), ví dụ: `max(age, na.rm = TRUE)`.\
-   Bạn *có thể* sử dụng một dấu bằng `=` thay cho dấu `<-` để tạo và định nghĩa các đối tượng, nhưng điều này không được khuyến khích. Bạn có thể đọc về lý do tại sao điều này không được khuyến khích ở [đây](https://renkun.me/2014/01/28/difference-between-assignment-operators-in-r/).

**Bộ dữ liệu**

Bộ dữ liệu (datasets) cũng là một đối tượng (thường là một "dataframes") và phải được gán tên khi chúng được nhập. Trong đoạn mã dưới đây, đối tượng `linelist` được tạo và gán giá trị từ tệp CSV, tệp này được nhập bằng package **rio** và hàm `import()` của package này.

```{r basics_objects_dataframes, eval=FALSE}
# linelist is created and assigned the value of the imported CSV file
linelist <- import("my_linelist.csv")
```

Bạn có thể đọc thêm về nhập và xuất dữ liệu trong chương [Nhập xuất dữ liệu].

[***THẬN TRỌNG:*** Lưu ý nhanh về cách đặt tên đối tượng:]{style="color: orange;"}

-   Tên đối tượng không được chứa dấu cách, nhưng bạn nên sử dụng dấu gạch dưới (\_) hoặc dấu chấm (.) thay vì dấu cách.\
-   Tên đối tượng phân biệt chữ hoa và chữ thường (nghĩa là Dataset_A khác với dataset_A).
-   Tên đối tượng phải bắt đầu bằng chữ cái (không được bắt đầu bằng số như 1, 2 hoặc 3).

**Kết quả đầu ra**

Các kết quả đầu ra như bảng và biểu đồ cung cấp một ví dụ về cách các kết quả đầu ra có thể được lưu dưới dạng đối tượng hoặc chỉ được in ra mà không cần lưu. Ví dụ, một bảng chéo giữa giới tính và biến kết cục được tạo ra bởi hàm `table()` trong **base** R, có thể được in trực tiếp vào R console (*mà không* cần lưu).

```{r}
# printed to R console only
table(linelist$gender, linelist$outcome)
```

Nhưng bảng này cũng có thể được lưu dưới dạng một đối tượng được đặt tên. Sau đó, bạn có thể in nó ra.

```{r}
# save
gen_out_table <- table(linelist$gender, linelist$outcome)

# print
gen_out_table
```

**Cột**

Các cột trong tập dữ liệu cũng là các đối tượng và có thể được định nghĩa, ghi đè và tạo như được mô tả bên dưới trong phần Cột.

Bạn có thể sử dụng toán tử gán từ **base** R để tạo một cột mới. Dưới đây, cột mới `bmi` (Body Mass Index) được tạo, và giá trị mới ứng với mỗi hàng là kết quả của một phép toán trên giá trị của các hàng trong cột `wt_kg` và cột `ht_cm`.

```{r, eval=F}
# create new "bmi" column using base R syntax
linelist$bmi <- linelist$wt_kg / (linelist$ht_cm/100)^2
```

Tuy nhiên, trong cuốn sách này, chúng tôi tập trung vào một cách tiếp cận khác để định nghĩa cột, sử dụng hàm `mutate()` trong package **dplyr** và *piping* với toán tử pipe (`%>%`). Cú pháp dễ đọc hơn và có những ưu điểm khác đã được giải thích trong cuốn sách này ở chương [Làm sạch số liệu và các hàm quan trọng]. Bạn có thể đọc thêm về *piping* trong phần Piping phía bên dưới.

```{r, eval=F}
# create new "bmi" column using dplyr syntax
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

<!-- ======================================================= -->

### Cấu trúc đối tượng {#objectstructure}

**Các đối tượng có thể là một phần dữ liệu đơn lẻ (ví dụ: `my_number <- 24`), hoặc chúng có thể bao gồm dữ liệu có cấu trúc.**

Hình ảnh dưới đây được tham khảo từ [hướng dẫn R trực tuyến này](http://venus.ifca.unican.es/Rintro/dataStruct.html). Nó cho thấy một số cấu trúc dữ liệu phổ biến và tên của chúng. Hình ảnh này không bao gồm dữ liệu không gian. Bạn có thể xem thêm về dữ liệu không gian tại chương [GIS cơ bản].

```{r basics_objects_structures, echo=F, out.width = "75%", out.height="50%", fig.align = "center"}
knitr::include_graphics(here::here("images", "R_data_structures.png"))
```

Trong dịch tễ học (và đặc biệt là dịch tễ học thực địa), bạn sẽ *thường xuyên* phải tiếp xúc với data frames và vectors:

+---------------------+--------------------------------------------------------------------------------------------------+---------------------------------------------------------------------+
| Cấu trúc thường gặp | Giái thích                                                                                       | Ví dụ                                                               |
+=====================+==================================================================================================+=====================================================================+
| Vectors             | Một vùng chứa cho một chuỗi các đối tượng đơn lẻ, tất cả đều thuộc cùng một loại (e.g. số, chữ). | **"Biến" (Cột) trong dữ liệu là vectors** (ví dụ: cột `age_years`). |
+---------------------+--------------------------------------------------------------------------------------------------+---------------------------------------------------------------------+
| Data Frames         | Vectors (ví dụ: các cột) được liên kết với nhau mà tất cả đều có cùng số hàng.                   | \`linelist\` là một data frame.                                     |
+---------------------+--------------------------------------------------------------------------------------------------+---------------------------------------------------------------------+

Lưu ý rằng để tạo một vectơ "độc lập" (mà không phải là một phần của data frame), hàm `c()` được sử dụng để kết hợp các phần tử khác nhau. Ví dụ: nếu tạo một vectơ màu sắc thang màu của biểu đồ: `vector_of_colors <- c("blue", "red2", "orange", "grey")`

<!-- ======================================================= -->

### Kiểu đối tượng {.unnumbered}

Tất cả các đối tượng được lưu trữ trong R đều có một *kiểu* dữ liệu cho biết cách nó được xử lý. Có nhiều kiểu đối tượng, nhưng những kiểu phổ biến bao gồm:

+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Kiểu       | Giải thích                                                                                                                                                                                                    | Ví dụ                                                                                                              |
+============+===============================================================================================================================================================================================================+====================================================================================================================+
| Ký tự      | Là các chữ/từ/câu được đặt **"trong dấu ngoặc kép"**. Đối tượng kiểu ký tự thì không thể tính toán                                                                                                            | "Những ký tự nằm trong dấu ngoặc kép"                                                                              |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Số nguyên  | Các số **nguyên** (không có phần thập phân)                                                                                                                                                                   | -5, 14, hoặc 2000                                                                                                  |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Số thực    | Bao gồm các số nguyên và **có thể bao gồm phần thập phân**. Nếu trong dấu ngoặc kép, chúng sẽ được coi là dạng ký tự                                                                                          | 23.1 hoặc 14                                                                                                       |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Factor     | Đây là các vector có **trật tự xác định** hoặc các giá trị có nhiều danh mục                                                                                                                                  | Biến số của tình trạng kinh tế với các giá trị theo tứ tự                                                          |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Ngày tháng | **Khi R được thông báo rằng một dữ liệu ở dạng ngày tháng R**, những dữ liệu này có thể được thao tác và hiển thị theo những cách đặc biệt. Xem thêm về biến ngày tháng tại chương [Làm việc với ngày tháng]. | 2018-04-12 hoặc 15/3/1954 hoặc Wed 4 Jan 1980                                                                      |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Logic      | Giá trị của biến chỉ có thể là hai giá trị đặc biệt sau TRUE hoặc FALSE (lưu ý đây **không phải** là "TRUE" và"FALSE" trong dấu ngoặc kép)                                                                    | TRUE hoặc FALSE                                                                                                    |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| data.frame | Một data.frame trong R lưu trữ một **tập dữ liệu điển hình**. Data.frame bao gồm các vector (cột) dữ liệu được liên kết với nhau, tất cả chúng đều có cùng một số lượng quan sát (hàng).                      | Tập dữ liệu mẫu AJS có tên là `linelist_raw`chứa 68 biến với 300 quan sát (mỗi hàng)                               |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| tibble     | tibbles là một dạng khác của data.frame, sự khác biệt chính là tibble in đẹp hơn trong R console (hiển thị 10 hàng đầu tiên và chỉ các cột vừa với màn hình)                                                  | data frame, danh sách, hoặc ma trận có thể chuyển đổi thành tibble bằng hàm `as_tibble()`                          |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+
| Danh sách  | Một danh sách giống như một vector, nhưng chứa các đối tượng có kiểu khác nhau                                                                                                                                | Một danh sách có thể chứa một số duy nhất, một data.frame, một vector và thậm chí một danh sách khác bên trong nó! |
+------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------+

**Bạn có thể kiểm tra kiểu của một đối tượng bằng cách cung cấp tên của nó tới hàm `class()`**. Lưu ý: bạn có thể tham chiếu một cột cụ thể trong tập dữ liệu bằng cách sử dụng ký hiệu `$` để phân tách tên của tập dữ liệu và tên của cột.

```{r, echo=TRUE,}
class(linelist)         # class should be a data frame or tibble

class(linelist$age)     # class should be numeric

class(linelist$gender)  # class should be character
```

Đôi khi, một cột sẽ được tự động chuyển đổi thành một kiểu khác bởi R. Hãy coi chừng điều này! Ví dụ: nếu bạn có một vectơ hoặc cột kiểu số, nhưng một giá trị ký tự được chèn vào ... thì toàn bộ cột sẽ thay đổi thành kiểu ký tự.

```{r}
num_vector <- c(1,2,3,4,5) # define vector as all numbers
class(num_vector)          # vector is numeric class
num_vector[3] <- "three"   # convert the third element to a character
class(num_vector)          # vector is now character class
```

Một ví dụ phổ biến của điều này là khi thao tác với một data frame để in bảng - nếu bạn tạo một hàng tính tổng và cố gắng dán /gắn phần trăm với số trong cùng một ô (ví dụ: `23 (40%)`), toàn bộ cột dạng số ở trên sẽ chuyển đổi thành ký tự và không còn có thể được sử dụng cho các phép tính toán học nữa.

**Đôi khi, bạn sẽ cần chuyển đổi các đối tượng hoặc cột sang một loại khác.**

+------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| Hàm              | Chức năng                                                                                                                         |
+==================+===================================================================================================================================+
| `as.character()` | Chuyển sang kiểu ký tự                                                                                                            |
+------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| `as.numeric()`   | Chuyển sang kiểu số                                                                                                               |
+------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| `as.integer()`   | Chuyển sang kiểu số nguyên                                                                                                        |
+------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| `as.Date()`      | Chuyển sang kiểu ngày tháng - Chú ý: Xem mục [Ngày tháng](#dates) để biết thêm chi tiết                                           |
+------------------+-----------------------------------------------------------------------------------------------------------------------------------+
| `factor()`       | Chuyển sang kiểu factor - Chú ý: nếu muốn định nghĩa lại thứ tự của các giá trị trong biến factor thì cần thêm các đối số bổ sung |
+------------------+-----------------------------------------------------------------------------------------------------------------------------------+

Tương tự như vậy, một số hàm **base** R có thể kiểm tra xem một đối tượng CÓ thuộc của một kiểu dữ liệu cụ thể nào hay không, chẳng hạn như `is.numeric()`, `is.character()`, `is.double()`, `is.factor()`, `is.integer()`

Bạn có thể tham khảo [một tài liệu trực tuyến về các kiểu và cấu trúc dữ liệu trong R](https://swcarpentry.github.io/r-novice-inflammation/13-supp-data-structures/) tại đây.

<!-- ======================================================= -->

### Cột / Biến số (`$`) {.unnumbered}

**Một cột trong data frame về mặt kỹ thuật là một "vector" (xem bảng ở trên)** - bao gồm một chuỗi các giá trị cùng loại (ký tự, số, lôgic, v.v.).

Một vectơ có thể tồn tại độc lập với một data frame, ví dụ: vectơ tên cột mà bạn muốn đưa vào làm biến giải thích trong mô hình. Để tạo một vectơ "độc lập", hãy sử dụng hàm `c()` như dưới đây:

```{r, warning=F, message=F}
# define the stand-alone vector of character values
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")

# print the values in this named vector
explanatory_vars
```

**Các cột trong data frame cũng là vectơ và có thể được gọi, tham chiếu, trích xuất hoặc tạo bằng ký hiệu `$`.** Ký hiệu `$` kết nối tên của cột với tên của data frame tương ứng. Trong cuốn sách này, chúng tôi cố gắng sử dụng từ "cột" thay vì "biến số".

```{r basics_objects_call, eval=F}
# Retrieve the length of the vector age_years
length(linelist$age) # (age is a column in the linelist data frame)

```

Bằng cách nhập tên của một dataframe, theo sau bởi ký tự `$`, bạn sẽ thấy menu gợi ý của tất cả các tên cột trong dataframe. Bạn có thể di chuyển giữa các cột bằng phím mũi tên, chọn cột bằng phím Enter để tránh lỗi chính tả!

```{r echo=F, out.width = "100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Calling_Names.gif"))
```

[***MẸO NÂNG CAO:*** Một số đối tượng phức tạp hơn (ví dụ: một danh sách hoặc đối tượng `epicontacts`) có thể có nhiều cấp độ có thể được truy cập thông qua nhiều ký tự đô la. Ví dụ: `epicontacts$linelist$date_onset`]{style="color: darkgreen;"}

<!-- ======================================================= -->

### Truy cập / indexing đối tượng bằng dấu ngoặc vuông (`[ ]`) {.unnumbered}

Khi cần xem một phần của đối tượng, còn được gọi là "indexing", bạn có thể sử dụng dấu ngoặc vuông `[ ]`. Sử dụng `$` trên dataframe để truy cập một cột cũng là một kiểu indexing.

```{r}
my_vector <- c("a", "b", "c", "d", "e", "f")  # define the vector
my_vector[5]                                  # print the 5th element
```

Dấu ngoặc vuông cũng hoạt động để xem các phần cụ thể trong kết quả đầu ra, chẳng hạn như đầu ra của hàm `summary()`:

```{r}
# All of the summary
summary(linelist$age)

# Just the second element of the summary, with name (using only single brackets)
summary(linelist$age)[2]

# Just the second element, without name (using double brackets)
summary(linelist$age)[[2]]

# Extract an element by name, without showing the name
summary(linelist$age)[["Median"]]

```

Dấu ngoặc vuông cũng hoạt động trên data frames để xem các hàng và cột cụ thể. Bạn có thể thực hiện việc này bằng cú pháp `dataframe[rows, columns]`:

```{r basics_objects_access, eval=F}
# View a specific row (2) from dataset, with all columns (don't forget the comma!)
linelist[2,]

# View all rows, but just one column
linelist[, "date_onset"]

# View values from row 2 and columns 5 through 10
linelist[2, 5:10] 

# View values from row 2 and columns 5 through 10 and 18
linelist[2, c(5:10, 18)] 

# View rows 2 through 20, and specific columns
linelist[2:20, c("date_onset", "outcome", "age")]

# View rows and columns based on criteria
# *** Note the dataframe must still be named in the criteria!
linelist[linelist$age > 25 , c("date_onset", "outcome", "age")]

# Use View() to see the outputs in the RStudio Viewer pane (easier to read) 
# *** Note the capital "V" in View() function
View(linelist[2:20, "date_onset"])

# Save as a new object
new_table <- linelist[2:20, c("date_onset")] 
```

Lưu ý rằng bạn cũng có thể indexing hàng / cột trong một data frames và tibbles bằng cách sử dụng cú pháp của package **dplyr** (hàm `filter()` đối với hàng, và `select()` đối với cột). Đọc thêm về các hàm quan trọng này trong chương [Làm sạch số liệu và các hàm quan trọng].

Để lọc dựa trên "số thứ tự hàng", bạn có thể sử dụng hàm `row_number()`trong package **dplyr** với dấu ngoặc đơn mở như một phần của biểu thức lọc logic. Thường thì bạn sẽ sử dụng toán tử `%in%` và một khoảng giá trị số như một phần của câu lệnh logic đó, như được trình bày dưới đây. Để xem N hàng *đầu tiên*, bạn cũng có thể sử dụng hàm `head()` của package **dplyr**.

```{r, eval=F}
# View first 100 rows
linelist %>% head(100)

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns (note no quotes necessary on column names)
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

Khi indexing một đối tượng chứa một **danh sách** bằng một dấu ngoặc vuông sẽ luôn trả về kiểu danh sách, ngay cả khi chỉ một đối tượng được trả về . Tuy nhiên, hai dấu ngoặc vuông có thể được sử dụng để truy cập một phần tử đơn lẻ đối và trả về một kiểu không phải là một danh sách.\
Dấu ngoặc vuông cũng có thể được viết sau nhau, như được minh họa bên dưới.

Bạn có thể xem một [giải thích trực quan về việc indexing với ví dụ về hộp lắc hạt tiêu](https://r4ds.had.co.nz/vectors.html#lists-of-condiments) tại đây, rất hài hước và hữu ích.

```{r}
# define demo list
my_list <- list(
  # First element in the list is a character vector
  hospitals = c("Central", "Empire", "Santa Anna"),
  
  # second element in the list is a data frame of addresses
  addresses   = data.frame(
    street = c("145 Medical Way", "1048 Brown Ave", "999 El Camino"),
    city   = c("Andover", "Hamilton", "El Paso")
    )
  )
```

Đây là cách mà một danh sách được in trong R console. Có hai phần tử được đặt tên:

-   `hospitals`, một vector chứa ký tự\
-   `addresses`, một data frame chứa các địa chỉ

```{r}
my_list
```

Dưới đây là các phương pháp indexing mà bạn có thể sử dụng:

```{r}
my_list[1] # this returns the element in class "list" - the element name is still displayed

my_list[[1]] # this returns only the (unnamed) character vector

my_list[["hospitals"]] # you can also index by name of the list element

my_list[[1]][3] # this returns the third element of the "hospitals" character vector

my_list[[2]][1] # This returns the first column ("street") of the address data frame

```

<!-- ======================================================= -->

### Xóa đối tượng {.unnumbered}

Bạn có thể xóa từng đối tượng riêng lẻ khỏi cửa sổ R environment bằng cách để tên của đối tượng cần xóa vào trong hàm `rm()` (không có dấu ngoặc kép):

```{r, eval=F}
rm(object_name)
```

Bạn có thể xóa tất cả các đối tượng (xóa không gian làm việc của bạn) bằng cách chạy:

```{r, eval=F}
rm(list = ls(all = TRUE))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Piping (`%>%`)

**Hai cách tiếp cận chung để làm việc với các đối tượng là:**

1)  **Pipes/tidyverse** - pipes chuyển một đối tượng từ hàm này sang hàm khác - tập trung vào *hành động* chứ không phải đối tượng\
2)  **Xác định đối tượng trung gian** - một đối tượng được xác định lại nhiều lần - tập trung vào đối tượng

<!-- ======================================================= -->

### **Pipes** {.unnumbered}

**Giải thích một cách đơn giản, toán tử pipe (`%>%`) chuyển một đầu ra trung gian từ hàm này sang hàm tiếp theo.**\
Hiểu đơn giản pipe nghĩa là "sau đó". Nhiều hàm có thể được liên kết với nhau bằng toán tử `%>%`.

-   **Piping nhấn mạnh một chuỗi các hành động, không phải đối tượng mà các hành động đang áp dụng**\
-   Pipes được áp dụng tốt nhất khi một chuỗi hành động phải được thực hiện trên một đối tượng\
-   Pipes đến từ package **magrittr**, và đã tự động được thêm vào packages **dplyr** và **tidyverse**
-   Pipes làm cho code sạch hơn, dễ đọc hơn và trực quan hơn

Đọc thêm về cách tiếp cận này trong package tidyverse tại đây [Hướng dẫn](https://style.tidyverse.org/pipes.html)

Đây là một ví dụ mô phỏng dùng để so sánh, sử dụng các hàm hư cấu để "nướng bánh". Đầu tiên, phương pháp pipe:

```{r piping_example_pipe, eval=F}
# A fake example of how to bake a cake using piping syntax

cake <- flour %>%       # to define cake, start with flour, and then...
  add(eggs) %>%   # add eggs
  add(oil) %>%    # add oil
  add(water) %>%  # add water
  mix_together(         # mix together
    utensil = spoon,
    minutes = 2) %>%    
  bake(degrees = 350,   # bake
       system = "fahrenheit",
       minutes = 35) %>%  
  let_cool()            # let it cool down
```

Đây là một [link](https://cfss.uchicago.edu/notes/pipes/#:~:text=Pipes%20are%20an%20extremely%20useful,code%20and%20combine%20multiple%20operations) khác mô tả công dụng của pipe.

Piping không phải là một hàm trong **base** R. Để sử dụng piping, package **magrittr** phải được cài đặt và gọi ra trong phiên làm việc hiện tại (điều này thường được thực hiện bằng cách gọi package **tidyverse** hoặc **dplyr**). Bạn có thể [đọc thêm về piping trong tài liệu magrittr](https://magrittr.tidyverse.org/).

Lưu ý rằng cũng giống như các lệnh R khác, các pipes có thể được sử dụng để hiển thị kết quả hoặc lưu/lưu lại một đối tượng, tùy thuộc vào toán tử `<-` được code như thế nào. Xem hai ví dụ dưới đây:

```{r, eval=F}
# Create or overwrite object, defining as aggregate counts by age category (not printed)
linelist_summary <- linelist %>% 
  count(age_cat)
```

```{r}
# Print the table of counts in the console, but don't save it
linelist %>% 
  count(age_cat)
```

**`%<>%`**\

Đây là một "assignment pipe (pipe dùng để gán)" từ package **magrittr**, package này sẽ *pipe một đối tượng theo chiều tiến lên và cũng tái định nghĩa lại đối tượng*. Đối tượng cần đứng đầu trong chuỗi pipe. Nó nhanh hơn sử dụng pipe thông thường. Hai lệnh dưới đây là tương đương với nhau:

```{r, eval=F}
linelist <- linelist %>%
  filter(age > 50)

linelist %<>% filter(age > 50)
```

<!-- ======================================================= -->

### Định nghĩa đối tượng trung gian {.unnumbered}

Cách tiếp cận này dùng để thay đổi đối tượng/dataframes sẽ phát huy hiệu quả nếu:

-   Bạn cần thao tác trên nhiều đối tượng\
-   Các bước trung gian có ý nghĩa cụ thể và xứng đáng tạo các tên đối tượng riêng biệt

**Các nguy cơ:**

-   Tạo đối tượng mới cho mỗi bước có nghĩa là bạn sẽ tạo thêm rất nhiều đối tượng. Nếu bạn sử dụng không cẩn thận, bạn có thể dễ dàng bị nhầm lẫn!\
-   Đặt thêm nhiều tên cho nhiều đối tượng có thể gây nhầm lẫn\
-   Nếu có lỗi thì không dễ để phát hiện

Đặt tên cho từng đối tượng trung gian hoặc ghi đè lên đối tượng gốc hoặc kết hợp tất cả hàm với nhau đều đi kèm với những rủi ro.

Dưới đây vẫn là ví dụ mô phỏng quy trình làm "bánh" tương tự như trên, nhưng sử dụng phong cách này:

```{r piping_example_redefine, eval=F}
# a fake example of how to bake a cake using this method (defining intermediate objects)
batter_1 <- left_join(flour, eggs)
batter_2 <- left_join(batter_1, oil)
batter_3 <- left_join(batter_2, water)

batter_4 <- mix_together(object = batter_3, utensil = spoon, minutes = 2)

cake <- bake(batter_4, degrees = 350, system = "fahrenheit", minutes = 35)

cake <- let_cool(cake)
```

Kết hợp tất cả các hàm với nhau - câu lệnh rất khó đọc:

```{r eval=F}
# an example of combining/nesting mutliple functions together - difficult to read
cake <- let_cool(bake(mix_together(batter_3, utensil = spoon, minutes = 2), degrees = 350, system = "fahrenheit", minutes = 35))
```

<!-- ======================================================= -->

## Các toán tử và hàm chính {#operators}

Mục này sẽ trình bày chi tiết các toán tử trong R, chẳng hạn như :

-   Toán tử định nghĩa\
-   Toán tử quan hệ (nhỏ hơn, bằng nhau..)\
-   Toán tử logic (và, hoặc..)\
-   Xử lý missing\
-   Các toán tử và hàm toán học (+/-, \>, sum(), median(), ...)\
-   Toán tử `%in%`

<!-- ======================================================= -->

### Toán tử gán {.unnumbered}

**`<-`**

Toán tử gán cơ bản trong R là `<-`. Chẳng hạn như `object_name <- value`.\
Toán tử gán này cũng có thể được viết là `=`. Chúng tôi khuyên bạn nên sử dụng `<-`.\
Bạn nên sử dụng dấu cách trong khi viết code với toán tử gán để dễ đọc hơn.

**`<<-`**

Khi [Viết hàm], hoặc khi sử dụng R với scipt nguồn, thì bạn có thể cần sử dụng toán tử gán này `<<-` (từ **base** R). Toán tử này được sử dụng để định nghĩa một đối tượng trong một hàm lồng trong một hàm khác. Xem thêm tại [nguồn tham khảo online này](https://stat.ethz.ch/R-manual/R-devel/library/base/html/assignOps.html).

**`%<>%`**

Đây là một "pipe gán" từ package **magrittr**, package này sẽ *gán một đối tượng theo chiều tiến lên và cũng định nghĩa lại đối tượng*. Pipe gán phải là toán tử đầu tiên trong chuỗi pipe code. Đây là cách viết ngắn gọn, như được trình bày dưới đây là hai ví dụ tương đương với nhau:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age_months = age_years * 12)
```

Đoạn code bên trên tương đương với code dưới đây:

```{r, eval=F}
linelist %<>% mutate(age_months = age_years * 12)
```

**`%<+%`**

Toán tử này được sử dụng dể thêm dữ liệu vào Cây phả hệ với package **ggtree**. Xem thêm chương [Cây phả hệ] hoặc [Sách online này](https://yulab-smu.top/treedata-book/).

<!-- ======================================================= -->

### Toán tử quan hệ và logic {.unnumbered}

Toán tử quan hệ so sánh các giá trị và thường được sử dụng khi định nghĩa các biến mới và tập con của bộ dữ liệu. Dưới đây là các toán tử quan hệ phổ biến trong R:

+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Ý nghĩa               | Toán tử    | Ví dụ        | Kết quả đầu ra của ví dụ                                                                                                                                   |
+=======================+============+==============+============================================================================================================================================================+
| Bằng                  | `==`       | `"A" == "a"` | `FALSE` (vì R phân biệt chữ hoa chữ thường) Lưu ý rằng *== (hai dấu bằng) khác với = (một dấu bằng), một dấu bằng hoạt động tương tự với toán tử gán `<-`* |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Không bằng            | `!=`       | `2 != 0`     | `TRUE`                                                                                                                                                     |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Lớn hơn               | `>`        | `4 > 2`      | `TRUE`                                                                                                                                                     |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Nhỏ hơn               | `<`        | `4 < 2`      | `FALSE`                                                                                                                                                    |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Lớn hơn hoặc bằng     | `>=`       | `6 >= 4`     | `TRUE`                                                                                                                                                     |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Nhỏ hơn hoặc bằng     | `<=`       | `6 <= 4`     | `FALSE`                                                                                                                                                    |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Giá trị bị missing    | `is.na()`  | `is.na(7)`   | `FALSE` (Xem thêm chương [Dữ liệu Missing])                                                                                                                |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Giá trị không missing | `!is.na()` | `!is.na(7)`  | `TRUE`                                                                                                                                                     |
+-----------------------+------------+--------------+------------------------------------------------------------------------------------------------------------------------------------------------------------+

Các toán tử logic, chẳng hạn như AND và OR, thường được sử dụng để kết nối các quan hệ và tạo ra các điều kiện phức tạp hơn. Các biểu thức phức tạp có thể yêu cầu dấu ngoặc đơn () để phân nhóm và thứ tự áp dụng.

+---------------+---------------------------------------------------------------------------------+
| Ý nghĩa       | Toán tử                                                                         |
+===============+=================================================================================+
| AND           | `&`                                                                             |
+---------------+---------------------------------------------------------------------------------+
| OR            | `|` (thanh dọc)                                                                 |
+---------------+---------------------------------------------------------------------------------+
| Dấu ngoặc đơn | `( )` Được sử dụng để nhóm các tiêu chí lại với nhau và làm rõ thứ tự hoạt động |
+---------------+---------------------------------------------------------------------------------+

Ví dụ: chúng ta có một số liệu có tên linelist với hai biến mà chúng tôi muốn sử dụng để minh họa, `hep_e_rdt`: kết quả xét nghiệm và `other_cases_in_hh`: những trường hợp khác trong gia đình. Lệnh dưới đây sử dụng hàm `case_when()` để tạo biến mới `case_def` như sau:

```{r eval=FALSE}
linelist_cleaned <- linelist %>%
  mutate(case_def = case_when(
    is.na(rdt_result) & is.na(other_case_in_home)            ~ NA_character_,
    rdt_result == "Positive"                                 ~ "Confirmed",
    rdt_result != "Positive" & other_cases_in_home == "Yes"  ~ "Probable",
    TRUE                                                     ~ "Suspected"
  ))
```

+---------------------------------------------------------------------------------------------------------+-------------------------------------------+
| Điều kiện trong ví dụ ở trên                                                                            | Giá trị kết quả trong biến mới "case_def" |
+=========================================================================================================+===========================================+
| Nếu giá trị của biến `rdt_result` và `other_cases_in_home` bị missing                                   | `NA` (missing)                            |
+---------------------------------------------------------------------------------------------------------+-------------------------------------------+
| Nếu giá trị trong `rdt_result` là "Positive"                                                            | "Confirmed"                               |
+---------------------------------------------------------------------------------------------------------+-------------------------------------------+
| Nếu giá trị trong `rdt_result` KHÔNG phải là "Positive" VÀ giá trị trong `other_cases_in_home` là "Yes" | "Probable"                                |
+---------------------------------------------------------------------------------------------------------+-------------------------------------------+
| Nếu một trong các tiêu chí trên không được đáp ứng                                                      | "Suspected"                               |
+---------------------------------------------------------------------------------------------------------+-------------------------------------------+

Lưu ý rằng R có phân biệt chữ hoa chữ thường, vì vậy *"Positive" khác với "positive"...*

<!-- ======================================================= -->

### Giá trị Missing {.unnumbered}

Trong R, giá trị missing được biểu diễn bằng giá trị đặc biệt `NA` (giá trị "dành riêng cho missing") (chữ N và A viết hoa - không nằm trong dấu ngoặc kép). Nếu dữ liệu bạn nhập vào R bị missing theo cách khác (ví dụ: 99, "Missing", or .), bạn có thể sẽ cần phải mã hóa lại các giá trị đó thành `NA`. Cách thực hiện việc này được đề cập trong chương [Nhập xuất dữ liệu].

**Để kiểm tra xem một giá trị có phải là `NA` hay không, sử dụng hàm đặc biệt `is.na()`**, kết quả sẽ trả về `TRUE` hoặc `FALSE`.

```{r basics_operators_missing}
rdt_result <- c("Positive", "Suspected", "Positive", NA)   # two positive cases, one suspected, and one unknown
is.na(rdt_result)  # Tests whether the value of rdt_result is NA
```

Đọc thêm về missing, vô hạn, `NULL`, và các giá trị không thể trong chương [Dữ liệu Missing]. Tìm hiểu thêm cách chuyển đổi các giá trị bị missing khi nhập dữ liệu trong chương [Nhập xuất dữ liệu].

<!-- ======================================================= -->

### Toán học và thống kê {.unnumbered}

Tất cả các toán tử và hàm trong chương này đều có sẵn bằng cách sử dụng **base** R.

#### Toán tử toán học {.unnumbered}

Chúng thường được sử dụng để thực hiện phép cộng, phép chia, để tạo cột mới, v.v. Dưới đây là các toán tử toán học phổ biến trong R. Việc bạn có đặt dấu cách xung quanh các toán tử hay không là không quan trọng.

| Mục đích         | Ví dụ trong R |
|------------------|---------------|
| phép cộng        | 2 + 3         |
| phép trừ         | 2 - 3         |
| phép nhân        | 2 \* 3        |
| phép chia        | 30 / 5        |
| số mũ            | 2\^3          |
| thứ tự hoạt động | ( )           |

#### Các hàm toán học {.unnumbered}

| Mục tiêu          | Hàm                                   |
|-------------------|---------------------------------------|
| làm tròn          | round(x, digits = n)                  |
| làm tròn          | janitor::round_half_up(x, digits = n) |
| làm tròn lên      | ceiling(x)                            |
| làm tròn xuống    | floor(x)                              |
| giá trị tuyệt đối | abs(x)                                |
| căn bậc hai       | sqrt(x)                               |
| số mũ             | exponent(x)                           |
| logarit tự nhiên  | log(x)                                |
| logarit cơ số 10  | log10(x)                              |
| logarit cơ số 2   | log2(x)                               |

lưu ý: sử dụng hàm `round()` và `digits =` để xác định số chữ số thập phân được hiển thị. Sử dụng hàm `signif()` để làm tròn đến số chữ số nhất định.

#### Ký hiệu khoa học {.unnumbered}

Khả năng ký hiệu khoa học được sử dụng phụ thuộc vào giá trị của `scipen`.

Từ tài liệu hướng dẫn của `?options`: scipen được áp dụng khi quyết định in các giá trị số theo ký hiệu cố định hoặc hàm mũ. Giá trị dương thuộc về ký hiệu cố định còn giá trị âm thuộc về ký hiệu khoa học: ký hiệu cố định sẽ luôn được ưu tiên trừ khi có nhiều chữ số 'scipen'.

Nếu như có rất nhiều số bé cần hiển thị (vd: số 0), mặc định tính năng này sẽ "được bật". Để "tắt" tính năng ký hiệu khoa học trong phiên làm việc của bạn, hãy thiết lập nó với một số rất lớn, ví dụ:

```{r, eval=F}
# turn off scientific notation
options(scipen=999)
```

#### Làm tròn {.unnumbered}

[***NGUY HIỂM:*** Hàm `round()` sử dụng "cách làm tròn của ngân hàng" nghĩa là chỉ làm tròn với số .5 nếu số được làm tròn lên là số chẵn. Sử dụng hàm `round_half_up()` từ package **janitor** để thống nhất cách làm tròn với giá trị .5. Xem thêm [giải thích sau đây](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)]{style="color: red;"}

```{r}
# use the appropriate rounding function for your work
round(c(2.5, 3.5))

janitor::round_half_up(c(2.5, 3.5))
```

#### Các hàm thống kê {.unnumbered}

[***CẨN TRỌNG:*** Các hàm sau đây sẽ mặc định bao gồm cả giá trị missing khi tính toán. Giá trị missing sẽ trả về kết quả đầu ra chứa `NA`, trừ khi đối số `na.rm = TRUE` được xác định khi viết hàm. Nó cũng có thể viết ngắn gọn thành `na.rm = T`.]{style="color: orange;"}

| Mục đích          | Hàm                |
|-------------------|--------------------|
| trung bình        | mean(x, na.rm=T)   |
| trung vị          | median(x, na.rm=T) |
| độ lệch chuẩn     | sd(x, na.rm=T)     |
| phân vị\*         | quantile(x, probs) |
| tổng              | sum(x, na.rm=T)    |
| giá trị nhỏ nhất  | min(x, na.rm=T)    |
| giá trị lớn nhất  | max(x, na.rm=T)    |
| khoảng giá trị số | range(x, na.rm=T)  |
| tóm tắt\*\*       | summary(x)         |

Notes:

-   `*quantile()`: `x` là vectơ số cần khảo sát, và `probs =` là một vectơ số với các xác suất nằm giữa 0 và 1.0, ví dụ `c(0.5, 0.8, 0.85)`
-   `**summary()`: trả về tóm tắt một vectơ số bao gồm giá trị trung bình, trung vị, và các khoảng phân vị thường gặp

[***NGUY HIỂM:*** Nếu cung cấp một vectơ số cho một trong các hàm trên, hãy đảm bảo các số được đặt trong hàm `c()` .]{style="color: red;"}

```{r}
# If supplying raw numbers to a function, wrap them in c()
mean(1, 6, 12, 10, 5, 0)    # !!! INCORRECT !!!  

mean(c(1, 6, 12, 10, 5, 0)) # CORRECT
```

#### Một số hàm hữu ích khác {.unnumbered}

+------------------------+-------------------+-------------------------------------------------+
| Mục đích               | Hàm               | Ví dụ                                           |
+========================+===================+=================================================+
| Tạo chuỗi số liên tục  | seq(from, to, by) | `seq(1, 10, 2)`                                 |
+------------------------+-------------------+-------------------------------------------------+
| lặp x, n lần           | rep(x, ntimes)    | `rep(1:3, 2)` or `rep(c("a", "b", "c"), 3)`     |
+------------------------+-------------------+-------------------------------------------------+
| chia nhỏ một vectơ số  | cut(x, n)         | `cut(linelist$age, 5)`                          |
+------------------------+-------------------+-------------------------------------------------+
| lấy một mẫu ngẫu nhiên | sample(x, size)   | `sample(linelist$id, size = 5, replace = TRUE)` |
+------------------------+-------------------+-------------------------------------------------+

<!-- ======================================================= -->

### `%in%` {.unnumbered}

Một toán tử rất hữu ích để nhanh chóng đánh giá xem một giá trị có nằm trong một vectơ hoặc một dataframe hay không.

```{r}
my_vector <- c("a", "b", "c", "d")
```

```{r}
"a" %in% my_vector
"h" %in% my_vector
```

Để truy vấn một giá trị **không** `%in%` một vectơ, hãy đặt dấu chấm than (!) **phía trước** biểu thức logic:

```{r}
# to negate, put an exclamation in front
!"a" %in% my_vector
!"h" %in% my_vector
```

`%in%` sẽ rất hữu dụng khi dùng hàm `case_when()` của package **dplyr**. Bạn có thể định nghĩa một vectơ trước đó, sau đó tham chiếu đến nó. ví dụ:

```{r eval=F}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")

linelist <- linelist %>% 
  mutate(child_hospitaled = case_when(
    hospitalized %in% affirmative & age < 18 ~ "Hospitalized Child",
    TRUE                                      ~ "Not"))
```

Lưu ý: Nếu bạn muốn phát hiện một phần của chuỗi, có lẽ việc sử dụng hàm `str_detect()` từ package **stringr**, sẽ không chấp nhận một vectơ ký tự kiểu như `c("1", "Yes", "yes", "y")`. Thay vào đó, nó cần được cung cấp dưới dạng một *biểu thức chính quy* - một chuối cô đọng với thanh dọc cho phép so sánh OR, chẳng hạn như "1\|Yes\|yes\|y". Ví dụ, `str_detect(hospitalized, "1|Yes|yes|y")`. Xem thêm chương [Ký tự và chuỗi] để biết thêm chi tiết.

Bạn có thể chuyển đổi một vectơ ký tự thành một biểu thức chính quy được đặt tên bằng lệnh này:

```{r}
affirmative <- c("1", "Yes", "YES", "yes", "y", "Y", "oui", "Oui", "Si")
affirmative

# condense to 
affirmative_str_search <- paste0(affirmative, collapse = "|")  # option with base R
affirmative_str_search <- str_c(affirmative, collapse = "|")   # option with stringr package

affirmative_str_search
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Lỗi và cảnh báo

Phần này giải thích:

-   Sự khác biệt giữa lỗi và cảnh báo\
-   Mẹo cú pháp chung để viết code R\
-   Trợ giúp viết code

Các lỗi thường gặp và cảnh báo cũng như mẹo khắc phục sự cố có thể được tìm thấy trong chương [Các lỗi thường gặp].

<!-- ======================================================= -->

### Lỗi và Cảnh báo {.unnumbered}

Khi một lệnh được thực thi, cửa sổ R Console có thể hiển thị cho bạn cảnh báo hoặc thông báo lỗi bằng văn bản màu đỏ.

-   Một **cảnh báo** nghĩa là R đã hoàn thành lệnh của bạn, nhưng phải thực hiện các bước bổ sung hoặc tạo ra kết quả bất thường mà bạn cần lưu ý.

-   Một **lỗi** nghĩa là R không thể hoàn thành lệnh của bạn.

Tìm manh mối:

-   Thông báo lỗi/cảnh báo thường sẽ bao gồm số dòng xảy ra sự cố.

-   Nếu một đối tượng "không xác định được (is unknown)" hoặc "không tìm thấy (not found)", có lẽ bạn đã viết sai chính tả, quên gọi một package bằng hàm library(), hoặc quên chạy lại tập lệnh của bạn sau khi thực hiện các thay đổi.

Nếu vẫn thất bại, hãy sao chép thông báo lỗi vào Google cùng với một số từ khóa chính - rất có thể ai đó cũng đã gặp lỗi này rồi!

<!-- ======================================================= -->

### Mẹo cú pháp chung {.unnumbered}

Một số điều cần nhớ khi viết lệnh trong R, để tránh lỗi và cảnh báo:

-   Luôn đóng dấu ngoặc đơn - mẹo: đếm số lần mở dấu ngoặc đơn "(" và đóng dấu ngoặc đơn ")" cho mỗi đoạn mã
-   Tránh để khoảng trắng trong tên cột và đối tượng. Thay vào đó, hãy sử dụng dấu gạch dưới (\_) hoặc dấu chấm (.)
-   Theo dõi và nhớ tách các đối số của hàm bằng dấu phẩy
-   R phân biệt chữ hoa và chữ thường, nghĩa là `Variable_A` *khác* với `variable_A`

<!-- ======================================================= -->

### Trợ giúp viết code {.unnumbered}

Bất kỳ tập lệnh nào (RMarkdown hoặc những cái khác) sẽ cung cấp manh mối khi bạn mắc lỗi. Ví dụ: nếu bạn quên viết dấu phẩy ở vị trí cần thiết hoặc quên đóng dấu ngoặc đơn, RStudio sẽ treo cờ trên dòng đó, ở phía bên trái của script, để cảnh báo bạn.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/basics.Rmd-->

# Chuyển đổi sang R {#transition-to-R}

Dưới đây, chúng tôi cung cấp một số lời khuyên và tài nguyên nếu bạn đang chuyển đổi sang R.

R được giới thiệu vào cuối những năm 1990 và kể từ đó đã phát triển quy mô mạnh mẽ. Khả năng của nó rộng đến mức các lựa chọn thương mại thay thế đã phản ứng với sự phát triển của R để duy trì tính cạnh tranh! ([đọc bài viết so sánh R, SPSS, SAS, STATA và Python](https://www.inwt-statistics.com/read-blog/comparison-of-r-python-sas-spss-and-stata.html)).

Hơn thế nữa, R đã dễ học hơn nhiều so với 10 năm trước. Trước đây, R nổi tiếng là khó sử dụng cho những người mới bắt đầu. Giờ đây việc này trở nên dễ dàng hơn nhiều với giao diện người dùng thân thiện như RStudio, code trực quan như **tidyverse** và có nhiều tài nguyên hướng dẫn.

[**Đừng ngần ngại - hãy đến khám phá thế giới của R!**]{style="color: darkgreen;"}

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "transition_door.png"))
```

## Từ Excel

Chuyển đổi từ Excel trực tiếp sang R hoàn toàn là mục tiêu có thể đạt được. Nó dường như có vẻ khó khăn, nhưng bạn có thể làm được!

Sự thật là một người có kỹ năng Excel tốt có thể thực hiện các thao tác nâng cao chỉ trong Excel - ngay cả khi sử dụng các công cụ tạo script như VBA. Excel được sử dụng trên toàn thế giới và là một công cụ cần thiết cho một nhà dịch tễ học. Tuy nhiên, kết hợp nó với R có thể cải thiện và mở rộng đáng kể quy trình công việc của bạn.

### Lợi ích {.unnumbered}

Bạn sẽ thấy rằng việc sử dụng R mang lại những lợi ích to lớn trong việc tiết kiệm thời gian, giúp phân tích nhất quán và chính xác hơn, có khả năng tái lập, khả năng chia sẻ và sửa lỗi nhanh hơn. Giống như bất kỳ phần mềm mới nào, bạn phải đầu tư một "đường cong" thời gian học tập để trở nên quen thuộc. Bạn sẽ được mở ra những kĩ năng mới trên một phạm vi rộng đáng kể với R.

Excel là một phần mềm phổ biến mà người dùng mới bắt đầu có thể dễ dàng sử dụng để tạo ra các phân tích và sơ đồ hóa đơn giản với các thao tác "trỏ và nhấp". Trong khi đó, có thể mất vài tuần để trở nên quen thuộc với các chức năng và giao diện của R. Tuy nhiên, R đã phát triển trong những năm gần đây để trở nên thân thiện hơn với người mới bắt đầu.

Nhiều quy trình làm việc của Excel phụ thuộc vào trí nhớ và sự lặp lại - do đó, có nhiều khả năng xảy ra lỗi. Hơn nữa, nhìn chung, việc làm sạch dữ liệu, phương pháp phân tích và các phương trình được sử dụng đều bị ẩn đi trong trang tính. Có thể cần đến một khoảng thời gian đáng kể để những người mới bắt đầu hiểu trang tính Excel đang làm gì và cách khắc phục sự cố. Với R, tất cả các bước được viết rõ ràng trong script và có thể dễ dàng xem, chỉnh sửa, sửa lỗi và áp dụng cho các bộ dữ liệu khác.

**Để bắt đầu chuyển đổi từ Excel sang R, bạn phải điều chỉnh tư duy của mình theo một số hướng quan trọng:**

### Tidy data {.unnumbered}

Sử dụng "tidy" data để máy có thể đọc được thay vì dữ liệu lộn xộn "con người có thể đọc được". Dưới đây là ba yêu cầu chính đối với "tidy" data", đã được giải thích trong hướng dẫn này về ["tidy" data trong R](https://r4ds.had.co.nz/tidy-data.html):

-   Mỗi biến số nằm trên một cột
-   Mỗi quan sát phải nằm trên một hàng
-   Mỗi giá trị phải có ô riêng

Đối với người dùng Excel - hãy nghĩ đến vai trò của ["bảng" Excel](https://exceljet.net/excel-tables) trong việc chuẩn hóa dữ liệu và làm cho định dạng trở nên dễ đoán hơn.

Một ví dụ về "tidy" data là trường hợp bộ dữ liệu linelist được sử dụng trong cuốn sổ tay này - mỗi biến được chứa trong một cột, mỗi quan sát (mỗi trường hợp) có hàng riêng và mọi giá trị chỉ nằm trong một ô. Dưới đây, bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu linelist:

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

*Nguyên nhân chính khiến người dùng gặp phải tình trạng non-tidy data là do nhiều bảng tính Excel được thiết kế để ưu tiên con người dễ đọc chứ không phải máy móc/phần mềm dễ đọc.*

Để giúp bạn thấy sự khác biệt, dưới đây là một số ví dụ mô phỏng về **non-tidy data** mà ưu tiên khả năng đọc của *con người* hơn khả năng đọc của *máy*:

```{r, echo=F, out.width = "100%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_1.png"))
```

*Vấn đề:* Trong bảng tính ở trên, một số ô *đã được ghép với nhau* - khiến chúng trở nên khó đọc bởi R. Hàng nào nên được coi là "tiêu đề" không rõ ràng. Từ điển dựa trên màu sắc nằm ở phía bên phải và các giá trị ô được biểu thị bằng màu sắc - điều này cũng không dễ dàng được giải thích bởi R (cũng như những người bị mù màu!). Hơn nữa, các phần thông tin khác nhau được kết hợp thành một ô (nhiều tổ chức đối tác hoạt động trong cùng một khu hoặc trạng thái "TBC" trong cùng ô với "Partner D").

```{r, echo=F, out.width = "100%", out.height="100%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Excel_nonTidy_2.png"))
```

*Vấn đề:* Trong bảng tính ở trên, có rất nhiều hàng và cột trống trong bộ dữ liệu - điều này sẽ gây phiền toái khi làm sạch trong R. Hơn nữa, tọa độ GPS được trải rộng trên hai hàng cho một trung tâm điều trị nhất định. Một lưu ý nhỏ - tọa độ GPS có hai định dạng khác nhau!

Các bộ dữ liệu "tidy" có thể không đọc được bằng mắt người, nhưng chúng giúp việc làm sạch và phân tích dữ liệu dễ dàng hơn rất nhiều! Tidy data có thể được lưu trữ ở nhiều định dạng khác nhau, chẳng hạn như dạng "dọc" hoặc "ngang""(xem chương về [Xoay trục dữ liệu]), tuy nhiên các nguyên tắc trên vẫn được tuân thủ.

### Hàm {.unnumbered}

Từ "hàm (function)" trong R có thể mới, nhưng khái niệm này cũng tồn tại trong Excel dưới dạng *công thức (formulas)*. Công thức trong Excel cũng yêu cầu cú pháp chính xác (ví dụ: vị trí của dấu chấm phẩy và dấu ngoặc đơn). Tất cả những gì bạn cần làm là tìm hiểu một vài hàm mới và cách chúng hoạt động cùng nhau trong R.

### Script {.unnumbered}

Thay vì nhấp vào các biểu tượng và kéo các ô, bạn sẽ viết *mọi* bước và quy trình thành một "script". Người dùng Excel có thể quen thuộc với "VBA macros", thứ mà cũng sử dụng cách tiếp cận script.

*R script bao gồm các hướng dẫn từng bước.* Điều này cho phép bất kỳ đồng nghiệp nào cũng có thể đọc script và dễ dàng xem các bước bạn đã thực hiện. Điều này cũng giúp loại bỏ lỗi hoặc các tính toán không chính xác. Xem phần [R cơ bản] về script để có thêm các ví dụ.

Dưới đây là một ví dụ của một R script:

```{r, echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "example_script.png"))
```

### Tài liệu liên quan đến chuyển đổi từ Excel-sang-R {.unnumbered}

Dưới đây là một vài đường link hướng dẫn giúp bạn chuyển đổi sang R từ Excel:

-   [R vs. Excel](https://www.northeastern.edu/graduate/blog/r-vs-excel/)\
-   [Các khóa RStudio trong R cho người dùng Excel](https://rstudio-conf-2020.github.io/r-for-excel/)

### Tương tác giữa R và Excel {.unnumbered}

R có khả năng mạnh trong việc nhập các Excel workbook, làm việc với dữ liệu, xuất/lưu tệp Excel và làm việc với các sắc thái của các trang tính Excel.

Đúng là một số định dạng Excel có tính thẩm mỹ hơn có thể bị mất trong quá trình chuyển đổi (ví dụ: chữ nghiêng, chữ nằm ngang, v.v.). Nếu quy trình công việc của bạn yêu cầu chuyển tài liệu qua lại giữa R và Excel trong khi vẫn giữ nguyên định dạng Excel ban đầu, hãy thử các package như **openxlsx**.

## Từ Stata

**Chuyển đến R từ Stata**

Nhiều nhà dịch tễ học được dạy cách sử dụng Stata ngay từ đầu, và có vẻ khó khăn khi chuyển sang R. Tuy nhiên, nếu bạn là một người dùng quen Stata thì việc chuyển sang R chắc chắn sẽ dễ quản lý hơn bạn nghĩ. Mặc dù có một số khác biệt chính giữa Stata và R về cách tạo và sửa đổi dữ liệu, cũng như cách triển khai các chức năng phân tích -- sau khi tìm hiểu những khác biệt chính này, bạn sẽ có thể chuyển đổi các kỹ năng của mình.

Dưới đây là một số cách chuyển đổi chính giữa Stata và R, điều mà có thể hữu ích khi bạn xem lại hướng dẫn này.

**Những lưu ý chung**

+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                                                                                         | **R**                                                                                                                                                                                  |
+===================================================================================================================================================================+========================================================================================================================================================================================+
| Bạn chỉ có thể xem và thao tác với một bộ dữ liệu tại một thời điểm                                                                                               | Bạn có thể xem và thao tác với nhiều bộ dữ liệu cùng một lúc, do đó, bạn sẽ thường xuyên phải xác định bộ dữ liệu của mình trong code                                                  |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Cộng đồng trực tuyến có sẵn trên <https://www.statalist.org/>                                                                                                     | Cộng đồng trực tuyến có sẵn trên [RStudio](https://community.rstudio.com/), [StackOverFlow](https://stackoverflow.com/questions/tagged/r) và [R-bloggers](https://www.r-bloggers.com/) |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Thao tác trỏ và nhấp chuột như một tùy chọn                                                                                                                       | Thao tác trỏ và nhấp chuột được giảm tối thiểu                                                                                                                                         |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Trợ giúp cho các lệnh có sẵn trong `help [command]`                                                                                                               | Trợ giúp có sẵn trong `[function]?` hoặc tìm kiếm trong cửa sổ Help                                                                                                                    |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Bình luận code sử dụng \* hoặc /// hoặc /\* VĂN BẢN \*/                                                                                                           | Bình luận code sử dụng \#                                                                                                                                                              |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Hầu hết tất cả các lệnh đều được tích hợp sẵn trong Stata. Các lệnh mới do người dùng viết có thể được cài đặt như file **ado** sử dụng **ssc install** [package] | R được cài đặt sẵn các lệnh **cơ bản**, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương [R cơ bản])                                              |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Phân tích thường được viết trong **do** file                                                                                                                      | Phân tích được viết trong R script ở cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.                                                                    |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Thư mục làm việc**

+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                        | **R**                                                                                                                                                       |
+==================================================================================================+=============================================================================================================================================================+
| Thư mục làm việc bao gồm các đường dẫn tuyệt đối (Ví dụ: "C:/usename/documents/projects/data/")\ | Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package **here** (xem chương [Nhập xuất dữ liệu]) |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Xem thư mục làm việc hiện tại với **pwd**                                                        | Sử dụng `getwd()` hoặc `here()` (nếu sử dụng package **here**), với dấu ngoặc đơn trống                                                                     |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Cài đặt thư mục làm việc với **cd** "folder location"                                            | Sử dụng `setwd(“folder location”)` hoặc `set_here("folder location)` (nếu sử dụng package **here**)                                                         |
+--------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Nhập và xem dữ liệu**

+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                                                                          | **R**                                                                                                                                                                                                           |
+====================================================================================================================================================+=================================================================================================================================================================================================================+
| Các lệnh cụ thể cho mỗi loại tệp                                                                                                                   | Sử dụng `import()` từ package **rio** cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương [Nhập xuất dữ liệu])                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Đọc file csv được thực hiện bằng cách sử dụng **import delimited** "filename.csv"                                                                  | Sử dụng `import("filename.csv")`                                                                                                                                                                                |
+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Đọc file xslx được thực hiện bằng cách sử dụng **import excel** "filename.xlsx"                                                                    | Sử dụng `import("filename.xlsx")`                                                                                                                                                                               |
+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Duyệt dữ liệu của bạn trong một cửa sổ mới bằng lệnh **browse**                                                                                    | Xem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng `View(dataset)`. *Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hoa "V" trong hàm này* |
+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Có cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng **summarize**, lệnh này cung cấp tên biến và các thông tin cơ bản của bộ dữ liệu | Có cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng `summary(dataset)`                                                                                                                            |
+----------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Thao tác dữ liệu cơ bản**

+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                 | **R**                                                                                                                                                                                     |
+===========================================================================================+===========================================================================================================================================================================================+
| Các cột của bộ dữ liệu thường được gọi là "các biến (variables)"                          | Thường được gọi là "các cột (columns)" hoặc thỉnh thoảng là "các véctơ (vectors)" hoặc "các biến (variables)"                                                                             |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Không cần xác định bộ dữ liệu                                                             | Trong mỗi lệnh dưới đây, bạn cần xác định bộ dữ liệu - xem ví dụ trong chương [Làm sạch số liệu và các hàm quan trọng]                                                                    |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến mới được tạo bằng lệnh **generate** *varname* =                                  | Tạo các biến mới bằng cách sử dụng lệnh `mutate(varname = )`. Xem chương [Làm sạch số liệu và các hàm quan trọng] để biết tất cả chi tiết về câu lệnh **dplyr** bên dưới                  |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến được đổi tên bằng cách sử dụng **rename** *old_name new_name*                    | Các cột có thể được đổi tên bằng cách sử dụng lệnh `rename(new_name = old_name)`                                                                                                          |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến được lược bỏ sử dụng **drop** *varname*                                          | Có thể lược bỏ các cột bằng cách sử dụng lệnh `select()` với tên cột trong ngoặc đơn sau dấu trừ                                                                                          |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến factor có thể được gán nhãn bằng cách sử dụng một loạt lệnh như **label define** | Việc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương [Factors]. Tên cột thường không được gán nhãn như trong Stata. |
+-------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Phân tích mô tả**

+-------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **STATA**                                                                                 | **R**                                                                                                                                                                                                |
+===========================================================================================+======================================================================================================================================================================================================+
| Đếm số lượng bảng của một biến sử dụng **tab** *varname*                                  | Cung cấp bộ dữ liệu và tên cột cho `table()` ví dụ như `table(dataset$colname)`. Ngoài ra, có thể sử dụng lệnh `count(varname)` từ package **dplyr**, đã được giải thích trong chương [Nhóm dữ liệu] |
+-------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Lập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng **tab** *varname1 varname2* | Sử dụng `table(dataset$varname1, dataset$varname2` hoặc `count(varname1, varname2)`                                                                                                                  |
+-------------------------------------------------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Mặc dù danh sách này cung cấp một cái nhìn tổng quan về những điều cơ bản trong việc chuyển các lệnh Stata sang R, nhưng nó vẫn chưa đầy đủ. Bạn có thể quan tâm tới nhiều nguồn tài nguyên tuyệt vời khác dành cho người dùng Stata chuyển sang R:

-   <https://dss.princeton.edu/training/RStata.pdf>
-   <https://clanfear.github.io/Stata_R_Equivalency/docs/r_stata_commands.html>
-   <http://r4stats.com/books/r4stata/>

## Từ SAS

**Chuyển từ SAS sang R**

SAS thường được sử dụng tại các cơ quan y tế công cộng và các lĩnh vực nghiên cứu học thuật. Mặc dù chuyển đổi sang một ngôn ngữ mới hiếm khi là một quá trình đơn giản, nhưng hiểu được những điểm khác biệt chính giữa SAS và R có thể giúp bạn bắt đầu chuyển hướng ngôn ngữ mới bằng ngôn ngữ mẹ đẻ của mình. Dưới đây là phác thảo các bước chuyển đổi chính trong quản lý dữ liệu và phân tích mô tả giữa SAS và R.

**Những lưu ý chung**

+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                                                               | **R**                                                                                                                                         |
+=======================================================================================================================================================================================================================+===============================================================================================================================================+
| Cộng đồng trực tuyến có sẵn trên [SAS Customer Support](https://support.sas.com/en/support-home.html)                                                                                                                 | Cộng đồng trực tuyến có sẵn trên RStudio, StackOverFlow và R-bloggers                                                                         |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Trợ giúp cho các lệnh có sẵn trong `help [command]`                                                                                                                                                                   | Trợ giúp có sẵn trong `[function]?` hoặc tìm kiếm trong cửa sổ Help                                                                           |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Bình luận code sử dụng `* VĂN BẢN ;` hoặc `/* VĂN BẢN */`                                                                                                                                                             | Bình luận code sử dụng \#                                                                                                                     |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Hầu hết tất cả các lệnh đều được tích hợp sẵn. Người dùng có thể viết lệnh mới bằng cách sử dụng SAS macro, SAS/IML, SAS Component Language (SCL) và mới đây nhất là, được thực hiện bằng `Proc Fcmp` và `Proc Proto` | R được cài đặt sẵn các lệnh \*\*cơ bản\*\*, nhưng quá trình sử dụng thông thường cần cài đặt các package khác từ CRAN (xem chương [R cơ bản]) |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+
| Phân tích thường được viết trong chương trình SAS ở cửa sổ Editor.                                                                                                                                                    | Phân tích được viết trong R script trong cửa sổ chính của RStudio. Các script của R markdown là một giải pháp thay thế.                       |
+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-----------------------------------------------------------------------------------------------------------------------------------------------+

**Thư mục làm việc**

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                         | **R**                                                                                                                                                       |
+=================================================================================================================================================================================+=============================================================================================================================================================+
| Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng `%let rootdir=/root path; %include “&rootdir/subfoldername/filename”` | Thư mục làm việc có thể là đường dẫn tuyệt đối hoặc tương đối đến thư mục gốc của dự án bằng cách sử dụng package **here** (xem chương [Nhập xuất dữ liệu]) |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Xem thư mục làm việc hiện tại với `%put %sysfunc(getoption(work));`                                                                                                             | Sử dụng `getwd()` hoặc `here()` (nếu sử dụng package **here**), với dấu ngoặc đơn trống                                                                     |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Cài đặt thư mục làm việc với `libname “folder location”`                                                                                                                        | Sử dụng `setwd(“folder location”)` hoặc `set_here("folder location)` (nếu sử dụng package **here**)                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Nhập và xem dữ liệu**

+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                                                                 | **R**                                                                                                                                                                                                       |
+=========================================================================================================================================================================================================================+=============================================================================================================================================================================================================+
| Sử dụng lệnh `Proc Import` hoặc sử dụng lệnh `Data Step Infile`                                                                                                                                                         | Sử dụng `import()` từ package **rio** cho hầu hết tất cả các loại tệp. Các chức năng cụ thể tồn tại dưới dạng lựa chọn thay thế (xem chương [Nhập xuất dữ liệu])                                            |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Đọc file csv được thực hiện bằng cách sử dụng `Proc Import datafile=”filename.csv” out=work.filename dbms=CSV; run;` HOẶC sử dụng [Data Step Infile statement](http://support.sas.com/techsup/technote/ts673.pdf)       | Sử dụng `import("filename.csv")`                                                                                                                                                                            |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Đọc các tệp xslx được thực hiện bằng cách sử dụng `Proc Import datafile=”filename.xlsx” out=work.filename dbms=xlsx; run;` HOẶC sử dụng [Data Step Infile statement](http://support.sas.com/techsup/technote/ts673.pdf) | Sử dụng `import("filename.xlsx")`                                                                                                                                                                           |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Duyệt bộ dữ liệu của bạn trong cửa sổ mới bằng cách mở cửa sổ Explorer và chọn thư viện và tập dữ liệu mong muốn.                                                                                                       | Xem bộ dữ liệu trong cửa sổ nguồn RStudio sử dụng View(dataset). *Bạn cần xác định tên bộ dữ liệu của mình cho hàm trong R vì nhiều bộ dữ liệu có thể được mở cùng một lúc. Lưu ý viết hóa "V" trong hàm này* |
+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Thao tác dữ liệu cơ bản**

+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                                                   | **R**                                                                                                                                                                     |
+===========================================================================================================================================================================+===========================================================================================================================================================================+
| Các cột của bộ dữ liệu thường được gọi là "các biến (variables)"                                                                                                          | Thường được gọi là "các cột (columns)" hoặc thỉnh thoảng là "các véctơ (vectors)" hoặc "các biến (variables)"                                                             |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Không cần thao tác đặc biệt để tạo ra một biến. Các biến mới được tạo đơn giản bằng cách nhập tên biến mới, theo sau là dấu bằng, sau đó là biểu thức cho giá trị         | Tạo các biến mới bằng cách sử dụng hàm `mutate(varname = )`. Xem chương [Làm sạch số liệu và các hàm quan trọng] để biết tất cả chi tiết về câu lệnh **dplyr** bên dưới   |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến được đổi tên bằng cách sử dụng `rename *old_name=new_name*`                                                                                                      | Các cột có thể được đổi tên bằng cách sử dụng ệnh `rename(new_name = old_name)`                                                                                           |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến được giữ bằng cách sử dụng `**keep**=varname`                                                                                                                    | Các cột có thể được chọn bằng cách sử dụng lệnh `select()` với tên cột trong ngoặc đơn                                                                                    |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến được lược bỏ sử dụng `**drop**=varname`                                                                                                                          | Có thể lược bỏ các cột bằng cách sử dụng lệnh `select()` với tên cột trong ngoặc đơn sau dấu trừ                                                                          |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các biến Factor có thể được gán nhãn trong Data Step bằng cách sử dụng lệnh `Label`                                                                                       | Việc gán nhãn các giá trị có thể được thực hiện bằng cách chuyển đổi cột thành nhóm Factor và chỉ định thứ bậc. Xem chương [Factors]. Tên cột thường không được gán nhãn. |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Các bản ghi được chọn bằng cách sử dụng lệnh `Where` hoặc `If` trong Data Step. Nhiều điều kiện lựa chọn được phân tách bằng lệnh "and".                                  | Các bản ghi được chọn bằng cách sử dụng lệnh `filter()` với nhiều điều kiện lựa chọn được phân tách bằng toán tử AND (&) hoặc dấu phẩy                                    |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Bộ dữ liệu được hợp nhất bằng cách sử dụng lệnh `Merge` trong Data Step. Các bộ dữ liệu được hợp nhất cần phải được sắp xếp trước bằng cách sử dụng thao tác `Proc Sort`. | Package **dplyr** cung cấp một số chức năng để hợp nhất các tập dữ liệu. Xem chi tiết trong chương [Nối dữ liệu].                                                         |
+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Phân tích mô tả**

+------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **SAS**                                                                                                                                        | **R**                                                                                                                                                                                                                          |
+================================================================================================================================================+================================================================================================================================================================================================================================+
| Có cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng thao tác `Proc Summary`, thao tác mà cung cấp tên biến và các thống kê mô tả | Có cái nhìn tổng quan hơn về bộ dữ liệu của bạn bằng cách sử dụng `summary(dataset)` hoặc `skim(dataset)` từ package **skimr** package                                                                                         |
+------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Đếm số lượng bảng của một biến sử dụng `proc freq data=Dataset; Tables varname; Run;`                                                          | Xem chương [Bảng mô tả]. Các tùy chọn trong số tất cả các tùy chọn khác bao gồm `table()` từ **base** R và `tabyl()` từ package **janitor**. Lưu ý rằng bạn sẽ cần xác định bộ dữ liệu và tên cột vì R chứa nhiều tập dữ liệu. |
+------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Lập bảng chéo của hai biến trong bảng 2x2 được thực hiện bằng `proc freq data=Dataset; Tables rowvar*colvar; Run;`                             | Một lần nữa, bạn có thể sử dụng `table()`, `tabyl()` hoặc những cách khác đã được mô tả trong chương [Bảng mô tả].                                                                                                             |
+------------------------------------------------------------------------------------------------------------------------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

**Một số tài nguyên hữu ích:**

[R for SAS and SPSS Users (2011)](https://www.amazon.com/SAS-SPSS-Users-Statistics-Computing/dp/1461406846/ref=sr_1_1?dchild=1&gclid=EAIaIQobChMIoqLOvf6u7wIVAhLnCh1c9w_DEAMYASAAEgJLIfD_BwE&hvadid=241675955927&hvdev=c&hvlocphy=9032185&hvnetw=g&hvqmt=e&hvrand=16854847287059617468&hvtargid=kwd-44746119007&hydadcr=16374_10302157&keywords=r+for+sas+users&qid=1615698213&sr=8-1)

[SAS and R, Second Edition (2014)](https://www.amazon.com/SAS-Management-Statistical-Analysis-Graphics-dp-1466584491/dp/1466584491/ref=dp_ob_title_bk)

## Khả năng tương tác dữ liệu

Xem chương [Nhập xuất dữ liệu] để biết chi tiết về cách R package **rio** có thể nhập và xuất các file như file STATA .dta, file SAS .xpt và .sas7bdat, file SPSS .por và .sav và nhiều file khác.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/transition_to_R.Rmd-->

# Package đề xuất {#packages-suggested}

Dưới đây là danh sách các package được đề xuất dành cho các công việc dịch tễ học phổ biến trong R. Bạn có thể sao chép code này, chạy nó và tất cả các package này sẽ cài đặt từ CRAN và tải để sử dụng trong phiên làm việc hiện tại. Nếu một package đã được cài đặt, nó sẽ chỉ được gọi ra để sử dụng.  

Bạn có thể sửa đổi code với ký hiệu `#` để loại bỏ bất kỳ packages nào bạn không muốn.  

Chú ý:  

* Đầu tiên, cần cài đặt package **pacman** trước khi chạy đoạn code dưới đây. Bạn có thể thực hiện việc này với lệnh `install.packages("pacman")`. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, sẽ có thể vừa cài đặt package nếu cần *và* gọi chúng ra để sử dụng trong phiên làm việc. Bạn cũng có thể gọi package đã được cài đặt với lệnh `library()` từ **base** R.  
* Trong đoạn code dưới đây, các packages được bao gồm khi cài đặt/gọi thông qua một package khác được trình bày bằng cách thụt lề và dấu thăng. Ví dụ: **ggplot2** được liệt kê bên dưới **tidyverse**.  
* Nếu nhiều package có các hàm cùng tên, việc *đè lên nhau* đè lên nhau có thể xảy ra khi hàm từ package được gọi ra sau sẽ được ưu tiên hơn. Đọc thêm trong chương [R cơ bản]. Cân nhắc sử dụng package **conflicted** để quản lý các xung đột tương tự.  
* Xem chương [R cơ bản] mục packages để biết thêm về **pacman** và ghi đè.  

Để xem các phiên bản của R, RStudio và R packages được sử dụng trong quá trình viết cuốn sổ tay này, xem chương [Biên tập và ghi chú kỹ thuật].  

## Packages từ CRAN  

```{r, eval=F}

##########################################
# List of useful epidemiology R packages #
##########################################

# This script uses the p_load() function from pacman R package, 
# which installs if package is absent, and loads for use if already installed


# Ensures the package "pacman" is installed
if (!require("pacman")) install.packages("pacman")


# Packages available from CRAN
##############################
pacman::p_load(
     
     # learning R
     ############
     learnr,   # interactive tutorials in RStudio Tutorial pane
     swirl,    # interactive tutorials in R console
        
     # project and file management
     #############################
     here,     # file paths relative to R project root folder
     rio,      # import/export of many types of data
     openxlsx, # import/export of multi-sheet Excel workbooks 
     
     # package install and management
     ################################
     pacman,   # package install/load
     renv,     # managing versions of packages when working in collaborative groups
     remotes,  # install from github
     
     # General data management
     #########################
     tidyverse,    # includes many packages for tidy data wrangling and presentation
          #dplyr,      # data management
          #tidyr,      # data management
          #ggplot2,    # data visualization
          #stringr,    # work with strings and characters
          #forcats,    # work with factors 
          #lubridate,  # work with dates
          #purrr       # iteration and working with lists
     linelist,     # cleaning linelists
     naniar,       # assessing missing data
     
     # statistics  
     ############
     janitor,      # tables and data cleaning
     gtsummary,    # making descriptive and statistical tables
     rstatix,      # quickly run statistical tests and summaries
     broom,        # tidy up results from regressions
     lmtest,       # likelihood-ratio tests
     easystats,
          # parameters, # alternative to tidy up results from regressions
          # see,        # alternative to visualise forest plots 
     
     # epidemic modeling
     ###################
     epicontacts,  # Analysing transmission networks
     EpiNow2,      # Rt estimation
     EpiEstim,     # Rt estimation
     projections,  # Incidence projections
     incidence2,   # Make epicurves and handle incidence data
     i2extras,     # Extra functions for the incidence2 package
     epitrix,      # Useful epi functions
     distcrete,    # Discrete delay distributions
     
     
     # plots - general
     #################
     #ggplot2,         # included in tidyverse
     cowplot,          # combining plots  
     # patchwork,      # combining plots (alternative)     
     RColorBrewer,     # color scales
     ggnewscale,       # to add additional layers of color schemes

     
     # plots - specific types
     ########################
     DiagrammeR,       # diagrams using DOT language
     incidence2,       # epidemic curves
     gghighlight,      # highlight a subset
     ggrepel,          # smart labels
     plotly,           # interactive graphics
     gganimate,        # animated graphics 

     
     # gis
     ######
     sf,               # to manage spatial data using a Simple Feature format
     tmap,             # to produce simple maps, works for both interactive and static maps
     OpenStreetMap,    # to add OSM basemap in ggplot map
     spdep,            # spatial statistics 
     
     # routine reports
     #################
     rmarkdown,        # produce PDFs, Word Documents, Powerpoints, and HTML files
     reportfactory,    # auto-organization of R Markdown outputs
     officer,          # powerpoints
     
     # dashboards
     ############
     flexdashboard,    # convert an R Markdown script into a dashboard
     shiny,            # interactive web apps
     
     # tables for presentation
     #########################
     knitr,            # R Markdown report generation and html tables
     flextable,        # HTML tables
     #DT,              # HTML tables (alternative)
     #gt,              # HTML tables (alternative)
     #huxtable,        # HTML tables (alternative) 
     
     # phylogenetics
     ###############
     ggtree,           # visualization and annotation of trees
     ape,              # analysis of phylogenetics and evolution
     treeio            # to visualize phylogenetic files
 
)

```

## Packages từ Github  


Dưới đây là các lệnh giúp cài đặt trực tiếp packages từ kho lưu trữ trên Github.  

* Phiên bản phát triển của **epicontacts** có khả năng tạo cây lây nhiễm với trục x tạm thời  
* Package **epirhandbook** chứa tất cả các dữ liệu minh họa cho sổ tay này và có thể được sử dụng để tải xuống phiên bản ngoại tuyến của sổ tay.  


```{r, eval=F}
# Packages to download from Github (not available on CRAN)
##########################################################

# Development version of epicontacts (for transmission chains with a time x-axis)
pacman::p_install_gh("reconhub/epicontacts@timeline")

# The package for this handbook, which includes all the example data  
pacman::p_install_gh("appliedepi/epirhandbook")



```

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/packages_suggested.Rmd-->


# Dự án R {#r-projects}  


Một dự án R cho phép công việc của bạn được đóng gói trong một thư mục khép kín. Trong dự án, tất cả các tập lệnh, tệp dữ liệu, biểu đồ/kết quả đầu ra và lịch sử có liên quan được lưu trữ trong các thư mục con và quan trọng là - *thư mục làm việc* là thư mục gốc của dự án.  


## Gợi ý sử dụng  

Một cách phổ biến, hiệu quả và ít rắc rối để sử dụng R là sự kết hợp của 3 thành tố này. Mỗi dự án công việc cụ thể sẽ được lưu trữ trong một dự án R. Từng thành tố được mô tả như dưới đây.  

1) Một **Dự án R**  
     - Một môi trường làm việc khép kín với các thư mục bao gồm dữ liệu, tập lệnh, các kết quả đầu ra, v.v.  
2) Package **here** dành cho các đường dẫn tương đối  
     - Đường dẫn tệp được ghi một cách tương đối dẫn đến thư mục gốc của dự án R - xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết  
3) Package **rio** để nhập/xuất  
     - `import()` và `export()` giúp giải quyết tất cả các tệp với phần mở rộng khác nhau (ví dụ: .csv, .xlsx, .png)  
     
     


<!-- ======================================================= -->
## Tạo một dự án R {}

Để tạo một dự án R, hãy chọn “New Project” từ menu File.

* Nếu bạn muốn tạo một thư mục mới cho dự án, hãy chọn "New directory" và cho biết nơi bạn muốn nó được tạo.  
* Nếu bạn muốn tạo dự án trong một thư mục có sẵn, hãy chọn “Existing directory” và trỏ tới đường dẫn thư mục đó.  
* Nếu bạn muốn tạo một bản sao từ kho lưu trữ Github, hãy chọn tùy chọn thứ ba “Version Control” và sau đó chọn “Git”. Xem chương [Version control với Git và Github] để biết thêm chi tiết.  


```{r out.width = "75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "create_project.png"))
```


Dự án R bạn tạo ra sẽ có dạng một thư mục chứa tệp *.Rproj*. Tệp này có thể đóng vai trò là một lối tắt mà bạn sẽ mở dự án của mình. Bạn cũng có thể mở một dự án bằng cách chọn “Open Project” từ menu File. Ngoài ra, ở phía trên bên phải trên của RStudio, bạn sẽ thấy biểu tượng dự án R và menu thả xuống gồm các dự án R có sẵn. 

Để thoát khỏi một dự án R, hãy mở một dự án mới hoặc đóng dự án (File - Close Project).  


### Di chuyển giữa các dự án {.unnumbered}

Để di chuyển giữa các dự án, hãy bấm vào biểu tượng dự án R và menu thả xuống ở phía trên cùng bên phải của RStudio. Bạn sẽ thấy các tùy chọn Close Project, Open Project và danh sách các dự án gần đây.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "Rproject_dropdown.png"))
```


### Thiết lập {.unnumbered}  

Thông thường, mỗi khi bạn khởi động RStudio nên là một “clean slate - khởi đầu mới” - nghĩa là với không gian làm việc hiện tại **không** được giữ nguyên so với phiên làm việc trước đó. Điều này có nghĩa là các đối tượng và kết quả của bạn sẽ không tồn tại giữa các phiên làm việc (bạn phải tạo lại chúng bằng cách chạy lại scripts của mình). Điều này là tốt, vì nó sẽ buộc bạn phải viết các đoạn code tốt hơn và tránh được lỗi về lâu dài.  

Để thiết lập RStudio có một “khởi đầu mới” mỗi khi khởi động:  

* Chọn “Project Options” từ menu Tools.  
* Trong tab “General”, thiết lập RStudio to **không** khôi phục .RData vào môi trường làm việc của bạn mỗi khi khởi động, và cũng **không** lưu môi trường làm việc vào tệp .RData khi kết thúc.  



### Tổ chức {.unnumbered}  

Thông thường sẽ có các thư mục con trong dự án của bạn. Hãy cân nhắc đặt tên các thư mục như “data”, “scripts”, “figures”, “presentations”. Bạn có thể thêm các thư mục theo cách thông thường mà bạn sẽ thêm một thư mục mới cho máy tính của mình. Ngoài ra, hãy xem chương [Tương tác với thư mục làm việc] để tìm hiểu cách tạo thư mục mới bằng lệnh R.  


### Kiểm soát phiên bản {.unnumbered}  

Hãy cân nhắc sử dụng một hệ thống kiểm soát phiên bản. Nó có thể là một cái gì đó đơn giản như có ngày tháng trên tên của các scripts (ví dụ: “transmission_analysis_2020-10-03.R”) và một thư mục “lưu trữ”. Bạn cũng có thể thêm các đoạn văn bản tiêu đề nhận xét ở đầu mỗi scripts bao gồm các thông tin như mô tả, thẻ, tác giả và nhật ký thay đổi.  

Một phương pháp phức tạp hơn đó là việc sử dụng Github hoặc một nền tảng tương tự để kiểm soát phiên bản. Xem chương [Version control với Git và Github].  

Một mẹo là bạn có thể tìm kiếm trong toàn bộ dự án hoặc thư mục bằng cách sử dụng công cụ “Find in Files” (Edit menu)). Công cụ này có thể tìm kiếm và thậm chí thay thế các chuỗi trên nhiều tệp.  






## Các ví dụ  

Dưới đây là một vài ví dụ về cách nhập/xuất/lưu trữ sử dụng lệnh `here()` from within an R projct. bên trong một dự án R. Đọc thêm về package **here** trong chương [Nhập xuất dữ liệu].  


*Nhập `linelist_raw.xlsx` từ thư mục “data” trong dự án R của bạn*  

```{r eval=F}
linelist <- import(here("data", "linelist_raw.xlsx"))
```

*Xuất đối tượng `linelist` thành tệp "my_linelist.rds" vào thư mục “clean” nằm trong thư mục “data” trong dự án R của bạn.*   

```{r, eval=F}
export(linelist, here("data","clean", "my_linelist.rds"))
```

*Lưu biểu đồ được in gần đây nhất thành tệp "epicurve_2021-02-15.png" nằm trong thư mục “epicurves” của thư mục “outputs” trong dự án R của bạn.*  

```{r, eval=F}
ggsave(here("outputs", "epicurves", "epicurve_2021-02-15.png"))
```




<!-- ======================================================= -->
## Nguồn {}

Trang web của RStudio về việc [sử dụng các dự án R](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects)




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/r_projects.Rmd-->

# Nhập xuất dữ liệu {#importing}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Import_Export_1500x500.png"))
```

Trong chương này, chúng tôi mô tả các cách để định vị, nhập và xuất tệp:

-   Sử dụng package **rio** để `import()` và `export()` linh hoạt nhiều loại tệp\

-   Sử dụng package **here** để định vị tệp liên quan đến dự án R gốc - để ngăn ngừa sự phức tạp do nhiều đường dẫn tệp chỉ dành riêng cho một máy tính\

-   Các tình huống nhập dữ liệu thường gặp:

    -   Từ một Trang tính Excel\
    -   Có tiêu đề sắp xếp lộn xộn và cần bỏ qua một số hàng\
    -   Từ trang tính của Google\
    -   Từ dữ liệu được đăng lên các trang web\
    -   Với APIs\
    -   Nhập tệp *gần đây nhất*\

-   Nhập dữ liệu thủ công\

-   Các loại tệp R đặc trưng ví dụ như RDS và RData\

-   Xuất/lưu tệp và biểu đồ

<!-- ======================================================= -->

## Tổng quan

Khi bạn nhập một "dataset (bộ dữ liệu)" vào R, bạn thường cần tạo ra một đối tượng *data frame* mới trong môi trường R và định nghĩa nó là tệp được nhập (ví dụ: Excel, CSV, TSV, RDS), từ trong các thư mục của bạn tại một đường dẫn/địa chỉ tệp nhất định.

Bạn có thể nhập/xuất nhiều loại tệp, bao gồm cả những tệp được tạo bởi các chương trình thống kê khác (SAS, STATA, SPSS). Bạn cũng có thể kết nối với các cơ sở dữ liệu liên quan.

R thậm chí còn có các định dạng dữ liệu riêng:

-   Một tệp RDS (.rds) lưu trữ một đối tượng R đơn lẻ, chẳng hạn như một data frame. Chúng hữu ích trong việc lưu trữ dữ liệu đã được làm sạch, vì chúng giữ lại kiểu dữ liệu cho các cột R. Đọc thêm trong [mục này](#import_rds).\
-   Một tệp RData (.Rdata) có thể được sử dụng để lưu trữ nhiều đối tượng hoặc thậm chí là một không gian làm việc trong R hoàn chỉnh. Đọc thêm trong [mục này](#import_rdata).

<!-- ======================================================= -->

## Package **rio**

Package R chúng tôi gợi ý là: **rio**. Tên "rio" là chữ viết tắt của "R I/O" (dữ liệu đầu vào (input)/kết quả đầu ra (output)).

Hàm `import()` và `export()` có thể xử lý nhiều loại tệp khác nhau (ví dụ: .xlsx, .csv, .rds, .tsv). Khi bạn cung cấp đường dẫn tệp đến một trong các hàm này (bao gồm cả đuôi file mở rộng như ".csv"), **rio** sẽ đọc phần mở rộng và sử dụng đúng công cụ để nhập hoặc xuất tệp.

Giải pháp thay thế cho việc sử dụng **rio** là sử dụng các hàm từ nhiều package khác, mỗi package cụ thể cho một loại tệp. Ví dụ như, `read.csv()` (**base** R), `read.xlsx()` (package **openxlsx**) và `write_csv()` (package **readr**), v.v... Những lựa chọn thay thế này có thể khó nhớ, trong khi sử dụng `import()` và `export()` từ **rio** rất dễ dàng.

Các hàm `import()` và `export()` của **rio** sử dụng package và lệnh phù hợp cho một tệp nhất định, dựa trên phần mở rộng của tệp đó. Xem phần cuối của chương này để xem bảng đầy đủ về các package/hàm **rio** sử dụng trong nền. Hàm này cũng có thể được sử dụng để nhập các tệp STATA, SAS và SPSS trong hàng tá các loại tệp khác.

Nhập/xuất shapefiles đòi hỏi sử dụng các package khác, được mô tả cụ thể trong chương [GIS cơ bản].

## Package **here** {#here}

Package **here** và hàm `here()` của nó giúp R dễ dàng biết nơi tìm và lưu tệp của bạn - về bản chất, nó xây dựng đường dẫn tệp.

Được sử dụng cùng với dự án R, **here** cho phép bạn mô tả vị trí các tệp trong dự án R của bạn trong *thư mục gốc (root directory*) của dự án R (thư mục cấp cao nhất). Điều này hữu ích khi dự án R có thể được chia sẻ hoặc truy cập bởi nhiều người dùng/máy tính. Package này ngăn ngừa sự phức tạp do các đường dẫn tệp là duy nhất trên các máy tính khác nhau (ví dụ: `"C:/Users/Laura/Documents..."`) bằng cách "khởi động (starting)" đường dẫn tệp ở thư mục chung cho tất cả người dùng (dự án R gốc).

Đây là cách `here()` làm việc trong một dự án R:

-   Khi package **here** được tải lần đầu tiên trong dự án R, nó đặt một tệp nhỏ có tên là ".here" trong thư mục gốc dự án R của bạn như là một "điểm chuẩn" hoặc "mỏ neo"\
-   Trong script của bạn, để tham chiếu một tệp trong các thư mục con của dự án R, bạn sử dụng hàm `here()` để tạo đường dẫn tệp *liên quan đến thư mục gốc (anchor)*
-   Để tạo đường dẫn tệp, viết tên các thư mục bên ngoài thư mục gốc, trong dấu ngoặc kép, được phân tách bằng dấu phẩy, cuối cùng kết thúc bằng tên và phần mở rộng của tệp như được trình bày dưới đây\
-   Các đường dẫn tệp `here()` có thể được sử dụng cả để nhập và xuất dữ liệu

Ví dụ, dưới đây, một đường dẫn tệp được tạo bởi hàm `here()` đang được cung cấp cho hàm `import()`

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

Lệnh `here("data", "linelists", "ebola_linelist.xlsx")` trên thực tế đang cung cấp đường dẫn tệp đầy đủ mà *là duy nhất cho máy tính của người dùng:*

    "C:/Users/Laura/Documents/my_R_project/data/linelists/ebola_linelist.xlsx"

Ưu điểm là lệnh `here()` được R sử dụng có thể chạy thành công trên bất kỳ máy tính nào truy cập vào dự án R.

[***MẸO:*** Nếu bạn không chắc gốc ".here" được đặt ở đâu, hãy chạy lệnh `here()` với dấu ngoặc đơn trống.]{style="color: darkgreen;"}

Đọc thêm về package **here** [tại đường dẫn này](https://here.r-lib.org/).

<!-- ======================================================= -->

## Đường dẫn tệp

Khi nhập hoặc xuất dữ liệu, bạn phải cung cấp một đường dẫn tệp. Bạn có thể thực hiện thao tác này bằng một trong ba cách sau:

1)  *Khuyên dùng:* cung cấp một đường dẫn tệp "tương đối" bằng package **here**\
2)  Cung cấp đường dẫn tệp "đầy đủ" / "tuyệt đối"\
3)  Chọn tệp theo cách thủ công

### Đường dẫn tệp "tương đối" {.unnumbered}

Trong R, đường dẫn tệp "tương đối" bao gồm đường dẫn tệp mà *liên quan* đến phần gốc của dự án R. Chúng cho phép nhiều đường dẫn tệp đơn giản hơn có thể làm việc trên nhiều máy tính khác nhau (ví dụ: nếu dự án R nằm trên bộ nhớ dùng chung hoặc được gửi qua thư điện tử). Như đã được [mô tả ở trên](#here), đường dẫn tệp tương đối được tạo ra dễ dàng bằng cách sử dụng package **here**.

Dưới đây là một ví dụ về đường dẫn tệp tương đối được tạo bằng package `here()`. Chúng tôi giả sử công việc nằm trong một dự án R có chứa một thư mục con "data" và bên trong nó là thư mục con "linelists", trong đó có tệp .xlsx được quan tâm.

```{r, eval=F}
linelist <- import(here("data", "linelists", "ebola_linelist.xlsx"))
```

### Đường dẫn tệp "tuyệt đối" {.unnumbered}

Đường dẫn tệp tuyệt đối hay "đầy đủ" có thể được cung cấp cho các hàm như `import()` nhưng chúng "dễ đứt gãy" bởi vì chúng là duy nhất đối với các máy tính của những người dùng khác nhau, và do đó *không được khuyến khích* sử dụng.

Dưới đây là một ví dụ về đường dẫn tệp tuyệt đối, trong máy tính của Laura có một thư mục "analysis", tiếp theo là thư mục con "data" và bên trong là thư mục con "linelists", trong đó có tệp .xlsx được quan tâm.

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/analysis/data/linelists/ebola_linelist.xlsx")
```

Một vài điều cần lưu ý về đường dẫn tệp tuyệt đối:

-   **Tránh sử dụng đường dẫn tệp tuyệt đối** vì chúng sẽ bị đứt gãy nếu script được chạy trên một máy tính khác
-   Sử dụng dấu gạch chéo *tiến* (`/`), như trong ví dụ trên (lưu ý: đây *KHÔNG* phải là kiểu mặc định đối với đường dẫn tệp trong Windows)\
-   Đường dẫn tệp bắt đầu với hai dấu gạch chéo (ví dụ: "//...") sẽ có khả năng **không được R nhận ra** và tạo ra lỗi. Hãy cân nhắc chuyển công việc của bạn sang ổ đĩa "có tên" hoặc "có chữ" bắt đầu bằng một chữ cái (ví dụ: "J:" hoặc "C:"). Xem chương về [Tương tác với thư mục làm việc] để biết thêm chi tiết về vấn đề này.

Một tình huống mà đường dẫn tệp tuyệt đối có thể thích hợp là khi bạn muốn nhập một tệp từ bộ nhớ dùng chung có cùng đường dẫn tệp đầy đủ cho tất cả người dùng.

[***MẸO:*** Để nhanh chóng chuyển đổi tất cả `\` thành `/`, hãy bôi đen đoạn code cần chuyển, sử dụng Ctrl + F (trong Windows) và tích vào tùy chọn "In selection", sau đó sử dụng chức năng thay thế (replace) để chuyển đổi chúng.]{style="color: darkgreen;"}

<!-- ======================================================= -->

### Chọn tệp theo cách thủ công {.unnumbered}

Bạn có thể nhập dữ liệu theo cách thủ công thông qua một trong các phương pháp sau:

1)  Từ cửa sổ Environment trong RStudio, nhấp vào "Import Dataset" và chọn loại dữ liệu
2)  Nhấp vào File / Import Dataset / (chọn loại dữ liệu)\
3)  Để lựa chọn thủ công bằng code, hãy sử dụng lệnh `file.choose()` trong *base R* (để trống dấu ngoặc đơn) để kích hoạt sự xuất hiện của một **cửa sổ pop-up** cho phép người dùng chọn tệp theo cách thủ công từ máy tính của họ. Ví dụ:

```{r import_choose, eval=F}
# Manual selection of a file. When this command is run, a POP-UP window will appear. 
# The file path selected will be supplied to the import() command.

my_data <- import(file.choose())
```

[***MẸO:*** **Cửa sổ pop-up** có thể xuất hiện SAU cửa sổ RStudio của bạn.]{style="color: darkgreen;"}

## Nhập dữ liệu

Sử dụng lệnh `import()` để nhập một bộ dữ liệu khá đơn giản. Chỉ cần cung cấp đường dẫn của tệp (bao gồm tên và phần mở rộng của tệp) trong dấu ngoặc kép. Nếu sử dụng hàm `here()` để xây dựng đường dẫn tệp, hãy làm theo hướng dẫn ở bên trên. Dưới đây là một vài ví dụ:

Nhập một tệp csv nằm trong "thư mục làm việc (working directory)" của bạn hoặc trong thư mục gốc của dự án R:

```{r, eval=F}
linelist <- import("linelist_cleaned.csv")
```

Nhập sheet đầu tiên của Excel workbook, được đặt trong thư mục con "data" và "linelists" của dự án R (đường dẫn tệp được tạo bằng hàm `here()`):

```{r, eval=F}
linelist <- import(here("data", "linelists", "linelist_cleaned.xlsx"))
```

Nhập một data frame (một tệp .rds ) sử dụng đường dẫn tệp tuyệt đối:

```{r, eval=F}
linelist <- import("C:/Users/Laura/Documents/tuberculosis/data/linelists/linelist_cleaned.rds")
```

### Trang tính Excel cụ thể {.unnumbered}

Theo mặc định, nếu bạn cung cấp một Excel workbook (.xlsx) để nhập bằng hàm `import()`, trang tính đầu tiên của workbook sẽ được nhập. Nếu bạn muốn nhập một **trang tính** cụ thể, hãy cụ thể tên trang tính vào đối số `which =`. Ví dụ:

```{r eval=F}
my_data <- import("my_excel_file.xlsx", which = "Sheetname")
```

Nếu sử dụng hàm `here()` để cung cấp một đường dẫn tương đối đến hàm `import()`, bạn vẫn có thể chỉ ra một trang tính cụ thể bằng cách thêm đối số `which =` sau dấu đóng ngoặc của hàm `here()`.

```{r import_sheet_here, eval=F}
# Demonstration: importing a specific Excel sheet when using relative pathways with the 'here' package
linelist_raw <- import(here("data", "linelist.xlsx"), which = "Sheet1")`  
```

Để *xuất* một data frame từ R sang một trang tính Excel và phần còn lại của Excel workbook không thay đổi, bạn sẽ phải nhập, chỉnh sửa và xuất với một package thay thế chuyên biệt cho mục đích này, chẳng hạn như **openxlsx**. Xem thêm thông tin trong chương về [Tương tác với thư mục làm việc] hoặc [tại trang github này](https://ycphs.github.io/openxlsx/).

Nếu Excel workbook của bạn có phần mở rộng là .xlsb (định dạng nhị phân của Excel workbook) bạn có thể sẽ không nhập được bằng package **rio**. Hãy cân nhắc lưu lại tệp dưới dạng .xlsx hoặc sử dụng một package như **readxlsb**, là package được xây dựng cho [kiểu tệp này](https://cran.r-project.org/web/packages/readxlsb/vignettes/read-xlsb-workbook.html).

<!-- ======================================================= -->

### Giá trị missing {#import_missing .unnumbered}

Bạn có thể muốn xác định (các) giá trị nào trong bộ dữ liệu của mình nên được coi là missing. Như đã giải thích trong chương về [Dữ liệu missing], giá trị cho dữ liệu missing trong R là `NA`, nhưng có thể bộ dữ liệu bạn muốn nhập vào sử dụng giá trị 99, "Missing" hoặc chỉ là khoảng trống ký tự "".

Sử dụng đối số `na =` để (nhập) `import()` và cung cấp (các) giá trị trong dấu ngoặc kép (ngay cả khi chúng là các số). Bạn có thể chỉ định nhiều giá trị bằng cách gộp chúng trong một vectơ, bằng cách sử dụng `c()` như được trình bày dưới đây.

Tại đây, giá trị "99" trong bộ dữ liệu đã nhập được coi là missing và được chuyển đổi thành `NA` trong R.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.xlsx"), na = "99")
```

Còn ở đây, bất kỳ giá trị nào là "Missing", "" (ô trống) hoặc " " (khoảng trắng) trong bộ dữ liệu đã nhập đều được chuyển đổi thành `NA` trong R.

```{r, eval=F}
linelist <- import(here("data", "my_linelist.csv"), na = c("Missing", "", " "))
```

<!-- ======================================================= -->

### Bỏ qua một số hàng {.unnumbered}

Đôi khi, bạn có thể không muốn nhập một hàng dữ liệu. Bạn có thể thực hiện thao tác này với đối số `skip =` nếu sử dụng hàm `import()` từ package **rio** trên tệp .xlsx hoặc .csv. Cung cấp số hàng bạn muốn bỏ qua.

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx", skip = 1)  # does not import header row
```

Không may là hàm `skip =` chỉ chấp nhận một giá trị số nguyên, *không* chấp nhận một khoảng (ví dụ: "2:10" sẽ không hoạt động). Để bỏ qua việc nhập các hàng cụ thể không liên tiếp từ trên cùng, hãy cân nhắc nhập nhiều lần và sử dụng hàm `bind_rows()` từ **dplyr**. Hãy xem ví dụ dưới đây về việc chỉ bỏ qua hàng thứ 2.

### Quản lý hàng tiêu đề thứ hai {.unnumbered}

Đôi khi, dữ liệu của bạn có thể có hàng *thứ hai*, với chức năng như là "từ điển dữ liệu" như hình dưới đây. Trường hợp này có thể xảy ra vấn đề vì nó có thể dẫn đến việc tất cả các cột được nhập vào dưới dạng kiểu "ký tự (character)".

```{r, echo=F}
# HIDDEN FROM READER
####################
# Create second header row of "data dictionary" and insert into row 2. Save as new dataframe.
linelist_2headers <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%         
        mutate(across(everything(), as.character)) %>% 
        add_row(.before = 1,
                #row_num = "000",
                case_id = "case identification number assigned by MOH",
                generation = "transmission chain generation number",
                date_infection = "estimated date of infection, mm/dd/yyyy",
                date_onset = "date of symptom onset, YYYY-MM-DD",
                date_hospitalisation = "date of initial hospitalization, mm/dd/yyyy",
                date_outcome = "date of outcome status determination",
                outcome = "either 'Death' or 'Recovered' or 'Unknown'",
                gender = "either 'm' or 'f' or 'unknown'",
                hospital = "Name of hospital of first admission",
                lon = "longitude of residence, approx",
                lat = "latitude of residence, approx",
                infector = "case_id of infector",
                source = "context of known transmission event",
                age = "age number",
                age_unit = "age unit, either 'years' or 'months' or 'days'",
                fever = "presence of fever on admission, either 'yes' or 'no'",
                chills = "presence of chills on admission, either 'yes' or 'no'",
                cough = "presence of cough on admission, either 'yes' or 'no'",
                aches = "presence of aches on admission, either 'yes' or 'no'",
                vomit = "presence of vomiting on admission, either 'yes' or 'no'",
                time_admission = "time of hospital admission HH:MM")
```

Dưới đây là một ví dụ về kiểu bộ dữ liệu này (với hàng đầu tiên là từ điển dữ liệu).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_2headers, 5), rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

### Xóa hàng tiêu đề thứ hai {.unnumbered}

Để bỏ hàng tiêu đề thứ hai, bạn có thể sẽ cần nhập dữ liệu hai lần.

1)  Nhập dữ liệu vào để lấy tên các cột chính xác\
2)  Nhập lại dữ liệu, bỏ qua *hai* hàng đầu tiên (hàng tiêu đề và hàng thứ hai)\
3)  Liên kết dataframe đã xóa bỏ 2 hàng đầu tiên với tên cột chính xác ở bước 1

Đối số chính xác được sử dụng để liên kết các tên cột tùy thuộc vào loại tệp dữ liệu (.csv, .tsv, .xlsx, v.v.). Điều này là do **rio** sử dụng các hàm khác nhau cho các loại tệp khác nhau (xem bảng ở trên).

**Đối với tệp Excel:** (`col_names =`)

```{r, eval=F}
# import first time; store the column names
linelist_raw_names <- import("linelist_raw.xlsx") %>% names()  # save true column names

# import second time; skip row 2, and assign column names to argument col_names =
linelist_raw <- import("linelist_raw.xlsx",
                       skip = 2,
                       col_names = linelist_raw_names
                       ) 
```

**Đối với tệp CSV:** (`col.names =`)

```{r, eval=F}
# import first time; sotre column names
linelist_raw_names <- import("linelist_raw.csv") %>% names() # save true column names

# note argument for csv files is 'col.names = '
linelist_raw <- import("linelist_raw.csv",
                       skip = 2,
                       col.names = linelist_raw_names
                       ) 
```

**Tùy chọn sao lưu** - thay đổi tên cột dưới dạng một lệnh riêng biệt

```{r, eval=F}
# assign/overwrite headers using the base 'colnames()' function
colnames(linelist_raw) <- linelist_raw_names
```

#### Tạo từ điển dữ liệu {.unnumbered}

Thông tin thêm! Nếu bạn có hàng thứ hai là từ điển dữ liệu, bạn có thể dễ dàng tạo từ điển dữ liệu thích hợp từ nó. Mẹo này được tham khảo từ [bài đăng](https://alison.rbind.io/post/2018-02-23-read-multiple-header-rows/) này.

```{r}
dict <- linelist_2headers %>%             # begin: linelist with dictionary as first row
  head(1) %>%                             # keep only column names and first dictionary row                
  pivot_longer(cols = everything(),       # pivot all columns to long format
               names_to = "Column",       # assign new column names
               values_to = "Description")
```

```{r message=FALSE, echo=F}
DT::datatable(dict, rownames = FALSE, filter="top", options = list(pageLength = 4, scrollX=T), class = 'white-space: nowrap' )
```

#### Kết hợp hai hàng tiêu đề {.unnumbered}

Trong một số trường hợp khi bộ dữ liệu thô của bạn có *hai* hàng tiêu đề (hoặc cụ thể hơn, hàng dữ liệu thứ 2 là tiêu đề phụ), bạn có thể sẽ muốn "kết hợp" chúng hoặc thêm các giá trị trong hàng tiêu đề thứ hai vào hàng tiêu đề đầu tiên.

Lệnh dưới đây sẽ xác định tên cột của data frame là sự kết hợp (dán với nhau) của các tiêu đề (đúng) đầu tiên với giá trị ngay bên dưới (trong hàng đầu tiên).

```{r, eval=F}
names(my_data) <- paste(names(my_data), my_data[1, ], sep = "_")
```

<!-- ======================================================= -->

### Trang tính Google {.unnumbered}

Bạn có thể nhập dữ liệu từ một trang tính Google trực tuyến với package **googlesheet4** và bằng cách xác thực quyền truy cập của bạn vào trang tính.

```{r, eval=F}
pacman::p_load("googlesheets4")
```

Dưới đây là một trang tính Google minh họa được nhập và lưu. Lệnh này có thể yêu cầu xác thực tài khoản Google của bạn. Làm theo lời nhắc và cửa sổ bật lên trong trình duyệt Internet của bạn để cấp cho các package Tidyverse API quyền chỉnh sửa, tạo và xóa trang tính của bạn trong Google Drive.

Trang tính dưới đây "có thể được xem bởi bất kỳ ai có liên kết" và bạn có thể thử nhập trang tính đó.

```{r, eval=F}
Gsheets_demo <- read_sheet("https://docs.google.com/spreadsheets/d/1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY/edit#gid=0")
```

Trang tính cũng có thể được nhập chỉ bằng ID của sheet, một phần ngắn hơn của URL:

```{r, eval=F}
Gsheets_demo <- read_sheet("1scgtzkVLLHAe5a6_eFQEwkZcc14yFUx1KgOMZ4AKUfY")
```

Một package khác, **googledrive** cung cấp các hàm hữu ích để viết, chỉnh sửa và xóa các trang tính Google. Ví dụ: các hàm được sử dụng `gs4_create()` và `sheet_write()` đều được tìm thấy trong package này.

Dưới đây là một số hướng dẫn trực tuyến hữu ích khác:\
[hướng dẫn nhập Google sheet cơ bản](https://arbor-analytics.com/post/getting-your-data-into-r-from-google-sheets/)\
[hướng dẫn chi tiết hơn](https://googlesheets4.tidyverse.org/articles/googlesheets4.html)\
[tương tác giữa googlesheets4 và tidyverse](https://googlesheets4.tidyverse.org/articles/articles/drive-and-sheets.html)

## Nhập, xuất, tách, kết hợp - nhiều tệp

Xem chương về [Lặp, vòng lặp, và danh sách] để biết ví dụ về cách nhập và kết hợp nhiều tệp hoặc nhiều Excel workbook. Chương này cũng có các ví dụ về cách chia một data frame thành các phần và xuất từng phần riêng biệt hoặc dưới dạng các trang tính được đặt tên trong một Excel workbook.

<!-- ======================================================= -->

## Nhập từ Github {#import_github}

Nhập dữ liệu trực tiếp từ Github vào R có thể rất dễ dàng hoặc có thể yêu cầu một vài bước - tùy thuộc vào loại tệp. Dưới đây là một số cách tiếp cận:

### Tệp CSV {.unnumbered}

Có thể dễ dàng nhập tệp .csv trực tiếp từ Github vào R bằng lệnh R.

1)  Đi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\
2)  Nhấp vào nút "Raw" (sau đó bạn sẽ thấy dữ liệu csv "thô", như được hiển thị bên dưới)\
3)  Sao chép URL (địa chỉ web)\
4)  Đặt URL trong dấu ngoặc kép trong lệnh R `import()`

```{r, out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_csv_raw.png"))
```

### Tệp XLSX {.unnumbered}

Bạn có thể không xem được dữ liệu "Thô" cho một số tệp (ví dụ: .xlsx, .rds, .nwk, .shp)

1)  Đi tới repo Github, tìm tệp quan tâm và nhấp vào tệp đó\
2)  Nhấp vào nút "Download", như được hiển thị bên dưới\
3)  Lưu tệp trên máy tính của bạn và nhập tệp đó vào R

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_xlsx.png"))
```

### Shapefiles {.unnumbered}

Các Shapefiles có nhiều tệp thành phần phụ, mỗi tệp có một phần mở rộng khác nhau. Một tệp sẽ có phần mở rộng ".shp", nhưng những tệp khác có thể là ".dbf", ".prj", v.v. Để tải xuống shapefiles từ Github, bạn sẽ cần tải xuống từng tệp thành phần phụ riêng lẻ và lưu chúng trong cùng một thư mục trên máy tính của bạn. Trong Github, nhấp vào từng tệp riêng lẻ và tải chúng xuống bằng cách nhấp vào nút "Download".

Một khi được lưu vào máy tính, bạn có thể nhập định dạng tệp như được trình bày trong chương [GIS cơ bản] bằng cách sử dụng hàm `st_read()` từ package **sf**. Bạn chỉ cần cung cấp đường dẫn tệp và tên của tệp ".shp" - miễn là các tệp liên quan khác nằm trong cùng một thư mục trên máy tính của bạn.

Dưới đây, bạn có thể thấy shapefiles tên "sl_adm3" bao gồm nhiều tệp như thế nào - mỗi tệp phải được tải xuống từ Github.

```{r , out.width=c('100%', '100%'), fig.align = "left", echo=F}
knitr::include_graphics(here::here("images", "download_shp.png"))
```

<!-- ======================================================= -->

## Nhập dữ liệu thủ công

### Nhập theo hàng {.unnumbered}

Sử dụng hàm `tribble` của package **tibble** từ tidyverse ([tài liệu tham khảo trực tuyến](https://tibble.tidyverse.org/reference/tribble.html)).

Lưu ý cách tiêu đề cột bắt đầu bằng dấu ngã (`~`). Cũng lưu ý rằng mỗi cột chỉ được chứa một nhóm dữ liệu (ký tự, số, v.v.). Bạn có thể sử dụng các tab, khoảng cách và hàng mới để làm cho việc nhập dữ liệu trực quan và dễ đọc hơn. Khoảng trắng không quan trọng giữa các giá trị, nhưng mỗi hàng được biểu thị bằng một dòng code mới. Ví dụ:

```{r import_manual_row}
# create the dataset manually by row
manual_entry_rows <- tibble::tribble(
  ~colA, ~colB,
  "a",   1,
  "b",   2,
  "c",   3
  )
```

Và giờ chúng ta hiển thị bộ dữ liệu mới:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_rows)
```

### Nhập theo cột {.unnumbered}

Vì data frame bao gồm các vectơ (cột dọc), cách tiếp cận **cơ bản** để tạo data frame thủ công trong R yêu cầu bạn phải tạo từng cột và sau đó liên kết chúng lại với nhau. Điều này có thể phản trực quan trong dịch tễ học, vì chúng ta thường nghĩ về dữ liệu của mình theo hàng (như trên).

```{r import_manual_col}
# define each vector (vertical column) separately, each with its own name
PatientID <- c(235, 452, 778, 111)
Treatment <- c("Yes", "No", "Yes", "Yes")
Death     <- c(1, 0, 1, 0)
```

[***CHÚ Ý:*** Tất cả các vectơ phải có cùng độ dài (cùng số giá trị).]{style="color: orange;"}

Các vectơ sau đó có thể được liên kết với nhau bằng cách sử dụng lệnh `data.frame()`:

```{r}
# combine the columns into a data frame, by referencing the vector names
manual_entry_cols <- data.frame(PatientID, Treatment, Death)
```

Và giờ chúng ta hiển thị bộ dữ liệu mới:

```{r, echo=F}
# display the new dataset
DT::datatable(manual_entry_cols)
```

### Dán từ clipboard {.unnumbered}

Nếu bạn sao chép dữ liệu từ nơi khác và có nó trong clipboard (bộ nhớ tạm), bạn có thể thử một trong hai cách dưới đây:

Từ package **clipr**, bạn có thể sử dụng hàm `read_clip_tbl()` để nhập dưới dạng data frame hoặc chỉ cần hàm `read_clip()` để nhập dưới dạng một vectơ ký tự. Trong cả hai trường hợp, hãy để trống dấu ngoặc đơn.

```{r, eval=F}
linelist <- clipr::read_clip_tbl()  # imports current clipboard as data frame
linelist <- clipr::read_clip()      # imports as character vector
```

Bạn cũng có thể dễ dàng xuất sang clipboard của hệ thống bằng **clipr**. Xem mục bên dưới về Xuất dữ liệu.

Ngoài ra, bạn có thể sử dụng lệnh `read.table()` từ **base** R với `file = "clipboard")` để nhập dưới dạng data frame:

```{r, eval=F}
df_from_clipboard <- read.table(
  file = "clipboard",  # specify this as "clipboard"
  sep = "t",           # separator could be tab, or commas, etc.
  header=TRUE)         # if there is a header row
```

## Nhập tệp gần đây nhất

Thường thì bạn có thể nhận được các bản cập nhật hàng ngày cho bộ dữ liệu của mình. Trong trường hợp này, bạn sẽ muốn viết code mà nhập tệp gần đây nhất. Dưới đây, chúng tôi trình bày hai cách để tiếp cận điều này:

-   Chọn tệp dựa trên ngày trong tên tệp\
-   Chọn tệp dựa trên metadata (siêu dữ liệu - là dạng dữ liệu mô tả thông tin chi tiết về dữ liệu) của tệp (lần sửa đổi cuối cùng) 

### Ngày trong tên tệp {.unnumbered}

Cách tiếp cận này dựa trên ba cơ sở:

1)  Bạn tin tưởng ngày tháng trong tên tệp\
2)  Ngày tháng ở dạng số và *thường* xuất hiện ở cùng một định dạng (ví dụ: năm rồi tháng rồi ngày)\
3)  Không có số nào khác trong tên tệp

Chúng tôi sẽ giải thích từng bước và sau đó cho bạn thấy cách chúng được kết hợp ở phần cuối.

Đầu tiên, sử dụng `dir()` từ **base** R để chỉ trích xuất tên tệp cho mỗi tệp trong thư mục quan tâm. Xem chương về [Tương tác với thư mục làm việc] để biết thêm chi tiết về `dir()`. Trong ví dụ này, thư mục quan tâm là thư mục "linelists" trong thư mục "example" chứa trong thư mục "data" của dự án R.

```{r}
linelist_filenames <- dir(here("data", "example", "linelists")) # get file names from folder
linelist_filenames                                              # print
```

Một khi bạn có vectơ chứa các tên này, bạn có thể trích xuất ngày với chúng bằng cách áp dụng hàm `str_extract()` từ **stringr** với việc sử dụng biểu thức chính quy sau đây. Nó giúp trích xuất bất kỳ số nào trong tên tệp (bao gồm bất kỳ ký tự nào khác ở giữa như dấu gạch ngang hoặc dấu gạch chéo). Bạn có thể đọc thêm về **stringr** trong chương [Ký tự và chuỗi].

```{r}
linelist_dates_raw <- stringr::str_extract(linelist_filenames, "[0-9].*[0-9]") # extract numbers and any characters in between
linelist_dates_raw  # print
```

Giả sử ngày thường được viết theo cùng một định dạng ngày (ví dụ: Năm rồi Tháng rồi Ngày) và năm có 4 chữ số, bạn có thể sử dụng các hàm chuyển đổi linh hoạt của **lubridate** (`ymd()`, `dmy()`, or `mdy()`) để chuyển đổi chúng thành ngày. Đối với các hàm này, dấu gạch ngang, dấu cách hoặc dấu gạch chéo không quan trọng, quan trọng chỉ là thứ tự của các số. Đọc thêm trong chương [Làm việc với ngày tháng].

```{r}
linelist_dates_clean <- lubridate::ymd(linelist_dates_raw)
linelist_dates_clean
```

Sau đó, hàm **base** R `which.max()` có thể được sử dụng để trả về vị trí chỉ mục (ví dụ: 1, 2, 3,...) của giá trị ngày lớn nhất. Tệp mới nhất được xác định chính xác là tệp thứ 6 - "case_linelist_2020-10-08.xlsx".

```{r}
index_latest_file <- which.max(linelist_dates_clean)
index_latest_file
```

Nếu chúng ta tổng hợp tất cả các lệnh này, code hoàn chỉnh có thể trông giống như bên dưới. Lưu ý rằng dấu `.` ở dòng cuối cùng thay thế cho đối tượng được truyền vào hàm trước đó. Tại thời điểm đó, giá trị chỉ đơn giản là số 6. Giá trị này được đặt trong dấu ngoặc kép để trích xuất phần tử thứ 6 của vectơ tên tệp được tạo bởi `dir()`.

```{r}
# load packages
pacman::p_load(
  tidyverse,         # data management
  stringr,           # work with strings/characters
  lubridate,         # work with dates
  rio,               # import / export
  here,              # relative file paths
  fs)                # directory interactions

# extract the file name of latest file
latest_file <- dir(here("data", "example", "linelists")) %>%  # file names from "linelists" sub-folder          
  str_extract("[0-9].*[0-9]") %>%                  # pull out dates (numbers)
  ymd() %>%                                        # convert numbers to dates (assuming year-month-day format)
  which.max() %>%                                  # get index of max date (latest file)
  dir(here("data", "example", "linelists"))[[.]]              # return the filename of latest linelist

latest_file  # print name of latest file
```

Bây giờ bạn có thể sử dụng tên này để hoàn thiện đường dẫn tệp tương đối, với hàm `here()`:

```{r, eval=F}
here("data", "example", "linelists", latest_file) 
```

Và bây giờ bạn có thể nhập tệp mới nhất:

```{r, eval=F}
# import
import(here("data", "example", "linelists", latest_file)) # import 
```

### Sử dụng thông tin tệp {.unnumbered}

Nếu tệp của bạn không có ngày trong tên của chúng (hoặc bạn không tin tưởng vào những ngày đó), bạn có thể thử trích xuất ngày sửa đổi cuối cùng từ siêu dữ liệu tệp. Sử dụng các hàm từ package **fs** để kiểm tra thông tin siêu dữ liệu cho từng tệp, bao gồm thời gian sửa đổi cuối cùng và đường dẫn tệp.

Dưới đây, chúng tôi cung cấp thư mục quan tâm tới hàm `dir_info()` của package **fs**. Trong trường hợp này, thư mục quan tâm nằm trong dự án R trong thư mục "data", thư mục con "example" và thư mục con thư mục này "linelists". Kết quả là một data frame với một dòng cho mỗi tệp và các cột cho `modification_time`, `path`, v.v. Bạn có thể xem ví dụ trực quan về điều này trong chương về [Tương tác với thư mục làm việc].

Chúng ta có thể sắp xếp data frame này của các tệp theo cột với `modification_time`, và sau đó chỉ giữ lại hàng trên cùng/mới nhất (tệp) với `head()`của **base** R. Sau đó, chúng ta có thể trích xuất đường dẫn tệp của tệp mới nhất này chỉ với hàm `pull()` của **dplyr** trên `path` cột. Cuối cùng, chúng ta có thể chuyển đường dẫn tệp này đến `import()`. Tệp đã nhập được lưu dưới dạng `latest_file`.

```{r, eval=F}
latest_file <- dir_info(here("data", "example", "linelists")) %>%  # collect file info on all files in directory
  arrange(desc(modification_time)) %>%      # sort by modification time
  head(1) %>%                               # keep only the top (latest) file
  pull(path) %>%                            # extract only the file path
  import()                                  # import the file

```

<!-- ======================================================= -->

## API {#import_api}

Một "Giao diện lập trình tự động (Automated Programming Interface)" (API) có thể được sử dụng để yêu cầu trực tiếp dữ liệu từ một trang web. API là một tập hợp các quy tắc cho phép một ứng dụng phần mềm tương tác với một ứng dụng phần mềm khác. Khách hàng (bạn) gửi một "yêu cầu (request)" và nhận được một "phản hồi (response)" có chứa nội dung. Các package R **httr** và **jsonlite** có thể hỗ trợ quá trình này.

Mỗi trang web hỗ trợ API sẽ có tài liệu và chi tiết cụ thể riêng để làm quen. Một số trang web công khai API và cho phép có thể được truy cập bởi bất kỳ ai. Những nền tảng khác, chẳng hạn như nền tảng có ID người dùng và thông tin đăng nhập, yêu cầu xác thực để truy cập dữ liệu của họ.

Không cần phải nói, để nhập dữ liệu qua API thì cần phải có kết nối internet. Chúng tôi sẽ đưa ra các ví dụ ngắn gọn về việc sử dụng API để nhập dữ liệu và liên kết bạn với các tài nguyên khác.

*Lưu ý: Hãy nhớ lại rằng dữ liệu có thể được đăng trên một trang web không có API, điều này có thể dễ dàng truy xuất hơn. Ví dụ: một tệp CSV đã đăng có thể được truy cập chỉ bằng cách cung cấp URL của trang web để `import()` như được mô tả trong mục [nhập từ Github](#import_github).*

### HTTP request {.unnumbered}

Trao đổi API thường được thực hiện thông qua một HTTP request. HTTP là Giao thức truyền siêu văn bản (Hypertext Transfer Protocol) và là định dạng cơ bản của giao thức yêu cầu (request)/phản hồi (response) giữa máy khách và máy chủ. Đầu vào và đầu ra chính xác có thể khác nhau tùy thuộc vào loại API nhưng quy trình là giống nhau - "Request" (thường là HTTP request) từ người dùng, thường chứa một truy vấn, theo sau là "Response", chứa thông tin trạng thái về request và có thể là nội dung được yêu cầu.

Dưới đây là một số thành phần của một *HTTP request*:

-   URL của điểm cuối API\
-   "Method (Phương thức)" (hoặc "Verb (Động từ)")\
-   Các tiêu đề\
-   Phần thân

HTTP request "method" là hành động bạn muốn thực hiện. Hai phương thức HTTP phổ biến nhất là `GET` và `POST` nhưng những phương thức khác có thể bao gồm `PUT`, `DELETE`, `PATCH`, v.v. Khi nhập dữ liệu vào R, rất có thể bạn sẽ sử dụng `GET`.

Sau request của bạn, máy tính của bạn sẽ nhận được "phản hồi" ở định dạng tương tự như những gì bạn đã gửi, bao gồm URL, trạng thái HTTP (Trạng thái 200 là thứ bạn muốn!), loại tệp, kích thước và nội dung mong muốn. Sau đó, bạn sẽ cần phân tích cú pháp phản hồi này và biến nó thành một data frame khả thi trong môi trường R của bạn.

### Package {.unnumbered}

Package **httr** hoạt động tốt để xử lý các yêu cầu HTTP trong R. Nó đòi hỏi ít kiến thức về API Web và có thể được sử dụng bởi những người ít quen thuộc với thuật ngữ phát triển phần mềm. Ngoài ra, nếu phản hồi HTTP là .json, bạn có thể sử dụng **jsonlite** để phân tích cú pháp phản hồi.

```{r, eval=F}
# load packages
pacman::p_load(httr, jsonlite, tidyverse)
```

### Dữ liệu công khai {.unnumbered}

Dưới đây là một ví dụ về một HTTP request, được mượn từ một hướng dẫn từ [Phòng thí nghiệm Dữ liệu Trafford](https://www.trafforddatalab.io/open_data_companion/#A_quick_introduction_to_APIs). Trang web này chứa một số tài nguyên khác để tìm hiểu và các bài tập về API.

Tình huống: Chúng ta muốn nhập một danh sách các cửa hàng thức ăn nhanh ở thành phố Trafford, Vương quốc Anh. Dữ liệu có thể được truy cập từ API của Cơ quan Tiêu chuẩn Thực phẩm, cơ quan cung cấp dữ liệu xếp hạng vệ sinh thực phẩm cho Vương quốc Anh.

Dưới đây là các thông số cho yêu cầu của chúng tôi:

-   Phương thức HTTP: GET\
-   URL của điểm cuối API: <http://api.ratings.food.gov.uk/Establishments>\
-   Các thông số đã chọn: tên, địa chỉ, kinh độ, vĩ độ, businessTypeId, ratingKey, localAuthorityId\
-   Các tiêu đề: "x-api-version", 2\
-   (Các) Định dạng dữ liệu: JSON, XML\
-   Tài liệu: <http://api.ratings.food.gov.uk/help>

R code sẽ như sau:

```{r, eval=F, warning=F, message=F}
# prepare the request
path <- "http://api.ratings.food.gov.uk/Establishments"
request <- GET(url = path,
             query = list(
               localAuthorityId = 188,
               BusinessTypeId = 7844,
               pageNumber = 1,
               pageSize = 5000),
             add_headers("x-api-version" = "2"))

# check for any server error ("200" is good!)
request$status_code

# submit the request, parse the response, and convert to a data frame
response <- content(request, as = "text", encoding = "UTF-8") %>%
  fromJSON(flatten = TRUE) %>%
  pluck("establishments") %>%
  as_tibble()
```

Bây giờ bạn có thể làm sạch và sử dụng data frame có tên `response`, với mỗi hàng là một cơ sở thức ăn nhanh.

### Yêu cầu xác thực {.unnumbered}

Một số API yêu cầu xác thực - để bạn chứng minh mình là ai và có thể truy cập vào dữ liệu bị hạn chế. Để nhập những dữ liệu này, trước tiên bạn có thể cần sử dụng phương thức POST để cung cấp tên người dùng, mật khẩu hoặc code. Điều này sẽ trả về một mã thông báo truy cập, có thể được sử dụng cho các yêu cầu phương thức GET tiếp theo để truy xuất dữ liệu mong muốn.

Dưới đây là một ví dụ về truy vấn dữ liệu từ *Go.Data*, một công cụ điều tra ổ dịch. *Go.Data* sử dụng một API cho tất cả các tương tác giữa giao diện người dùng web và các ứng dụng điện thoại thông minh được sử dụng để thu thập dữ liệu. *Go.Data* được sử dụng trên khắp thế giới. Bởi vì dữ liệu các vụ dịch là nhạy cảm và bạn nên là người duy nhất có thể truy cập vào dữ liệu vụ dịch *của mình*, nên việc xác thực là bắt buộc.

Dưới đây là một số code R mẫu sử dụng **httr** và **jsonlite** để kết nối với API *Go.Data* để nhập dữ liệu liên hệ truy vết từ vụ dịch của bạn.

```{r, eval=F}
# set credentials for authorization
url <- "https://godatasampleURL.int/"           # valid Go.Data instance url
username <- "username"                          # valid Go.Data username 
password <- "password"                          # valid Go,Data password 
outbreak_id <- "xxxxxx-xxxx-xxxx-xxxx-xxxxxxx"  # valid Go.Data outbreak ID

# get access token
url_request <- paste0(url,"api/oauth/token?access_token=123") # define base URL request

# prepare request
response <- POST(
  url = url_request,  
  body = list(
    username = username,    # use saved username/password from above to authorize                               
    password = password),                                       
    encode = "json")

# execute request and parse response
content <-
  content(response, as = "text") %>%
  fromJSON(flatten = TRUE) %>%          # flatten nested JSON
  glimpse()

# Save access token from response
access_token <- content$access_token    # save access token to allow subsequent API calls below

# import outbreak contacts
# Use the access token 
response_contacts <- GET(
  paste0(url,"api/outbreaks/",outbreak_id,"/contacts"),          # GET request
  add_headers(
    Authorization = paste("Bearer", access_token, sep = " ")))

json_contacts <- content(response_contacts, as = "text")         # convert to text JSON

contacts <- as_tibble(fromJSON(json_contacts, flatten = TRUE))   # flatten JSON to tibble
```

[***CẨN TRỌNG:*** Nếu bạn đang nhập một lượng lớn dữ liệu từ một API yêu cầu xác thực, nó có thể hết thời gian chờ. Để tránh điều này, hãy truy xuất lại access_token trước mỗi yêu cầu API GET và thử sử dụng các bộ lọc hoặc giới hạn trong truy vấn.]{style="color: orange;"}

[***MẸO:*** Lệnh `fromJSON()` từ package **jsonlite** không hoàn toàn không - lồng ghép vào lần đầu tiên nó được chạy, vì vậy bạn vẫn có thể có danh sách các hàng trong phần kết quả của mình. Bạn sẽ cần phải bỏ lồng ghép thêm cho một số biến nhất định; tùy thuộc vào cách .json của bạn được lồng ghép vào nhau. Để xem thêm thông tin về điều này, hãy xem tài liệu về package **jsonlite**, chẳng hạn như [`flatten()` function](https://rdrr.io/cran/jsonlite/man/flatten.html).]{style="color: darkgreen;"}

Để biết thêm chi tiết, hãy xem tài liệu trên [LoopBack Explorer](https://loopback.io/doc/en/lb4/index.html), chương [Truy vết tiếp xúc] hoặc các mẹo API trên [Go.Data Github repository](https://worldhealthorganization.github.io/godata/api-docs)

Bạn có thể đọc thêm về *httr* trong gói lệnh [here](https://httr.r-lib.org/articles/quickstart.html)

Phần này cũng đã được trình bày trong [hướng dẫn này](https://www.dataquest.io/blog/r-api-tutorial/) và [hướng dẫn này](https://medium.com/@traffordDataLab/querying-apis-in-r-39029b73d5f1).

<!-- ======================================================= -->

## Xuất dữ liệu

### Với package **rio** {.unnumbered}

Với **rio**, bạn có thể sử dụng lệnh `export()` theo cách tương tự với `import()`. Đầu tiên, cung cấp tên của đối tượng R bạn muốn lưu (ví dụ: `linelist`), sau đó trong dấu ngoặc kép đặt đường dẫn tệp nơi bạn muốn lưu tệp, bao gồm tên tệp mong muốn và phần mở rộng tệp. Ví dụ:

Thao tác này lưu data frame `linelist` dưới dạng một Excel workbook vào thư mục làm việc/thư mục gốc của dự án R:

```{r, eval=F}
export(linelist, "my_linelist.xlsx") # will save to working directory
```

Bạn có thể lưu cùng một data frame dưới dạng tệp csv bằng cách thay đổi phần mở rộng. Ví dụ, chúng tôi cũng lưu nó vào một đường dẫn tệp được tạo bằng `here()`:

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.csv"))
```

### Tới clipboard {.unnumbered}

Để xuất khung dữ liệu sang "clipboard" của máy tính (để sau đó dán vào một phần mềm khác như Excel, Google Spreadsheets, v.v.), bạn có thể sử dụng `write_clip()` từ package **clipr**.

```{r, eval=F}
# export the linelist data frame to your system's clipboard
clipr::write_clip(linelist)
```

## Tệp RDS {#import_rds}

Giống như .csv, .xlsx, v.v., bạn cũng có thể xuất/lưu các R data frame dưới dạng tệp .rds. Đây là định dạng tệp dành riêng cho R và rất hữu ích nếu bạn biết mình sẽ làm việc lại với dữ liệu đã xuất trong R.

Các nhóm của cột được lưu trữ, vì vậy bạn không cần phải làm sạch lại khi chúng được nhập (với Excel hoặc thậm chí là tệp CSV, điều này có thể khiến bạn đau đầu!). Nó cũng là một tệp nhỏ hơn, hữu ích cho việc xuất và nhập nếu bộ dữ liệu của bạn lớn.

Ví dụ: nếu bạn làm việc trong nhóm Dịch tễ học và cần gửi tệp cho nhóm GIS để lập bản đồ và họ cũng sử dụng R, chỉ cần gửi tệp .rds cho họ! Sau đó, tất cả các nhóm cột được giữ lại và có ít việc phải xử lý hơn.

```{r, eval=F}
export(linelist, here("data", "clean", "my_linelist.rds"))
```

<!-- ======================================================= -->

## Tệp và danh sách Rdata {#import_rdata}

Tệp `.Rdata` có thể lưu trữ nhiều đối tượng R - ví dụ: nhiều data frame, kết quả mô hình, danh sách, v.v. Điều này có thể rất hữu ích để hợp nhất hoặc chia sẻ nhiều dữ liệu của bạn cho một dự án nhất định.

Trong ví dụ dưới đây, nhiều đối tượng R được lưu trữ trong tệp "my_objects.Rdata" đã xuất:

```{r, eval=F}
rio::export(my_list, my_dataframe, my_vector, "my_objects.Rdata")
```

Lưu ý: nếu bạn đang thử *nhập* một danh sách, hãy sử dụng `import_list()` từ **rio** để nhập nó với cấu trúc và nội dung gốc hoàn chỉnh.

```{r, eval=F}
rio::import_list("my_list.Rdata")
```

<!-- ======================================================= -->

## Lưu biểu đồ

Hướng dẫn về cách lưu các biểu đồ, chẳng hạn như các biểu đồ được tạo bởi `ggplot()`, được thảo luận sâu trong chương [ggplot cơ bản].

Tóm lại, chạy lệnh `ggsave("my_plot_filepath_and_name.png")` sau khi in biểu đồ của bạn. Bạn có thể cung cấp một đối tượng biểu đồ đã lưu cho đối số `plot =` hoặc chỉ cần xác định đường dẫn tệp đích (với phần mở rộng tệp) để lưu biểu đồ được hiển thị gần đây nhất. Bạn cũng có thể kiểm soát `width =`, `height =`, `units =` và `dpi =`.

Cách để lưu đồ thị mạng lưới (network graph), chẳng hạn như cây lây nhiễm, được đề cập trong chương [Chuỗi lây nhiễm].

<!-- ======================================================= -->

## Tài nguyên học liệu

[R Data Import/Export Manual](https://cran.r-project.org/doc/manuals/r-release/R-data.html)\
[R 4 Data Science chapter on data import](https://r4ds.had.co.nz/data-import.html#data-import)\
[ggsave() documentation](https://ggplot2.tidyverse.org/reference/ggsave.html)

Dưới đây là một bảng, lấy từ **rio** [vignette](https://cran.r-project.org/web/packages/rio/vignettes/rio.html) trực tuyến. Đối với mỗi loại dữ liệu, nó hiển thị: phần mở rộng tệp dự kiến, package **rio** sử dụng để nhập hoặc xuất dữ liệu và trả lời chức năng này có được bao gồm trong phiên bản **rio** được cài đặt mặc định hay không.

+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Định dạng                                 | Phần mở rộng điển hình  | Package nhập         | Package xuất | Được cài đặt theo mặc định |
+===========================================+=========================+======================+==============+============================+
| Dữ liệu được phân tách bằng-dấu phẩy      | .csv                    | data.table `fread()` | data.table   | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Dữ liệu được phân tách bằng-dấu gạch      | .psv                    | data.table `fread()` | data.table   | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Dữ liệu được phân tách bằng-tab           | .tsv                    | data.table `fread()` | data.table   | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| SAS                                       | .sas7bdat               | haven                | haven        | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| SPSS                                      | .sav                    | haven                | haven        | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Stata                                     | .dta                    | haven                | haven        | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| SAS                                       | XPORT                   | .xpt                 | haven        | haven                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| SPSS Portable                             | .por                    | haven                |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Excel                                     | .xls                    | readxl               |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Excel                                     | .xlsx                   | readxl               | openxlsx     | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Cú pháp R                                 | .R                      | base                 | base         | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Đối tượng R được lưu                      | .RData, .rda            | base                 | base         | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Đối tượng R được nối tiếp                 | .rds                    | base                 | base         | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Epiinfo                                   | .rec                    | foreign              |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Minitab                                   | .mtp                    | foreign              |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Systat                                    | .syd                    | foreign              |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| "XBASE"                                   | database files          | .dbf                 | foreign      | foreign                    |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Định dạng tệp Weka Attribute-Relation     | .arff                   | foreign              | foreign      | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Định dạng trao đổi dữ liệu                | .dif                    | utils                |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Dữ liệu Fortran                           | no recognized extension | utils                |              | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Định dạng dữ liệu Fixed-width             | .fwf                    | utils                | utils        | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Dữ liệu gzip được phân tách bằng-dấu phẩy | .csv.gz                 | utils                | utils        | Có                         |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| CSVY (Tiêu đề siêu dữ liệu CSV + YAML)    | .csvy                   | csvy                 | csvy         | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| EViews                                    | .wf1                    | hexView              |              | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Định dạng trao đổi Feather giữa R/Python  | .feather                | feather              | feather      | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Fast Storage                              | .fst                    | fst                  | fst          | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| JSON                                      | .json                   | jsonlite             | jsonlite     | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Matlab                                    | .mat                    | rmatio               | rmatio       | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| OpenDocument Spreadsheet                  | .ods                    | readODS              | readODS      | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Bảng HTML                                 | .html                   | xml2                 | xml2         | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| Tài liệu XML cạn                          | .xml                    | xml2                 | xml2         | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| YAML                                      | .yml                    | yaml                 | yaml         | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
| clipboard mặc định là tsv                |                         | clipr                | clipr        | Không                      |
+-------------------------------------------+-------------------------+----------------------+--------------+----------------------------+
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/importing.Rmd-->

# (PART) Quản lý dữ liệu {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_management.Rmd-->

# Làm sạch số liệu và các hàm quan trọng {#cleaning}

```{r, out.height = "10%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "cleaning.png"))
```

Chương này trình bày các bước phổ biến được sử dụng trong quá trình "làm sạch" bộ dữ liệu và cũng giải thích việc sử dụng các hàm quản lý dữ liệu thiết yếu trong R.

Để giải thích rõ hơn quá trình làm sạch dữ liệu, chương này bắt đầu từ cách nhập bộ dữ liệu thô có tên linelist và tiến hành từng bước trong quá trình làm sạch. Trong code R, quy trình này được biểu thị dưới dạng một chuỗi "pipe", tham chiếu đến toán tử "pipe" `%>%` để chuyển tiếp từ thao tác này sang thao tác tiếp theo trong cùng một bộ dữ liệu.

### Các hàm quan trọng {.unnumbered}

Cuốn sách này nhấn mạnh việc sử dụng các hàm từ hệ sinh thái của package [**tidyverse**](https://www.tidyverse.org/). Các hàm thiết yếu trong R trình bày trong chương này được liệt kê dưới đây.

Nhiều hàm thuộc về package [**dplyr**](https://dplyr.tidyverse.org/), mà cung cấp các hàm dạng "verb" để giải quyết các thách thức trong thao tác xử lý dữ liệu (tên package được viết đầy đủ là "data frame-[plier](https://www.thefreedictionary.com/plier#:~:text=also%20ply%C2%B7er%20(pl%C4%AB%E2%80%B2,holding%2C%20bending%2C%20or%20cutting.)%22). **dplyr** là một phần trong hệ sinh thái của package **tidyverse** (mà bao gồm các package khác như **ggplot2**, **tidyr**, **stringr**, **tibble**, **purrr**, **magrittr**, và **forcats**).

+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| Hàm                                                 | Chức năng                                                  | Package                  |
+=====================================================+============================================================+==========================+
| `%>%`                                               | "pipe" (chuyển tiếp) dữ liệu từ một hàm sang hàm tiếp theo | **magrittr**             |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `mutate()`                                          | tạo, chuyển dạng, và định nghĩa lại cột                    | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `select()`                                          | giữ lại, xóa, chọn, hoặc đổi tên cột                       | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `rename()`                                          | đổi tên cột                                                | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `clean_names()`                                     | chuẩn hóa cú pháp tên cột                                  | **janitor**              |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `as.character()`, `as.numeric()`, `as.Date()`, etc. | chuyển đổi định dạng cột                                   | **base** R               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `across()`                                          | biến đổi đồng thời nhiều cột                               | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| các hàm **tidyselect**                              | sử dụng logic để chọn cột                                  | **tidyselect**           |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `filter()`                                          | giữ lại các dòng theo điều kiện                            | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `distinct()`                                        | lọc quan sát trùng                                         | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `rowwise()`                                         | xử lý theo/trong mỗi dòng                                  | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `add_row()`                                         | thêm dòng thủ công                                         | **tibble**               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `arrange()`                                         | săp xếp dòng                                               | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `recode()`                                          | recode lại giá trị trong cột                               | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `case_when()`                                       | recode lại giá trị trong cột kèm các điều kiện phức tạp    | **dplyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `replace_na()`, `na_if()`, `coalesce()`             | các hàm đặc biệt để recode                                 | **tidyr**                |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `age_categories()` and `cut()`                      | tạo biến phân nhóm từ biến định lượng                      | **epikit** và **base** R |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `clean_variable_spelling()`                         | recode/làm sạch giá trị sử dụng từ điển dữ liệu            | **linelist**             |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+
| `which()`                                           | áp dụng các điều kiện logic; trả về các chỉ số             | **base** R               |
+-----------------------------------------------------+------------------------------------------------------------+--------------------------+

Nếu bạn muốn xem các hàm này so sánh với các câu lệnh trong Stata hoặc SAS, hãy xem chương [Chuyển đổi sang R].

Bạn cũng có thể gặp một framework quản lý dữ liệu khác từ package **data.table** trong R với các toán tử như `:=` và thường xuyên sử dụng dấu ngoặc `[ ]`. Cách tiếp cận và cú pháp này được giải thích ngắn gọn trong chương [Data Table].

### Thuật ngữ {.unnumbered}

Trong cuốn sách này, chúng tôi quy ước chung "cột" và "hàng" thay cho "biến" và "quan sát". Như đã giải thích trong phần dẫn trên ["dữ liệu gọn gàng - tidy data"](https://tidyr.tidyverse.org/articles/tidy-data.html), hầu hết các bộ dữ liệu dịch tễ-thống kê đều có cấu trúc gồm các hàng, cột và giá trị.

*Variables (biến)* chứa các giá trị đo lường cùng một thuộc tính cơ bản (như nhóm tuổi, kết quả hoặc ngày bắt đầu). *Observations (quan sát)* chứa tất cả các giá trị được đo trên cùng một đơn vị (ví dụ: một người, địa điểm hoặc mẫu phòng thí nghiệm). Vì vậy, những khía cạnh này có thể khó xác định một cách hữu hình hơn.

Trong bộ dữ liệu "tidy", mỗi cột là một biến, mỗi hàng là một quan sát và mỗi ô là một giá trị duy nhất. Tuy nhiên, một số bộ dữ liệu bạn gặp phải sẽ không giống với mô tả này - bộ dữ liệu định dạng "wide (ngang)" có thể có một biến số được chia thành nhiều cột (xem ví dụ trong chương [Xoay trục dữ liệu]). Tương tự như vậy, các quan sát có thể được chia thành nhiều hàng.

Cuốn sách này tập trung về quản lý và biến đổi dữ liệu, do đó, việc đề cập đến cấu trúc dữ liệu cụ thể của các hàng và cột sẽ thích hợp hơn là các quan sát và biến vốn khá trừu tượng. Các trường hợp ngoại lệ chủ yếu xảy ra trong các chương về phân tích dữ liệu, nơi bạn sẽ thấy nhiều tham chiếu hơn đến các biến và quan sát.

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Quy trình làm sạch

**Chương này tiến hành các bước làm sạch điển hình, bằng cách thêm chúng tuần tự vào một chuỗi pipe.**

Trong phân tích dịch tễ học và xử lý dữ liệu, các bước làm sạch thường được thực hiện tuần tự, liên kết với nhau. Trong R, việc này thường được thực hiện dưới dạng một "pipeline - đường ống" làm sạch, trong đó *bộ dữ liệu thô được chuyển tiếp hoặc "dẫn" từ bước làm sạch này sang bước làm sạch khác*.

Các chuỗi như vậy sử dụng các hàm dạng "verb" trong package **dplyr** và toán tử pipe `%>%` trong package **magrittr**. Chuỗi pipe bắt đầu từ dữ liệu "thô" ("linelist_raw.xlsx") và kết thúc bằng bộ dữ liệu "sạch" trên R (`linelist`) có thể được sử dụng, lưu, xuất, v.v.

Trong quy trình làm sạch dữ liệu, thứ tự của các bước là quan trọng. Các bước làm sạch có thể bao gồm:

-   Nhập dữ liệu
-   Làm sạch hoặc đổi tên cột
-   Loại bỏ trùng lặp
-   Tạo và chuyển đổi cột (ví dụ: mã hóa lại hoặc chuẩn hóa các giá trị)
-   Lọc hoặc thêm hàng

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Gọi package

Đoạn code này trình bày cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt package nếu cần *và* gọi package ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` sẵn có trong **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r, message = F}
pacman::p_load(
  rio,        # importing data  
  here,       # relative file pathways  
  janitor,    # data cleaning and tables
  lubridate,  # working with dates
  epikit,     # age_categories() function
  tidyverse   # data management and visualization
)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Nhập dữ liệu

### Nhập {.unnumbered}

Ở đây, chúng ta sẽ nhập tệp tin Excel "thô" bằng cách sử dụng hàm `import()` từ package **rio**. Package **rio** có thể xử lý linh hoạt nhiều loại tệp tin (ví dụ: .xlsx, .csv, .tsv, .rds. Xem chương về [Nhập xuất dữ liệu] để biết thêm thông tin và mẹo về các tình huống bất thường (ví dụ: loại bỏ hàng, thiết lập giá trị trống, nạp trang tính Google, v.v.).

Nếu bạn muốn hiểu rõ hơn, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_raw.xlsx' class='download-button'>hãy tải xuống tệp dữ liệu linelist "thô"</a> (với file dạng .xlsx).

Nếu bộ dữ liệu của bạn quá lớn và mất nhiều thời gian để nhập, sẽ hữu ích khi bạn đặt lệnh nhập dữ liệu riêng biệt với chuỗi pipe và dữ liệu "thô" sẽ được lưu thành một tệp riêng biệt. Điều này cũng cho phép dễ dàng so sánh giữa phiên bản gốc và phiên bản đã làm sạch.

Dưới đây, chúng ta nạp một tệp Excel thô và lưu nó dưới dạng dataframe `linelist_raw`. Chúng tôi giả định rằng tệp này nằm trong thư mục làm việc của bạn hoặc thư mục gốc của dự án R và vì vậy không có thư mục con nào được chỉ định trong đường dẫn tệp.

```{r, echo=F, message=F}
# HIDDEN FROM READER
# actually load the data using here()
linelist_raw <- rio::import(here::here("data", "case_linelists", "linelist_raw.xlsx"))
```

```{r, eval=F}
linelist_raw <- import("linelist_raw.xlsx")
```

Bạn có thể xem 50 hàng đầu tiên của bộ dữ liệu bên dưới. Lưu ý: hàm `head(n)` trong **base** R cho phép bạn chỉ xem `n` hàng đầu tiên trong R console.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_raw,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Đánh giá {.unnumbered}

Bạn có thể sử dụng hàm `skim()` từ package **skimr** để có cái nhìn tổng quan về toàn bộ bộ dữ liệu (xem chương [Bảng mô tả] để biết thêm thông tin). Các cột được tóm tắt theo phân lớp/định dạng như ký tự và số. Lưu ý: "POSIXct" là một loại phân lớp ngày thô (xem chương [Làm việc với ngày tháng].

```{r, eval=F}
skimr::skim(linelist_raw)
```

```{r, echo=F}
skimr::skim_without_charts(linelist_raw)
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tên cột

Trong R, *tên* cột là "tiêu đề" hoặc giá trị "trên đỉnh" của một cột. Chúng được sử dụng để tham chiếu đến các cột trong đoạn code và đóng vai trò như một nhãn mặc định trong các bảng biểu.

Các phần mềm thống kê khác như SAS và STATA sử dụng *"nhãn"* là tên cột phiên bản dài hơn khi in, cùng tồn tại song song với tên cột. Mặc dù R cung cấp tính năng thêm nhãn của cột vào dữ liệu, nhưng điều này hầu hết không được nhấn mạnh trong thực tế. Để đặt tên cột "dễ nhìn" cho các bảng biểu, người ta thường điều chỉnh hiển thị của chúng trong các lệnh vẽ biểu đồ để tạo ra kết quả (ví dụ: tiêu đề trục hoặc chú giải của một biểu đồ hoặc tiêu đề cột trong bảng - xem thêm [mục scales trong chương Các tips với ggplot](#%20ggplot_tips_scales) và chương [Trình bày bảng]). Nếu bạn muốn gán nhãn cột trong dữ liệu, hãy đọc thêm tài liệu trực tuyến [tại đây](https://cran.r-project.org/web/packages/expss/vignettes/labels-support.html) và [tại đây](https%20:%20//cran.r-project.org/web/packages/labelt/vignettes/intro_labelling.html).

Vì tên cột trong R được sử dụng rất thường xuyên, vì vậy chúng phải có cú pháp "sạch". Chúng tôi đề xuất những tiêu chí sau:

-   Tên ngắn
-   Không có khoảng trắng (thay thế bằng dấu gạch dưới\_)
-   Không có ký tự lạ (&, \#, \<, \>, ...)
-   Thống nhất cách định danh (vd: toàn bộ tên cột ngày như **date\_**onset, **date\_**report, **date\_**death...)

Tên các cột trong `linelist_raw` được in bên dưới bằng cách sử dụng hàm `names()` từ **base** R. Ban đầu chúng ta có thể thấy rằng:

-   Một số tên chứa khoảng trắng (vd: `infection date`)
-   Một số mẫu tên khác nhau được sử dụng cho biến ngày (`date onset` và `infection date`)
-   Phải có một *tiêu đề được hợp nhất* ở hai cột cuối cùng trong tệp .xlsx. Chúng tôi biết điều này vì tên của hai cột được hợp nhất ("merge_header") được R gán cho cột đầu tiên và cột thứ hai được gán tên giữ chỗ "... 28" (vì lúc đó nó trống và là cột thứ 28).

```{r}
names(linelist_raw)
```

[***CHÚ Ý:*** Để tham chiếu tên một cột có chứa khoảng trắng, hãy bao quanh tên cột bằng dấu huyền, ví dụ: linelist\$`` ` '\x60infection date\x60'` ``. Lưu ý là trên bàn phím, dấu huyền (\`) được phân biệt với dấu ngoặc đơn (').]{style="color: black;"}

### Làm sạch tự động {.unnumbered}

Hàm `clean_names()` từ package **janitor** chuẩn hóa tên cột và biến chúng thành duy nhất bằng cách thực hiện như sau:

-   Chuyển đổi tất cả các tên cột thành chỉ bao gồm dấu gạch dưới, số và chữ cái
-   Các ký tự có dấu được chuyển ngữ sang dạng ASCII (ví dụ: o tiếng Đức với âm sắc trở thành "o", "enye" tiếng Tây Ban Nha trở thành "n")
-   Tùy chọn viết hoa cho tên cột mới có thể được chỉ định bằng cách sử dụng đối số `case =` (mặc định là "snake", các lựa chọn thay thế bao gồm "sentence", "title", "small_camel"...)
-   Bạn có thể chỉ định các tên thay thế cụ thể bằng cách cung cấp một vectơ tới đố số `replace =` (ví dụ: `replace = c(onset = "date_of_onset")`)
-   Đây là một [hướng dẫn](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#cleaning) trực tuyến

Sau đây, quy trình làm sạch bắt đầu bằng cách sử dụng hàm `clean_names()` trên bộ dữ liệu linelist thô.

```{r clean_names}
# pipe the raw dataset through the function clean_names(), assign result as "linelist"  
linelist <- linelist_raw %>% 
  janitor::clean_names()

# see the new column names
names(linelist)
```

[***LƯU Ý***: Tên cột cuối cùng "... 28" đã được đổi thành "x28".]{style="color: black;"}

### Làm sạch tên cột thủ công {.unnumbered}

Việc đặt tên lại các cột theo cách thủ công thường là cần thiết, ngay cả sau bước chuẩn hóa ở trên. Dưới đây, việc đổi tên được thực hiện bằng cách sử dụng hàm `rename()` từ package **dplyr**, như một phần của quy trình. `rename()` sử dụng cú pháp `NEW = OLD` - tên cột mới được đặt trước tên cột cũ.

Dưới đây, một lệnh đổi tên được thêm vào quy trình làm sạch. Các khoảng trắng đã được thêm vào một cách chọn lọc để căn chỉnh code dễ đọc hơn.

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome)
```

Bây giờ bạn có thể thấy rằng tên các cột đã được thay đổi:

```{r message=FALSE, echo=F}
names(linelist)
```

#### Thay đối tên cột theo vị trí {.unnumbered}

Bạn cũng có thể đổi tên theo vị trí cột, thay vì tên cột, ví dụ:

```{r, eval=F}
rename(newNameForFirstColumn  = 1,
       newNameForSecondColumn = 2)
```

#### Đổi tên bằng hàm `select()` và `summarise()` {.unnumbered}

Như một lối tắt, bạn cũng có thể đổi tên các cột bằng hàm `select()` và `summarise()` thuộc package **dplyr**. Hàm `select()` được sử dụng để chỉ giữ một số cột nhất định (sẽ được đề cập sau trong chương này). Hàm `summarise()` được đề cập trong các chương [Nhóm dữ liệu] và [Bảng mô tả]. Các hàm này cũng sử dụng định dạng `new_name = old_name`. Đây là một ví dụ:

```{r, eval=F}
linelist_raw %>% 
  select(# NEW name             # OLD name
         date_infection       = `infection date`,    # rename and KEEP ONLY these columns
         date_hospitalisation = `hosp date`)
```

### Các thách thức khác {.unnumbered}

#### Cột trống tên trên file Excel {.unnumbered}

R không thể nhận diện các cột trong bộ dữ liệu mà không có tên cột (tiêu đề). Vì vậy, nếu bạn nhập một bộ dữ liệu Excel có dữ liệu nhưng không có tiêu đề cột, R sẽ điền vào các tiêu đề đó mặc định như "... 1" hoặc "... 2". Phần số đại diện cho số cột (ví dụ: nếu cột thứ 4 trong bộ dữ liệu không có tiêu đề, thì R sẽ mặc định đặt tên là "... 4").

Bạn có thể làm sạch các tên cột này theo cách thủ công bằng cách tham chiếu số vị trí của chúng (xem ví dụ ở trên) hoặc tên được chỉ định của chúng (`linelist_raw$...1`).

#### Hợp nhất tên cột và ô Excel {.unnumbered}

Các ô được hợp nhất trong file Excel là một sự cố thường xảy ra khi nhận dữ liệu. Như đã giải thích trong chương [Chuyển đổi sang R], các ô được hợp nhất có thể dễ nhìn cho con người đọc dữ liệu, nhưng không phải là "cấu trúc dữ liệu cơ bản" và gây ra nhiều vấn đề cho máy khi nhận diện dữ liệu. R không thể chứa các ô đã hợp nhất.

Nhắc nhở người nhập liệu rằng **dữ liệu có thể đọc được bởi con người không giống với dữ liệu mà máy có thể đọc được**. Hãy cố gắng đào tạo người dùng về các nguyên tắc về [**dữ liệu tidy** ](https://r4ds.had.co.nz/tidy-data.html). Nếu có thể, hãy cố gắng thay đổi quy trình để dữ liệu có định dạng gọn gàng hơn mà không hợp nhất các ô.

-   Mỗi biến phải là một cột riêng biệt
-   Mỗi quan sát phải là một dòng riêng biệt
-   Mỗi giá trị phải là một ô riêng biệt

Khi sử dụng hàm `import()` của package **rio**, giá trị trong một ô đã hợp nhất sẽ được gán cho ô đầu tiên và các ô tiếp theo sẽ trống.

Một giải pháp để xử lý các ô đã hợp nhất là nạp dữ liệu bằng hàm `readWorkbook()` từ package **openxlsx**. Thiết lập đối số `fillMergedCells = TRUE`. Điều này cho phép giá trị trong ô hợp nhất được tham chiếu cho tất cả các ô nằm trong phạm vi hợp nhất.

```{r, eval=F}
linelist_raw <- openxlsx::readWorkbook("linelist_raw.xlsx", fillMergedCells = TRUE)
```

[***NGUY HIỂM***: Nếu các tên cột được hợp nhất với `readWorkbook()`, có thể sẽ trả về tên cột trùng lặp, mà bạn sẽ cần phải sửa một cách thủ công - R không làm việc được với các tên cột trùng lặp! Bạn có thể đặt lại tên cho chúng bằng cách tham chiếu vị trí của chúng (ví dụ: cột 5), như được giải thích trong mục làm sạch tên cột thủ công.]{style="color: red;"}

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Chọn hoặc đổi vị trí cột

Sử dụng hàm `select()` từ package **dplyr** để chọn các cột bạn muốn giữ lại và sắp xếp lại thứ tự của chúng trong bộ dữ liệu.

[***CẨN TRỌNG***: Trong các ví dụ dưới đây, bộ dữ liệu `linelist` được điều chỉnh với hàm `select()` và được hiển thị, nhưng không được lưu. Việc này được sử dụng phục vụ mục đích mô tả. Tên cột đã sửa đổi được in ra bằng cách chuyển tiếp bộ dữ liệu tới hàm `names()`.]{style="color: orange;"}

**Dưới đây là TẤT CẢ các tên cột trong bộ dữ liệu linelist tại thời điểm làm sạch**:

```{r}
names(linelist)
```

### Giữ cột {.unnumbered}

**Giữ lại những cột mong muốn**

Viết tên cột cần giữ trong hàm `select()`, không có dấu ngoặc kép. Kết quả trả về sẽ xuất hiện trong bộ dữ liệu theo thứ tự mà bạn cung cấp. Lưu ý rằng nếu bạn chỉ định một cột không tồn tại, R sẽ báo lỗi (xem cách sử dụng hàm `any_of()` bên dưới nếu bạn không muốn gặp lỗi trong trường hợp này).

```{r}
# linelist dataset is piped through select() command, and names() prints just the column names
linelist %>% 
  select(case_id, date_onset, date_hospitalisation, fever) %>% 
  names()  # display the column names
```

### Hàm trợ giúp "tidyselect" {#clean_tidyselect .unnumbered}

Các hàm trợ giúp này được xây dựng để giúp bạn dễ dàng chỉ định các cột cần giữ, loại bỏ hoặc chuyển đổi. Chúng nằm trong package **tidyselect**, thuộc hệ sinh thái **tidyverse** và làm cơ sở cho cách chọn cột trong các hàm **dplyr**.

Ví dụ: nếu bạn muốn sắp xếp lại các cột, hàm `everything()` là một hàm hữu ích để biểu thị "tất cả các cột khác chưa được đề cập". Lệnh dưới đây di chuyển các cột `date_onset` và `date_hospitalisation` lên cột đầu tiên (bên trái) của bộ dữ liệu, nhưng vẫn giữ tất cả các cột khác sau đó. Lưu ý rằng hàm `everything()` được viết bằng dấu ngoặc đơn trống:

```{r}
# move date_onset and date_hospitalisation to beginning
linelist %>% 
  select(date_onset, date_hospitalisation, everything()) %>% 
  names()
```

Dưới đây là các hàm trợ giúp "tidyselect" khác cũng hoạt động *trong* các hàm **dplyr** như `select()`, `across()`, và `summarise()`:

-   `everything()` - tất cả các cột khác chưa được đề cập

-   `last_col()` - cột cuối cùng

-   `where()` - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE

-   `contains()` - cột chứa một chuỗi ký tự

    -   Ví dụ: `select(contains("time"))`

-   `starts_with()` - khớp với các tiền tố được chỉ định

    -   Ví dụ: `select(starts_with("date_"))`

-   `ends_with()` - khớp với các hậu tố được chỉ định

    -   Ví dụ: `select(ends_with("_post"))`

-   `matches()` - để áp dụng một mệnh đề chính quy (regex)

    -   Ví dụ: `select(matches("[pt]al"))`

-   `num_range()` - một khoảng số học như x01, x02, x03

-   `any_of()` - khớp NẾU cột tồn tại nhưng không báo lỗi nếu không tìm thấy

    -   Ví dụ: `select(any_of(date_onset, date_death, cardiac_arrest))`

Ngoài ra, sử dụng các toán tử bình thường như `c()` để liệt kê danh sách cột, hoặc `:` cho các cột liên tiếp, `!` cho đối lập, `&` cho VÀ, và `|` cho HOẶC.

Sử dụng `where()` để cụ thể tiêu chí logic cho các cột. Nếu đưa một hàm vào trong `where()`, hãy nhớ không bao gồm dấu ngoặc đơn trống của hàm đó. Câu lệnh bên dưới chọn các cột kiểu Số.

```{r}
# select columns that are class Numeric
linelist %>% 
  select(where(is.numeric)) %>% 
  names()
```

Sử dụng `contains()` để chọn các cột trong đó tên cột chứa một chuỗi ký tự được chỉ định. `ends_with()` và `starts_with()` cung cấp thêm các lựa chọn khác nhau.

```{r}
# select columns containing certain characters
linelist %>% 
  select(contains("date")) %>% 
  names()
```

Hàm `matches()` hoạt động tương tự như hàm `contains()` nhưng có thể được cung cấp một biểu thức chính quy (xem chương [Ký tự và chuỗi]), chẳng hạn như nhiều chuỗi được phân tách bằng toán tự OR trong dấu ngoặc đơn:

```{r}
# searched for multiple character matches
linelist %>% 
  select(matches("onset|hosp|fev")) %>%   # note the OR symbol "|"
  names()
```

[***CẨN TRỌNG***: Nếu tên cột mà bạn đưa ra không tồn tại trong dữ liệu, máy có thể báo lỗi và dừng code của bạn. Cân nhắc sử dụng hàm `any_of()` để trích dẫn các cột có thể hoặc không thể tồn tại, đặc biệt hữu ích trong các lựa chọn loại trừ (loại bỏ).]{style="color: orange;"}

Chỉ có một trong các cột này tồn tại, nhưng không có lỗi được báo và code sẽ tiếp tục các bước trong quy trình làm sạch.

```{r}
linelist %>% 
  select(any_of(c("date_onset", "village_origin", "village_detection", "village_residence", "village_travel"))) %>% 
  names()
```

### Xóa cột {.unnumbered}

**Chỉ ra cột nào cần loại bỏ** bằng cách đặt biểu tượng dấu trừ "-" ở phía trước tên cột (ví dụ: `select(-outcome)`) hoặc một vectơ tên các cột (như bên dưới). Tất cả các cột khác sẽ được giữ nguyên.

```{r}
linelist %>% 
  select(-c(date_onset, fever:vomit)) %>% # remove date_onset and all columns from fever to vomit
  names()
```

Bạn cũng có thể xóa một cột bằng cú pháp trong **base** R, bằng cách định nghĩa nó là `NULL`. Ví dụ:

```{r, eval=F}
linelist$date_onset <- NULL   # deletes column with base R syntax 
```

### Hoạt động độc lập {.unnumbered}

`select()` cũng có thể được sử dụng như một lệnh độc lập (không bắt buộc trong chuỗi các bước làm sạch). Trong trường hợp này, đối số đầu tiên trong bộ dữ liệu gốc sẽ được tham chiếu.

```{r}
# Create a new linelist with id and age-related columns
linelist_age <- select(linelist, case_id, contains("age"))

# display the column names
names(linelist_age)
```

#### Thêm vào quy trình làm sạch {.unnumbered}

Trong bộ dữ liệu `linelist_raw`, có một vài cột chúng ta không cần: `row_num`, `merged_header`, và `x28`. Chúng ta xóa chúng bằng lệnh `select()` trong chuỗi các bước làm sạch như sau:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################

    # remove column
    select(-c(row_num, merged_header, x28))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Loại bỏ trùng lặp

Xem chương [Loại bỏ trùng lặp] để biết các tùy chọn mở rộng về cách loại bỏ dữ liệu trùng lặp. Chỉ một ví dụ rất đơn giản về cách loại bỏ hàng trùng lặp được trình bày ở chương này.

Package **dplyr** cung cấp hàm `distinct()`. Hàm này kiểm tra tất cả các hàng và rút gọn bộ dữ liệu cho chỉ còn các hàng là duy nhất. Nghĩa là, nó loại bỏ 100% các hàng trùng lặp.

Khi đánh giá các hàng trùng lặp, hàm này sẽ thực hiện trên các cột được chỉ định - mặc định nó sẽ xem xét tất cả các cột. Như trình bày trong chương loại bỏ trùng lặp, bạn có thể điều chỉnh phạm vi cột để việc khảo sát tính duy nhất của các hàng sẽ chỉ được đánh giá trong phạm vi một số cột nhất định.

Trong ví dụ đơn giản này, chúng ta chỉ cần thêm câu lệnh trống `distinct()` vào chuỗi các bước làm sạch. Điều này đảm bảo không có hàng nào là bản sao 100% của các hàng khác (được đánh giá trên tất cả các cột).

Chúng ta bắt đầu với `nrow(linelist)` hàng trong bộ `linelist`.

```{r}
linelist <- linelist %>% 
  distinct()
```

Sau khi loại bỏ trùng lặp, thì bộ dữ liệu mới có `nrow(linelist)` hàng. Bất kỳ hàng nào bị xóa cũng có thể là 100% bản sao của các hàng khác.

Dưới đây, lệnh `distinct()` được thêm vào quy trình làm sạch:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    #####################################################
    
    # de-duplicate
    distinct()
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tạo và biến đổi cột

**Chúng tôi khuyến khích sử dụng hàm `mutate()` trong package dplyr để thêm một cột mới hoặc để sửa đổi một cột sẵn có.**

Dưới đây là một ví dụ về tạo cột mới với hàm `mutate()`. Cú pháp là: `mutate(new_column_name = value or transformation)`

Trong Stata, điều này tương tự như lệnh `generate`, nhưng hàm `mutate()` trong R còn có thể được sử dụng để điều chỉnh cột đã tồn tại.

### Tạo cột mới {.unnumbered}

Tính năng cơ bản nhất của hàm `mutate()` là để tạo một cột mới, có thể thấy trong ví dụ dưới đây. Nó tạo một cột mới `new_col` trong đó giá trị trong mỗi hàng đều là 10.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(new_col = 10)
```

Bạn cũng có thể tham chiếu các giá trị trong các cột khác, để thực hiện phép tính toán. Dưới đây, cột mới `bmi` được tạo để tính chỉ số khối cơ thể (BMI) cho mỗi trường hợp - như được tính bằng công thức BMI = kg/m\^2, sử dụng cột `ht_cm` và cột `wt_kg`.

```{r}
linelist <- linelist %>% 
  mutate(bmi = wt_kg / (ht_cm/100)^2)
```

Nếu tạo nhiều cột mới, hãy tách riêng từng cột bằng dấu phẩy và dòng mới. Dưới đây là các ví dụ về tạo các cột mới, bao gồm một cột mà chứa các giá trị từ các cột khác được kết hợp bằng hàm `str_glue()` từ package **stringr** (xem chương [Ký tự và chuỗi]).

```{r}
new_col_demo <- linelist %>%                       
  mutate(
    new_var_dup    = case_id,             # new column = duplicate/copy another existing column
    new_var_static = 7,                   # new column = all values the same
    new_var_static = new_var_static + 5,  # you can overwrite a column, and it can be a calculation using other variables
    new_var_paste  = stringr::str_glue("{hospital} on ({date_hospitalisation})") # new column = pasting together values from other columns
    ) %>% 
  select(case_id, hospital, date_hospitalisation, contains("new"))        # show only new columns, for demonstration purposes
```

Kiểm tra các cột mới. Đối với mục tiêu minh họa, chỉ các cột mới và các cột được sử dụng để tạo cột mới được hiển thị:

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(new_col_demo,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***MẸO***: Một biến thể của hàm `mutate()` là hàm `transmute()`. Hàm này thêm một cột mới giống như `mutate()`, nhưng cũng bỏ/xóa tất cả các cột khác mà bạn không đề cập trong dấu ngoặc đơn của hàm.]{style="color: darkgreen;"}

```{r, eval=F}
# HIDDEN FROM READER
# removes new demo columns created above
# linelist <- linelist %>% 
#   select(-contains("new_var"))
```

### Chuyển đổi kiểu dữ liệu của cột {.unnumbered}

Các cột chứa giá trị là ngày tháng, số hoặc giá trị logic (TRUE/FALSE) sẽ chỉ hoạt động như mong đợi nếu chúng được phân loại chính xác. Có sự khác biệt giữa "2" của phân lớp ký tự và 2 của phân lớp số!

Có nhiều cách để thiết lập kiểu dữ liệu cho cột trong các lệnh nhập, nhưng chúng thường phức tạp. Xem chương [R cơ bản] về các lớp đối tượng để tìm hiểu thêm về cách chuyển đổi phân lớp đối tượng và cột.

Đầu tiên, hãy kiểm tra các cột quan trọng để xem chúng đã đúng định dạng chính xác chưa. Chúng ta có thể phát hiện điều này ngay từ khi chúng ta chạy lệnh `skim()`.

Hiện tại, kiểu của cột `age` là dạng ký tự. Để thực hiện các phân tích định lượng, chúng ta cần những giá trị số này được nhận biết là dạng số!

```{r}
class(linelist$age)
```

Phân lớp của cột `date_onset` cũng là ký tự! Để thực hiện phân tích, những cột ngày này phải được nhận biết là dạng ngày tháng!

```{r}
class(linelist$date_onset)
```

Để giải quyết vấn đề này, hãy sử dụng hàm `mutate()` để định dạng và chuyển đổi lại một cột. Chúng ta giữ nguyên cột đó và định dạng lại sang một phân lớp khác. Sau đây là một ví dụ cơ bản, chuyển đổi hoặc đảm bảo rằng cột `age` là phân lớp dạng số:

```{r, eval=F}
linelist <- linelist %>% 
  mutate(age = as.numeric(age))
```

Theo cách tương tự, bạn có thể sử dụng hàm `as.character()` và hàm `as.logical()`. Để chuyển đổi sang kiểu Factor, bạn có thể sử dụng hàm `factor()` từ **base** R hoặc hàm `as_factor()` từ package **forcats**. Đọc thêm ở chương [Factors].

Bạn phải cẩn thận khi chuyển đổi sang phân lớp Ngày. Một số phương pháp được giải thích rõ hơn ở chương [Làm việc với ngày tháng]. Thông thường, tất cả các giá trị ngày ban đầu phải ở cùng một định dạng cần chuyển đổi để có thể sử dụng (ví dụ: "MM/DD/YYYY" hoặc "DD MM YYYY"). Sau khi chuyển đổi thành thành phân lớp Ngày, hãy kiểm tra dữ liệu của bạn để xác nhận rằng mỗi giá trị đã được chuyển đổi chính xác.

### Dữ liệu được nhóm {.unnumbered}

Nếu bộ dữ liệu của bạn đã được *nhóm* (xem chương [Nhóm dữ liệu]), hàm `mutate()` có thể hoạt động khác so với khi bộ dữ liệu không được nhóm. Bất kỳ hàm tổng hợp nào, như `mean()`, `median()`, `max()`, v.v. sẽ tính theo nhóm, không phải theo tất cả các hàng.

```{r, eval=F}
# age normalized to mean of ALL rows
linelist %>% 
  mutate(age_norm = age / mean(age, na.rm=T))

# age normalized to mean of hospital group
linelist %>% 
  group_by(hospital) %>% 
  mutate(age_norm = age / mean(age, na.rm=T))
```

Đọc thêm về cách sử dụng hàm `mutate()` trên các bộ dữ liệu được nhóm ở [tài liệu về mutate trong package tidyverse](https://dplyr.tidyverse.org/reference/mutate.html).

### Biến đổi nhiều cột {#clean_across .unnumbered}

Thông thường, để viết mã ngắn gọn, bạn muốn áp dụng cùng một biến đổi trên nhiều cột cùng một lúc. Một cách biến đổi có thể được áp dụng trên nhiều cột cùng một lúc bằng cách sử dụng hàm `across()` từ package **dplyr** (cũng trong package **tidyverse**). Hàm `across()` có thể được sử dụng với bất kỳ hàm nào trong packe **dplyr**, nhưng thường được sử dụng với hàm `select()`, `mutate()`, `filter()`, hoặc `summarise()`. Xem cách sử dụng hàm `summarise()` trong chương [Bảng mô tả].

Chỉ định các cột bằng đối số `.cols =` và các hàm được sử dụng bằng `.fns =`. Bất kỳ đối số bổ sung nào để cung cấp cho hàm `.fns` đều có thể được bao gồm sau dấu phẩy, vẫn nằm trong hàm `across()`.

#### Lựa chọn cột với hàm `across()` {.unnumbered}

Chỉ định các cột tới đối số `.cols =`. Bạn có thể đặt tên cho chúng một cách riêng lẻ hoặc sử dụng các hàm trợ giúp "tidyselect". Cụ thể hàm tới đối số `.fns =`. Lưu ý rằng cách sử dụng hàm được trình bày bên dưới, hàm được viết mà *không có* dấu ngoặc đơn ().

Ở đây, phép biến đổi `as.character()` được áp dụng cho tên cột cụ thể trong hàm `across()`.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = c(temp, ht_cm, wt_kg), .fns = as.character))
```

Các hàm trợ giúp "tidyselect" có sẵn để hỗ trợ bạn trong việc chỉ định các cột. Chúng được trình bày chi tiết ở trên trong mục Chọn và sắp xếp thứ tự cột, bao gồm: `everything()`, `last_col()`, `where()`, `starts_with()`, `ends_with()`, `contains()`, `matches()`, `num_range()` và `any_of()`.

Đây là một ví dụ về cách thay đổi tất cả các cột thành phân lớp dạng ký tự:

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = everything(), .fns = as.character))
```

Chuyển đổi tất cả các cột thành dạng ký tự có tên chứa chuỗi ký tự "date" (lưu ý vị trí của dấu phẩy và dấu ngoặc đơn):

```{r, eval=F}
#to change all columns to character class
linelist <- linelist %>% 
  mutate(across(.cols = contains("date"), .fns = as.character))
```

Dưới đây, một ví dụ về việc thay đổi các cột hiện là phân lớp POSIXct (một kiểu dữ liệu ngày tháng thô hiển thị mốc thời gian) - hay nói cách khác, khi hàm `is.POSIXct()` đánh giá là `TRUE`. Sau đó, chúng ta muốn áp dụng hàm `as.Date()` cho các cột này để chuyển đổi chúng thành kiểu Ngày thông thường.

```{r, eval=F}
linelist <- linelist %>% 
  mutate(across(.cols = where(is.POSIXct), .fns = as.Date))
```

-   Lưu ý rằng trong hàm `across()`, chúng tôi cũng sử dụng hàm `where()` tương tự như hàm `is.POSIXct` được đánh giá là TRUE hoặc FALSE.\
-   Lưu ý rằng hàm `is.POSIXct()` là từ package **lubridate**. Các hàm "is" tương tự khác như `is.character()`, `is.numeric()`, và `is.logical()` thì thuộc **base R**

#### Hàm `across()` {.unnumbered}

Bạn có thể đọc tài liệu với hàm `?across` để biết chi tiết về cách sử dụng hàm `across()`. Một vài điểm tóm tắt: có một số cách để chỉ định (các) hàm để thực hiện trên một cột và bạn thậm chí có thể tự chỉ định các hàm riêng của mình:

-   Bạn có thể cung cấp tên hàm đứng một mình (ví dụ: `mean` hoặc `as.character`)\

-   Bạn có thể cung cấp hàm theo phong cách **purrr** (ví dụ: `~ mean(.x, na.rm = TRUE)`) (xem chương [Lặp, vòng lặp, và danh sách])\

-   Bạn có thể chỉ định nhiều hàm bằng cách cung cấp danh sách (ví dụ: `list(mean = mean, n_miss = ~ sum(is.na(.x))`).

    -   Nếu bạn cung cấp nhiều hàm, nhiều cột được chuyển đổi sẽ được trả về dựa trên mỗi cột ban đầu, với các tên duy nhất theo định dạng `col_fn`. Bạn có thể điều chỉnh cách đặt tên các cột mới với đối số `.names =` bằng cách sử dụng cú pháp **glue** (xem chương [Ký tự và chuỗi]) trong đó `{.col}` và `{.fn}` được viết tắt cho cột và hàm đầu vào.

Dưới đây là một số tài nguyên trực tuyến về cách sử dụng hàm `across()`: [creator Hadley Wickham's thoughts/rationale](https://www.tidyverse.org/blog/2020/04/dplyr-1-0-0-colwise/)

### Hàm `coalesce()` {.unnumbered}

Hàm **dplyr** này tìm giá trị không bị thiếu đầu tiên tại mỗi vị trí. Nó "điền vào" các giá trị còn thiếu với giá trị có sẵn đầu tiên theo thứ tự bạn chỉ định.

Đây là một ví dụ *ngoài phạm vi của bộ dữ liệu*: Giả sử bạn có hai vectơ, một vectơ chứa thông tin về làng nơi bệnh nhân được phát hiện và một vectơ chứa thông tin làng nơi bệnh nhân cư trú . Bạn có thể sử dụng hàm `coalesce()` để chọn giá trị không bị thiếu đầu tiên cho mỗi biến số:

```{r}
village_detection <- c("a", "b", NA,  NA)
village_residence <- c("a", "c", "a", "d")

village <- coalesce(village_detection, village_residence)
village    # print
```

Điều này hoạt động tương tự nếu bạn cung cấp các cột trong bộ dữ liệu: đối với mỗi hàng, hàm sẽ gán giá trị cột mới với giá trị không bị thiếu đầu tiên trong các cột bạn đã cung cấp (theo thứ tự được cung cấp).

```{r, eval=F}
linelist <- linelist %>% 
  mutate(village = coalesce(village_detection, village_residence))
```

Đây là một ví dụ về thao tác "theo hàng (row-wise)". Để biết các phép tính theo hàng phức tạp hơn, hãy xem chương bên dưới về Tính toán theo hàng.

### Toán lũy tích {.unnumbered}

Nếu bạn muốn một cột thể hiện tổng tích lũy/trung bình/tối thiểu/tối đa, v.v. như đánh giá các hàng của bộ dữ liệu cho đến thời điểm đó, hãy sử dụng các hàm sau:

`cumsum()` trả về tổng tích lũy, như được hiển thị bên dưới:

```{r}
sum(c(2,4,15,10))     # returns only one number
cumsum(c(2,4,15,10))  # returns the cumulative sum at each step
```

Điều này có thể được sử dụng trong bộ dữ liệu khi tạo một cột mới. Ví dụ: để tính toán số ca lũy tích mỗi ngày trong một đợt bùng dịch, hãy xem xét đoạn code như sau:

```{r, warning=F, message=F}
cumulative_case_counts <- linelist %>%  # begin with case linelist
  count(date_onset) %>%                 # count of rows per day, as column 'n'   
  mutate(cumulative_cases = cumsum(n))  # new column, of the cumulative sum at each row
```

Dưới đây là 10 hàng đầu tiên:

```{r}
head(cumulative_case_counts, 10)
```

Xem chương [Đường cong dịch bệnh] để biết cách lập biểu đồ các trường hợp mới mắc tích lũy với epicurve.

Xem thêm:\
`cumsum()`, `cummean()`, `cummin()`, `cummax()`, `cumany()`, `cumall()`

### Sử dụng **base** R {.unnumbered}

Để định nghĩa một cột mới (hoặc tái định nghĩa lại một cột) bằng cách sử dụng **base** R, hãy viết tên của bộ dữ liệu, được liên kết với `$`, vào tên cột *mới* (hoặc cột được sửa đổi). Sử dụng toán tử gán `<-` để xác định (các) giá trị mới. Hãy nhớ rằng khi sử dụng **base** R, bạn phải chỉ định tên bộ dữ liệu trước tên cột (ví dụ: `dataframe$column`). Đây là một ví dụ về cách tạo cột `bmi` bằng cách sử dụng **base** R:

```{r, eval=F}
linelist$bmi = linelist$wt_kg / (linelist$ht_cm / 100) ^ 2)
```

### Thêm vào chuỗi pipe {.unnumbered}

**Dưới đây, một cột mới được thêm vào chuỗi pipe và một số phân lớp được chuyển đổi.**

```{r }
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    # add new column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>% 
  
    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) 
```

## Mã hóa lại giá trị

Dưới đây là một số tình huống mà bạn cần mã hóa lại (thay đổi) các giá trị:

-   để chỉnh sửa một giá trị cụ thể (ví dụ: một ngày có năm hoặc định dạng không chính xác)
-   để hợp nhất các giá trị được viết sai chính tả
-   để tạo một cột chứa giá trị phân loại mới
-   để tạo một cột chứa danh mục số mới (ví dụ: danh mục độ tuổi)

### Giá trị cụ thể {.unnumbered}

Để thay đổi các giá trị theo cách thủ công, bạn có thể sử dụng hàm `recode()` bên trong hàm `mutate()`.

Hãy tưởng tượng có một ngày không bình thường trong dữ liệu (ví dụ: "2014-14-15"): bạn có thể sửa ngày theo cách thủ công trong dữ liệu thô hoặc, bạn có thể ghi thay đổi trong chuỗi các bước làm sạch thông qua `mutate()` và `recode()`. Cách thứ hai sẽ rõ ràng hơn và có thể được tái lập lại cho bất kỳ ai khác muốn hiểu hoặc lặp lại phân tích của bạn.

```{r, eval=F}
# fix incorrect values                   # old value       # new value
linelist <- linelist %>% 
  mutate(date_onset = recode(date_onset, "2014-14-15" = "2014-04-15"))
```

Dòng `mutate()` ở trên có thể được đọc là: "biến đổi cột `date_onset` bằng với cột `date_onset` sau khi được mã hóa lại để GIÁ TRỊ CŨ được đổi thành GIÁ TRỊ MỚI". Lưu ý rằng cú pháp (CŨ = MỚI) này của hàm `recode()` ngược lại với hầu hết các cú pháp trong R (mới = cũ). Cộng đồng phát triển R đang làm việc để sửa đổi điều này.

**Sau đây là một ví dụ khác về việc mã hóa lại nhiều giá trị trong một cột.**

Trong bộ dữ liệu `linelist`, các giá trị trong cột "hospital" phải được làm sạch. Có một số cách viết khác nhau và nhiều giá trị bị thiếu.

```{r}
table(linelist$hospital, useNA = "always")  # print table of all unique values, including missing  
```

Lệnh `recode()` bên dưới tái định nghĩa lại cột "hospital" theo cột hiện tại "hospital", nhưng với các thay đổi mã hóa được chỉ định. Đừng quên dấu phẩy sau mỗi dòng mã hóa lại!

```{r}
linelist <- linelist %>% 
  mutate(hospital = recode(hospital,
                     # for reference: OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      ))
```

Bây giờ chúng ta thấy các cách viết trong cột `hospital` đã được sửa chữa và hợp nhất:

```{r}
table(linelist$hospital, useNA = "always")
```

[***MẸO***: Số lượng khoảng trắng trước và sau dấu bằng không quan trọng. Hãy làm cho code của bạn dễ đọc hơn bằng cách căn chỉnh dấu = cho tất cả hoặc hầu hết các hàng. Ngoài ra, hãy cân nhắc thêm hàng bình luận để làm rõ cho người đọc biết bên nào CŨ và bên nào MỚI.]{style="color: darkgreen;"}

[***MẸO***: Đôi khi tồn tại một giá trị ký tự *trống* trong bộ dữ liệu (không được nhận dạng là giá trị missing của R - `NA`). Bạn có thể tham chiếu giá trị này bằng hai dấu ngoặc kép không có khoảng trắng ở giữa ("").]{style="color: darkgreen;"}

### Theo logic {.unnumbered}

Dưới đây, chúng ta trình bày cách mã hóa lại các giá trị trong một cột bằng cách sử dụng logic và điều kiện:

-   Sử dụng hàm `replace()`, `ifelse()` và `if_else()` cho logic đơn giản
-   Sử dụng hàm `case_when()` cho logic phức tạp

### Logic đơn giản {.unnumbered}

#### `replace()` {.unnumbered}

Để mã hóa lại với các tiêu chí logic đơn giản, bạn có thể sử dụng hàm `replace()` bên trong hàm `mutate()`. `replace()` là một hàm từ **base** R. Sử dụng một điều kiện logic để cụ thể các hàng cần thay đổi. Cú pháp chung là:

`mutate(col_to_change = replace(col_to_change, criteria for rows, new value))`.

Một tình huống phổ biến để sử dụng `replace()` là **chỉ thay đổi một giá trị trong một hàng, bằng cách sử dụng định danh hàng duy nhất**. Dưới đây, giới tính được thay đổi thành "Female" trong hàng mà cột `case_id` có giá trị là "2195".

```{r, eval=F}
# Example: change gender of one specific observation to "Female" 
linelist <- linelist %>% 
  mutate(gender = replace(gender, case_id == "2195", "Female"))
```

Lệnh tương tự sử dụng cú pháp trong **base** R và dấu ngoặc vuông [] ở bên dưới. Nó có nội dung là "Thay đổi giá trị của cột `gender` trong bộ dữ liệu `linelist` (đối với các hàng mà cột `case_id` của `linelist` có giá trị '2195') thành 'Female' ".

```{r, eval=F}
linelist$gender[linelist$case_id == "2195"] <- "Female"
```

#### `ifelse()` và `if_else()` {.unnumbered}

Một cách khác áp dụng cho logic đơn giản là hàm `ifelse()` và hàm tương tự là `if_else()`. Tuy nhiên, trong hầu hết các trường hợp để mã hóa lại, cách rõ ràng hơn là sử dụng hàm `case_when()` (chi tiết bên dưới). Câu lệnh "if else" này là các phiên bản đơn giản hóa của câu lệnh lập trình `if` và `else`. Cú pháp chung là:\
`ifelse(condition, value to return if condition evaluates to TRUE, value to return if condition evaluates to FALSE)`

Dưới đây, cột `source_known` được định nghĩa. Giá trị của nó trong một hàng được đặt thành "known" nếu giá trị của hàng trong cột `source` không bị thiếu. Nếu thiếu giá trị trong cột `source`, thì giá trị trong `source_known` được đặt thành "unknown".

```{r, eval=F}
linelist <- linelist %>% 
  mutate(source_known = ifelse(!is.na(source), "known", "unknown"))
```

`if_else()` là một phiên bản đặc biệt từ package **dplyr** để xử lý ngày tháng. Lưu ý rằng nếu giá trị 'true' là một ngày thì giá trị 'false' cũng phải đủ điều kiện là một ngày, do đó sử dụng giá trị đặc biệt `NA_real_` thay vì chỉ `NA`.

```{r, eval=F}
# Create a date of death column, which is NA if patient has not died.
linelist <- linelist %>% 
  mutate(date_death = if_else(outcome == "Death", date_outcome, NA_real_))
```

**Tránh lồng ghép nhiều lệnh ifelse với nhau... thay vào đó hãy sử dụng `case_when()`!** `case_when()` dễ đọc hơn và bạn sẽ mắc ít lỗi hơn.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "ifelse bad.png"))
```

Ngoài phạm vi của bộ dữ liệu, nếu bạn muốn một đối tượng được sử dụng trong code của mình chuyển đổi giá trị của nó, hãy xem xét sử dụng hàm `switch()` từ **base** R.

### Logic phức tạp {#clean_case_when .unnumbered}

Sử dụng `case_when()` của package **dplyr** nếu bạn đang mã hóa lại thành nhiều nhóm mới hoặc nếu bạn cần sử dụng các câu lệnh logic phức tạp để mã hóa lại các giá trị. Hàm này đánh giá mọi hàng trong bộ dữ liệu, đánh giá xem các hàng có đáp ứng các tiêu chí đã chỉ định hay không và chỉ định giá trị mới chính xác.

Câu lệnh `case_when()` bao gồm hai cấu phần là Bên tay Phải (RHS) và Bên tay Trái (LHS) được phân tách bằng "dấu ngã" `~`. Các tiêu chí logic nằm ở phía bên trái và các giá trị tương ứng nằm ở phía bên phải của mỗi mệnh đề. Các mệnh đề được phân tách bằng dấu phẩy.

Ví dụ: chúng tôi sử dụng cột `age` và `age_unit` để tạo cột `age_years`:

```{r}
linelist <- linelist %>% 
  mutate(age_years = case_when(
            age_unit == "years"  ~ age,       # if age is given in years
            age_unit == "months" ~ age/12,    # if age is given in months
            is.na(age_unit)      ~ age,       # if age unit is missing, assume years
            TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

Khi mỗi hàng trong dữ liệu được đánh giá, các tiêu chí được áp dụng/đánh giá theo thứ tự đã viết trong `case_when()` - từ trên xuống dưới. Nếu tiêu chí hàng đầu đánh giá là `TRUE` cho một hàng nhất định, giá trị Bên tay phải sẽ được chỉ định và các tiêu chí còn lại thậm chí không được kiểm tra cho hàng đó. Vì vậy, tốt nhất là bạn nên viết các tiêu chí cụ thể nhất trước và cuối cùng là tiêu chí chung chung.

Dọc theo những dòng đó, trong mệnh đề cuối cùng của bạn, hãy đặt `TRUE` ở phía bên trái để ghi lại bất kỳ hàng nào không đáp ứng bất kỳ tiêu chí nào trước đó. Phía bên phải của câu lệnh này có thể được gán một giá trị như "kiểm tra tôi! (check me)" hoặc missing.

[***NGUY HIỂM***: Các giá trị ở phía bên phải đều phải cùng một phần lớp - số, ký tự, ngày tháng, lôgic, v.v. Để gán giá trị thiếu (NA), bạn có thể cần sử dụng các biến thể đặc biệt của `NA` như `NA_character_`, `NA_real_` (cho số hoặc POSIX) và `as.Date(NA)`. Đọc thêm trong chương [Làm việc với ngày tháng].]{style="color: red;"}

### Giá trị missing {.unnumbered}

Dưới đây là các hàm đặc biệt để xử lý các giá trị bị thiếu trong khi làm sạch dữ liệu.

Xem chương về [Dữ liệu Missing] để biết thêm các mẹo chi tiết về xác định và xử lý các giá trị bị thiếu. Ví dụ, hàm `is.na()` kiểm tra một cách logic sự thiếu giá trị.

**`replace_na()`**

Để thay đổi các giá trị bị thiếu (`NA`) thành một giá trị cụ thể, chẳng hạn như "Missing", hãy sử dụng hàm `replace_na()` trong hàm `mutate()` trong package **dplyr**. Lưu ý rằng điều này được sử dụng theo cách tương tự như hàm `recode` ở trên - tên của biến phải được lặp lại trong `replace_na()`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = replace_na(hospital, "Missing"))
```

**fct_explicit_na()**

Đây là một hàm từ package **forcats**. Package **forcats** xử lý các cột dạng Factor. Factor là cách của R để xử lý các giá trị có thứ tự như `c("First", "Second", "Third")` hoặc để thiết lập thứ tự cho các giá trị (ví dụ: bệnh viện) xuất hiện trong bảng và biểu đồ. Xem chương [Factors].

Nếu dữ liệu của bạn là kiểu Factor và bạn đang cố gắng chuyển giá trị `NA` thành "Missing" bằng cách sử dụng hàm `replace_na()`, bạn sẽ gặp lỗi này: `invalid factor level, NA generated`. Bạn đã cố gắng thêm "Missing" làm giá trị, trong khi nó đã không được xác định là một thứ bậc trong cột Factor, và câu lệnh bị từ chối.

Cách dễ nhất để giải quyết vấn đề này là sử dụng hàm **forcats** `fct_explicit_na()` để chuyển đổi một cột thành kiểu Factor và chuyển đổi các giá trị `NA` thành ký tự "(Missing)".

```{r, eval=F}
linelist %>% 
  mutate(hospital = fct_explicit_na(hospital))
```

Một giải pháp thay thế chậm hơn sẽ là thêm thứ bậc cho cột Factor bằng cách sử dụng hàm `fct_expand()` và sau đó chuyển đổi các giá trị bị thiếu.

**`na_if()`**

Để chuyển đổi một *giá trị cụ thể* thành `NA`, hãy sử dụng hàm `na_if()` trong package **dplyr**. Hàm này thực hiện thao tác ngược lại với hàm `replace_na()`. Trong ví dụ bên dưới, bất kỳ giá trị nào bị "Missing" trong cột `hospital` đều được chuyển đổi thành `NA`.

```{r}
linelist <- linelist %>% 
  mutate(hospital = na_if(hospital, "Missing"))
```

Lưu ý: `na_if()` **không thể sử dụng cho điều kiện logic** (ví dụ: "all values \> 99") - hãy sử dụng `replace()` hoặc `case_when()` cho điều này:

```{r, eval=F}
# Convert temperatures above 40 to NA 
linelist <- linelist %>% 
  mutate(temp = replace(temp, temp > 40, NA))

# Convert onset dates earlier than 1 Jan 2000 to missing
linelist <- linelist %>% 
  mutate(date_onset = replace(date_onset, date_onset > as.Date("2000-01-01"), NA))
```

### Từ điển làm sạch {.unnumbered}

Sử dụng package **linelist** trong R và hàm `clean_variable_spelling()` để làm sạch bộ dữ liệu bằng *từ điển làm sạch*. **linelist** là một package được phát triển bởi [RECON](https://github.com/reconhub/linelist) - R Epidemics Consortium.

1)  Tạo từ điển làm sạch với 3 cột:

    -   Cột "từ" (giá trị không chính xác)\
    -   Cột "tới" (giá trị chính xác)\
    -   Một cột chỉ định cột cho các thay đổi sẽ được áp dụng (hoặc ".global" để áp dụng cho tất cả các cột)

Lưu ý: các mục từ điển .global sẽ bị ghi đè bởi các mục từ điển theo cột cụ thể.

```{r, fig.align = "center", out.width = "100%", echo=F}
knitr::include_graphics(here::here("images", "cleaning_dict.png"))
```

2)  Nạp tệp từ điển vào R. Ví dụ này có thể được tải xuống theo hướng dẫn trong chương [Tải sách và dữ liệu].

```{r, echo=F}
cleaning_dict <- rio::import(here("data", "case_linelists", "cleaning_dict.csv"))
```

```{r, eval=F}
cleaning_dict <- import("cleaning_dict.csv")
```

3)  Chuyển bộ dữ liệu linelist ban đầu đến hàm `clean_variable_spelling()`, xác định `wordlists =` là bộ dữ liệu từ điển làm sạch. Đối số `spelling_vars =` có thể được sử dụng để chỉ định cột nào trong từ điển tham chiếu đến các cột khác (cột thứ 3 theo mặc định) hoặc có thể được đặt thành `NULL` để từ điển áp dụng cho tất cả các cột dạng ký tự và phân loại. Lưu ý rằng hàm này có thể mất nhiều thời gian để chạy.

```{r}
linelist <- linelist %>% 
  linelist::clean_variable_spelling(
    wordlists = cleaning_dict,
    spelling_vars = "col",        # dict column containing column names, defaults to 3rd column in dict
  )
```

Bây giờ, hãy cuộn sang bên phải để xem các giá trị đã thay đổi như thế nào - đặc biệt là `gender` (chữ thường thành chữ hoa) và tất cả các cột triệu chứng đã được chuyển từ có/không thành 1/0.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Lưu ý rằng tên cột của bạn trong từ điển làm sạch phải tương ứng với tên *tại thời điểm* trong script làm sạch của bạn. Xem [tài liệu tham khảo trực tuyến về package linelist](https://www.repidemicsconsortium.org/linelist/reference/clean_data.html) để biết thêm chi tiết.

#### Thêm vào chuỗi làm sạch {.unnumbered}

**Dưới đây, một số cột mới và biến đổi cột được thêm vào chuỗi các bước làm sạch.**

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 
  
    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
   # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
   ###################################################

    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Biến danh mục số {#num_cats}

Ở đây chúng tôi mô tả một số cách tiếp cận đặc biệt để tạo cột dạng danh mục từ các cột dạng số. Các ví dụ phổ biến bao gồm danh mục độ tuổi, nhóm giá trị trong phòng thí nghiệm, v.v. Ở đây chúng ta sẽ thảo luận:

-   `age_categories()`, từ package **epikit**\
-   `cut()`, từ **base** R\
-   `case_when()`\
-   Chia khoảng phân vị với `quantile()` and `ntile()`

### Đánh giá phân phối {.unnumbered}

Trong ví dụ này, chúng tôi sẽ tạo một cột `age_cat` bằng cách sử dụng cột `age_years`.

```{r}
#check the class of the linelist variable age
class(linelist$age_years)
```

Trước tiên, hãy kiểm tra phân phối dữ liệu của bạn để đưa ra các điểm cắt thích hợp. Xem chương [ggplot cơ bản].

```{r, out.height='50%'}
# examine the distribution
hist(linelist$age_years)
```

```{r}
summary(linelist$age_years, na.rm=T)
```

[***CẨN TRỌNG***: Đôi khi, các biến số sẽ được nhập vào dưới dạng kiểu "ký tự". Điều này xảy ra nếu có các ký tự không phải số trong một số giá trị, ví dụ: có bản ghi nhập "2 tháng" cho biến tuổi hoặc (tùy thuộc vào cài đặt ngôn ngữ R của bạn) nếu dấu phẩy được sử dụng cho số thập phân (ví dụ: "4,5 "nghĩa là bốn năm rưỡi).]{style="color: orange;"}

<!-- ======================================================= -->

### `age_categories()` {.unnumbered}

Với package **epikit**, bạn có thể sử dụng hàm `age_categories()` để dễ dàng phân loại và gắn nhãn các cột dạng số (lưu ý: hàm này cũng có thể được áp dụng cho các biến ngoài biến tuổi). Như một "phần thưởng", cột trả về tự động là một cột dạng factor có thứ tự.

Dưới đây là các yêu cầu đầu vào:

-   Một vectơ (cột) dạng số\
-   Đối sốc `breakers =` - cung cấp một vectơ dạng số của các điểm cắt cho các phân nhóm mới.

Đầu tiên, ví dụ đơn giản nhất:

```{r}
# Simple example
################
pacman::p_load(epikit)                    # load package

linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(             # create new column
      age_years,                            # numeric column to make groups from
      breakers = c(0, 5, 10, 15, 20,        # break points
                   30, 40, 50, 60, 70)))

# show table
table(linelist$age_cat, useNA = "always")
```

Các giá trị cắt bạn chỉ định mặc định là các giới hạn thấp hơn - nghĩa là chúng được đưa vào nhóm "cao hơn"/các nhóm "mở" ở phía dưới/bên trái. Như trình bày dưới đây, bạn có thể thêm 1 vào mỗi giá trị cắt để đạt được các nhóm mà được "mở" ở trên cùng/bên phải.

```{r}
# Include upper ends for the same categories
############################################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 6, 11, 16, 21, 31, 41, 51, 61, 71)))

# show table
table(linelist$age_cat, useNA = "always")
```

Bạn có thể điều chỉnh cách hiển thị nhãn bằng `separator =`. Giá trị mặc định là "-"

Bạn có thể điều chỉnh cách xử lý các số ở hàng đầu, với đối số `ceiling =`. Thiết lập mức giới hạn cắt trên với `ceiling = TRUE`. Trong cách sử dụng này, giá trị cắt cao nhất được cung cấp là "ceiling" và danh mục "XX+" không được tạo. Bất kỳ giá trị nào trên giá trị cắt cao nhất (hoặc `upper =`, nếu được xác định) đều được phân loại là `NA`. Dưới đây là một ví dụ với `ceiling = TRUE`, do đó không có danh mục nào là XX + và các giá trị trên 70 (giá trị cắt cao nhất) được chỉ định là NA.

```{r}
# With ceiling set to TRUE
##########################
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      breakers = c(0, 5, 10, 15, 20, 30, 40, 50, 60, 70),
      ceiling = TRUE)) # 70 is ceiling, all above become NA

# show table
table(linelist$age_cat, useNA = "always")
```

Ngoài ra, thay vì dùng `breakers =`, bạn có thể sử dụng hàm `lower =`, `upper =`, và `by =`:

-   `lower =` Mức giới hạn thấp nhất bạn muốn xem xét - mặc định là 0\
-   `upper =` Mức giới hạn cao nhất bạn muốn xem xét\
-   `by =` Khoảng cách "năm" giữa các nhóm

```{r}
linelist <- linelist %>% 
  mutate(
    age_cat = age_categories(
      age_years, 
      lower = 0,
      upper = 100,
      by = 10))

# show table
table(linelist$age_cat, useNA = "always")
```

Xem thêm trang trợ giúp của hàm để biết thêm chi tiết (nhập `?age_categories` trong R console).

<!-- ======================================================= -->

### `cut()` {.unnumbered}

Hàm `cut()` trong **base R** là một thay thế cho hàm `age_categories()`, nhưng tôi nghĩ bạn sẽ thấy lý do tại sao hàm `age_categories()` được phát triển để đơn giản hóa quá trình này. Một số khác biệt đáng chú ý với hàm `age_categories()` là:

-   Bạn không cần cài đặt/gọi package khác\
-   Bạn có thể chỉ định xem các nhóm được mở/đóng ở bên phải/bên trái\
-   Bạn cần phải cung cấp nhãn chính xác\
-   Nếu bạn muốn 0 được thêm vào trong nhóm thấp nhất, bạn cần phải cụ thể điều này

Cú pháp cơ bản trong `cut()` trước tiên là cung cấp cột dạng số cần xử lý (`age_years`), sau đó là đối số *break*, một vectơ dạng số `c()` bao gồm các điểm cắt. Sử dụng `cut()`, kết quả trả về là cột kiểu factor có thứ tự.

Mặc định, việc phân loại xảy ra sao cho phía bên phải/phía trên là "mở" và có tính dung nạp (và phía bên trái/phía dưới là "đóng" hoặc tách biệt). Cách vận hành của hàm này ngược lại với hàm `age_categories()`. Các nhãn mặc định sử dụng ký hiệu "(A,B]", có nghĩa là A không được bao gồm nhưng B thì có. **Đảo ngược hành động này bằng cách cung cấp** **đối số `right = TRUE`**.

Do đó, theo mặc định, các giá trị "0" bị loại trừ khỏi nhóm thấp nhất và được phân loại là `NA`! Giá trị "0" có thể là trẻ sơ sinh được mã hóa là 0 tuổi, vì vậy hãy thật thận trọng! Để thay đổi điều này, hãy thêm argument `include.lowest = TRUE` để mọi giá trị "0" sẽ được đưa vào nhóm thấp nhất. Nhãn được tạo tự động cho danh mục thấp nhất sau đó sẽ là "[A],B]". Lưu ý rằng nếu bạn thêm `include.lowest = TRUE` **và** `right = TRUE`, hành động này bây giờ sẽ áp dụng cho điểm cắt giá trị *cao nhất* và phân loại, không phải điểm thấp nhất.

Bạn có thể cung cấp một vectơ nhãn tùy chỉnh bằng cách sử dụng argument `labels =`. Vì chúng được viết theo cách thủ công, hãy rất cẩn thận để đảm bảo chúng chính xác! Kiểm tra bằng cách lập bảng chéo, như được mô tả bên dưới.

Dưới đây là một ví dụ về hàm `cut()` được áp dụng cho biến `age_years` để tạo biến `age_cat` mới:

```{r}
# Create new variable, by cutting the numeric age variable
# lower break is excluded but upper break is included in each category
linelist <- linelist %>% 
  mutate(
    age_cat = cut(
      age_years,
      breaks = c(0, 5, 10, 15, 20,
                 30, 50, 70, 100),
      include.lowest = TRUE         # include 0 in lowest group
      ))

# tabulate the number of observations per group
table(linelist$age_cat, useNA = "always")
```

**Kiểm tra đoạn code của bạn!!!** Hãy chắc chắn rằng mỗi giá trị độ tuổi đã được chỉ định đúng danh mục bằng cách lập bảng chéo giữa các cột số và danh mục. Kiểm tra việc gán các giá trị ranh giới (ví dụ: 15, nếu các danh mục lân cận là 10-15 và 16-20).

```{r}
# Cross tabulation of the numeric and category columns. 
table("Numeric Values" = linelist$age_years,   # names specified in table for clarity.
      "Categories"     = linelist$age_cat,
      useNA = "always")                        # don't forget to examine NA values
```

**Gán nhãn giá trị `NA`**

Bạn có thể muốn gán nhãn cho các giá trị `NA` chẳng hạn như "Missing". Bởi vì cột mới có kiểu Factor (số giá trị bị hạn chế), bạn không thể chỉ đơn giản thay đổi nó bằng `replace_na()`, vì giá trị này sẽ không được chấp nhận. Thay vào đó, hãy sử dụng hàm `fct_explicit_na()` từ package **forcats** như được giải thích trong chương [Factors].

```{r}
linelist <- linelist %>% 
  
  # cut() creates age_cat, automatically of class Factor      
  mutate(age_cat = cut(
    age_years,
    breaks = c(0, 5, 10, 15, 20, 30, 50, 70, 100),          
    right = FALSE,
    include.lowest = TRUE,        
    labels = c("0-4", "5-9", "10-14", "15-19", "20-29", "30-49", "50-69", "70-100")),
         
    # make missing values explicit
    age_cat = fct_explicit_na(
      age_cat,
      na_level = "Missing age")  # you can specify the label
  )    

# table to view counts
table(linelist$age_cat, useNA = "always")
```

**Tạo nhanh điểm cắt và dán nhãn**

Để nhanh chóng tạo điểm cắt và gắn nhãn vectơ, hãy thực hành như bên dưới. Xem chương [R cơ bản] về hàm `seq()` và `rep()`.

```{r, eval=F}
# Make break points from 0 to 90 by 5
age_seq = seq(from = 0, to = 90, by = 5)
age_seq

# Make labels for the above categories, assuming default cut() settings
age_labels = paste0(age_seq + 1, "-", age_seq + 5)
age_labels

# check that both vectors are the same length
length(age_seq) == length(age_labels)
```

Đọc thêm về hàm `cut()` trong trang Trợ giúp của hàm bằng cách nhập `?cut` trong R console.

### Chia khoảng phân vị {.unnumbered}

Theo cách hiểu thông thường, "phân vị" hoặc "phần trăm" thường đề cập đến một giá trị dưới ngưỡng tỷ lệ đang được đề cập. Ví dụ: phân vị thứ thứ 95 của biến độ tuổi trong `linelist` sẽ là các độ tuổi dưới 95% độ tuổi.

Tuy nhiên, trong cách nói thông thường, "tứ phân vị" và "thập phân vị" cũng có thể đề cập đến *phân nhóm dữ liệu* được chia đều thành 4 hoặc 10 nhóm (lưu ý sẽ có thêm một điểm cắt so với số nhóm).

Để nhận biết điểm cắt của khoảng phân vị, bạn có thể sử dụng hàm `quantile()` từ package **stats** trong **base** R. Bạn cung cấp một vectơ số (ví dụ: một cột trong bộ dữ liệu) và vectơ các giá trị xác suất số từ 0 đến 1. Các điểm cắt được trả về dưới dạng một vectơ số. Đọc thêm chi tiết các phương pháp thống kê bằng cách nhập `?quantile`.

-   Nếu vectơ số đầu vào của bạn có bất kỳ giá trị nào bị thiếu, tốt nhất nên thiết lập `na.rm = TRUE`\
-   Thiết lập`names = FALSE` để lấy một vectơ số chưa được đặt tên

```{r}
quantile(linelist$age_years,               # specify numeric vector to work on
  probs = c(0, .25, .50, .75, .90, .95),   # specify the percentiles you want
  na.rm = TRUE)                            # ignore missing values 
```

Bạn có thể sử dụng kết quả của `quantile()` làm điểm cắt trong `age_categories()` hoặc `cut()`. Dưới đây, chúng ta tạo một cột `deciles` mới bằng cách sử dụng hàm `cut()` trong đó các dấu ngắt được xác định bằng cách sử dụng hàm `quantiles()` trên cột `age_years`. Sau đó, chúng ta hiển thị kết quả bằng hàm `tabyl()` từ package **janitor** để bạn có thể xem tỷ lệ phần trăm (xem chương [Bảng mô tả]). Lưu ý rằng chúng không chính xác là 10% trong mỗi nhóm.

```{r}
linelist %>%                                # begin with linelist
  mutate(deciles = cut(age_years,           # create new column decile as cut() on column age_years
    breaks = quantile(                      # define cut breaks using quantile()
      age_years,                               # operate on age_years
      probs = seq(0, 1, by = 0.1),             # 0.0 to 1.0 by 0.1
      na.rm = TRUE),                           # ignore missing values
    include.lowest = TRUE)) %>%             # for cut() include age 0
  janitor::tabyl(deciles)                   # pipe to table to display
```

### Nhóm có khoảng đều {.unnumbered}

Một công cụ khác để tạo nhóm dạng số là hàm `ntile()` trong package **dplyr**, cố gắng chia dữ liệu của bạn thành n *nhóm có khoảng cách đều - nhưng lưu ý rằng không giống như với `quantile()`, cùng một giá trị có thể xuất hiện trong nhiều nhóm*. Cung cấp vectơ số và sau đó là số lượng nhóm. Các giá trị trong cột mới được tạo chỉ là nhóm "số" (ví dụ: 1 đến 10), không phải phạm vi giá trị như khi sử dụng hàm `cut()`.

```{r}
# make groups with ntile()
ntile_data <- linelist %>% 
  mutate(even_groups = ntile(age_years, 10))

# make table of counts and proportions by group
ntile_table <- ntile_data %>% 
  janitor::tabyl(even_groups)
  
# attach min/max values to demonstrate ranges
ntile_ranges <- ntile_data %>% 
  group_by(even_groups) %>% 
  summarise(
    min = min(age_years, na.rm=T),
    max = max(age_years, na.rm=T)
  )

# combine and print - note that values are present in multiple groups
left_join(ntile_table, ntile_ranges, by = "even_groups")
```

<!-- ======================================================= -->

### `case_when()` {.unnumbered}

Có thể sử dụng hàm `case_when()` từ **dplyr** để tạo biến danh mục từ cột số, tuy nhiên điều này được thực hiện dễ dàng hơn với hàm `age_categories()` từ **epikit** hoặc `cut()` vì chúng sẽ tự động tạo ra một biến factor có thứ tự.

Nếu sử dụng `case_when()`, vui lòng xem lại cách sử dụng thích hợp như đã mô tả trước đó trong mục Mã hóa lại giá trị. Cũng lưu ý rằng tất cả các giá trị bên tay phải phải thuộc cùng một kiểu. Do đó, nếu bạn muốn giá trị `NA` ở phía bên phải, bạn nên viết "Missing" hoặc sử dụng giá trị `NA` đặc biệt là `NA_character_`.

### Thêm vào chuỗi làm sạch {.unnumbered}

Dưới đây, code để tạo hai cột phân loại tuổi được thêm vào chuỗi các bước làm sạch:

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################   
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5)))
```

<!-- ======================================================= -->

## Thêm hàng

### Thêm từng hàng một {.unnumbered}

Việc thêm từng hàng một theo cách thủ công là rất nhàm chán nhưng có thể được thực hiện với hàm `add_row()` từ package **dplyr**. Hãy nhớ rằng mỗi cột chỉ được chứa các giá trị của một phân lớp (ký tự, số, lôgic, v.v.). Vì vậy, khi thêm một hàng cần chú ý tới điều này.

```{r, eval=F}
linelist <- linelist %>% 
  add_row(row_num = 666,
          case_id = "abc",
          generation = 4,
          `infection date` = as.Date("2020-10-10"),
          .before = 2)
```

Sử dụng `.before` và `.after.` để cụ thể vị trí của hàng bạn muốn thêm. `.before = 3` sẽ cho phép hàng mới được thêm trước hàng thứ 3 hiện tại. Mặc định thì hàng sẽ được thêm vào dòng cuối cùng. Các cột không được chỉ định sẽ được để trống (`NA`).

*Số thứ tự hàng* mới có thể trông lạ ("... 23") nhưng số thứ tự hàng trong các hàng tồn tại trước đó *đã* thay đổi. Vì vậy, nếu sử dụng lệnh hai lần, hãy kiểm tra/thử việc chèn một cách cẩn thận.

Nếu một phân lớp bạn cung cấp không hoạt động, bạn sẽ thấy báo lỗi như sau:

    Error: Can't combine ..1$infection date <date> and ..2$infection date <character>.

(khi chèn một hàng có giá trị ngày tháng, hãy nhớ đặt thông tin `as.Date()` ví dụ như `as.Date("2020-10-10")`).

### Nối các hàng {.unnumbered}

Để kết hợp các bộ dữ liệu với nhau bằng cách liên kết các hàng của một bộ dữ liệu này với phần cuối bộ dữ liệu khác, bạn có thể sử dụng hàm `bind_rows()` từ **dplyr**. Điều này được giải thích chi tiết hơn trong chương [Nối dữ liệu].

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Lọc hàng

Bước làm sạch điển hình sau khi bạn đã làm sạch các cột và các giá trị được mã hóa lại đó là *lọc* bộ dữ liệu cho các hàng cụ thể bằng cách sử dụng hàm `filter()` trong package **dplyr**.

Trong hàm `filter()`, hãy cụ thể điều kiện logic phải là giá trị `TRUE` cho một hàng được giữ trong bộ dữ liệu. Dưới đây chúng tôi trình bày cách lọc hàng dựa trên điều kiện logic đơn giản và phức tạp.

<!-- ======================================================= -->

### Lọc đơn giản {.unnumbered}

Ví dụ đơn giản này định nghĩa lại bộ dữ liệu `linelist`, đã lọc các hàng để đáp ứng điều kiện logic. **Chỉ những hàng mà câu lệnh logic trong dấu ngoặc đơn đánh giá là `TRUE` mới được giữ lại**.

Trong ví dụ này, câu lệnh logic là `gender == "f"`, được hỏi liệu giá trị trong cột `gender` có bằng "f" (phân biệt chữ hoa chữ thường) hay không.

Trước khi bộ lọc được áp dụng, số hàng trong `linelist` là `nrow(linelist)`.

```{r, eval=F}
linelist <- linelist %>% 
  filter(gender == "f")   # keep only rows where gender is equal to "f"
```

Sau khi bộ lọc được áp dụng, số hàng trong `linelist` là `linelist %>% filter(gender == "f") %>% nrow()`.

### Lọc bỏ các giá trị missing {.unnumbered}

Một điều khá phổ biến là bạn muốn lọc bỏ các hàng có giá trị missing. Hãy bỏ qua cách lọc cổ điển `filter(!is.na(column) & !is.na(column))` và thay vào đó, hãy sử dụng hàm `drop_na()` trong package **tidyr** được xây dựng để tùy chỉnh cho mục đích này. Nếu chạy với dấu ngoặc trống, nó sẽ loại bỏ các hàng có bất kỳ giá trị nào bị missing. Ngoài ra, bạn có thể cung cấp tên của các cột cụ thể sẽ được đánh giá về mức độ missing hoặc sử dụng các hàm trợ giúp "tidyselect" như được mô tả [ở trên](#clean_tidyselect).

```{r, eval=F}
linelist %>% 
  drop_na(case_id, age_years)  # drop rows with missing values for case_id or age_years
```

Xem chương về [Dữ liệu Missing] để biết nhiều kỹ thuật phân tích và quản lý dữ liệu missing.

### Lọc bằng số thứ tự của hàng {.unnumbered}

Trong một data frame hoặc tibble, mỗi hàng thường sẽ có một "số thứ tự" (khi xem trong R Viewer) xuất hiện ở bên trái của cột đầu tiên. Bản thân nó không phải là một cột trong dữ liệu, nhưng nó có thể được sử dụng trong câu lệnh `filter()`.

Để lọc dựa trên "số thứ tự của hàng", bạn có thể sử dụng hàm **dplyr** `row_number()` với "dấu ngoặc đơn mở" như một phần của câu lệnh lọc logic. Thường thì bạn sẽ sử dụng toán tử `%in%` và một dãy số như một phần của câu lệnh logic đó, như được trình bày bên dưới. Để xem N hàng *đầu tiên*, bạn cũng có thể sử dụng hàm đặc biệt `head()` trong package **dplyr**.

```{r, eval=F}
# View first 100 rows
linelist %>% head(100)     # or use tail() to see the n last rows

# Show row 5 only
linelist %>% filter(row_number() == 5)

# View rows 2 through 20, and three specific columns
linelist %>% filter(row_number() %in% 2:20) %>% select(date_onset, outcome, age)
```

Bạn cũng có thể chuyển đổi số thứ tự hàng thành cột bằng cách sử dụng hàm **tibble** `rownames_to_column()` (không viết bất kỳ ký tự nào trong dấu ngoặc đơn).

<!-- ======================================================= -->

### Lọc phức tạp {.unnumbered}

Các câu lệnh logic phức tạp hơn có thể được xây dựng bằng cách sử dụng các toán tử ngoặc đơn `( )`, HOẶC `|`, PHỦ ĐỊNH `!`, `%in%`, và VÀ `&`. Dưới đây là một ví dụ:

Lưu ý: Bạn có thể sử dụng `!` trước một mệnh đề logic để phủ định nó. Ví dụ, `!is.na(column)` trả về giá trị TRUE nếu cột đó không bị thiếu giá trị. Tương tự như vậy `!column %in% c("a", "b", "c")` trả về kết quả là TRUE nếu giá trị cột *không* có trong vectơ.

#### Kiểm tra dữ liệu {.unnumbered}

Dưới đây là một dòng lệnh đơn giản để tạo biểu đồ các ngày bắt đầu. Chúng ta thấy rằng có một đợt bùng phát nhỏ thứ hai từ năm 2012-2013 cũng được bao gồm trong tập bộ liệu thô này. **Trong các phân tích, chúng ta muốn xóa các bản ghi từ đợt bùng phát sớm.**

```{r, out.width = "50%"}
hist(linelist$date_onset, breaks = 50)
```

#### Cách lọc và xử lý các giá trị số và ngày bị missing {.unnumbered}

Chúng ta có thể chỉ lọc theo `date_onset` đến những hàng sau tháng 6 năm 2013 không? **Lưu ý! Việc áp dụng code `filter(date_onset > as.Date("2013-06-01")))` sẽ xóa bất kỳ hàng nào trong đợt dịch sau đó có ngày bắt đầu bị thiếu!**

[***NGUY HIỂM***: Việc lọc với điều kiện lớn hơn (\>) hoặc nhỏ hơn (\<) một ngày hoặc số có thể loại bỏ bất kỳ hàng nào có giá trị bị thiếu (`NA`)! Điều này là do `NA` được coi là giá trị lớn hoặc nhỏ vô hạn.]{style="color: red;"}

*(Xem chương [Làm việc với ngày tháng] để biết thêm thông tin về cách xử lý với ngày tháng và package **lubridate**)*

#### Thiết kế bộ lọc {.unnumbered}

Lập một bảng chéo để đảm bảo rằng chúng ta chỉ loại bỏ các hàng cần loại bỏ:

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Liệu chúng ta có thể lọc theo tiêu chí nào khác để loại bỏ đợt bùng phát đầu tiên (trong năm 2012 & 2013) khỏi bộ dữ liệu? Chúng ta thấy rằng:

-   Vụ dịch đầu tiên năm 2012 & 2013 xảy ra tại Hospital A, Hospital B, tại Port Hospital cũng có 10 trường hợp mắc.\
-   Hospital A & B *không* có ca bệnh nào trong đợt dịch thứ hai, nhưng Port Hospital thì có.

Chúng ta muốn loại bỏ:

-   Các dòng `nrow(linelist %>% filter(hospital %in% c("Hospital A", "Hospital B") | date_onset < as.Date("2013-06-01")))` bắt đầu vào năm 2012 và 2013 tại Hospital A, B hoặc Port Hospital:

    -   Loại trừ các hàng `nrow(linelist %>% filter(date_onset < as.Date("2013-06-01")))` bắt đầu vào năm 2012 và 2013
    -   Loại trừ các hàng `nrow(linelist %>% filter(hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` từ Hospital A và B với các giá trị ngày bị thiếu\
    -   Không loại bỏ các dòng khác `nrow(linelist %>% filter(!hospital %in% c('Hospital A', 'Hospital B') & is.na(date_onset)))` bị thiếu ngày bắt đầu.

Chúng ta bắt đầu với `linelist` bằng câu lệnh `nrow(linelist)`. Đây là toàn bộ câu lệnh lọc của chúng ta:

```{r}
linelist <- linelist %>% 
  # keep rows where onset is after 1 June 2013 OR where onset is missing and it was a hospital OTHER than Hospital A or B
  filter(date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))

nrow(linelist)
```

Khi chúng ta lập lại bảng chéo, chúng ta thấy rằng Hospital A & B bị loại bỏ hoàn toàn, và 10 trường hợp của Port Hospital từ năm 2012 & 2013 bị loại bỏ và tất cả các giá trị khác đều tương tự - đúng như ý chúng ta muốn.

```{r}
table(Hospital  = linelist$hospital,                     # hospital name
      YearOnset = lubridate::year(linelist$date_onset),  # year of date_onset
      useNA     = "always")                              # show missing values
```

Nhiều biểu thức có thể được bao hàm trong một lệnh lọc (được phân tách bằng dấu phẩy) hoặc bạn luôn có thể viết chúng riêng biệt và nối tiếp nhau trong chuỗi các bước làm sạch để rõ ràng hơn.

*Ghi chú: một số độc giả có thể nhận thấy rằng sẽ dễ dàng hơn nếu chỉ lọc theo `date_hospitalisation` vì nó hoàn chỉnh 100% mà không có giá trị nào bị thiếu. Đây là sự thật. Nhưng `date_onset` được sử dụng cho mục đích thể hiện sự phức tạp của việc lọc.*

### Độc lập {.unnumbered}

Việc lọc cũng có thể được thực hiện như một lệnh độc lập (không phải là một phần của chuỗi các bước làm sạch). Giống như các hàm **dplyr** khác, trong trường hợp này, đối số đầu tiên phải chính là bộ dữ liệu.

```{r, eval=F}
# dataframe <- filter(dataframe, condition(s) for rows to keep)

linelist <- filter(linelist, !is.na(case_id))
```

Bạn cũng có thể sử dụng **base** R để chia nhỏ dữ liệu bằng cách sử dụng dấu ngoặc đểm tham chiếu tới [hàng, cột] mà bạn muốn giữ lại.

```{r, eval=F}
# dataframe <- dataframe[row conditions, column conditions] (blank means keep all)

linelist <- linelist[!is.na(case_id), ]
```

### Xem nhanh các bản ghi {.unnumbered}

Thường thì bạn muốn xem nhanh một vài bản ghi, chỉ cho một vài cột. Hàm `View()` trong **base** R sẽ hiển thị một khung dữ liệu để xem trong RStudio.

Xem `linelist` trong RStudio:

```{r, eval=F}
View(linelist)
```

Dưới đây là hai ví dụ về việc xem các ô cụ thể (hàng cụ thể và cột cụ thể):

**Với hàm `filter()` và `select()` trong dplyr:**

Với hàm `View()`, chuyển tiếp bộ dữ liệu đến hàm `filter()` để giữ các hàng nhất định và sau đó `select()` để giữ các cột nhất định. Ví dụ, để xem xét ngày khởi phát và nhập viện của 3 trường hợp cụ thể:

```{r, eval=F}
View(linelist %>%
       filter(case_id %in% c("11f8ea", "76b97a", "47a5f5")) %>%
       select(date_onset, date_hospitalisation))
```

Bạn có thể đạt được điều tương tự với cú pháp trong **base** R, sử dụng dấu ngoặc `[ ]` cho tập hợp con bạn muốn xem.

```{r, eval=F}
View(linelist[linelist$case_id %in% c("11f8ea", "76b97a", "47a5f5"), c("date_onset", "date_hospitalisation")])
```

#### Thêm vào chuỗi làm sạch {.unnumbered}

```{r}
# CLEANING 'PIPE' CHAIN (starts with raw data and pipes it through cleaning steps)
##################################################################################

# begin cleaning pipe chain
###########################
linelist <- linelist_raw %>%
    
    # standardize column name syntax
    janitor::clean_names() %>% 
    
    # manually re-name columns
           # NEW name             # OLD name
    rename(date_infection       = infection_date,
           date_hospitalisation = hosp_date,
           date_outcome         = date_of_outcome) %>% 
    
    # remove column
    select(-c(row_num, merged_header, x28)) %>% 
  
    # de-duplicate
    distinct() %>% 

    # add column
    mutate(bmi = wt_kg / (ht_cm/100)^2) %>%     

    # convert class of columns
    mutate(across(contains("date"), as.Date), 
           generation = as.numeric(generation),
           age        = as.numeric(age)) %>% 
    
    # add column: delay to hospitalisation
    mutate(days_onset_hosp = as.numeric(date_hospitalisation - date_onset)) %>% 
    
    # clean values of hospital column
    mutate(hospital = recode(hospital,
                      # OLD = NEW
                      "Mitylira Hopital"  = "Military Hospital",
                      "Mitylira Hospital" = "Military Hospital",
                      "Military Hopital"  = "Military Hospital",
                      "Port Hopital"      = "Port Hospital",
                      "Central Hopital"   = "Central Hospital",
                      "other"             = "Other",
                      "St. Marks Maternity Hopital (SMMH)" = "St. Mark's Maternity Hospital (SMMH)"
                      )) %>% 
    
    mutate(hospital = replace_na(hospital, "Missing")) %>% 

    # create age_years column (from age and age_unit)
    mutate(age_years = case_when(
          age_unit == "years" ~ age,
          age_unit == "months" ~ age/12,
          is.na(age_unit) ~ age,
          TRUE ~ NA_real_)) %>% 
  
    mutate(
          # age categories: custom
          age_cat = epikit::age_categories(age_years, breakers = c(0, 5, 10, 15, 20, 30, 50, 70)),
        
          # age categories: 0 to 85 by 5s
          age_cat5 = epikit::age_categories(age_years, breakers = seq(0, 85, 5))) %>% 
    
    # ABOVE ARE UPSTREAM CLEANING STEPS ALREADY DISCUSSED
    ###################################################
    filter(
          # keep only rows where case_id is not missing
          !is.na(case_id),  
          
          # also filter to keep only the second outbreak
          date_onset > as.Date("2013-06-01") | (is.na(date_onset) & !hospital %in% c("Hospital A", "Hospital B")))
```

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

## Tính toán theo hàng

Nếu bạn muốn thực hiện một phép tính trong một hàng, bạn có thể sử dụng hàm `rowwise()` từ **dplyr**. Xem chi tiết tại [row-wise calculations](https://cran.r-project.org/web/packages/dplyr/vignettes/rowwise.html).\
Ví dụ: code này sử dụng hàm `rowwise()` và sau đó tạo một cột mới là tổng số cột triệu chứng được chứa giá trị "có", cho mỗi hàng trong `linelist`. Các cột được cụ thể trong hàm `sum()` theo tên trong vectơ `c()`. Hàm `rowwise()` về cơ bản là một hình thức `group_by()` đặc biệt, vì vậy tốt nhất bạn nên sử dụng `ungroup()` khi bạn hoàn tất (trong chương [Nhóm dữ liệu]).

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_symptoms = sum(c(fever, chills, cough, aches, vomit) == "yes")) %>% 
  ungroup() %>% 
  select(fever, chills, cough, aches, vomit, num_symptoms) # for display
```

Khi bạn chỉ định cột để đánh giá, bạn có thể muốn sử dụng các hàm trợ giúp "tidyselect" như được mô tả trong mục `select()` của chương này. Bạn chỉ cần thực hiện một điều chỉnh (vì bạn đang không sử dụng chúng bên trong một hàm của **dplyr** như `select()` hoặc `summarise()`).

Đặt tiêu chí đặc tả cột trong hàm **dplyr** là `c_across()`. Điều này là do hàm `c_across` ([tài liệu](https://dplyr.tidyverse.org/reference/c_across.html)) được thiết kế để hoạt động cụ thể với hàm `rowwise()`. Ví dụ, như đoạn code sau:

-   Áp dụng `rowwise()` nên bước tiếp theo (`sum()`) được áp dụng trong mỗi hàng (không tính tổng toàn bộ các cột)\
-   Tạo cột mới `num_NA_dates`, được xác định cho mỗi hàng là số cột (có tên chứa "ngày tháng") mà `is.na()` trả về giá trị TRUE (nghĩa là chúng bị thiếu dữ liệu)\
-   `ungroup()` để loại bỏ ảnh hưởng của `rowwise()` cho các bước tiếp theo

```{r,}
linelist %>%
  rowwise() %>%
  mutate(num_NA_dates = sum(is.na(c_across(contains("date"))))) %>% 
  ungroup() %>% 
  select(num_NA_dates, contains("date")) # for display
```

Bạn cũng có thể cung cấp các hàm khác, chẳng hạn như `max()` để lấy ngày mới nhất hoặc gần đây nhất cho mỗi hàng:

```{r}
linelist %>%
  rowwise() %>%
  mutate(latest_date = max(c_across(contains("date")), na.rm=T)) %>% 
  ungroup() %>% 
  select(latest_date, contains("date"))  # for display
```

## Sắp xếp

Sử dụng hàm **dplyr** `arrange()` để sắp xếp thứ tự các hàng theo giá trị cột.

Đơn giản hãy liệt kê các cột theo thứ tự mà chúng cần được sắp xếp. Thêm `.by_group = TRUE` nếu bạn muốn việc sắp xếp xảy ra trước bất kỳ *hành động nhóm dữ liệu* nào được áp dụng trong dữ liệu (xem chương [Nhóm dữ liệu]).

Mặc định, cột sẽ được sắp xếp theo thứ tự "tăng dần" (áp dụng cho cột số và cả cột ký tự). Bạn có thể sắp xếp một biến theo thứ tự "giảm dần" bằng cách đặt tên biến trong hàm `desc()`.

Việc sắp xếp dữ liệu với hàm `arrange()` đặc biệt hữu ích khi [Trình bày bảng], sử dụng hàm `slice()` để lấy các hàng "trên cùng" trên mỗi nhóm hoặc thiết lập thứ tự danh mục theo thứ tự xuất hiện.

Ví dụ: để sắp xếp các hàng trong `linelist` theo `hospital`, sau đó theo `date_onset` thứ tự giảm dần, chúng ta sẽ thực hiện như sau:

```{r, eval=F}
linelist %>% 
   arrange(hospital, desc(date_onset))
```

```{r, echo=F}
# HIDDEN
#
# convert one remaining old outbreak row to missing for ease
linelist <- linelist %>% 
  mutate(
    date_hospitalisation = case_when(
      date_hospitalisation < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                         ~ date_hospitalisation),
    date_outcome = case_when(
      date_outcome < as.Date("2013-01-01") ~ as.Date(NA),
      TRUE                                 ~ date_outcome)
    )

#min(linelist$date_hospitalisation, na.rm=T)
#min(linelist$date_outcome, na.rm=T)
```

```{r echo=F}
# REARRANGE COLUMNS FOR EXPORT
linelist <- linelist %>% 
  select(case_id:gender, age, age_unit, age_years, age_cat, age_cat5, everything())
```

```{r echo=F}
# EXPORT CLEANED LINELIST FILE TO "DATA" FOLDER
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.xlsx"))
rio::export(linelist, here::here("data", "case_linelists", "linelist_cleaned.rds"))
```
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cleaning.Rmd-->


# Làm việc với ngày tháng {#dates}


```{r, out.width=c('50%'), fig.align='center', echo=F, message=F}
knitr::include_graphics(here::here("images", "Dates_500x500.png"))
```



Làm việc với trường ngày trên R cần nhiều sự tỉ mỉ hơn là làm việc với các lớp đối tượng khác. Dưới đây, chúng tôi giới thiệu một số công cụ và ví dụ để các thao tác trở nên dễ dàng hơn. Thật may mắn, trường ngày có thể biến đổi một cách dễ dàng với một bộ packages như **lubridate**.  

Khi nhập dữ liệu thô, R thường diễn giải trường ngày dưới dạng các ký tự - điều này có nghĩa là chúng không thể được sử dụng cho các thao tác chung như tạo chuỗi thời gian và tính toán khoảng thời gian. Để làm cho vấn đề trở nên khó hơn một chút, có nhiều cách để định dạng ngày và bạn cần thao tác để R nhận biết từng phần của biến ngày mô tả cái gì (tháng, ngày, giờ, v.v.). 

Ngày trong R có kiểu đối tượng riêng - kiểu `Date`. Nên lưu ý rằng cũng có một kiểu khác lưu trữ đối tượng với định dạng ngày *và* giờ. Đối tượng ngày giờ được chính thức định dạng ở kiểu `POSIXt`, `POSIXct`, và/hoặc `POSIXlt` sự khác biệt không quá quan trọng). Các đối tượng này được định dạng một cách không chính thức là kiểu *datetime*.

* Điều quan trọng là giúp R nhận ra khi một cột chứa thông tin ngày tháng.  
* Ngày là một kiểu đối tượng và khó để có thể làm việc.  
* Ở đây chúng tôi trình bày một số cách để chuyển đổi các cột ngày thành kiểu dữ liệu Ngày tiêu chuẩn.  


<!-- ======================================================= -->
## Chuẩn bị

### Gọi packages {.unnumbered}  

Đoạn code này hiển thị tải các package cần thiết để sử dụng. Trong tài liệu này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, mà có thể cài đặt package nếu cần thiết *và* gọi package để sử dụng. Bạn cũng có thể gọi và cài đặt package với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.  

```{r dates_packages, warning=F, message=F}
# Checks if package is installed, installs if necessary, and loads package for current session

pacman::p_load(
  lubridate,  # general package for handling and converting dates  
  linelist,   # has function to "guess" messy dates
  aweek,      # another option for converting dates to weeks, and weeks to dates
  zoo,        # additional date/time functions
  tidyverse,  # data management and visualization  
  rio)        # data import/export
```

### Nhập dữ liệu {.unnumbered}  

Chúng ta sẽ nhập bộ dữ liệu với các ca bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để thực hành theo từng bước, hãy xem hướng dẫn ở chương [Tải sách và dữ liệu]. Chúng ta giả định rằng tệp dữ liệu đã nằm trong thư mục làm việc của bạn nên bạn không cần chỉ định thư mục con trong đường dẫn này.  

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")

```



<!-- ======================================================= -->
## Ngày hiện tại  

Bạn có thể lấy ngày “hệ thống” hiện tại hoặc ngày giờ hệ thống của máy tính bằng cách thực hiện như sau với **base** R.  

```{r}
# get the system date - this is a DATE class
Sys.Date()

# get the system time - this is a DATETIME class
Sys.time()
```


Với package **lubridate**, chúng cũng có thể trả về giá trị tương ứng với hàm `today()` và `now()`. Hàm `date()` sẽ trả về giá trị ngày và giờ hiện tại với ngày trong tuần và tháng.  
  
  

<!-- ======================================================= -->
## Chuyển đổi sang Ngày  

Sau khi nạp tập dữ liệu vào R, giá trị cột ngày có thể trông giống như “1989/12/30”, “05/06/2014” hoặc “13 Jan 2020”. Trong những trường hợp này, R có thể vẫn coi các giá trị trong cột có định dạng ký tự. R cần được *hướng dẫn* rằng các giá trị này là ngày… và định dạng của ngày là gì (phần nào là Ngày, phần nào là tháng, phần nào là Năm, v.v.).  

Sau khi hướng dẫn, R chuyển đổi các giá trị này thành kiểu Ngày. Trong nền, R sẽ lưu trữ ngày tháng dưới dạng số (số ngày tính từ ngày "gốc" ngày 1 tháng 1 năm 1970). Bạn sẽ không phải làm việc với định dạng ngày-số thường xuyên, tuy nhiên điều này cho phép R coi ngày là các biến liên tục và cho phép các hoạt động đặc biệt như tính toán khoảng cách giữa các ngày.  

Mặc định, các giá trị của phân lớp Ngày trong R được hiển thị là YYYY-MM-DD. Sau chương này chúng ta sẽ thảo luận về cách thay đổi cách hiển thị giá trị ngày tháng.  

Dưới đây, chúng tôi trình bày hai cách để chuyển đổi một cột từ dạng ký tự sang kiểu Ngày tiêu chuẩn.  


<span style="color: darkgreen;">**_MẸO:_** Bạn có thể kiểm tra kiểu ngày hiện tại của cột bằng hàm `class()` trong **base** R, ví dụ như `class(linelist$date_onset)`.</span>  

  

### **base** R {.unnumbered}  

`as.Date()` là hàm chuẩn của **base** R để chuyển đổi một đối tượng hoặc cột thành kiểu Ngày (lưu ý viết hoa chữ "D").  

Sử dụng hàm `as.Date()` yêu cầu:  

* Bạn *làm rõ định dạng **hiện tại** của ngày ở dạng văn bản gốc* hoặc ngày gốc nếu biến ngày được cung cấp dưới dạng số (xem mục ngày tháng trong Excel)  
* Nếu hàm được áp dụng trên cột dạng văn bản, tất cả các giá trị ngày phải có cùng một định dạng chính xác (nếu không như vậy, hãy thử hàm `guess_dates()` từ package **linelist**)  

**Trước tiên**, hãy kiểm tra kiểu của cột với hàm `class()` trong **base** R. Nếu bạn không chắc chắn hoặc phân vân về kiểu dữ liệu của cột (vd: bạn thấy "POSIXct", v.v.) dễ dàng nhất là chuyển đổi cột thành kiểu văn bản với hàm `as.character()`, và sau đó chuyển đổi nó thành kiểu Ngày.  

**Thứ hai**, trong hàm `as.Date()`, sử dụng đối số `format =` để cho R biết định dạng *hiện tại* của các cấu phần trong biến ngày - những ký tự nào đề cập đến tháng, ngày và năm và cách chúng được phân tách. Nếu các giá trị của bạn đã ở một trong các định dạng ngày chuẩn của R ("YYYY-MM-DD" hoặc "YYYY/MM/DD") thì đối số `format =` là không cần thiết.  

Để `format = `, hãy cung cấp một chuỗi ký tự (trong dấu ngoặc kép) đại diện cho định dạng ngày *hiện tại* bằng cách sử dụng các chữ viết tắt đặc biệt "strptime" dưới đây. Ví dụ: nếu ngày ký tự của bạn hiện ở định dạng “DD / MM / YYYY”, như “24/04/1968”, bạn hãy sử dụng đối số `format = "%d/%m/%Y"` để chuyển đổi các giá trị này. **Đặt định dạng trong dấu ngoặc kép là cần thiết. Và đừng quên bất kỳ dấu gạch chéo hoặc dấu gạch ngang nào!**  

```{r eval=F}
# Convert to class date
linelist <- linelist %>% 
  mutate(date_onset = as.Date(date_of_onset, format = "%d/%m/%Y"))
```

Hầu hết các từ viết tắt của “strptime” được liệt kê dưới đây. Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh `?strptime`.  

%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)  
%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)  
%a = Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)  
%A = Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.)
%w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)  
%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)  
%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)  
%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)  
%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)  
%b = Tháng viết tắt (Jan, Feb, v.v.)  
%B = Tháng viết đầy đủ (January, February, v.v.)  
%y = năm 2 chữ số  (vd: 89)  
%Y = năm 4 chữ số  (vd: 1989)  
%H = giờ (đồng hồ 24h)  
%M = phút  
%S = giây
%z = offset from GMT  
%Z = Múi giờ (dạng ký tự)  

<span style="color: darkgreen;">**_MẸO:_** Đối số `format =` của hàm `as.Date()` sẽ *không* cho R biết định dạng ngày theo cách bạn muốn, nhưng hơn hết nó giúp xác định thành phần ngày trong cột *trước khi* bạn chạy dòng lệnh.</span>  

<span style="color: darkgreen;">**_MẸO:_** Hãy chắc chắn rằng đối số `format =` bạn có sử dụng *các ký tự ngăn cách ngày tháng* (vd: /, -, hoặc khoảng trắng) trong cột ngày hiện tại của bạn.</span>  

Khi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.



### **lubridate** {.unnumbered}  

Việc chuyển đổi các đối tượng dạng tự thành Ngày tháng có thể được thực hiện dễ dàng hơn bằng cách sử dụng package **lubridate**. Đây là một package thuộc hệ sinh thái **tidyverse** được thiết kế để giúp làm việc với ngày và giờ đơn giản và nhất quán hơn so với **base** R. Vì những lý do này, package **lubridate** thường được coi là package tiêu chuẩn vàng cho ngày và giờ và được khuyến khích sử dụng bất cứ khi nào làm việc với chúng.

Package **lubridate** cung cấp một số hàm trợ giúp khác nhau được thiết kế để chuyển đổi các đối tượng dạng ký tự thành ngày tháng một cách trực quan và dễ dàng hơn là định dạng bằng hàm `as.Date()`. Các hàm này dành riêng cho định dạng ngày tháng, nhưng cho phép nhiều kiểu dấu phân tách và từ đồng nghĩa của ngày tháng (vd: 01 so với Jan so với January) - chúng được đặt tên theo chữ viết tắt của các định dạng ngày. 


```{r, }
# install/load lubridate 
pacman::p_load(lubridate)
```

Hàm `ymd()` có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng **năm, sau đó là tháng, và ngày**.  

```{r}
# read date in year-month-day format
ymd("2020-10-11")
ymd("20201011")
```

Hàm `mdy()` có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng **tháng, ngày, và năm**.  

```{r}
# read date in month-day-year format
mdy("10/11/2020")
mdy("Oct 11 20")
```

Hàm `dmy()` có thể chuyển đổi linh hoạt các giá trị ngày được cung cấp dưới dạng **ngày, tháng, và năm**.  

```{r}
# read date in day-month-year format
dmy("11 10 2020")
dmy("11 October 2020")
```

<!-- The `as.character()` and `as.Date()` commands can optionally be combined as:   -->

<!-- ```{r eval=F} -->
<!-- linelist_cleaned$date_of_onset <- as.Date(as.character(linelist_cleaned$date_of_onset), format = "%d/%m/%Y") -->
<!-- ``` -->

Nếu sử dụng piping, việc chuyển đổi cột dạng ký tự thành ngày tháng với **lubridate** có thể trông như thế này:  

```{r, eval=F}
linelist <- linelist %>%
  mutate(date_onset = lubridate::dmy(date_onset))
```

Sau khi hoàn tất, bạn có thể chạy hàm `class()` để xác minh lại kiểu dữ liệu của cột  

```{r, eval=F}
# Check the class of the column
class(linelist$date_onset)  
```


Khi các giá trị nằm trong phân lớp Ngày tiêu chuẩn, R sẽ mặc định hiển thị chúng ở định dạng chuẩn, đó là YYYY-MM-DD.  

Lưu ý rằng các hàm trên sử dụng tốt nhất với thông tin về năm có 4 chữ số. Thông tin về năm có 2 chữ số có thể tạo ra các kết quả không mong muốn, bởi vì lubridate sẽ cố gắng đoán và lấy thông tin về thế kỷ.  

Để chuyển đổi thông tin về năm 2 chữ số thành 4 chữ số (tất cả trong cùng một thế kỷ), bạn có thể chuyển thành dạng ký tự và sau đó kết hợp các chữ số hiện có với một tiền tố sử dụng hàm `str_glue()` từ package **stringr** (xem chương [Ký tự và chuỗi]). Sau đó chuyển đổi sang dạng ngày.  

```{r}
two_digit_years <- c("15", "15", "16", "17")
str_glue("20{two_digit_years}")
```



### Kết hợp các cột {.unnumbered}  

Bạn có thể sử dụng các hàm `make_date()` và `make_datetime()` trong package **lubridate** để kết hợp nhiều cột dạng số thành một cột ngày. Ví dụ: nếu bạn có các cột kiểu số như `onset_day`, `onset_month`, và `onset_year` trong data frame `linelist`:  

```{r, eval=F}
linelist <- linelist %>% 
  mutate(onset_date = make_date(year = onset_year, month = onset_month, day = onset_day))
```




<!-- ======================================================= -->
## Ngày tháng trong Excel

Về cơ bản, hầu hết phần mềm lưu trữ thông tin ngày tháng dưới dạng số. R lưu trữ ngày bắt đầu từ ngày 1 tháng 1 năm 1970. Do đó, nếu bạn chạy hàm `as.numeric(as.Date("1970-01-01))`, bạn sẽ nhận được kết quả là `0`. 

Microsoft Excel lưu trữ ngày tháng có nguồn gốc là ngày 30 tháng 12 năm 1899 (hệ điều hành Windows) hoặc ngày 1 tháng 1 năm 1904 (hệ điều hành Mac), tùy thuộc vào hệ điều hành của bạn. Xem [hướng dẫn của Microsoft](https://docs.microsoft.com/en-us/office/troubleshoot/excel/1900-and-1904-date-system) để biết thêm thông tin.  

Ngày trong Excel thường nạp vào R dưới dạng các giá trị số thay vì dưới dạng ký tự. Nếu tập dữ liệu bạn đã nhập từ Excel hiển thị ngày tháng dưới dạng số hoặc ký tự như “41369”… hãy sử dụng hàm `as.Date()` (hoặc hàm `as_date()` của **lubridate**) để chuyển đổi, nhưng **thay vì cung cấp một "định dạng" như trên, hãy cung cấp ngày gốc trên Excel** tới đối số `origin = `.  

Điều này sẽ không hoạt động nếu ngày Excel được lưu trữ trong R dưới dạng một kiểu ký tự, vì vậy hãy đảm bảo rằng các số được lữu trữ ở kiểu Số!

<span style="color: black;">**_LƯU Ý:_** Bạn nên cung cấp định dạng ngày ở định dạng mặc định của R ("YYYY-MM-DD").</span>

```{r, eval = FALSE}
# An example of providing the Excel 'origin date' when converting Excel number dates
data_cleaned <- data %>% 
  mutate(date_onset = as.numeric(date_onset)) %>%   # ensure class is numeric
  mutate(date_onset = as.Date(date_onset, origin = "1899-12-30")) # convert to date using Excel origin
```



<!-- ======================================================= -->
## Ngày lộn xộn  

Hàm `guess_dates()` từ package **linelist** cố gắng nhận diện một cột ngày tháng "lộn xộn" chứa ngày tháng ở nhiều định dạng khác nhau và chuyển đổi ngày tháng sang định dạng chuẩn. Bạn có thể [đọc thêm tài liệu trực tuyến về `guess_dates()`](https://www.repidemicsconsortium.org/linelist/reference/guess_dates.html). Nếu hàm `guess_dates()` chưa có trên CRAN của R phiên bản 4.0.2, hãy thử cài đặt theo cách sau `pacman::p_load_gh("reconhub/linelist")`.

Ví dụ: hàm `guess_dates` sẽ nhận diện một vectơ gồm các ngày chứa ký tự như sau "03 Jan 2018", "07/03/1982", và "08/20/85" và chuyển đổi chúng thành định dạng Ngày tiêu chuẩn như: `2018-01-03`, `1982-03-07`, và `1985-08-20`.  

```{r, }
linelist::guess_dates(c("03 Jan 2018",
                        "07/03/1982",
                        "08/20/85"))
```

Một số tùy chọn đối số cho hàm `guess_dates()` mà bạn có thể đưa vào là:  

* `error_tolerance` - Tỷ lệ thông tin nhập không thể được xác định là ngày được chấp nhận (mặc định là 0,1 hoặc 10%)
* `last_date` - ngày hợp lệ cuối cùng (mặc định là ngày hiện tại)  
* `first_date` - ngày hợp lệ đầu tiên. Giá trị mặc định là năm mươi năm trước last_date.


```{r eval = FALSE}
# An example using guess_dates on the column dater_onset
linelist <- linelist %>%                 # the dataset is called linelist
  mutate(
    date_onset = linelist::guess_dates(  # the guess_dates() from package "linelist"
      date_onset,
      error_tolerance = 0.1,
      first_date = "2016-01-01"
    )
```




<!-- ======================================================= -->
## Làm việc với kiểu dữ liệu ngày-giờ  

Như đã đề cập ở trước, R cũng hỗ trợ kiểu dữ liệu `datetime` - là một cột chứa thông tin ngày **và** giờ. Bởi vì với kiểu dữ liệu `Date`, chúng cần được chuyển đổi từ các đối tượng kiểu `character` thành kiểu `datetime`. 

### Chuyển đổi ngày giờ {.unnumbered}  

Một đối tượng `datetime` được định dạng phần ngày trước, sau đó là phần thời gian - ví dụ:  _01 Jan 2020, 16:30_. Cũng như ngày, có nhiều cách có thể được định dạng và có nhiều cấp độ chính xác (giờ, phút, giây) có thể sử dụng.  

Thật may mắn, các hàm hỗ trợ trong **lubridate** cũng tồn tại để giúp chuyển đổi thông tin dạng chuỗi này thành các đối tượng dạng `datetime`. Các hàm này là phần mở rộng của các hàm ngày, với hàm `_h` (chỉ cung cấp giờ), hàm `_hm` (cung cấp giờ và phút), hoặc hàm `_hms` (cung cấp giờ, phút và giây) được thêm vào cuối cùng (vd: `dmy_hms()`). Chúng có thể được sử dụng như sau:

Chuyển đổi datetime chỉ có giờ thành đối tượng datetime 

```{r}
ymd_h("2020-01-01 16hrs")
ymd_h("2020-01-01 4PM")
```

Chuyển đổi datetime với giờ và phút thành đối tượng datetime  

```{r}
dmy_hm("01 January 2020 16:20")
```

Chuyển đổi datetime với giờ, phút và giây sang đối tượng datetime  

```{r}
mdy_hms("01 January 2020, 16:20:40")
```

Bạn có thể cung cấp múi giờ nhưng nó bị bỏ qua. Xem các phần sau trong chương này về múi giờ.  

```{r}
mdy_hms("01 January 2020, 16:20:40 PST")

```

Khi làm việc với một data frame, các cột ngày và giờ có thể được kết hợp để tạo cột ngày-giờ bằng cách sử dụng hàm `str_glue()` từ package **stringr**  và các hàm của package **lubridate**. Xem chương [Ký tự và chuỗi] để biết thêm chi tiết về **stringr**.  

Trong ví dụ này, bộ dữ liệu `linelist` có một cột ở định dạng “giờ:phút”. Để chuyển đổi thành ngày giờ, chúng tôi làm theo một số bước:  

1) Tạo một cột thời gian nhập viện "sạch" với các giá trị bị thiếu được điền bằng trung vị cột. Chúng ta làm điều này bởi vì **lubridate** sẽ không hoạt động trên các giá trị missing. Kết hợp nó với cột `date_hospitalisation`, sau đó sử dụng hàm `ymd_hm()` để chuyển đổi.  

```{r, eval = FALSE}
# packages
pacman::p_load(tidyverse, lubridate, stringr)

# time_admission is a column in hours:minutes
linelist <- linelist %>%
  
  # when time of admission is not given, assign the median admission time
  mutate(
    time_admission_clean = ifelse(
      is.na(time_admission),         # if time is missing
      median(time_admission),        # assign the median
      time_admission                 # if not missing keep as is
  ) %>%
  
    # use str_glue() to combine date and time columns to create one character column
    # and then use ymd_hm() to convert it to datetime
  mutate(
    date_time_of_admission = str_glue("{date_hospitalisation} {time_admission_clean}") %>% 
      ymd_hm()
  )

```

### Chỉ chuyển đổi thời gian {.unnumbered}  

Nếu dữ liệu của bạn chỉ chứa thời gian dạng ký tự (giờ và phút), bạn có thể chuyển đổi và thao tác chúng bằng cách sử dụng hàm `strptime()` từ **base** R. Ví dụ: để phân biệt sự khác biệt giữa hai loại thời gian này:  

```{r}
# raw character times
time1 <- "13:45" 
time2 <- "15:20"

# Times converted to a datetime class
time1_clean <- strptime(time1, format = "%H:%M")
time2_clean <- strptime(time2, format = "%H:%M")

# Difference is of class "difftime" by default, here converted to numeric hours 
as.numeric(time2_clean - time1_clean)   # difference in hours

```

Tuy nhiên, lưu ý rằng nếu không có giá trị ngày được cung cấp, phần mềm sẽ giả định là ngày hôm nay. Để kết hợp chuỗi ngày và giờ với nhau, hãy thử cách sử dụng **stringr** đã được nói ở phần bên trên. Đọc thêm về `strptime()` [tại đây](https://rdrr.io/r/base/strptime.html).  

Để chuyển đổi các số có một chữ số thành hai chữ số (ví dụ: để “độn thêm” giờ hoặc phút với các số 0 ở đầu để đạt được 2 chữ số), hãy xem phần ["Độ dài chuỗi ký tự" trong chương Ký tự và chuỗi](#str_pad).  


### Thời gian chính xác {.unnumbered}  

Bạn có thể trích xuất các phần tử của thời gian với các hàm `hour()`, `minute()`, hoặc `second()` từ **lubridate**.  

Đây là một ví dụ về trích xuất giờ và sau đó phân loại theo từng phần trong ngày. Chúng ta bắt đầu với cột `time_admission`, có kiểu ký tự ở định dạng "HH:MM". Đầu tiên, hàm `strptime()` được sử dụng như mô tả ở trên để chuyển đổi các ký tự thành kiểu ngày giờ. Sau đó, giờ được trích xuất với hàm `hour()`, trả về một số từ 0-24. Cuối cùng, cột `time_period` được tạo bằng cách sử dụng logic với hàm `case_when()` để phân loại các dòng thành các buổi Sáng / Chiều / Tối / Đêm dựa trên giờ được nhập liệu.  

```{r}
linelist <- linelist %>%
  mutate(hour_admit = hour(strptime(time_admission, format = "%H:%M"))) %>%
  mutate(time_period = case_when(
    hour_admit > 06 & hour_admit < 12 ~ "Morning",
    hour_admit >= 12 & hour_admit < 17 ~ "Afternoon",
    hour_admit >= 17 & hour_admit < 21 ~ "Evening",
    hour_admit >=21 | hour_admit <= 6 ~ "Night"))
```

Để tìm hiểu thêm về hàm `case_when()`, hãy xem chương [Làm sạch số liệu và các hàm quan trọng].  

<!-- ======================================================= -->
## Làm việc với ngày   

`lubridate` cũng có thể được sử dụng cho nhiều chức năng khác, chẳng hạn như **trích xuất các phần tử của ngày/ngày-giờ**, **tính toán ngày dạng số học**, hoặc **tính toán khoảng cách giữa ngày với ngày**

Ở đây chúng tôi tạo ra một ngày mẫu để sử dụng cho các ví dụ:  

```{r, }
# create object of class Date
example_date <- ymd("2020-03-01")
```

### Trích xuất các cấu phần của ngày {.unnumbered}  

Bạn có thể trích xuất các cấu phần phổ biến như tháng, ngày, ngày trong tuần:  

```{r}
month(example_date)  # month number
day(example_date)    # day (number) of the month
wday(example_date)   # day number of the week (1-7)
```

Bạn cũng có thể trích xuất các cấu phần thời gian từ một đối tượng hoặc cột có kiểu `datetime`. Điều này có thể hữu ích nếu bạn muốn xem phân phối của thời gian nhập viện.  

```{r, eval=F}
example_datetime <- ymd_hm("2020-03-01 14:45")

hour(example_datetime)     # extract hour
minute(example_datetime)   # extract minute
second(example_datetime)   # extract second
```

Có một số tùy chọn để trích xuất tuần. Xem thêm ở mục tuần Dịch tễ học bên dưới.  

Lưu ý rằng nếu bạn đang tìm cách *hiển thị* ngày theo một cách nhất định (ví dụ: "Jan 2020" hoặc "Thursday 20 March" hoặc "Week 20, 1977"), bạn có thể thực hiện điều này linh hoạt hơn như được mô tả trong mục Hiển thị ngày.  


### Tính toán ngày {.unnumbered}  

Bạn có thể thêm số ngày hoặc tuần nhất định bằng cách sử dụng các hàm tương ứng từ package **lubridate**.  

```{r}
# add 3 days to this date
example_date + days(3)
  
# add 7 weeks and subtract two days from this date
example_date + weeks(7) - days(2)
```

### Khoảng ngày {.unnumbered}  

Sự khác biệt giữa các ngày có thể được tính bằng:  

1. Đảm bảo cả hai trường ngày đều thuộc phân lớp ngày tiêu chuẩn  
2. Sử dụng phép trừ để trả về khoảng chênh lệch "difftime" giữa hai ngày  
3. Nếu cần thiết, hãy chuyển đổi kết quả thành phân lớp dạng số để thực hiện các phép tính toán học tiếp theo 

Dưới đây là khoảng thời gian giữa hai ngày được tính toán và hiển thị. Bạn có thể tìm các khoảng thời gian bằng cách sử dụng ký hiệu trừ "minus" trên các giá trị dạng Ngày tiêu chuẩn. Tuy nhiên, lưu ý rằng phân lớp của giá trị trả về là “difftime” như được hiển thị bên dưới và phải được chuyển đổi thành dạng số. 

```{r}
# find the interval between this date and Feb 20 2020 
output <- example_date - ymd("2020-02-20")
output    # print
class(output)
```

Để thực hiện các thao tác tiếp theo trên “difftime”, hãy chuyển nó thành dạng số với hàm `as.numeric()`. 

Tất cả điều này có thể được kết hợp với nhau để xử lý dữ liệu - ví dụ:

```{r, eval = F}
pacman::p_load(lubridate, tidyverse)   # load packages

linelist <- linelist %>%
  
  # convert date of onset from character to date objects by specifying dmy format
  mutate(date_onset = dmy(date_onset),
         date_hospitalisation = dmy(date_hospitalisation)) %>%
  
  # filter out all cases without onset in march
  filter(month(date_onset) == 3) %>%
    
  # find the difference in days between onset and hospitalisation
  mutate(days_onset_to_hosp = date_hospitalisation - date_of_onset)
```



Trong bối cảnh của bộ dữ liệu, nếu thiếu một trong hai giá trị ngày ở trên, thì thao tác này sẽ không thực hiện thành công. Điều này sẽ tạo ra một kết quả là `NA` thay vì là một giá trị số. Khi sử dụng các cột này để tính toán, hãy chắc chắn rằng bạn thiết lập đối số `na.rm = ` là `TRUE`. Ví dụ:

```{r, eval = FALSE}
# calculate the median number of days to hospitalisation for all cases where data are available
median(linelist_delay$days_onset_to_hosp, na.rm = T)
```


<!-- ======================================================= -->
## Hiển thị ngày  

Một khi ngày tháng đã được định dạng đúng kiểu, bạn thường muốn chúng hiển thị theo nhiều cách khác nhau, ví dụ: hiển thị là "Monday 05 January" thay vì "2018-01-05". Bạn cũng có thể muốn điều chỉnh hiển thị để nhóm các dòng theo các yếu tố ngày - ví dụ: nhóm theo tháng-năm.  

### `format()` {.unnumbered}  

Điều chỉnh hiển thị ngày với hàm `format()` từ **base** R. Hàm này chấp nhận một chuỗi ký tự (trong dấu ngoặc kép) xác định rõ định dạng đầu ra *mong muốn* bằng chữ viết tắt “%” strptime (cú pháp tương tự như được sử dụng trong hàm `as.Date()`). Dưới đây là các từ viết tắt phổ biến.  

Lưu ý: việc sử dụng hàm `format()` sẽ chuyển đổi các giá trị thành kiểu ký tự, vì vậy điều này thường được sử dụng ở cuối phân tích hoặc chỉ cho mục đích hiển thị! Bạn có thể xem danh sách đầy đủ bằng cách chạy lệnh `?strptime`.  

%d = Thứ tự ngày trong tháng (5, 17, 28, v.v.)  
%j = Thứ tự ngày trong năm (theo lịch Julian, ngày từ 001-366)  
%a = Ngày trong tuần viết tắt (Mon, Tue, Wed, v.v.)  
%A = Ngày trong tuần viết đầy đủ (Monday, Tuesday, v.v.)
%w = Thứ tự ngày trong tuần (0-6, Chủ Nhật là 0)  
%u = Thứ tự ngày trong tuần (1-7, Thứ hai là 1)  
%W = Thứ tự của tuần trong năm (00-53, Thứ Hai là đầu tuần)  
%U = Thứ tự của tuần trong năm (01-53, Chủ Nhật là ngày bắt đầu tuần)  
%m = Thứ tự của tháng trong năm (vd: 01, 02, 03, 04)  
%b = Tháng viết tắt (Jan, Feb, v.v.)  
%B = Tháng viết đầy đủ (January, February, v.v.)  
%y = năm 2 chữ số  (vd: 89)  
%Y = năm 4 chữ số  (vd: 1989)  
%H = giờ (đồng hồ 24h)  
%M = phút  
%S = giây
%z = offset from GMT  
%Z = Múi giờ (dạng ký tự)

Ví dụ về định dạng ngày hôm nay:  

```{r}
# today's date, with formatting
format(Sys.Date(), format = "%d %B %Y")

# easy way to get full date and time (default formatting)
date()

# formatted combined date, time, and time zone using str_glue() function
str_glue("{format(Sys.Date(), format = '%A, %B %d %Y, %z  %Z, ')}{format(Sys.time(), format = '%H:%M:%S')}")

# Using format to display weeks
format(Sys.Date(), "%Y Week %W")
```

Lưu ý rằng nếu sử dụng hàm `str_glue()`, hãy lưu ý rằng các nội dung lẽ ra nên để trong dấu ngoặc kép thì bạn chỉ nên sử dụng dấu ngoặc đơn (như trên).  


### Tháng-Năm {.unnumbered}  

Để chuyển đổi cột Ngày sang định dạng Tháng-năm, chúng tôi khuyên bạn nên sử dụng hàm `as.yearmon()` từ package **zoo**. Nó giúp chuyển đổi từ định dạng ngày thành định dạng “yearmon” và giữ lại thứ tự thích hợp. Ngược lại, sử dụng hàm `format(column, "%Y %B")` sẽ chuyển đổi giá trị thành kiểu Ký tự và sẽ sắp xếp các giá trị theo thứ tự bảng chữ cái (không chính xác). 

Dưới đây, một cột `yearmonth` mới được tạo ra từ cột `date_onset`, sử dụng hàm `as.yearmon()`. Thứ tự mặc định (đúng) của các giá trị kết quả được hiển thị trong bảng.  

```{r}
# create new column 
test_zoo <- linelist %>% 
     mutate(yearmonth = zoo::as.yearmon(date_onset))

# print table
table(test_zoo$yearmon)
```

Ngược lại, bạn có thể thấy sử dụng hàm `format()` chỉ có thể giúp đạt được định dạng hiển thị mong muốn, nhưng sẽ không có thứ tự chính xác.  

```{r}
# create new column
test_format <- linelist %>% 
     mutate(yearmonth = format(date_onset, "%b %Y"))

# print table
table(test_format$yearmon)
```

Lưu ý: nếu bạn đang làm việc với hàm `ggplot()` và chỉ muốn điều chỉnh chỉ *hiển thị* ngày, bạn chỉ cần cung cấp định dạng strptime là đủ tới đối số `date_labels = ` của hàm `scale_x_date()` - bạn có thể sử dụng `"%b %Y"` hoặc `"%Y %b"`. Xem thêm chương [Các tips với ggplot].  


Package **zoo** cũng cung cấp hàm `as.yearqtr()`, và bạn có thể sử dụng hàm `scale_x_yearmon()` khi sử dụng hàm `ggplot()`.  



<!-- ======================================================= -->
## Tuần dịch tễ học {#dates_epi_wks}

### **lubridate** {.unnumbered}  

Xem chương [Nhóm dữ liệu] để biết thêm các ví dụ mở rộng về nhóm dữ liệu theo ngày. Dưới đây chúng tôi mô tả ngắn gọn cách nhóm dữ liệu theo tuần.  

Thông thường, chúng tôi khuyên bạn nên sử dụng hàm `floor_date()` từ package **lubridate**, với đối số `unit = "week"`. Điều này làm tròn ngày cần xử lý thành ngày "bắt đầu" của tuần, như được xác định bởi đối số `week_start = `. Ngày bắt đầu của tuần mặc định là 1 (đối với Thứ Hai) nhưng bạn có thể chỉ định bất kỳ ngày nào trong tuần làm ngày bắt đầu (ví dụ: 7 đối với Chủ Nhật). Hàm `floor_date()` rất linh hoạt và có thể sử dụng để làm tròn xuống các đơn vị thời gian khác bằng cách thiết lập đối số `unit = ` bằng “giây”, “phút”, “giờ”, “ngày”, “tháng”, hoặc “năm”.  

Giá trị trả về là ngày bắt đầu trong tuần, với kiểu dữ liệu Ngày. Kiểu dữ liệu này rất hữu ích khi vẽ biểu đồ, vì nó sẽ dễ dàng sử dụng và sắp xếp chính xác trong hàm `ggplot()`.

Nếu bạn chỉ quan tâm đến việc điều chỉnh ngày để *hiển thị* theo tuần trong biểu đồ, hãy xem mục Hiển thị ngày trong chương này. Ví dụ: khi vẽ đồ thị một đường cong dịch tễ, bạn có thể định dạng hiển thị ngày bằng cách sử dụng cú pháp strptime "%". Ví dụ, sử dụng "%Y-%W" hoặc "%Y-%U" để trả về giá trị năm và số tuần (tương ứng với bắt đầu tuần vào ngày thứ Hai hoặc Chủ nhật).  

### Đếm theo tuần {.unnumbered}  

Xem chương [Nhóm dữ liệu] để được giải thích kỹ hơn về cách nhóm dữ liệu với hàm `count()`, `group_by()`, và `summarise()`. Dưới đây là một ví dụ ngắn gọn.  

1) Tạo cột ‘tuần’ mới với hàm `mutate()`, sử dụng hàm `floor_date()` với đối số `unit = "week"`  
2) Đếm số lượng dòng (quan sát) mỗi tuần với hàm `count()`; lọc ra bất kỳ trường hợp nào bị thiếu ngày  
3) Kết thúc với hàm `complete()` từ package **tidyr** để đảm bảo rằng *tất cả* các tuần đều xuất hiện trong dữ liệu - ngay cả những tuần không có dòng/ quan sát nào. Theo mặc định, giá trị đếm cho bất kỳ hàng "mới" nào sẽ là NA, nhưng bạn có thể đặt chúng bằng 0 với đối số `fill = `, mà điều này kỳ vọng cho một danh sách tên (bên dưới, `n` là tên của cột đếm).  

```{r}
# Make aggregated dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%             # remove cases missing onset date
  mutate(weekly_cases = floor_date(   # make new column, week of onset
    date_onset,
    unit = "week")) %>%            
  count(weekly_cases) %>%           # group data by week and count rows per group (creates column 'n')
  tidyr::complete(                  # ensure all weeks are present, even those with no cases reported
    weekly_cases = seq.Date(          # re-define the "weekly_cases" column as a complete sequence,
      from = min(weekly_cases),       # from the minimum date
      to = max(weekly_cases),         # to the maxiumum date
      by = "week"),                   # by weeks
    fill = list(n = 0))             # fill-in NAs in the n counts column with 0
```

Đây là các hàng đầu tiên của kết quả bộ dữ liệu:  

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_counts, 20), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


### Các thay thế cho tuần dịch tễ học {.unnumbered}  

Lưu ý là package **lubridate** cũng có các hàm `week()`, `epiweek()`, và `isoweek()`, mỗi hàm có ngày bắt đầu khác nhau một chút và các sắc thái khác nhau. Mặc dù nói chung, hàm `floor_date()` là tất cả những gì bạn cần. Đọc thêm về các hàm này bằng cách gõ `?week` ở cửa sổ console hoặc đọc tài liệu [tại đây](https://www.rdocumentation.org/packages/lubridate/versions/1.7.4/topics/week). 


Bạn có thể cân nhắc sử dụng package **aweek** để thiết lập tuần dịch tễ học. Bạn có thể đọc thêm về nó [ở trang web của RECON](https://www.repidemicsconsortium.org/aweek/). Nó có các hàm `date2week()` và `week2date()` trong đó bạn có thể đặt ngày bắt đầu tuần với `week_start = "Monday"`. Package này là dễ sử dụng nhất nếu bạn muốn hiển thị "tuần" theo kiểu đầu ra (vd: "2020-W12"). Một ưu điểm khác của **aweek** là khi áp dụng hàm `date2week()` cho cột ngày, cột trả về (định dạng tuần) sẽ tự động thuộc kiểu Factor và bao gồm các cấp độ cho tất cả các tuần trong khoảng thời gian (điều này tránh thêm bước `complete()` được mô tả ở trên). Tuy nhiên, **aweek** không có chức năng làm tròn ngày thành các đơn vị thời gian khác như tháng, năm, v.v.  


Một giải pháp thay thế khác cho chuỗi thời gian cũng hoạt động tốt để hiển thị định dạng “tuần” ("2020 W12") là hàm `yearweek()` từ package **tsibble**, như được minh họa trong chương [Chuỗi thời gian và phát hiện ổ dịch].  


<!-- ======================================================= -->
## Chuyển đổi múi ngày giờ

Khi dữ liệu hiển thị ở các múi giờ khác nhau, điều quan trọng là phải chuẩn hóa dữ liệu này thành một múi giờ thống nhất. Điều này có thể gây ra một thách thức lớn hơn nữa, vì thành phần múi giờ của dữ liệu phải được mã hóa theo cách thủ công trong hầu hết các trường hợp.

Trong R, mỗi đối tượng *datetime* có một cấu phần múi giờ. Mặc định, tất cả các đối tượng datetime sẽ mang múi giờ địa phương của máy tính đang sử dụng - điều này thường đặc trưng cho một *vị trí* chứ không phải tự đặt tên cho múi giờ đó, vì múi giờ thường sẽ thay đổi ở các vị trí phụ thuộc vào thời gian chiếu sáng. Không thể bù trừ chính xác cho các múi giờ mà không có cấu phần thời gian trong biến ngày, vì mốc trong cột ngày đại diện không thể được quy cho một thời gian cụ thể và do đó không thể tính toán hợp lý sự chuyển đổi thời gian bằng giờ

Để xử lý múi giờ, có một số hàm trợ giúp trong lubridate có thể được sử dụng để thay đổi múi giờ của đối tượng datetime từ múi giờ địa phương sang các múi giờ khác. Múi giờ được đặt bằng cách gán múi giờ cơ sở dữ liệu tz hợp lệ cho đối tượng datetime. Bạn có thể tìm thấy danh sách những thứ này tại đây - nếu vị trí bạn đang sử dụng dữ liệu không có trong danh sách này, các múi giờ của thành phố lớn lân cận có thể được sử dụng thay thế. 

https://en.wikipedia.org/wiki/List_of_tz_database_time_zones


```{r}
# assign the current time to a column
time_now <- Sys.time()
time_now

# use with_tz() to assign a new timezone to the column, while CHANGING the clock time
time_london_real <- with_tz(time_now, "Europe/London")

# use force_tz() to assign a new timezone to the column, while KEEPING the clock time
time_london_local <- force_tz(time_now, "Europe/London")


# note that as long as the computer that was used to run this code is NOT set to London time,
# there will be a difference in the times 
# (the number of hours difference from the computers time zone to london)
time_london_real - time_london_local

```

Điều này có vẻ trừu tượng và thường không cần thiết nếu người dùng không làm việc trên các múi giờ.  





<!-- ======================================================= -->
## Phép toán về khoảng thời gian  

`lead()` và `lag()` là các hàm thuộc package **dplyr** giúp tìm các giá trị trước đó (lagged) hoặc tiếp theo (leading) trong một vectơ - thường là vectơ số hoặc ngày. Điều này rất hữu ích khi thực hiện các phép tính về sự thay đổi / chênh lệch giữa các đơn vị thời gian.  


```{r, echo=F}
counts <- import(here("data", "example", "district_weekly_count_data.xlsx")) %>% 
  filter(District == "Nibari") %>% 
  mutate(Date = as.Date(Date),
         week_start = lubridate::floor_date(Date, "week")) %>%
  group_by(week_start) %>% 
  summarize(cases_wk = sum(Cases, na.rm=T)) %>% 
  complete(week_start = seq.Date(min(week_start), max(week_start), by = "week"), fill = list(cases_wk = 0))
```

Giả sử bạn muốn tính toán sự khác biệt trong trường hợp giữa tuần hiện tại và tuần trước đó. Dữ liệu ban đầu được cung cấp theo số lượng hàng tuần như dưới đây.  

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**Khi sử dụng hàm `lag()` hoặc `lead()`, thứ tự của các dòng trong khung dữ liệu là rất quan trọng! - chú ý xem ngày/số của bạn tăng dần hay giảm dần**  

Đầu tiên, tạo một cột mới chứa giá trị của tuần trước đó (lagged).  

* Kiểm soát số lượng đơn vị trước/sau với `n = ` (phải là số nguyên không âm)  
* Sử dụng `default = ` để xác định giá trị được đặt trong các dòng không tồn tại (vd: hàng đầu tiên không có giá trị lagged). Mặc định, nó là `NA`.  
* Sử dụng `order_by = TRUE` nếu các dòng không được sắp xếp theo cột tham chiếu  


```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1))
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Tiếp theo, tạo một cột mới khác biệt với hai cột đang tham chiếu:  

```{r}
counts <- counts %>% 
  mutate(cases_prev_wk = lag(cases_wk, n = 1),
         case_diff = cases_wk - cases_prev_wk)
```

```{r message=FALSE, echo=F}
DT::datatable(counts, rownames = FALSE,  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Bạn có thể đọc thêm về hàm `lead()` và `lag()` trong tài liệu [này](https://dplyr.tidyverse.org/reference/lead-lag.html) hoặc gõ `?lag` vào cửa sổ console.  


<!-- ======================================================= -->
## Nguồn  

**lubridate** [tidyverse page](https://lubridate.tidyverse.org/)  
**lubridate** RStudio [cheatsheet](https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf)  
R for Data Science page on [dates and times](https://r4ds.had.co.nz/dates-and-times.html)  
[Online tutorial](https://www.statmethods.net/input/dates.html)
[Date formats](https://www.r-bloggers.com/2013/08/date-formats-in-r/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/dates.Rmd-->

# Ký tự và chuỗi {#characters-strings}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Characters_Strings_1500x500.png"))
```

Chương này trình bày việc sử dụng package **stringr** để đánh giá và xử lý các giá trị ký tự ("chuỗi").

1.  Các hàm kết hợp, thiết lập thứ tự, phân tách, sắp xếp - `str_c()`, `str_glue()`, `str_order()`, `str_split()`

2.  Làm sạch và chuẩn hóa

    -   Các hàm điều chỉnh độ dài ký tự - `str_pad()`, `str_trunc()`, `str_wrap()`\
    -   Các hàm thay đổi chữ hoa/chữ thường - `str_to_upper()`, `str_to_title()`, `str_to_lower()`, `str_to_sentence()`

3.  Các hàm đánh giá và trích xuất vị trí - `str_length()`, `str_sub()`, `word()`

4.  Các hàm làm việc với patterns

    -   Phát hiện và định vị - `str_detect()`, `str_subset()`, `str_match()`, `str_extract()`\
    -   Sửa đổi và thay thế - `str_sub()`, `str_replace_all()`

5.  Biểu thức chính quy ("regex")

Để dễ hiển thị, hầu hết các code ví dụ đều mô phỏng trên một vectơ ngắn dạng ký tự đã được xác định, tuy nhiên chúng có thể dễ dàng áp dụng trên một cột trong bộ dữ liệu.

Package [stringr vignette](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) đã cung cấp nhiều ý tưởng cho chương này.

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Cài đặt hoặc gọi package **stringr** và các packages **tidyverse** khác.

```{r}
# install/load packages
pacman::p_load(
  stringr,    # many functions for handling strings
  tidyverse,  # for optional data manipulation
  tools)      # alternative for converting to title case

```

### Nhập dữ liệu {.unnumbered}

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị bên dưới.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Hợp nhất, tách, và sắp xếp

Chương này bao gồm:

-   Sử dụng hàm `str_c()`, `str_glue()`, và `unite()` để ghép nối ký tự
-   Sử dụng hàm `str_order()` để sắp xếp ký tự
-   Sử dụng hàm `str_split()` và `separate()` để phân tách ký tự

### Kết hợp các chuỗi ký tự {.unnumbered}

Để kết hợp hoặc nối nhiều chuỗi ký tự thành một chuỗi ký tự, chúng tôi khuyên bạn nên sử dụng hàm `str_c` từ **stringr**. Nếu bạn có các giá trị ký tự riêng biệt để kết hợp, đơn giản chỉ cần cung cấp chúng dưới dạng đối số, được phân tách bằng dấu phẩy.

```{r}
str_c("String1", "String2", "String3")
```

Đối số `sep =` chèn một giá dạng trị ký tự vào giữa mỗi đối số ký tự bạn cung cấp (ví dụ: chèn dấu phẩy, dấu cách hoặc dòng mới `"\n"`)

```{r}
str_c("String1", "String2", "String3", sep = ", ")
```

Đối số `collapse =` có liên quan nếu bạn đang nhập nhiều *vectơ* làm đối số cho hàm `str_c()`. Nó được sử dụng để tách các phần tử của một vectơ *kết quả*, sao cho vectơ kết quả chỉ là một phần tử chứa ký tự dài.

Ví dụ dưới đây cho thấy sự kết hợp của hai vectơ thành một (tên và họ). Một ví dụ tương tự khác có thể là các phạm vi địa chính và số lượng trường hợp. Trong ví dụ này:

-   Giá trị `sep =` xuất hiện giữa từng họ và tên
-   Giá trị `collapse =` xuất hiện giữa tên từng người

```{r}
first_names <- c("abdul", "fahruk", "janice") 
last_names  <- c("hussein", "akinleye", "okeke")

# sep displays between the respective input strings, while collapse displays between the elements produced
str_c(first_names, last_names, sep = " ", collapse = ";  ")
```

Lưu ý: Tùy thuộc vào trường hợp hiển thị mong muốn, khi in một chuỗi kết hợp như vậy với các dòng mới, bạn có thể cần phải đặt toàn bộ cụm từ trong hàm `cat()` để các dòng mới được in đúng cách:

```{r}
# For newlines to print correctly, the phrase may need to be wrapped in cat()
cat(str_c(first_names, last_names, sep = " ", collapse = ";\n"))
```

### Chuỗi động {.unnumbered}

Sử dụng hàm `str_glue()` để chèn đoạn code động của R vào chuỗi ký tự. Đây là một hàm hữu dụng để tạo tiêu đề biểu đồ động, như được mô tả dưới đây:

-   Tất cả nội dung nằm giữa dấu ngoặc kép `str_glue("")`\
-   Bất kỳ đoạn code động hoặc tham chiếu nào đến các giá trị được xác định trước đều được đặt trong dấu ngoặc nhọn `{}`, bên trong dấu ngoặc kép. Có thể có nhiều dấu ngoặc nhọn trong cùng một câu lệnh `str_glue()`.\
-   Để hiển thị dấu ngoặc kép ", hãy sử dụng dấu ngoặc *đơn* bên trong dấu ngoặc kép (ví dụ: khi cung cấp định dạng ngày - xem ví dụ bên dưới)
-   Mẹo: Bạn có thể sử dụng `\n` để bắt buộc xuống một dòng mới\
-   Mẹo: Bạn có thể sử dụng hàm `format()` để điều chỉnh hiển thị ngày và sử dụng hàm `Sys.Date()` để hiển thị ngày hiện tại.

Một ví dụ đơn giản về tiêu đề biểu đồ động:

```{r}
str_glue("Data include {nrow(linelist)} cases and are current to {format(Sys.Date(), '%d %b %Y')}.")
```

Một định dạng thay thế là sử dụng trình giữ chỗ (placeholder) bên trong dấu ngoặc kép và chỉ định chúng trong các đối số ở phía sau trong hàm `str_glue()` như bên dưới. Việc này sẽ làm tăng tính tường minh cho code nếu phần văn bản dài.

```{r}
str_glue("Linelist as of {current_date}.\nLast case hospitalized on {last_hospital}.\n{n_missing_onset} cases are missing date of onset and not shown",
         current_date = format(Sys.Date(), '%d %b %Y'),
         last_hospital = format(as.Date(max(linelist$date_hospitalisation, na.rm=T)), '%d %b %Y'),
         n_missing_onset = nrow(linelist %>% filter(is.na(date_onset)))
         )

```

**Kéo từ bộ dữ liệu**

Đôi khi, sẽ rất hữu ích khi lấy dữ liệu từ một bộ dữ liệu và dán chúng lại với nhau theo trình tự. Dưới đây là một ví dụ về bộ dữ liệu. Chúng ta sẽ sử dụng cách này để có một phát biểu tóm tắt về các khu vực pháp lý, cũng như số ca mắc mới và tổng số ca.

```{r}
# make case data frame
case_table <- data.frame(
  zone        = c("Zone 1", "Zone 2", "Zone 3", "Zone 4", "Zone 5"),
  new_cases   = c(3, 0, 7, 0, 15),
  total_cases = c(40, 4, 25, 10, 103)
  )
```

```{r, echo=F}
DT::datatable(case_table, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Sử dụng hàm `str_glue_data()`, được thiết kế để lấy dữ liệu từ các quan sát của bộ dữ liệu:

```{r}
case_table %>% 
  str_glue_data("{zone}: {new_cases} ({total_cases} total cases)")
```

**Kết hợp các chuỗi ký tự trên các dòng**

Nếu bạn đang cố gắng để "gộp" các giá trị trong một cột của bộ dữ liệu, ví dụ: kết hợp các giá trị từ nhiều hàng thành một hàng bằng cách gắn chúng với nhau cùng ký tự phân cách, hãy xem thêm ở chương [Loại bỏ trùng lặp] mục ["gộp" các giá trị](#str_rollup).

**Một bộ dữ liệu thành một dòng**

Bạn có thể tạo ra dãy thông tin chỉ trong một dòng bằng cách sử dụng lệnh `str_c()` (cụ thể tên bộ dữ liệu và tên cột), đồng thời cung cấp các đối số `sep =` và `collapse =`.

```{r}
str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  ")
```

Bạn có thể thêm đoạn tiền tố "New Cases:" vào đầu dòng thông tin bằng cách đặt trong hàm `str_c()` (nếu "New Cases:" nằm trong hàm `str_c()` ban đầu thì nó sẽ xuất hiện nhiều lần).

```{r}
str_c("New Cases: ", str_c(case_table$zone, case_table$new_cases, sep = " = ", collapse = ";  "))
```

### Hợp nhất các cột {#str_unite .unnumbered}

Trong bộ dữ liệu, việc tập hợp các giá trị dạng ký tự từ nhiều cột lại với nhau có thể thực hiện bằng cách dùng hàm `unite()` từ package **tidyr**. Tính năng này ngược lại với hàm `separate()`.

Đầu tiên, cần tên của cột mới. Sau đó, cần tên của các cột mà bạn muốn hợp nhất.

-   Mặc định, dấu ngăn cách được sử dụng trong cột hợp nhất là dấu gạch dưới \_, nhưng có thể được thay đổi bằng đối số `sep =`.\
-   `remove =` loại bỏ các cột ban đầu ra khỏi bộ dữ liệu (mặc định là TRUE)\
-   `na.rm =` loại bỏ các giá trị bị thiếu trong khi hợp nhất (mặc định là FALSE)

Dưới đây, chúng tôi xác định một bộ dữ liệu ngắn để minh họa:

```{r, message = F, warning=F}
df <- data.frame(
  case_ID = c(1:6),
  symptoms  = c("jaundice, fever, chills",     # patient 1
                "chills, aches, pains",        # patient 2 
                "fever",                       # patient 3
                "vomiting, diarrhoea",         # patient 4
                "bleeding from gums, fever",   # patient 5
                "rapid pulse, headache"),      # patient 6
  outcome = c("Recover", "Death", "Death", "Recover", "Recover", "Recover"))
```

```{r}
df_split <- separate(df, symptoms, into = c("sym_1", "sym_2", "sym_3"), extra = "merge")
```

Đây là bộ dữ liệu mẫu:

```{r, echo=F}
DT::datatable(df_split, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Dưới đây, chúng tôi hợp nhất ba cột triệu chứng:

```{r}
df_split %>% 
  unite(
    col = "all_symptoms",         # name of the new united column
    c("sym_1", "sym_2", "sym_3"), # columns to unite
    sep = ", ",                   # separator to use in united column
    remove = TRUE,                # if TRUE, removes input cols from the data frame
    na.rm = TRUE                  # if TRUE, missing values are removed before uniting
  )
```

<!-- ======================================================= -->

### Tách chuỗi {.unnumbered}

Để tách một chuỗi ký tự dựa trên một quy luật, hãy sử dụng hàm `str_split()`. Hàm này đánh giá (các) chuỗi ký tự và trả về danh sách `list` các vectơ ký tự chứa các giá trị mới được tách.

Ví dụ đơn giản dưới đây đánh giá một chuỗi ký tự và chia nó thành ba phần. Mặc định, hàm trả về một đối tượng kiểu danh sách `list` với một phần tử (một vectơ ký tự) cho mỗi chuỗi được cung cấp ban đầu. Nếu `simplify = TRUE` nó trả về một ma trận ký tự.

Trong ví dụ này, một chuỗi ký tự được cung cấp và hàm trả về một danh sách có một phần tử - một vectơ ký tự chứa ba giá trị.

```{r}
str_split(string = "jaundice, fever, chills",
          pattern = ",")
```

Nếu kết quả được lưu, thì bạn có thể truy cập giá trị phân chia thứ n bằng cú pháp dấu ngoặc vuông. Để truy cập vào một giá trị cụ thể, bạn có thể sử dụng cú pháp như sau: `the_returned_object[[1]][2]`, sẽ truy cập giá trị thứ hai từ chuỗi ký tự được đánh giá thứ nhất ("fever"). Xem thêm ở chương [R Cơ bản] để biết thêm chi tiết về cách truy vấn các phần tử.

```{r}
pt1_symptoms <- str_split("jaundice, fever, chills", ",")

pt1_symptoms[[1]][2]  # extracts 2nd value from 1st (and only) element of the list
```

Nếu nhiều chuỗi ký tự được sử dụng trong hàm `str_split()`, sẽ có nhiều hơn một phần tử trong danh sách trả về.

```{r}
symptoms <- c("jaundice, fever, chills",     # patient 1
              "chills, aches, pains",        # patient 2 
              "fever",                       # patient 3
              "vomiting, diarrhoea",         # patient 4
              "bleeding from gums, fever",   # patient 5
              "rapid pulse, headache")       # patient 6

str_split(symptoms, ",")                     # split each patient's symptoms
```

Thay vào đó, để trả về "ma trận chuỗi ký tự", có thể sẽ hữu ích nếu tạo cột trong bộ dữ liệu, đặt đối số `simplify = TRUE` như trình bày dưới đây:

```{r}
str_split(symptoms, ",", simplify = TRUE)
```

Bạn cũng có thể điều chỉnh số phần tách ra với đối số `n =`. Ví dụ dưới đây giới hạn số phần tách ra là 2. Bất kỳ dấu phẩy nào khác vẫn sẽ nằm trong giá trị thứ hai.

```{r}
str_split(symptoms, ",", simplify = TRUE, n = 2)
```

*Lưu ý - các kết quả tương tự có thể đạt được với hàm `str_split_fixed()`, trong đó bạn không dùng đối số `simplify` mà thay vào đó phải chỉ định số cột (`n`).*

```{r, eval=F}
str_split_fixed(symptoms, ",", n = 2)
```

### Tách cột {.unnumbered}

Nếu bạn đang cố gắng chia tách cột trong bộ dữ liệu, cách tốt nhất là sử dụng hàm `separate()` từ package **dplyr**. Nó được sử dụng để chia một cột ký tự thành các cột khác nhau.

Giả sử chúng ta có một bộ dữ liệu đơn giản `df` (được xác định và hợp nhất trong [unite section](#str_unite)) chứa một cột `case_ID` , một cột dạng ký tự có nhiều triệu chứng và một cột outcome. Mục tiêu của chúng ta là tách cột `symptoms` thành nhiều cột - mỗi cột chứa một triệu chứng.

```{r, echo=F}
DT::datatable(df, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Giả sử dữ liệu được đưa vào hàm `separate()`, trước tiên hãy chọn ra cột sẽ được phân tách. Sau đó, cung cấp thông tin tới đối số `into =` dưới dạng vectơ `c( )` có chứa tên các cột *mới*, như được trình bày dưới đây.

-   Dấu phân cách trong `sep =` có thể là một ký tự hoặc một số (được hiểu là vị trí ký tự cần tách)

-   Mặc định là `remove =` FALSE, xóa cột đầu vào ban ban đầu

-   Mặc định là `convert =` FALSE, các ký tự "NA" sẽ thành `NA`\

-   `extra =` kiểm soát điều gì sẽ xảy ra nếu có nhiều giá trị được tạo bởi sự phân tách nhiều hơn các cột mới được đặt tên.

    -   `extra = "warn"` có nghĩa là bạn sẽ thấy một cảnh báo nhưng nó sẽ loại bỏ các giá trị thừa (**mặc định là vậy**)\
    -   `extra = "drop"` có nghĩa là các giá trị thừa sẽ bị loại bỏ mà không có cảnh báo
    -   **`extra = "merge"` sẽ chỉ phân tách thành số cột mới được liệt kê trong `into` - *thiết lập này sẽ bảo toàn tất cả dữ liệu của bạn***

Dưới đây là một ví dụ về `extra = "merge"` - không có dữ liệu nào bị mất. Hai cột mới được xác định nhưng bất kỳ triệu chứng thứ ba nào sẽ quy về trong cột mới thứ hai:

```{r}
# third symptoms combined into second new column
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",", extra = "merge")
```

Khi sử dụng lệnh `extra = "drop"` mặc định như bên dưới, một cảnh báo sẽ được đưa ra nhưng triệu chứng thứ ba bị mất:

```{r}
# third symptoms are lost
df %>% 
  separate(symptoms, into = c("sym_1", "sym_2"), sep=",")
```

[**CẨN TRỌNG:** Nếu bạn không cung cấp đủ giá trị `into` cho các cột mới, dữ liệu của bạn có thể bị cắt bớt .]{style="color: orange;"}

### Sắp xếp theo thứ tự bảng chữ cái {.unnumbered}

Một số chuỗi ký tự có thể được sắp xếp theo thứ tự bảng chữ cái. Hàm `str_order()` trả về thứ tự của các phần tử, trong khi hàm `str_sort()` trả về các chuỗi theo thứ tự đó.

```{r}
# strings
health_zones <- c("Alba", "Takota", "Delta")

# return the alphabetical order
str_order(health_zones)

# return the strings in alphabetical order
str_sort(health_zones)
```

Để sử dụng một bảng chữ cái khác, hãy thêm đối số `locale =`. Xem danh sách đầy đủ các locales bằng cách gõ `stringi::stri_locale_list()` trong cửa sổ R console.

### Các hàm base R {.unnumbered}

Các hàm phổ biến của **base** R là `paste()` và `paste0()` nối các vectơ sau khi chuyển đổi tất cả các cấu phần thành ký tự. Chúng hoạt động tương tự như `str_c()` nhưng cú pháp được cho là phức tạp hơn - đó là trong ngoặc thì mỗi phần được phân tách bằng một dấu phẩy. Các cấu phần là ký tự dạng văn bản (trong dấu ngoặc kép) hoặc các đối tượng được xác định trước (không có dấu ngoặc kép). Ví dụ:

```{r}
n_beds <- 10
n_masks <- 20

paste0("Regional hospital needs ", n_beds, " beds and ", n_masks, " masks.")
```

Đối số `sep =` và `collapse =` có thể được cụ thể. Hàm `paste()` chỉ đơn giản dán `paste0()` vớ đối số mặc định `sep = " "` (một khoảng trắng).

## Làm sạch và chuẩn hóa

<!-- ======================================================= -->

### Thay đổi chữ hoa/chữ thường {.unnumbered}

Thông thường thì người ta cần phải thay đổi cách viết thường/viết hoa của một giá trị dạng chuỗi ký tự, ví dụ như tên địa danh. Hãy sử dụng hàm `str_to_upper()`, `str_to_lower()`, và `str_to_title()` từ **stringr**, như dưới đây:

```{r}
str_to_upper("California")

str_to_lower("California")
```

Sử dụng **base** R, bạn cũng có thể thực hiện điều trên với hàm `toupper()`, `tolower()`.

**Định dạng tiêu đề**

Biến đổi chuỗi ký tự sao cho mỗi từ được viết hoa có thể thực hiện được với hàm `str_to_title()`:

```{r}
str_to_title("go to the US state of california ")
```

Sử dụng hàm `toTitleCase()` từ package **tools** để chuyển đổi nhiều kiểu viết in hoa hơn (các từ như "to", "the" và "of" không cần viết hoa).

```{r}
tools::toTitleCase("This is the US state of california")
```

Bạn cũng có thể sử dụng hàm `str_to_sentence()`, chỉ viết hoa chữ cái đầu tiên của chuỗi ký tự.

```{r}
str_to_sentence("the patient must be transported")
```

### Độ dài chuỗi ký tự {#str_pad .unnumbered}

Sử dụng hàm `str_pad()` để thêm các ký tự vào một chuỗi, với độ dài tối thiểu. Mặc định, khoảng trắng sẽ được thêm vào, nhưng bạn cũng có thể chèn các ký tự khác bằng cách sử dụng đối số `pad =`.

```{r}
# ICD codes of differing length
ICD_codes <- c("R10.13",
               "R10.819",
               "R17")

# ICD codes padded to 7 characters on the right side
str_pad(ICD_codes, 7, "right")

# Pad with periods instead of spaces
str_pad(ICD_codes, 7, "right", pad = ".")
```

Ví dụ: để chèn thêm số bằng các số 0 ở đầu (chẳng hạn như giờ hoặc phút), bạn có thể chèn số có độ dài tối thiểu là 2 với `pad = "0"`.

```{r}
# Add leading zeros to two digits (e.g. for times minutes/hours)
str_pad("4", 2, pad = "0") 

# example using a numeric column named "hours"
# hours <- str_pad(hours, 2, pad = "0")
```

### Cắt chuỗi ký tự {.unnumbered}

Hàm `str_trunc()` thiết lập độ dài tối đa cho mỗi chuỗi ký tự. Nếu một chuỗi vượt quá độ dài này, nó sẽ bị xén (rút ngắn) và kết thúc bằng một dấu ba chấm (...) ám chỉ rằng chuỗi đó chưa hiển thị hết các ký tự. Lưu ý rằng dấu ba chấm *được* tính toán phụ thuộc vào độ dài. Các ký tự dấu ba chấm có thể được thay đổi bằng đối số `ellipsis =`. Đối số tùy chọn `side =` làm rõ vị trí mà dấu ba chấm sẽ xuất hiện trong chuỗi bị cắt ngắn (bên "trái", "phải" hoặc "giữa").

```{r}
original <- "Symptom onset on 4/3/2020 with vomiting"
str_trunc(original, 10, "center")
```

### Chuẩn hóa độ dài {.unnumbered}

Sử dụng hàm `str_trunc()` để thiết lập độ dài tối đa, sau đó sử dụng hàm `str_pad()` để tăng thêm độ dài cho các chuỗi rất ngắn sao cho bằng độ dài tiêu chuẩn. Trong ví dụ dưới đây, độ dài tối đa là 6 (một ký tự bị cắt giảm), và sau đó một giá trị rất ngắn được đệm thêm để đạt được độ dài chuỗi là 6.

```{r}
# ICD codes of differing length
ICD_codes   <- c("R10.13",
                 "R10.819",
                 "R17")

# truncate to maximum length of 6
ICD_codes_2 <- str_trunc(ICD_codes, 6)
ICD_codes_2

# expand to minimum length of 6
ICD_codes_3 <- str_pad(ICD_codes_2, 6, "right")
ICD_codes_3
```

### Xóa khoảng trắng đầu/cuối {.unnumbered}

Sử dụng hàm `str_trim()` để xóa khoảng trắng, dòng mới (`\n`) hoặc tabs (`\t`) ở các phía của chuỗi đầu vào. Thêm `"right"` `"left"`, hoặc `"both"` vào lệnh để xác định phía nào cần cắt (ví dụ: `str_trim(x, "right")`.

```{r}
# ID numbers with excess spaces on right
IDs <- c("provA_1852  ", # two excess spaces
         "provA_2345",   # zero excess spaces
         "provA_9460 ")  # one excess space

# IDs trimmed to remove excess spaces on right side only
str_trim(IDs)
```

### Xóa khoảng trắng lặp lại phía trong {.unnumbered}

Sử dụng hàm `str_squish()` để loại bỏ các khoảng trắng lặp lại *bên trong* một chuỗi. Ví dụ, để chuyển đổi khoảng trắng lặp thành khoảng trắng đơn. Điều này cũng sẽ loại bỏ dấu cách, dòng mới hoặc tab ở phía bên ngoài chuỗi như giống như hàm `str_trim()`.

```{r}
# original contains excess spaces within string
str_squish("  Pt requires   IV saline\n") 
```

Gõ `?str_trim`, `?str_pad` vào cửa sổ R console để biết thêm chi tiết.

### Gói lại thành đoạn văn bản {.unnumbered}

Sử dụng hàm `str_wrap()` để gói một đoạn văn bản dài không có cấu trúc thành một đoạn văn có cấu trúc với độ dài các dòng là cố định. Cần xác định độ dài lý tưởng cho mỗi dòng và áp dụng một thuật toán để chèn thêm dòng mới (`\n`) vào trong đoạn văn bản, như ví dụ bên dưới.

```{r}
pt_course <- "Symptom onset 1/4/2020 vomiting chills fever. Pt saw traditional healer in home village on 2/4/2020. On 5/4/2020 pt symptoms worsened and was admitted to Lumta clinic. Sample was taken and pt was transported to regional hospital on 6/4/2020. Pt died at regional hospital on 7/4/2020."

str_wrap(pt_course, 40)
```

Hàm `cat()` trong **base** R có thể xử lý toàn bộ câu lệnh trên để trả kết quả, hiển thị các dòng mới được thêm vào.

```{r}
cat(str_wrap(pt_course, 40))
```

<!-- ======================================================= -->

## Xử lý theo vị trí

### Tách chuỗi theo vị trí ký tự {.unnumbered}

Sử dụng hàm `str_sub()` để trả về một phần của chuỗi. Hàm chứa 3 đối số chính là:

1)  các vector ký tự\
2)  vị trí bắt đầu\
3)  vị trí kết thúc

Một vài lưu ý về số thứ tự vị trí:

-   Nếu số thứ tự vị trí là số dương, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên trái của chuỗi.\
-   Nếu số thứ tự vị trí là số âm, vị trí được xử lý bắt đầu từ vị trí cuối cùng bên phải của chuỗi.\
-   Số thứ tự vị trí được bao gồm.\
-   Các vị trí vượt quá chuỗi sẽ bị cắt bớt (loại bỏ).

Dưới đây là một số ví dụ được áp dụng cho chuỗi ký tự "pneumonia":

```{r}
# start and end third from left (3rd letter from left)
str_sub("pneumonia", 3, 3)

# 0 is not present
str_sub("pneumonia", 0, 0)

# 6th from left, to the 1st from right
str_sub("pneumonia", 6, -1)

# 5th from right, to the 2nd from right
str_sub("pneumonia", -5, -2)

# 4th from left to a position outside the string
str_sub("pneumonia", 4, 15)
```

### Tách theo vị trí từ {.unnumbered}

Để tách 'từ' thứ n, hãy sử dụng hàm `word()` cũng thuộc package **stringr**. Đầu tiên, xác định (các) chuỗi ký tự, sau đó là vị trí từ đầu tiên cần trích xuất và vị trí từ cuối cùng để trích xuất.

Mặc định, dấu phân cách giữa các 'từ' được giả định là khoảng trắng, trừ khi được chỉ định cách khác bằng đối số `sep =` (ví dụ: `sep = "_"` khi các từ được phân tách bằng dấu gạch dưới)

```{r}
# strings to evaluate
chief_complaints <- c("I just got out of the hospital 2 days ago, but still can barely breathe.",
                      "My stomach hurts",
                      "Severe ear pain")

# extract 1st to 3rd words of each string
word(chief_complaints, start = 1, end = 3, sep = " ")
```

### Thay thế theo vị trí ký tự {.unnumbered}

Hàm `str_sub()` được ghép nối với toán tử gán (`<-`) có thể được sử dụng để sửa đổi một phần của chuỗi ký tự:

```{r}
word <- "pneumonia"

# convert the third and fourth characters to X 
str_sub(word, 3, 4) <- "XX"

# print
word
```

Một ví dụ áp dụng cho nhiều chuỗi (ví dụ: một cột). Lưu ý sự mở rộng về độ dài của từ "HIV".

```{r}
words <- c("pneumonia", "tubercolosis", "HIV")

# convert the third and fourth characters to X 
str_sub(words, 3, 4) <- "XX"

words
```

### Đánh giá độ dài chuỗi {.unnumbered}

```{r}
str_length("abc")
```

Ngoài ra, có thể sử dụng hàm `nchar()` từ **base** R

<!-- ======================================================= -->

## Quy luật chuỗi

Nhiều hàm **stringr** được sử dụng để nhận diện, định vị, trích xuất, khớp, thay thế và phân tách dựa trên một *pattern - quy luật* được chỉ định. .

<!-- ======================================================= -->

### Nhận diện quy luật {.unnumbered}

Sử dụng hàm `str_detect()` như bên dưới để phát hiện sự hiện diện/sự vắng mặt của một quy luật trong chuỗi. Đầu tiên, hãy cung cấp cho chuỗi hoặc vectơ cần tìm tới hàm (`string =`), sau đó là quy luật tìm kiếm (`pattern =`). Lưu ý rằng theo mặc định thì tìm kiếm phân biệt *chữ hoa chữ thường*!

```{r}
str_detect(string = "primary school teacher", pattern = "teach")
```

Đối số `negate =` có thể được bao gồm và đặt thành `TRUE` nếu bạn muốn tìm một quy luật KHÔNG xuất hiện.

```{r}
str_detect(string = "primary school teacher", pattern = "teach", negate = TRUE)
```

Để bỏ qua chữ hoa / chữ thường, hãy đặt pattern trong hàm `regex()`, và *bên trong* hàm `regex()` hãy thêm đối số `ignore_case = TRUE` (hoặc viết tắt là `T`).

```{r}
str_detect(string = "Teacher", pattern = regex("teach", ignore_case = T))
```

Khi hàm `str_detect()` được áp dụng cho một vectơ ký tự hoặc một cột trong bộ dữ liệu, nó sẽ trả về giá trị TRUE hoặc FALSE cho mỗi giá trị.

```{r}
# a vector/column of occupations 
occupations <- c("field laborer",
                 "university professor",
                 "primary school teacher & tutor",
                 "tutor",
                 "nurse at regional hospital",
                 "lineworker at Amberdeen Fish Factory",
                 "physican",
                 "cardiologist",
                 "office worker",
                 "food service")

# Detect presence of pattern "teach" in each string - output is vector of TRUE/FALSE
str_detect(occupations, "teach")
```

Nếu bạn cần đếm giá trị `TRUE`, chỉ cần đơn giản tính tổng bằng hàm `sum()` kết quả đầu ra. Nó sẽ đếm số lượng giá trị `TRUE`.

```{r}
sum(str_detect(occupations, "teach"))
```

Để tìm kiếm bao gồm nhiều cụm từ, hãy nhóm chúng bằng ký tự OR (`|`) bên trong đối số `pattern =` như được trình bày dưới đây:

```{r}
sum(str_detect(string = occupations, pattern = "teach|professor|tutor"))
```

Nếu bạn cần xây dựng một danh sách dài gồm các cụm từ cần tìm kiếm, bạn có thể kết hợp chúng bằng cách sử dụng hàm `str_c()` và `sep = |`, sau đó chỉ định nó là một đối tượng dạng ký tự, và sau đó tham chiếu vector một cách ngắn gọn hơn. Ví dụ dưới đây bao gồm các cụm từ tìm kiếm bao gồm các nghề nghiệp có thể sử dụng cho các nhà cung cấp dịch vụ y tế tuyến đầu.

```{r}
# search terms
occupation_med_frontline <- str_c("medical", "medicine", "hcw", "healthcare", "home care", "home health",
                                "surgeon", "doctor", "doc", "physician", "surgery", "peds", "pediatrician",
                               "intensivist", "cardiologist", "coroner", "nurse", "nursing", "rn", "lpn",
                               "cna", "pa", "physician assistant", "mental health",
                               "emergency department technician", "resp therapist", "respiratory",
                                "phlebotomist", "pharmacy", "pharmacist", "hospital", "snf", "rehabilitation",
                               "rehab", "activity", "elderly", "subacute", "sub acute",
                                "clinic", "post acute", "therapist", "extended care",
                                "dental", "dential", "dentist", sep = "|")

occupation_med_frontline
```

Lệnh này trả về số lượng nghề nghiệp mà chứa bất kỳ một trong các cụm từ tìm kiếm dành cho nhà cung cấp dịch vụ y tế tuyến đầu (`occupation_med_frontline`):

```{r}
sum(str_detect(string = occupations, pattern = occupation_med_frontline))
```

**Các hàm tìm kiếm chuỗi trong Base R**

Hàm `grepl()` trong **base** R hoạt động tương tự như hàm `str_detect()`, trong đó nó tìm kiếm các kết quả phù hợp với một quy luật và trả về một vectơ logic. Cú pháp cơ bản đó là `grepl(pattern, strings_to_search, ignore.case = FALSE, ...)`. Một ưu điểm đó là đối số `ignore.case` dễ viết hơn (không cần có sự tham gia của hàm `regex()`).

Tương tự như vậy, các hàm `sub()` và `gsub()` của **base** R hoạt động tương tự như hàm `str_replace()`. Cú pháp cơ bản đó là: `gsub(pattern, replacement, strings_to_search, ignore.case = FALSE)`. `sub()` sẽ thay thế trường hợp đầu tiên của pattern, trong khi `gsub()` sẽ thay thế tất cả các trường hợp của pattern.

#### Chuyển đổi dấu phẩy thành dấu chấm {.unnumbered}

Sau đây là một ví dụ về việc sử dụng hàm `gsub()` để chuyển đổi dấu phẩy thành dấu chấm trong một vectơ dạng số. Điều này có thể hữu ích nếu dữ liệu của bạn bắt nguồn từ nhiều nơi trên thế giới ngoài Hoa Kỳ hoặc Vương quốc Anh.

Hàm `gsub()` ở bên trong đầu tiên hoạt động trên đối tượng `lengths` để chuyển đổi bất kỳ dấu chấm nào thành không có khoảng trắng "". Ký tự dấu chấm "." phải được "đi liền" với hai dấu gạch chéo để biểu thị một dấu chấm, bởi vì "." trong biểu thức chính quy có nghĩa là "bất kỳ ký tự nào". Sau đó, kết quả (chỉ có dấu phẩy) được chuyển tiếp đến hàm `gsub()` bên ngoài trong đó dấu phẩy được thay thế bằng dấu chấm.

```{r, eval=F}
lengths <- c("2.454,56", "1,2", "6.096,5")

as.numeric(gsub(pattern = ",",                # find commas     
                replacement = ".",            # replace with periods
                x = gsub("\\.", "", lengths)  # vector with other periods removed (periods escaped)
                )
           )                                  # convert outcome to numeric
```

### Thay thế toàn bộ {.unnumbered}

Sử dụng hàm `str_replace_all()` như là một công cụ "find and replace (tìm kiếm và thay thế)". Đầu tiên, cung cấp các chuỗi ký tự sẽ được đánh giá tới đối số `string =`, sau đó là quy luật sẽ được thay thế vào đối số `pattern =`, và sau đó là giá trị thay thế vào `replacement =`. Ví dụ dưới đây thay thế tất cả các trường hợp "dead" bằng "deceased". Lưu ý, phân biệt chữ hoa chữ thường.

```{r}
outcome <- c("Karl: dead",
            "Samantha: dead",
            "Marco: not dead")

str_replace_all(string = outcome, pattern = "dead", replacement = "deceased")
```

Lưu ý:

-   Để thay thế một pattern cho `NA`, sử dụng hàm `str_replace_na()`.\
-   Hàm `str_replace()` thay thế duy nhất trường hợp đầu tiên của pattern trong mỗi chuỗi ký tự.

<!-- ======================================================= -->

### Nhận diện logic {.unnumbered}

**Bên trong hàm `case_when()`**

`str_detect()` thường được sử dụng trong hàm `case_when()` (từ **dplyr**). Hãy coi `occupations` là một cột trong bộ linelist. Hàm `mutate()` dưới đây tạo một cột mới gọi là `is_educator` bằng cách sử dụng logic có điều kiện bởi `case_when()`. Xem thêm ở chương về làm sạch dữ liệu để hiểu hơn về hàm `case_when()`.

```{r, eval=F}
df <- df %>% 
  mutate(is_educator = case_when(
    # term search within occupation, not case sensitive
    str_detect(occupations,
               regex("teach|prof|tutor|university",
                     ignore_case = TRUE))              ~ "Educator",
    # all others
    TRUE                                               ~ "Not an educator"))
```

Xin nhắc lại, điều quan trọng là phải thêm tiêu chí loại trừ vào điều kiện logic (`negate = F`):

```{r, eval=F}
df <- df %>% 
  # value in new column is_educator is based on conditional logic
  mutate(is_educator = case_when(
    
    # occupation column must meet 2 criteria to be assigned "Educator":
    # it must have a search term AND NOT any exclusion term
    
    # Must have a search term
    str_detect(occupations,
               regex("teach|prof|tutor|university", ignore_case = T)) &              
    
    # AND must NOT have an exclusion term
    str_detect(occupations,
               regex("admin", ignore_case = T),
               negate = TRUE                        ~ "Educator"
    
    # All rows not meeting above criteria
    TRUE                                            ~ "Not an educator"))
```

<!-- ======================================================= -->

### Định vị vị trí pattern {.unnumbered}

Để xác định vị trí *đầu tiên* của một pattern, hãy sử dụng hàm `str_locate()`. Nó xuất ra vị trí bắt đầu và kết thúc.

```{r}
str_locate("I wish", "sh")
```

Giống như các hàm `str` khác, có một phiên bản "\_all" (`str_locate_all()`) sẽ trả về vị trí của *tất cả* các phiên bản của pattern trong mỗi chuỗi. Kết quả này xuất ra dưới dạng danh sách `list`.

```{r}
phrases <- c("I wish", "I hope", "he hopes", "He hopes")

str_locate(phrases, "h" )     # position of *first* instance of the pattern
str_locate_all(phrases, "h" ) # position of *every* instance of the pattern
```

<!-- ======================================================= -->

### Trích xuất kết quả ghép cặp {.unnumbered}

`str_extract_all()` trả về các patterns được matching, sẽ hữu dụng nhất khi bạn cung cấp một vài patterns thông qua điều kiện "OR". Ví dụ: tìm trong vectơ chuỗi nghề nghiệp (xem tab trước) các từ "teach", "prof" hoặc "tutor".

`str_extract_all()` trả về một danh sách `list` chứa *tất cả các kết quả ghép cặp* cho mỗi chuỗi được đánh giá. Xem dưới đây ta thấy occupation 3 có hai pattern được tìm thấy.

```{r}
str_extract_all(occupations, "teach|prof|tutor")
```

`str_extract()` chỉ trích xuất *kết quả ghép cặp đầu tiên* trong mỗi chuỗi được xem xét, tạo ra một vectơ ký tự với một phần tử cho mỗi chuỗi được xem xét. Nó trả về giá trị `NA` khi không có giá trị nào được tìm thấy. Các giá trị `NA` có thể được loại bỏ bằng cách đặt vectơ trả về trong hàm `na.exclude()`. Lưu ý đoạn khớp nối thứ hai của occupation 3 không được hiển thị.

```{r}
str_extract(occupations, "teach|prof|tutor")
```

<!-- ======================================================= -->

### Tập hợp con và số lượng {.unnumbered}

Bao gồm hàm `str_subset()` và `str_count()`.

`str_subset()` trả về các giá trị thực có chứa pattern:

```{r}
str_subset(occupations, "teach|prof|tutor")
```

`str_count()` trả về một vectơ số: **số lần** một cụm từ tìm kiếm xuất hiện trong mỗi giá trị được xem xét.

```{r}
str_count(occupations, regex("teach|prof|tutor", ignore_case = TRUE))
```

<!-- ======================================================= -->

### Nhóm Regex {.unnumbered}

ĐANG ĐƯỢC XÂY DỰNG

<!-- ======================================================= -->

## Các ký tự đặc biệt

**Dấu gạch chéo ngược `\` để bỏ qua**

Dấu gạch chéo ngược `\` được sử dụng "để bỏ qua" nghĩa của ký tự tiếp theo. Bằng cách này, dấu gạch chéo ngược có thể được sử dụng để hiển thị dấu ngoặc kép *bên trong* các dấu ngoặc kép khác (`\"`) - dấu ngoặc kép ở giữa sẽ không "phá vỡ" các dấu ngoặc kép xung quanh.

Lưu ý - do đó, nếu bạn muốn *hiển thị* một dấu gạch chéo ngược, bạn phải ngắt nghĩa của nó bằng một dấu gạch chéo ngược khác. Vì vậy, bạn phải viết hai dấu gạch chéo ngược `\\` để chỉ hiển thị một.

**Các ký tự đặc biệt**

| Ký tự đặc biệt                                                                    | Ý nghĩa                             |
|-----------------------------------------------------------------------------------|-------------------------------------|
| `"\\"`                                                                            | Dấu gạch chéo ngược                 |
| `"\n"`                                                                            | một dòng mới                        |
| `"\""`                                                                            | dấu ngoặc kép *trong* dấu ngoặc kép |
| `'\''`                                                                            | dấu ngoặc đơn *trong* dấu ngoặc đơn |
| `"\`"`| grave accent`"\r"`| carriage return`"\t"`| tab`"\v"`| vertical tab`"\b"\` | backspace                           |

Gõ `?"'"` trong cửa sổ R Console để hiển thị danh sách đầy đủ các ký tự đặc biệt (nó sẽ xuất hiện trong cửa sổ Help của RStudio).

<!-- ======================================================= -->

## Biểu thức chính quy (regex)

<!-- ======================================================= -->

## Regex và các ký tự đặc biệt

Biểu thức chính quy, hoặc "regex", là một ngôn ngữ ngắn gọn để mô tả các patterns trong chuỗi ký tự. Nếu bạn không quen với nó, một biểu thức chính quy có thể trông giống như một ngôn ngữ ngoài hành tinh. Ở đây chúng tôi cố lột tả ngôn ngữ này dễ hiểu hơn

*Phần lớn nội dung mục này được tham khảo từ [hướng dẫn này](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432) và [cheatsheet này](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)*. Chúng tôi tóm tắt một cách chọn lọc ở đây khi biết rằng cuốn ebook này có thể được xem bởi những người không có quyền truy cập internet để có thể xem các hướng dẫn khác.

Một biểu thức chính quy thường được áp dụng để trích xuất các pattern cụ thể từ văn bản "không có cấu trúc" - ví dụ: ghi chú y tế, khiếu nại, tiền sử bệnh tật hoặc các cột văn bản khác trong bộ dữ liệu.

Có bốn công cụ cơ bản mà người ta có thể sử dụng để tạo một biểu thức chính quy cơ bản:

1)  Bộ ký tự\
2)  Siêu ký tự\
3)  Bộ định lượng\
4)  Nhóm

**Bộ ký tự**

Bộ ký tự, là một cách thể hiện các tùy chọn liệt kê phù hợp với ký tự gốc, trong dấu ngoặc. Vì vậy, mọi kết quả khớp sẽ được đánh dấu nếu tìm thấy bất kỳ ký tự nào trong dấu ngoặc trong chuỗi. Ví dụ, để tìm các nguyên âm, người ta có thể sử dụng bộ ký tự này: "[aeiou]". Một số bộ ký tự phổ biến khác là:

| Bộ ký tự    | Ghép cặp                                     |
|-------------|----------------------------------------------|
| `"[A-Z]"`   | bất kỳ ký tự viết hoa đơn lẻ nào             |
| `"[a-z]"`   | bất kỳ ký tự viết thường đơn lẻ nào          |
| `"[0-9]"`   | bất kỳ số nào                                |
| `[:alnum:]` | bất kỳ ký tự chữ và số nào                   |
| `[:digit:]` | bất kỳ chữ số nào                            |
| `[:alpha:]` | bất kỳ ký tự nào (viết hoa hoặc viết thường) |
| `[:upper:]` | bất kỳ ký tự viết hoa nào                    |
| `[:lower:]` | bất kỳ ký tự viết thường nào                 |

Các bộ ký tự có thể được kết hợp trong một dấu ngoặc vuông (không có khoảng trắng!), chẳng hạn như `"[A-Za-z]"` (bất kỳ chữ cái viết hoa hoặc viết thường nào), hoặc một ví dụ khác `"[t-z0-5]"` (từ t viết thường đến z HOẶC số 0 đến 5).

**Siêu ký tự**

Các siêu ký tự là cách viết tắt của các bộ ký tự. Một số điều quan trọng được liệt kê dưới đây:

| Siêu ký tự | Ý nghĩa                                                |
|------------|--------------------------------------------------------|
| `"\\s"`    | khoảng trắng đơn                                       |
| `"\\w"`    | bất kỳ ký tự chữ hoặc số đơn lẻ nào (A-Z, a-z, or 0-9) |
| `"\\d"`    | bất kỳ chữ số đơn lẻ nào (0-9)                         |

**Bộ định lượng**

Thông thường, bạn không muốn tìm kiếm kết quả phù hợp chỉ trên một ký tự. Bộ định lượng cho phép bạn chỉ định độ dài của các chữ cái/số để cho phép ghép nối.

Bộ định lượng là các số được viết trong dấu ngoặc nhọn `{ }` *sau* ký tự mà chúng đang định lượng, ví dụ:

-   `"A{2}"` sẽ trả về trường hợp **hai** chữ cái A viết hoa.\
-   `"A{2,4}"` sẽ trả về các trường hợp **từ hai đến bốn** chữ cái A viết hoa *(không đặt dấu cách!)*.\
-   `"A{2,}"` sẽ trả về các trường hợp **từ hai hoặc nhiều hơn** chữ cái A viết hoa.\
-   `"A+"` sẽ trả về các trường hợp **từ một hoặc nhiều hơn** chữ cái A viết hoa (nhóm được mở rộng cho đến khi gặp một ký tự khác).\
-   Bắt đầu bằng dấu hoa thị `*` để trả về **không hoặc nhiều hơn** kết quả phù hợp (hữu ích nếu bạn không chắc chắn pattern có sẵn)

Sử dụng ký hiệu dấu cộng `+` như một bộ định lượng, việc khớp sẽ xảy ra cho tới khi gặp ký tự khác. Ví dụ, biểu thứ này sẽ trả về tất cả *các từ* (ký tự alpha: `"[A-Za-z]+"`

```{r}
# test string for quantifiers
test <- "A-AA-AAA-AAAA"
```

Khi bộ định lượng {2} được sử dụng, chỉ các cặp chữ A liên tiếp được trả về. Hai cặp được xác định trong `AAAA`.

```{r}
str_extract_all(test, "A{2}")
```

Khi bộ định lượng {2,4} được sử dụng, các nhóm chữ A liên tiếp có độ dài từ hai đến bốn được trả về.

```{r}
str_extract_all(test, "A{2,4}")
```

Với bộ định lượng `+`, các nhóm của **một hoặc nhiều hơn** được trả về:

```{r}
str_extract_all(test, "A+")
```

**Vị trí tương đối**

Những biểu thức dưới đây yêu cầu cho những thứ đứng trước hoặc theo sau một mẫu. Ví dụ, để trích xuất câu, "two numbers that are followed by a period" (`""`). (?\<=\\.)\\s(?=[A-Z])

```{r}
str_extract_all(test, "")
```

| Biểu thức vị trí | Khớp với                            |
|------------------|-------------------------------------|
| `"(?<=b)a"`      | "a" **bị đứng trước** bởi "b"       |
| `"(?<!b)a"`      | "a" **KHÔNG bị đứng trước** bởi "b" |
| `"a(?=b)"`       | "a" **được theo sau** bởi "b"       |
| `"a(?!b)"`       | "a" **KHÔNG được theo sau** bởi "b" |

**Nhóm**

Việc bắt các nhóm trong biểu thức chính quy là một cách để kết quả trả về có tổ chức hơn khi trích xuất.

**Ví dụ về Regex**

Dưới đây là một văn bản tự do sử dụng làm ví dụ. Chúng ta sẽ cố gắng trích xuất thông tin hữu ích từ nó bằng cách sử dụng cụm từ tìm kiếm theo biểu thức chính quy.

```{r}
pt_note <- "Patient arrived at Broward Hospital emergency ward at 18:00 on 6/12/2005. Patient presented with radiating abdominal pain from LR quadrant. Patient skin was pale, cool, and clammy. Patient temperature was 99.8 degrees farinheit. Patient pulse rate was 100 bpm and thready. Respiratory rate was 29 per minute."
```

Biểu thức sau đây khớp với tất cả các từ (bất kỳ ký tự nào cho đến khi gặp thứ không phải ký tự, chẳng hạn như dấu cách):

```{r}
str_extract_all(pt_note, "[A-Za-z]+")
```

Biểu thức `"[0-9]{1,2}"` khớp với các số liên tiếp có độ dài 1 hoặc 2 chữ số. Nó cũng có thể được viết là `"\\d{1,2}"`, hoặc `"[:digit:]{1,2}"`.

```{r}
str_extract_all(pt_note, "[0-9]{1,2}")
```

<!-- This expression will extract all sentences (assuming first letter is capitalized, and the sentence ends with a period). The pattern reads in English as: "A capital letter followed by some lowercase letters, a space, some letters, a space,     -->

<!-- ```{r} -->

<!-- str_extract_all(pt_note, "[A-Z][a-z]+\\s\\w+\\s\\d{1,2}\\s\\w+\\s*\\w*") -->

<!-- ``` -->

Bạn có thể xem danh sách hữu ích về các biểu thức regex và các mẹo trên trang 2 của [cheatsheet này](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Bạn cũng có thể xem [tutorial này](https://towardsdatascience.com/a-gentle-introduction-to-regular-expressions-with-r-df5e897ca432).

<!-- ======================================================= -->

## Nguồn

Bạn có thể tìm thấy trang tham khảo cho các hàm **stringr** [tại đây](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf)

Một vignette về **stringr** có thể được tìm thấy [tại đây](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/characters_strings.Rmd-->

# Factors {#factors}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Factors_1500x500.png"))
```

Trong R, *factors* là một kiểu dữ liệu cho phép sắp xếp các danh mục với một tập hợp các giá trị có thể chấp nhận.

Thông thường, bạn sẽ chuyển đổi một cột từ dạng ký tự hoặc dạng số thành dạng factor khi bạn muốn sắp xếp một thứ tự đặc biệt cho các giá trị ("*levels*") để chúng không hiển thị mặc định theo thứ tự bảng chữ cái trong các biểu đồ và bảng. Một cách sử dụng phổ biến khác của factor là chuẩn hóa các chú thích của biểu đồ để chúng không thay đổi nếu một giá trị tạm thời không có trong dữ liệu.

Chương này giới thiệu cách sử dụng các hàm từ package **forcats** (tên viết tắt của "**For** **categorical variables**") và một số hàm **base** R. Chúng tôi cũng đề cập đến việc sử dụng **lubridate** và **aweek** cho các trường hợp factor đặc biệt liên quan đến tuần dịch tễ học.

Bạn có thể tìm thấy danh sách đầy đủ các hàm của package **forcats** trực tuyến tại đường [link này](https://forcats.tidyverse.org/reference/index.html). Sau đây, chúng tôi sẽ chỉ trình bày một số hàm phổ biến nhất.

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đoạn code dưới đây hiển thị cách gọi các package cần thiết cho việc phân tích. Trong sách này, chúng tôi nhấn mạnh đến việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt package nếu nó chưa được cài *và* gọi nó ra cho phiên làm việc. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r}
pacman::p_load(
  rio,           # import/export
  here,          # filepaths
  lubridate,     # working with dates
  forcats,       # factors
  aweek,         # create epiweeks with automatic factor levels
  janitor,       # tables
  tidyverse      # data mgmt and viz
  )
```

### Nhập dữ liệu {.unnumbered}


Chúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Để tiện muốn theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải bộ dữ liệu linelist "đã được làm sạch"</a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (hàm có thể áp dụng với nhiều loại dữ liệu như .xlsx, .rds, .csv - Xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết).


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import your dataset
linelist <- import("linelist_cleaned.rds")
```

### Thêm biến danh mục mới {#fct_newcat .unnumbered}

Trong chương này, chúng tôi sẽ minh họa một trường hợp thường gặp, đó là tạo ra một biến danh mục mới.

Lưu ý rằng khi bạn chuyển đổi một cột dạng số thành dạng factor, bạn sẽ không thể thực hiện các tính toán thống kê đối với dữ liệu dạng số trên cột đó nữa.

#### Tạo biến {.unnumbered}

Chúng ta sẽ sử dụng một biến có sẵn, tên là `days_onset_hosp` (số ngày, tính từ khi bắt đầu có triệu chứng cho đến khi nhập viện) và tạo một biến mới có tên `delay_cat` bằng cách phân loại các giá trị trong mỗi hàng của biến có sẵn đó thành một số nhóm khác nhau. Chúng ta sẽ thực hiện việc này bằng hàm `case_when()` trong package **dplyr**, hàm này sẽ giúp áp dụng tuần tự các tiêu chí logic (phía bên phải) cho mỗi giá trị của biễn có sẵn và trả về giá trị bên trái tương ứng ở biến mới `delay_cat`. Đọc thêm về `case_when()` tại chương [Làm sạch số liệu và các hàm quan trọng].

```{r}
linelist <- linelist %>% 
  mutate(delay_cat = case_when(
    # criteria                                   # new value if TRUE
    days_onset_hosp < 2                        ~ "<2 days",
    days_onset_hosp >= 2 & days_onset_hosp < 5 ~ "2-5 days",
    days_onset_hosp >= 5                       ~ ">5 days",
    is.na(days_onset_hosp)                     ~ NA_character_,
    TRUE                                       ~ "Check me"))  
```

#### Thứ tự mặc định của các giá trị {.unnumbered}

Khi sử dụng hàm `case_when()`, biến mới `delay_cat` tạo ra sẽ là một biến danh mục với kiểu dữ liệu là ký tự - *chưa* phải là một factor. Do đó, trong bảng tần suất dưới đây, chúng ta thấy rằng các giá trị xuất hiện theo thứ tự mặc định của bảng chữ cái, điều này không có nhiều ý nghĩa trực quan:

```{r}
table(linelist$delay_cat, useNA = "always")
```

Tương tự như vậy, nếu chúng ta tạo biểu đồ cột, các giá trị cũng xuất hiện theo thứ tự này trên trục x (xem chương [ggplot cơ bản] để hiểu thêm về package **ggplot2** - package giúp trực quan hóa dữ liệu phổ biến nhất trong R).

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```

## Chuyển đổi sang factor

Để chuyển đổi một biến dạng ký tự hoặc dạng số sang dạng *factor*, bạn có thể sử dụng bất kỳ hàm nào trong package **forcats** (nhiều hàm được nêu chi tiết tại [mục dưới đây](#fct_adjust)). Các biến sẽ chuyển đổi sang dạng factor và sau đó cũng thực hiện hoặc sắp xếp theo một thứ tự nhất định của các levels - ví dụ: hàm `fct_relevel()` cho phép bạn chỉ định thứ tự levels theo cách thủ công. Hàm `as_factor()` chỉ đơn giản là chuyển đổi biến sang dạng factor mà không có thêm bất kỳ chức năng nào khác.

Hàm `factor()` trong **base** R chuyển đổi một biến thành factor và cho phép bạn tự sắp xếp thứ tự của các nhóm giá trị, dưới dạng một vectơ ký tự của đối số `levels =`.

Dưới đây, chúng tôi sử dụng hàm `mutate()` và hàm `fct_relevel()` để chuyển đối biến có sẵn `delay_cat` từ dạng ký tự sang dạng factor. Biến `delay_cat` đã được tạo ở phần [Chuẩn bị](#fct_newcat) bên trên.

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat))
```

*Các "giá trị" duy nhất trong biến số được gọi là các "thứ bậc" của biến factor.* Các thứ bậc này được sắp xếp *theo một trật tự nhất định* và có thể được in ra bằng hàm `levels()` từ **base** R, hoặc bạn có thể xem nó bằng một bảng đếm thông qua hàm `table()`từ **base** R, hoặc hàm `tabyl()` từ package **janitor**. Trật tự này sẽ được hiển thị theo thứ tự của bảng chữ cái. Lưu ý rằng `NA` không được xem là một thứ bậc trong factor.

```{r}
levels(linelist$delay_cat)
```

Hàm `fct_relevel()` có thêm chức năng cho phép bạn có thể tự sắp xếp trật tự của các thứ bậc trong factor. Đơn giản, bạn chỉ cần viết các thứ bậc theo thứ tự bạn muốn, để chúng trong dấu ngoặc kép, được phân tách bằng dấu phẩy, như được hiển thị bên dưới. Lưu ý rằng chính tả phải khớp chính xác với tên các thứ bậc. Nếu bạn muốn tạo các thứ bậc không tồn tại trong dữ liệu, hãy sử dụng hàm [`fct_expand()`](#fct_add) nhé.

```{r}
linelist <- linelist %>%
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", "2-5 days", ">5 days"))
```

Bây giờ chúng ta có thể thấy rằng các thứ bậc đã được sắp xếp theo một thứ tự hợp lý.

```{r}
levels(linelist$delay_cat)
```

Bây giờ trật tự các cột trong biểu đồ cũng trực quan hơn.

```{r, warning=F, message=F}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = delay_cat))
```

## Thêm hoặc xóa thứ bậc

### Thêm thứ bậc {#fct_add .unnumbered}

Nếu bạn cần thêm thứ bậc trong factor, bạn có thể sử dụng hàm `fct_expand()`. Bạn chỉ cần viết tên biến và theo sau là tên các thứ bậc mới (phân tách bằng dấu phẩy). Bằng cách lập bảng, chúng ta có thể thấy các thứ bậc mới xuất hiện và chưa nhận giá trị nào. Bạn có thể sử dụng hàm `table()` trong **base** R, hoặc hàm `tabyl()` trong package **janitor**:

```{r}
linelist %>% 
  mutate(delay_cat = fct_expand(delay_cat, "Not admitted to hospital", "Transfer to other jurisdiction")) %>% 
  tabyl(delay_cat)   # print table
```

Lưu ý: Package **forcats** có thể dễ dàng thêm các giá trị missing (`NA`) như là một thứ bậc. Bạn có thể xem thêm tại mục [Giá trị Missing](#fct_missing) dưới đây.

### Xóa thứ bậc {.unnumbered}

Nếu bạn sử dụng hàm `fct_drop()`, các thứ bậc "không được sử dụng" và không có quan sát nào sẽ bị loại bỏ khỏi factors. Thứ bậc mà chúng ta đã thêm ở trên ("Not admitted to a hospital") có tồn tại nhưng thực tế không có dòng nào chứa giá trị này. Vì vậy, chúng sẽ bị loại bỏ khỏi biến factor của chúng ta bằng cách sử dụng hàm `fct_drop()` như sau:

```{r}
linelist %>% 
  mutate(delay_cat = fct_drop(delay_cat)) %>% 
  tabyl(delay_cat)
```

## Thay đổi trật tự của các thứ bậc {#fct_adjust}

Package **forcats** cung cấp các hàm hữu ích để dễ dàng thay đổi trật tự của các thứ bậc trong một biến kiểu factor (sau khi một biến số được định nghĩa là một factor):

Các hàm trong package này có thể được áp dụng cho biến dạng factor trong hai trường hợp dưới đây:

1)  Đối với cột trong một data frame, thông thường, việc thay đổi sẽ được giữ nguyên cho các lần sử dụng dữ liệu tiếp theo
2)  *Trong một biểu đồ*, sự thay đổi trật tự chỉ được áp dụng cho biểu đồ đó

### Thay đổi thủ công {.unnumbered}

Hàm này được sử dụng để thay đổi trật tự của các thứ bậc trong một biến dạng factor theo cách thủ công. Nếu hàm này được sử dụng trên một biến dạng khác, không phải factor, hàm sẽ giúp chuyển biến đó sang dạng factor trước.

Trong dấu ngoặc đơn trước tiên điền tên của biến factor, sau đó điền:

-   Tất cả các thứ bậc trong biến factor mà bạn mong muốn thay đổi trật tự (dưới dạng vector ký tự `c()`), hoặc
-   Chỉ một giá trị thứ bậc với vị trí tương ứng mong muốn, sử dụng đối số `after =`

Dưới đây là một ví dụ về chuyển biến `delay_cat` thành dạng factor (mặc dù biến này đã ở dạng Factor rồi) và sắp xếp lại các thứ bậc theo thứ tự mong muốn.

```{r}
# re-define level order
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days")))
```

Nếu bạn chỉ muốn chỉ định vị trí cho một thứ bậc, bạn có thể dùng hàm `fct_relevel()` và sử dụng đối số `after =` để chỉ định một giá trị thứ bậc với vị trí tương ứng mong muốn. Ví dụ: lệnh dưới đây chuyển thứ bậc "\<2 days" sang vị trí thứ hai:

```{r, eval=F}
# re-define level order
linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 1)) %>% 
  tabyl(delay_cat)
```

### Đối với biểu đồ {.unnumbered}

Các lệnh trong package **forcats** có thể được sử dụng để thay đổi trật tự của biến trong data frame hoặc trong biểu đồ. Bằng cách sử dụng các lệnh để "gói" tên biến vào *trong* các lệnh vẽ biểu đồ của package `ggplot()`, bạn có thể dảo ngược/thay đổi một trật tự có sẵn của biến. Sự thay đổi này chỉ áp dụng trong biểu đồ đang vẽ.

Dưới đây, hai biểu đồ đều được vẽ bởi hàm `ggplot()` (xem thêm tại chương [ggplot cơ bản]). Trong biểu đồ đầu tiên, biến `delay_cat` được vẽ trên trục x của biểu đồ với thứ tự các thứ bậc là mặc định trong dữ liệu `linelist`. Trong biểu đồ thứ hai, biến được đặt trong bởi hàm `fct_relevel()` và trật tự của các thứ bậc đã được sắp xếp lại.

```{r, echo =F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, c("2-5 days", "<2 days", ">5 days")))

```

```{r, warning=F, message=F, out.width = c('50%', '50%'), fig.show='hold'}
# Alpha-numeric default order - no adjustment within ggplot
ggplot(data = linelist)+
    geom_bar(mapping = aes(x = delay_cat))

# Factor level order adjusted within ggplot
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = fct_relevel(delay_cat, c("<2 days", "2-5 days", ">5 days"))))
```

Lưu ý rằng, ở biểu đồ thứ hai, tiêu đề mặc định của trục x được hiện khá phức tạp - bạn có thể sử tiêu đề này bằng đối số `labs()` trong **ggplot2**.

### Đảo ngược thứ tự {.unnumbered}

Bạn sẽ thường xuyên cần đảo ngược trật tự của các thứ bậc trong một biến. Đơn giản, bạn chỉ cần thêm tên biến vào bên trong hàm `fct_rev()`.

Lưu ý rằng, nếu bạn *chỉ* muốn đảo ngược thứ tự trong một biểu đồ chứ không phải thứ tự của biến đó, bạn có thể thực hiện điều đó với hàm `guides()` (Xem thêm tại chương [Các tips với ggplot]).

### Theo tần suất {.unnumbered}

Để sắp xếp trật tự các thứ bậc theo tần suất mà nó xuất hiện trong dữ liệu, hãy sử dụng hàm `fct_infreq()`. Tất cả các giá trị mising (`NA`) sẽ tự động được đưa xuống cuối, trừ khi chúng được chuyển sang một thứ bậc khác (xem thêm ở [mục này](#fct_missing)). Bạn có thể đảo ngược trật tự bằng cách thêm hàm `fct_rev()` vào câu lệnh.

Hàm này có thể được sử dụng trong `ggplot()`, như hình bên dưới.

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# ordered by frequency
ggplot(data = linelist, aes(x = fct_infreq(delay_cat)))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by frequency")

# reversed frequency
ggplot(data = linelist, aes(x = fct_rev(fct_infreq(delay_cat))))+
  geom_bar()+
  labs(x = "Delay onset to admission (days)",
       title = "Reverse of order by frequency")
```

### Theo sự xuất hiện {.unnumbered}

Sử dụng hàm `fct_inorder()` để thiết lập thứ bậc tương tự với thứ tự xuất hiện của các giá trị trong dữ liệu, bắt đầu từ hàng đầu tiên. Điều này có thể hữu ích nếu trước đó bạn đã cẩn thận sắp xếp dữ liệu trong data frame bằng hàm `arrange()`, sau đó sử dụng điều này để đặt trật tự các thứ bậc của biến facror.

### Theo thống kê tóm tắt của một cột khác {.unnumbered}

Bạn có thể sử dụng hàm `fct_reorder()` để sắp xếp các thứ bậc của một biến *theo thống kê tóm tắt của một biến khác*. Về mặt trực quan, điều này có cho kết quả là các biểu đồ như ý bạn, có các cột/điểm lên hoặc xuống theo một chiều trong toàn bộ biểu đồ.

Trong các ví dụ bên dưới, trục x là `delay_cat`, và trục y là `ct_blood` (giá trị ngưỡng chu kỳ). Biểu đồ hộp (Box plot) hiển thị phân bố của giá trị CT theo nhóm `delay_cat`. Chúng ta cần sắp xếp các hộp theo thứ tự tăng dần của giá trị trung vị CT của nhóm.

Trong ví dụ đầu tiên bên dưới, các thứ bậc được sắp xếp một cách mặc định. Bạn có thể thấy các chiều cao của hộp bị lộn xộn và không theo bất kỳ thứ tự cụ thể nào. Trong ví dụ thứ hai, cột `delay_cat` (được sắp xếp theo trục x) đã được viết lệnh với hàm `fct_reorder()`, cột `ct_blood` được đưa ra làm đối số thứ hai và "trung vị" được đưa ra làm đối số thứ ba (bạn cũng có thể sử dụng "max", "mean", "min", v.v.). Do đó, thứ tự các thứ bậc của biến `delay_cat` bây giờ sẽ phản ánh các giá trị trung vị CT tăng dần theo nhóm `delay_cat`. Điều này được trình bày trong biểu đồ thứ hai - các hộp đã được sắp xếp lại theo chiều tăng dần. Lưu ý giá trị missing `NA` sẽ luôn xuất hiện ở cuối, trừ khi được chuyển đổi thành một thứ bậc khác.

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# boxplots ordered by original factor levels
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = delay_cat,
        y = ct_blood, 
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by original alpha-numeric levels")+
  theme_classic()+
  theme(legend.position = "none")


# boxplots ordered by median CT value
ggplot(data = linelist)+
  geom_boxplot(
    aes(x = fct_reorder(delay_cat, ct_blood, "median"),
        y = ct_blood,
        fill = delay_cat))+
  labs(x = "Delay onset to admission (days)",
       title = "Ordered by median CT value in group")+
  theme_classic()+
  theme(legend.position = "none")
```

Lưu ý trong ví dụ bên trên không có bước nào được yêu cầu cần thực hiện trước khi gọi hàm `ggplot()` - việc nhóm và tính toán đều được thực hiện bên trong hàm ggplot.

### Theo giá trị cuối {.unnumbered}

Sử dụng hàm `fct_reorder2()` cho biểu đồ đường theo nhóm. Hàm sẽ sắp xếp thứ tự xuất hiện các nhóm (bao gồm cả phần *chú giải*) dọc theo biểu đồ. Nói về mặt kỹ thuật, nó "sắp xếp theo các giá trị y tương ứng với các giá trị x lớn nhất."

Ví dụ, nếu bạn có các dòng hiển thị số lượng trường hợp theo bệnh viện và thời gian, bạn có thể áp dụng hàm `fct_reorder2()` cho đối số `color =` trong `aes()`, sao cho thứ tự của các bệnh viện xuất hiện trong phần chú giải tương đương với thứ tự xuất hiện của các đường trong biểu đồ. Đọc thêm trong [tài liệu trực tuyến sau đây](https://forcats.tidyverse.org/reference/fct_reorder.html).

```{r, warning=F, message=F}
epidemic_data <- linelist %>%         # begin with the linelist   
    filter(date_onset < as.Date("2014-09-21")) %>%    # cut-off date, for visual clarity
    count(                                            # get case counts per week and by hospital
      epiweek = lubridate::floor_date(date_onset, "week"),  
      hospital                                            
    ) 
  
ggplot(data = epidemic_data)+                       # start plot
  geom_line(                                        # make lines
    aes(
      x = epiweek,                                  # x-axis epiweek
      y = n,                                        # height is number of cases per week
      color = fct_reorder2(hospital, epiweek, n)))+ # data grouped and colored by hospital, with factor order by height at end of plot
  labs(title = "Factor levels (and legend display) by line height at end of plot",
       color = "Hospital")                          # change legend title
```

## Giá trị Missing {#fct_missing}

Nếu có giá trị missing `NA` trong biến factor của bạn, bạn có thể dễ dàng chuyển đổi chúng thành một thứ bậc được đặt tên với hàm `fct_explicit_na()`. Giá trị missing `NA` được chuyển đổi thành "(Missing)" mặc định sẽ được xếp cuối cùng. Bạn có thể điều chỉnh tên thứ bậc bằng đối số `na_level =`.

Ví dụ dưới đây được thực hiện trên biến `delay_cat` và một bảng được in bằng`tabyl()`với các giá trị missing `NA` được chuyển thành "Missing delay".

```{r}
linelist %>% 
  mutate(delay_cat = fct_explicit_na(delay_cat, na_level = "Missing delay")) %>% 
  tabyl(delay_cat)
```

## Kết hợp các thứ bậc trong biến factor

### Kết hợp thủ công {.unnumbered}

Bạn có thể điều chỉnh cách hiển thị của các thứ bậc theo cách thủ công với hàm `fct_recode()`. Điều này giống như hàm `recode()` trong package **dplyr** (xem thêm tại chương [Làm sạch số liệu và các hàm quan trọng]), nhưng nó cho phép tạo các thứ bậc mới trong factor. Nếu bạn đơn giản chỉ sử dụng hàm `recode()` trên một factor, các giá trị được mã hóa mới sẽ bị từ chối trừ khi chúng đã được đặt ở thứ bậc cho phép.

Công cụ này cũng có thể được sử dụng để "kết hợp" các thứ bậc trong factor, bằng cách gán cho nhiều thứ bậc cùng một giá trị được mã hóa lại. Bạn cần cẩn thận để không bị mất thông tin! Cân nhắc thực hiện các bước kết hợp này trong một biến mới (không ghi đè lên biến hiện tại).

Hàm `fct_recode()` có cú pháp khác với hàm `recode()`. Hàm `recode()` sử dụng câu lệnh `OLD = NEW`, trong khi hàm `fct_recode()` sửu dụng câu lệnh `NEW = OLD`.

Những thứ bậc sẵn có của biến `delay_cat` như sau:

```{r, echo=F}
linelist <- linelist %>% 
  mutate(delay_cat = fct_relevel(delay_cat, "<2 days", after = 0))
```

```{r}
levels(linelist$delay_cat)
```

Để tạo một thứ bậc mới, bạn sử dụng câu lệnh sau `fct_recode(column, "new" = "old", "new" = "old", "new" = "old")` và in ra như sau:

```{r}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 2 days" = "<2 days",
    "2 to 5 days"      = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

Ở đây các thứ bậc cũ được kết hợp theo cách thủ công với `fct_recode()`. Lưu ý rằng không có lỗi phát sinh khi tạo thứ bậc mới "Less tham 5 days".

```{r, warning=F, message=F}
linelist %>% 
  mutate(delay_cat = fct_recode(
    delay_cat,
    "Less than 5 days" = "<2 days",
    "Less than 5 days" = "2-5 days",
    "More than 5 days" = ">5 days")) %>% 
  tabyl(delay_cat)
```

### Rút gọn thành "Other" {.unnumbered}

Bạn có thể sử dụng hàm `fct_other()` để gán các thứ bậc của factor theo cách thủ công cho thứ bậc "Other". Dưới đây, tất cả các thứ bậc trong biến `hospital`, ngoại trừ "Port Hospital" và "Central Hospital", được gộp chung thành "Other". Bạn có thể cung cấp một vectơ để giữ `keep =`, hoặc loại bỏ `drop =`. Bạn có thể thay đổi cách hiển thị của thứ bậc "Other" bằng hàm `other_level =`.

```{r}
linelist %>%    
  mutate(hospital = fct_other(                      # adjust levels
    hospital,
    keep = c("Port Hospital", "Central Hospital"),  # keep these separate
    other_level = "Other Hospital")) %>%            # All others as "Other Hospital"
  tabyl(hospital)                                   # print table

```

### Rút gọn theo tần suất {.unnumbered}

Bạn có thể tự động kết hợp các thứ bậc trong biến factor có tần suất ít nhất bằng cách sử dụng hàm `fct_lump()`.

Để "gộp" nhiều giá trị tần suất thấp lại thành một nhóm khác "Other", hãy thực hiện một trong các thao tác sau:

-   Đặt `n =` là số nhóm bạn muốn giữ. n thứ bậc có tần suất nhiều nhất sẽ được giữ nguyên và tất cả các cấp độ khác sẽ kết hợp thành nhóm "Other".
-   Đặt `prop =` là ngưỡng tỷ lệ cho các thứ bậc bạn muốn giữ ở trên. Tất cả các giá trị khác sẽ kết hợp thành nhóm "Other".

Bạn có thể thay đổi cách hiển thị của thứ bậc "Other" bằng hàm `other_level =`. Dưới đây, tất cả các giá trị ngoài hai bệnh viện phổ biến nhất đều được kết hợp thành nhóm "Other Hospital".

```{r, warning=F, message=F}
linelist %>%    
  mutate(hospital = fct_lump(                      # adjust levels
    hospital,
    n = 2,                                          # keep top 2 levels
    other_level = "Other Hospital")) %>%            # all others as "Other Hospital"
  tabyl(hospital)                                   # print table

```

## Hiển thị tất cả thứ bậc

Một lợi ích của việc sử dụng factors là chuẩn hóa sự xuất hiện của các chú thích trong biểu đồ và bảng, bất kể giá trị nào thực sự có trong tập dữ liệu.

Nếu bạn đang chuẩn bị nhiều bảng biểu (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú giải và bảng xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thành dữ liệu hoặc thành phần dữ liệu khác nhau.

### Trong biểu đồ {.unnumbered}

Trong hàm vẽ biểu đồ `ggplot ()`, chỉ cần thêm đối số `drop = FALSE` trong hàm liên quan `scale_xxxx()`. Tất cả các thứ bậc trong biến factor sẽ được hiển thị, bất kể chúng có trong dữ liệu hay không. Nếu các thứ bậc trong biến factor của bạn được hiển thị bằng cách sử dụng `fill =`, thì trong `scale_fill_discrete ()`, bạn cần thêm `drop = FALSE`, như được trình bày bên dưới. Nếu các thứ bậc trong biến factor của bạn được hiển thị với `x =` (đến trục x) `color =` hoặc `size =`, bạn sẽ cung cấp chúng tới `scale_color_discrete()` hoặc `scale_size_discrete()`.

Ví dụ này là một biểu đồ cột chồng của nhóm tuổi, theo bệnh viện. Việc thêm `scale_fill_discrete (drop = FALSE)` đảm bảo rằng tất cả các nhóm tuổi đều xuất hiện trong chú giải, ngay cả khi không có trong dữ liệu.

```{r}
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = hospital, fill = age_cat)) +
  scale_fill_discrete(drop = FALSE)+                        # show all age groups in the legend, even those not present
  labs(
    title = "All age groups will appear in legend, even if not present in data")
```

### Trong bảng {.unnumbered}

Cả hàm `table()` trong **base** R và hàm `tabyl()` trong package **janitor** đều sẽ hiển thị tất cả các thứ bậc trong factor (ngay cả các thứ bậc không sử dụng).

Nếu bạn sử dụng hàm `count()` hoặc `summarise()` từ package **dplyr** để tạo bảng, hãy thêm đối số `.drop = FALSE` để hiển thị số lượng cho tất cả các thứ bậc trong factor ngay cả các thứ bậc không sử dụng.

Đọc thêm tại chương [Bảng mô tả],hoặc tại các link sau [scale_discrete documentation](https://ggplot2.tidyverse.org/reference/scale_discrete.html), hoặc [count() documentation](https://dplyr.tidyverse.org/reference/count.html). Bạn có thể tìm các ví dụ khác tại chương [Truy vết tiếp xúc].

## Tuần dịch tễ

Vui lòng xem phần thảo luận đầy đủ về cách tạo các tuần dịch tễ trong chương [Nhóm dữ liệu].\
Vui lòng xem chương [Làm việc với ngày tháng] để biết các mẹo về cách tạo và định dạng các tuần dịch tễ học.

### Tuần dịch tễ trong biểu đồ {.unnumbered}

Nếu mục tiêu của bạn là tạo các tuần dịch tễ học để hiển thị trong một biểu đồ, bạn có thể thực hiện việc này đơn giản với hàm `floor_date()` trong package **lubridate**, như được giải thích trong chương [Nhóm dữ liệu]. Các giá trị trả về sẽ thuộc loại Ngày tháng với định dạng YYYY-MM-DD. Nếu bạn sử dụng cột này trong một biểu đồ, ngày tháng sẽ tự nhiên được sắp xếp chính xác và bạn không cần phải lo lắng về thứ bậc hoặc chuyển đổi sang dạng factor. Xem biểu đồ histogram trong hàm `ggplot()` về các ngày khởi phát bên dưới.

Trong cách tiếp cận này, bạn có thể điều chỉnh *việc hiển thị* của ngày tháng trên trục với `scale_x_date()`. Xem thêm tại trang [Đường cong dịch bệnh] để biết thêm thông tin. Bạn có thể chỉ định định dạng hiển thị `date_labels =` cho đối số `scale_x_date()`. Sử dụng "% Y" để đại diện cho năm có 4 chữ số và "% W" hoặc "% U" để đại diện cho số tuần (các tuần thứ Hai hoặc Chủ Nhật tương ứng).

```{r, warning=F, message=F}
linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week")) %>%  # create week column
  ggplot()+                                                  # begin ggplot
  geom_histogram(mapping = aes(x = epiweek_date))+           # histogram of date of onset
  scale_x_date(date_labels = "%Y-W%W")                       # adjust disply of dates to be YYYY-WWw
```

### Tuần dịch tễ trong dữ liệu {.unnumbered}

Tuy nhiên, nếu mục đích của bạn với biến factor *không phải* để lập biểu đồ, bạn có thể tiếp cận theo một trong hai cách:

1)  *Để kiểm soát tốt việc hiển thị*, hãy chuyển đổi cột **lubridate** tuần dịch tễ (YYYY-MM-DD) sang định dạng hiển thị mong muốn (YYYY-WWw) *trong chính data frame*, rồi chuyển đổi nó thành dạng factor.

Đầu tiên, sử dụng hàm `format()` từ **base** R để chuyển đổi hiển thị ngày từ hiển thị YYYY-MM-DD sang hiển thị YYYY-Www (xem thêm tại chương [Làm việc với ngày tháng]). Trong quá trình này, kiểu của biến số sẽ được chuyển đổi thành ký tự. Sau đó, chuyển đổi từ kiểu ký tự sang kiểu Factor với hàm `factor()`.

```{r}
linelist <- linelist %>% 
  mutate(epiweek_date = floor_date(date_onset, "week"),       # create epiweeks (YYYY-MM-DD)
         epiweek_formatted = format(epiweek_date, "%Y-W%W"),  # Convert to display (YYYY-WWw)
         epiweek_formatted = factor(epiweek_formatted))       # Convert to factor

# Display levels
levels(linelist$epiweek_formatted)
```

[**Nguy hiểm:** Nếu bạn đặt các tuần trước các năm ("Www-YYYY") ("%W-%Y"), thứ tự các thứ bậc sẽ sắp xếp mặc định theo bảng chữ cái và điều này là không chính xác (ví dụ: 01-2015 sẽ là trước 35-2014). Bạn có thể cần phải điều chỉnh thứ tự theo cách thủ công, đây sẽ là một quá trình dài khó khăn .]{style="color: red;"}

2)  *Để hiển thị nhanh theo mặc định*, sử dụng hàm `date2week()` trong package **aweek**. Bạn có thể đặt ngày theo hàm `week_start =`, và nếu bạn đặt đối số `factor = TRUE` thì cột đầu ra là một factor có thứ tự. Factor sẽ bao gồm các thứ bậc cho *tất cả* các tuần có thể có trong khoảng thời gian - ngay cả khi không có trường hợp nào xuất hiện trong tuần đó.

```{r, eval=F}
df <- linelist %>% 
  mutate(epiweek = date2week(date_onset, week_start = "Monday", factor = TRUE))

levels(df$epiweek)
```

Xem chương [Làm việc với ngày tháng] để biết thêm thông tin về package **aweek**. Nó cũng cung cấp thông tin về hàm đảo ngược `week2date()`.

<!-- ======================================================= -->

## Nguồn tham khảo

R trong Khoa học dữ liệu, chương [factors](https://r4ds.had.co.nz/factors.html)\
[aweek package vignette](https://cran.r-project.org/web/packages/aweek/vignettes/introduction.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/factors.Rmd-->

<!-- ======================================================= -->

<!-- ======================================================= -->

<!-- ======================================================= -->

# Xoay trục dữ liệu {#pivoting}

```{r, warning=F, message=F, out.height = c('50%'), fig.align="center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pivoting", "Pivoting_500x500.png"))

#knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_bar.png"))
#knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

Khi quản lý dữ liệu, *xoay trục* có thể được hiểu là đề cập đến một trong hai quy trình:

1.  Tạo *bảng dữ liệu tổng hợp (pivot tables)*, là bảng thống kê tóm tắt dữ liệu từ một bảng dữ liệu lớn hơn.\
2.  Chuyển đổi một bảng từ định dạng **dọc** sang định dạng **ngang** hoặc ngược lại.

**Trong chương này, chúng ta sẽ tập trung vào định nghĩa thứ hai**. Định nghĩa thứ nhất là một bước quan trọng trong phân tích dữ liệu và được đề cập ở những chương khác như trong chương [Nhóm dữ liệu] và [Bảng mô tả].

Chương này thảo luận về các định dạng của dữ liệu. Sẽ rất hữu ích khi biết ý tưởng về "dữ liệu gọn gàng", trong đó mỗi biến có cột riêng, mỗi quan sát có hàng riêng và mỗi giá trị có ô riêng. Bạn có thể tìm thêm thông tin về chủ đề này tại [bản trực tuyến của sách R for Data Science](https://r4ds.had.co.nz/tidy-data.html).

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ **pacman**, cài đặt package nếu cần và gọi ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  tidyverse)    # data management + ggplot2 graphics
```

### Nhập dữ liệu {.unnumbered}

### Dữ liệu số trường hợp sốt rét {.unnumbered}

Trong chương này, chúng ta sẽ sử dụng một bộ dữ liệu giả định về các trường hợp ghi nhận sốt rét hàng ngày, theo cơ sở y tế và nhóm tuổi. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/malaria_facility_count_data.rds' class='download-button'>bấm vào đây để tải tệp tin (tệp .rds)<span></a>. Nhập dữ liệu bằng hàm `import()` từ package **rio** (xử lý nhiều loại tệp tin như .xlsx; .csv; .rds - xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()
```

```{r, eval=F}
# Import data
count_data <- import("malaria_facility_count_data.rds")
```

Dưới đây là 50 hàng đầu tiên được hiển thị.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Bộ dữ liệu các trường hợp `linelist` {.unnumbered}

Trong phần cuối của chương này, chúng ta cũng sẽ sử dụng tập dữ liệu mô phỏng về các trường hợp từ một vụ dịch Ebola. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm vào đây để tải bộ dữ liệu `linelist` "đã làm sạch"</a> (tệp .rds). Nạp dữ liệu bằng hàm `import()` từ package **rio** (package này chấp nhận nhiều loại tệp tin dạng .xlsx; .csv; .rds - xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import your dataset
linelist <- import("linelist_cleaned.xlsx")
```

<!-- ======================================================= -->

## Định dạng dữ liệu từ "ngang-sang-dọc"

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

<!-- ======================================================= -->

### Định dạng "ngang" {.unnumbered}

Dữ liệu thường được nhập và lưu trữ ở định dạng "ngang" - nghĩa là các đặc điểm hoặc phản hồi của chủ thể được lưu trữ trong một hàng duy nhất. Mặc dù điều này có thể hữu ích cho việc hiển thị, tuy nhiên chưa phải là lý tưởng cho một số phân tích.

Chúng ta hãy lấy bộ dữ liệu `count_data` đã nhắc đến trong phần Chuẩn bị ở trên để làm ví dụ. Bạn có thể thấy rằng mỗi hàng đại diện cho một "cơ sở y tế-ngày (facility-day)". Số lượng trường hợp thực tế (các cột ngoài cùng bên phải) được lưu trữ ở định dạng "ngang", nghĩa là thông tin cho mọi nhóm tuổi trong một cơ sở y tế-ngày nhất định được lưu trữ trong một hàng.

```{r, echo=F}
DT::datatable(count_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

Mỗi quan sát trong bộ dữ liệu này đề cập đến số lượng ca sốt rét tại một trong 65 cơ sở y tế vào một ngày cụ thể, trong khoảng từ `count_data$data_date %>% min()` đến `count_data$data_date %>% max()`. Các cơ sở này nằm ở một tỉnh `Province` (North) và bốn quận `District` (Spring, Bolo, Dingo và Barnard). Bộ dữ liệu cung cấp số lượng tổng thể của các ca bệnh sốt rét, cũng như số lượng cụ thể theo độ tuổi ở mỗi nhóm trong ba nhóm tuổi - \<4 tuổi, 5-14 tuổi và từ 15 tuổi trở lên.

Dữ liệu "ngang" như vậy không tuân theo tiêu chuẩn "dữ liệu gọn gàng", bởi vì tiêu đề cột không thực sự đại diện cho "biến" - chúng đại diện cho các *giá trị* của biến giả định là "nhóm tuổi" .

Định dạng kiểu này có thể hữu ích để trình bày thông tin trong bảng hoặc để nhập dữ liệu (ví dụ: trong Excel) từ các biểu mẫu báo cáo ca bệnh (CRFs). Tuy nhiên, trong quá trình phân tích, những dữ liệu này thường phải được chuyển đổi sang định dạng "dọc" để phù hợp hơn với các tiêu chuẩn về "dữ liệu gọn gàng". Package vẽ biểu đồ **ggplot2** trong R nói riêng hoạt động tốt nhất khi dữ liệu ở định dạng "dọc".

Trực quan hóa *tổng số lượng* ca sốt rét theo thời gian không gây khó khăn gì với dữ liệu ở định dạng hiện tại:

```{r, warning=F, message=F}
ggplot(count_data) +
  geom_col(aes(x = data_date, y = malaria_tot), width = 1)
```

Tuy nhiên, điều gì sẽ xảy ra nếu chúng ta muốn hiển thị các đóng góp một cách tương đối của từng nhóm tuổi vào tổng số này? Trong trường hợp này, chúng ta cần đảm bảo rằng biến quan tâm (nhóm tuổi), xuất hiện trong bộ dữ liệu trong một cột duy nhất có thể được chuyển tiếp tới đối số `aes()` "mapping aesthetics" trong `{ggplot2}`.

<!-- ======================================================= -->

### `pivot_longer()` {.unnumbered}

Hàm `pivot_longer()` trong **tidyr** giúp biến đổi dữ liệu thành định dạng "dọc". **tidyr** là một package con trong hệ sinh thái **tidyverse** của R.

Hàm này chấp nhận sử dụng nhiều cột cùng thực hiện biến đổi (cụ thể với `cols =`). Do đó, nó chỉ có thể hoạt động trên một phần của bộ dữ liệu. Điều này rất hữu ích cho bộ dữ liệu về sốt rét, vì chúng ta chỉ muốn xoay trục các cột số ca bệnh.

Trong quá trình này, kết quả trả về hai cột "mới" - một cột có các danh mục (tên cột cũ) và một cột chứa các giá trị tương ứng (ví dụ: số lượng ca bệnh). Bạn có thể chấp nhận tên mặc định của cột mới hoặc có thể tùy chỉnh bằng `names_to =` và `values_to =`, tương ứng.

Hãy cùng xem hàm `pivot_longer()` hoạt động như thế nào ...

### Xoay trục tiêu chuẩn {.unnumbered}

Chúng ta muốn sử dụng hàm `pivot_longer()` trong package **tidyr** để chuyển đổi dữ liệu từ "ngang" sang định dạng "dọc". Cụ thể, để chuyển đổi bốn cột dạng số có dữ liệu về số lượng ca sốt rét thành hai cột mới: một cột chứa *nhóm tuổi* và một cột chứa các *giá trị* tương ứng.

```{r, eval=F}
df_long <- count_data %>% 
  pivot_longer(
    cols = c(`malaria_rdt_0-4`, `malaria_rdt_5-14`, `malaria_rdt_15`, `malaria_tot`)
  )

df_long
```

Lưu ý rằng bộ dữ liệu mới được tạo (`df_long`) có nhiều hàng hơn (12.152 so với 3.038); bộ dữ liệu đã trở nên "*dài hơn*". Trên thực tế, bộ dữ liệu đã dài hơn gấp bốn lần, bởi vì mỗi hàng trong tập dữ liệu ban đầu hiện đại diện cho bốn hàng trong `df_long`, một hàng cho mỗi quan sát số lượng ca sốt rét (\<4 tuổi, 5-14 tuổi, 15+ tuổi và tổng số).

Ngoài việc dài hơn, bộ dữ liệu mới có ít cột hơn (8 so với 10), vì dữ liệu trước đây được lưu trữ trong bốn cột (những cột bắt đầu bằng tiền tố `malaria_`), hiện được lưu trữ chỉ trong hai cột.

Vì tên của bốn cột này đều bắt đầu bằng tiền tố `malaria_`, chúng ta có thể sử dụng hàm "tidyselect" `starts_with()` để đạt được kết quả tương tự (xem chương [Làm sạch số liệu và các hàm quan trọng] để biết thêm về các hàm trợ giúp này).

```{r}
# provide column with a tidyselect helper function
count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_")
  )
```

hoặc sử dụng vị trí cột:

```{r, eval=F}
# provide columns by position
count_data %>% 
  pivot_longer(
    cols = 6:9
  )
```

hoặc sử dụng khoảng tên cột:

```{r, eval=F}
# provide range of consecutive columns
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_tot
  )
```

Hai cột mới này được đặt tên mặc định là `name` và `value`, nhưng chúng ta có thể ghi đè các giá trị mặc định này để cung cấp tên cột có ý nghĩa hơn, có thể giúp ghi nhớ dễ dàng đặc điểm các giá trị được lưu trữ bên trong, bằng cách sử dụng các đối số `names_to` và `values_to`. Hãy sử dụng tên `age_group` và `counts`:

```{r}
df_long <- 
  count_data %>% 
  pivot_longer(
    cols = starts_with("malaria_"),
    names_to = "age_group",
    values_to = "counts"
  )

df_long
```

Bây giờ chúng ta có thể chuyển tiếp bộ dữ liệu mới này tới `{ggplot2}`, và định vị cột mới `count` với trục y và cột mới `age_group` tới độ số `fill =` (màu bên trong cột). Việc này giúp hiển thị số lượng ca bệnh sốt rét trong một biểu đồ cột chồng, theo nhóm tuổi:

```{r, warning=F, message=F}
ggplot(data = df_long) +
  geom_col(
    mapping = aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Kiểm tra biểu đồ mới này và so sánh với biểu đồ chúng ta đã tạo trước đó - *hãy xem điều gì đã xảy ra?*

Chúng ta đã gặp phải một vấn đề phổ biến khi tổng hợp dữ liệu giám sát - chúng ta cũng đã gộp tổng số từ cột `malaria_tot`, vì vậy độ lớn của mỗi thanh trong biểu đồ cao gấp đôi so với bình thường.

Chúng ta có thể xử lý vấn đề này theo một số cách. Chúng ta có thể đơn giản lọc bỏ tổng số này ra khỏi bộ dữ liệu trước khi chuyển tới `ggplot()`:

```{r, warning=F, message=F}
df_long %>% 
  filter(age_group != "malaria_tot") %>% 
  ggplot() +
  geom_col(
    aes(x = data_date, y = counts, fill = age_group),
    width = 1
  )
```

Ngoài ra, chúng ta có thể đã loại bỏ biến này khi chúng ta chạy lệnh `pivot_longer()`, bằng cách đó có thể giữ biến đó trong bộ dữ liệu như một biến riêng biệt. Hãy xem cách mà giá trị của biến này "mở rộng" để lấp đầy các hàng mới.

```{r, warning=F, message=F}
count_data %>% 
  pivot_longer(
    cols = `malaria_rdt_0-4`:malaria_rdt_15,   # does not include the totals column
    names_to = "age_group",
    values_to = "counts"
  )
```

### Xoay trục dữ liệu trên nhiều định dạng cột {.unnumbered}

Ví dụ trên hoạt động ổn trong các trường hợp mà tất cả các cột bạn muốn "xoay trục dọc" đều thuộc cùng một phân lớp, định dạng (ký tự, số, lôgic, ...).

Tuy nhiên, sẽ có nhiều trường hợp, với tư cách là một nhà dịch tễ học thực địa, bạn sẽ làm việc với dữ liệu được chuẩn bị bởi những người không phải là chuyên gia và tuân theo những logic không chuẩn của riêng họ - như Hadley Wickham đã lưu ý (trích dẫn từ Tolstoy) trong [bài báo](https://vita.had.co.nz/papers/tidy-data.pdf) của ông ấy về nguyên tắc của **dữ liệu gọn gàng**: "Các bộ dữ liệu sạch đều giống nhau nhưng mọi bộ dữ liệu lộn xộn đều lộn xộn theo cách riêng của nó."

Một vấn đề đặc biệt phổ biến mà bạn sẽ gặp phải là nhu cầu xoay trục các cột chứa các phân lớp dữ liệu khác nhau. Việc xoay trục này sẽ dẫn đến việc lưu trữ các kiểu định dạng dữ liệu khác nhau này trong cùng một cột duy nhất, và đây không phải là một kịch bản tốt. Có nhiều cách tiếp cận khác nhau mà người ta có thể thực hiện để loại bỏ sự hỗn độn này, nhưng có một bước quan trọng bạn có thể thực hiện bằng cách sử dụng hàm `pivot_longer()` để tránh tạo ra tình huống như vậy.

Hãy thực hiện một tình huống trong đó có một loạt các quan sát ở các sự kiện thời gian khác nhau cho từng danh mục trong số ba danh mục A, B và C. Ví dụ về các danh mục đó có thể là từng cá nhân (ví dụ: các mối liên hệ của một trường hợp Ebola được theo dõi mỗi ngày trong 21 ngày) hoặc các trạm y tế thôn bản vùng sâu, vùng xa được theo dõi mỗi năm một lần để đảm bảo chúng vẫn được duy trì hoạt động. Hãy sử dụng ví dụ theo dõi mối liên hệ. Hãy tưởng tượng rằng dữ liệu sẽ được lưu trữ như sau:

```{r, message=FALSE, echo=F}

df <- 
  tibble::tribble(
     ~id,   ~obs1_date, ~obs1_status,   ~obs2_date, ~obs2_status,   ~obs3_date, ~obs3_status,
     "A", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",     "Unwell",
     "B", "2021-04-23",    "Healthy", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy",
     "C", "2021-04-23",    "Missing", "2021-04-24",    "Healthy", "2021-04-25",    "Healthy"
     ) 

DT::datatable(df, rownames = FALSE)

```

Có thể thấy, dữ liệu hơi phức tạp. Mỗi hàng lưu trữ thông tin về một danh mục, nhưng với chuỗi thời gian chạy ngày càng xa về bên phải khi thời gian tịnh tiến. Hơn nữa, các cột dạng phân loại xen kẽ giữa các giá trị ngày tháng và giá trị ký tự.

Một ví dụ đặc biệt tồi tệ mà tác giả này gặp phải liên quan đến dữ liệu giám sát dịch tả, trong đó 8 cột quan sát mới được thêm vào mỗi *ngày* trong suốt **4 năm**. Mất hơn 10 phút trên máy tính xách tay của tôi chỉ để mở tệp tin Excel lưu trữ những dữ liệu này!

Để làm việc với những dữ liệu này, chúng ta cần chuyển đổi bộ dữ liệu sang định dạng dọc, nhưng vẫn giữ sự riêng biệt giữa cột `date` và cột `character` (trạng thái), cho mỗi quan sát cho mỗi danh mục. Nếu không, chúng ta có thể thu về một sự hỗn hợp các loại biến trong một cột duy nhất (một sự "ngỡ ngàng vô định" khi nhắc đến quản lý dữ liệu và dữ liệu sạch):

```{r}
df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation")
  )

```

Ở trên, trục xoay của chúng ta đã hợp nhất giá trị *ngày* và giá trị *ký tự* trong cùng một cột giá trị duy nhất. R sẽ hoạt động bằng cách chuyển toàn bộ cột thành định dạng ký tự, và các định dạng liên quan đến giá trị ngày sẽ không còn.

Để ngăn chặn tình trạng này, chúng ta có thể tận dụng cấu trúc cú pháp của các tên cột ban đầu. Có một cấu trúc đặt tên phổ biến, với số quan sát, dấu gạch dưới và sau đó là "trạng thái" hoặc "ngày-tháng". Chúng ta có thể tận dụng cú pháp này để giữ lại hai kiểu dữ liệu này trong các cột riêng biệt sau khi xoay trục.

Chúng ta thực hiện như sau:

-   Cung cấp một vectơ dạng ký tự cho đối số `names_to =`, với mục thứ hai là (`".value"`). Thuật ngữ đặc biệt này chỉ ra rằng các cột được xoay trục sẽ được phân chia dựa trên ký tự trong tên của chúng ...\
-   Bạn cũng cần cung cấp ký tự "phân tách" cho đối số `names_sep =`. Trong trường hợp này, đó là dấu gạch dưới "\_".

Do đó, việc đặt tên và tách cột mới được dựa trên dấu gạch dưới trong các tên biến hiện có.

```{r}

df_long <- 
  df %>% 
  pivot_longer(
    cols = -id,
    names_to = c("observation", ".value"),
    names_sep = "_"
  )

df_long

```

**Hoàn thiện:**

Lưu ý rằng cột `date` hiện đang ở dạng *ký tự* - chúng ta có thể dễ dàng chuyển đổi cột này thành dạng ngày thích hợp bằng cách sử dụng hàm `mutate()` và `as_date()` được mô tả trong chương [Làm việc với ngày tháng].

Chúng ta cũng có thể muốn chuyển đổi cột `observation` sang định dạng `numeric` bằng cách bỏ tiền tố "obs" và chuyển đổi thành số. Chúng ta có thể thực hiện với hàm `str_remove_all()` từ package **stringr** (xem chương [Ký tự và chuỗi]).

```{r}

df_long <- 
  df_long %>% 
  mutate(
    date = date %>% lubridate::as_date(),
    observation = 
      observation %>% 
      str_remove_all("obs") %>% 
      as.numeric()
  )

df_long

```

Và bây giờ, chúng ta có thể bắt đầu làm việc với dữ liệu ở định dạng này, ví dụ: bằng cách vẽ biểu đồ mô tả dạng lưới-nhiệt:

```{r}
ggplot(data = df_long, mapping = aes(x = date, y = id, fill = status)) +
  geom_tile(colour = "black") +
  scale_fill_manual(
    values = 
      c("Healthy" = "lightgreen", 
        "Unwell" = "red", 
        "Missing" = "orange")
  )

```

<!-- ======================================================= -->

## Dọc-thành-ngang

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_wider_new.png"))
```

Trong một số trường hợp, chúng ta có thể muốn chuyển đổi bộ dữ liệu sang định dạng ngang. Đối với điều này, chúng ta có thể sử dụng hàm `pivot_wider()`.

Tình huống phổ biến là khi chúng ta muốn chuyển đổi kết quả phân tích thành một định dạng dễ hiểu hơn cho người đọc (chẳng hạn như trong chương [Trình bày bảng]). Thông thường, điều này bao gồm việc chuyển đổi một bộ dữ liệu trong đó thông tin chủ thể được trải rộng trên nhiều hàng, sau đó được thống nhất thành một định dạng mà thông tin được lưu trữ trên một hàng duy nhất.

### Dữ liệu {.unnumbered}

Trong chương này, chúng ta sẽ sử dụng bộ dữ liệu ca bệnh `linelist` (xem mục [Chuẩn bị](#pivot_prep)), với mỗi trường hợp nằm trên một hàng.

Dưới đây là 50 hàng đầu tiên:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Giả sử rằng chúng ta muốn biết số lượng cá thể ở các nhóm tuổi khác nhau, theo giới tính:

```{r}
df_wide <- 
  linelist %>% 
  count(age_cat, gender)

df_wide
```

Điều này cho chúng ta một bộ dữ liệu dạng dọc, rất tốt để trực quan hóa trong **ggplot2**, nhưng không lý tưởng để trình bày bảng:

```{r}
ggplot(df_wide) +
  geom_col(aes(x = age_cat, y = n, fill = gender))
```

### Xoay trục ngang {.unnumbered}

Do đó, chúng ta có thể sử dụng hàm `pivot_wider()` để chuyển đổi dữ liệu sang định dạng tốt hơn để đưa vào các bảng trong báo cáo.

Đối số `names_from` chỉ định cột mà *từ đó* tạo ra *tên* cột mới, trong khi đối số `values_from` chỉ định cột mà *từ đó* nhận các *giá trị* để điền. Đối số `id_cols =` là tùy chọn, nhưng nó có thể được chứa một vectơ tên các cột không xoay trục và do đó sẽ xác định từng hàng.

```{r}
table_wide <- 
  df_wide %>% 
  pivot_wider(
    id_cols = age_cat,
    names_from = gender,
    values_from = n
  )

table_wide
```

Bảng này thân thiện với người đọc hơn nhiều và có thể thêm vào báo cáo của chúng ta. Bạn có thể chuyển đổi thành một bảng tuyệt vời với một số package bao gồm **flextable** và **knitr**. Quá trình này được trình bày chi tiết trong chương [Trình bày bảng].

```{r}
table_wide %>% 
  janitor::adorn_totals(c("row", "col")) %>% # adds row and column totals
  knitr::kable() %>% 
  kableExtra::row_spec(row = 10, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

------------------------------------------------------------------------

<!-- ======================================================= -->

## Điền

Trong một số tình huống sau khi `pivot`, và phổ biến hơn là sau khi `bind`, chúng ta sẽ để lại một số ô trống mà chúng ta sẽ muốn lấp đầy.

<!-- ======================================================= -->

### Dữ liệu {.unnumbered}

Ví dụ: lấy hai bộ dữ liệu, mỗi bộ dữ liệu có các quan sát về các đại lượng đo lường, tên của cơ sở y tế và số ca bệnh tại thời điểm đó. Tuy nhiên, bộ dữ liệu thứ hai cũng có biến `Year`.

```{r}
df1 <- 
  tibble::tribble(
       ~Measurement, ~Facility, ~Cases,
                  1,  "Hosp 1",     66,
                  2,  "Hosp 1",     26,
                  3,  "Hosp 1",      8,
                  1,  "Hosp 2",     71,
                  2,  "Hosp 2",     62,
                  3,  "Hosp 2",     70,
                  1,  "Hosp 3",     47,
                  2,  "Hosp 3",     70,
                  3,  "Hosp 3",     38,
       )

df1 

df2 <- 
  tibble::tribble(
    ~Year, ~Measurement, ~Facility, ~Cases,
     2000,            1,  "Hosp 4",     82,
     2001,            2,  "Hosp 4",     87,
     2002,            3,  "Hosp 4",     46
  )

df2
```

Khi chúng ta thực hiện lệnh `bind_rows()` để nối hai bộ dữ liệu với nhau, biến `Year` được điền `NA` cho những hàng không có thông tin trước đó (ví dụ là bộ dữ liệu đầu tiên):

```{r}
df_combined <- 
  bind_rows(df1, df2) %>% 
  arrange(Measurement, Facility)

df_combined

```

<!-- ======================================================= -->

### `fill()` {.unnumbered}

Trong trường hợp này, `Year` là một biến hữu ích cần để thêm vào bộ số liệu, đặc biệt nếu chúng ta muốn tìm hiểu các xu hướng theo thời gian. Do đó, chúng ta sử dụng hàm `fill()` để *điền* vào các ô trống đó, bằng cách chỉ định cột và hướng cần điền (trong trường hợp này là hướng **từ dưới lên trên**):

```{r}
df_combined %>% 
  fill(Year, .direction = "up")
```

Ngoài ra, chúng ta có thể sắp xếp lại dữ liệu để chúng ta cần điền theo hướng từ trên xuống dưới:

```{r}
df_combined <- 
  df_combined %>% 
  arrange(Measurement, desc(Facility))

df_combined

df_combined <- 
  df_combined %>% 
  fill(Year, .direction = "down")

df_combined
```

Bây giờ chúng ta có một bộ dữ liệu sạch để vẽ biểu đồ:

```{r}
ggplot(df_combined) +
  aes(Year, Cases, fill = Facility) +
  geom_col()
```

Nhưng ít hữu ích cho việc trình bày bảng, vì vậy hãy thực hành chuyển đổi bộ dữ liệu dọc-chưa làm sạch này thành một bộ dữ liệu ngang-sạch:

```{r}
df_combined %>% 
  pivot_wider(
    id_cols = c(Facility, Year, Cases),
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  arrange(Facility) %>% 
  janitor::adorn_totals(c("row", "col")) %>% 
  knitr::kable() %>% 
  kableExtra::row_spec(row = 5, bold = TRUE) %>% 
  kableExtra::column_spec(column = 5, bold = TRUE) 
```

Chú ý: Trong trường hợp này, chúng ta cần chỉ định chỉ bao gồm ba biến `Facility`, `Year`, và `Cases` vì biến bổ sung `Measurement` sẽ khiến khó khăn hơn khi tạo bảng:

```{r}
df_combined %>% 
  pivot_wider(
    names_from = "Year",
    values_from = "Cases"
  ) %>% 
  knitr::kable()
```

## Tài liệu tham khảo

Đây là một [hướng dẫn](https://datacarpentry.org/r-socialsci/03-dplyr-tidyr/index.html) bổ ích
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/pivoting.Rmd-->

# Nhóm dữ liệu {#grouping}

```{r, out.width=c('100%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "Grouping_1500x500.png"))
```

Chương này trình bày cách nhóm và tổng hợp dữ liệu phục vụ phân tích mô tả. Sử dụng các package trong hệ sinh thái **tidyverse** với các hàm phổ biến và dễ sử dụng.

Nhóm dữ liệu là một cấu phần cốt lõi trong quản lý và phân tích dữ liệu. Dữ liệu được nhóm tổng hợp thống kê theo nhóm và có thể được vẽ biểu đồ theo nhóm. Các hàm từ package **dplyr** (một phần của thư viện **tidyverse**) giúp việc nhóm dữ liệu và các thao tác tiếp theo trở nên dễ dàng hơn.

Chương này sẽ giải quyết các chủ đề sau:

-   Nhóm dữ liệu với hàm `group_by()`\
-   Gỡ nhóm dữ liệu\
-   `summarise()` dữ liệu được nhóm với các thống kê \
-   Sự khác biệt giữa hàm `count()` và `tally()`\
-   Ứng dụng hàm `arrange()` với dữ liệu được nhóm\
-   Ứng dụng hàm `filter()` với dữ liệu được nhóm\
-   Ứng dụng hàm `mutate()` với dữ liệu được nhóm\
-   Ứng dụng hàm `select()` với dữ liệu được nhóm\
-   Hàm `aggregate()` trong **base** R như một lựa chọn thay thế 

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn này, chúng ta nhấn mạnh đến hàm `p_load()` từ package **pacman**, sẽ cài đặt packahe nếu cần *và* gọi để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r}
pacman::p_load(
  rio,       # to import data
  here,      # to locate files
  tidyverse, # to clean, handle, and plot the data (includes dplyr)
  janitor)   # adding total rows and columns
```

### Nhập dữ liệu {.unnumbered}

Chúng ta nhập bộ dữ liệu về các trường hợp mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn cùng thực hành, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm vào đây để tải bộ liệu `linelist` "sạch"</a> (tệp .rds). Bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau.

```{r, echo=F}
linelist <- rio::import(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ số liệu `linelist`:

```{r message=FALSE, echo=F}
DT::datatable(head(linelist,50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Nhóm

Hàm `group_by()` từ **dplyr** nhóm các hàng theo các giá trị duy nhất trong cột chỉ định. Nếu nhiều cột được chỉ định, các hàng được nhóm theo sự tổ hợp các giá trị thành giá trị duy nhất từ các cột. Mỗi giá trị duy nhất (hoặc tổ hợp các giá trị) tạo thành một nhóm. Những thay đổi sau đó đối với bộ dữ liệu hoặc các phép tính có thể thực hiện tùy theo đặc điểm của mỗi nhóm.

Ví dụ: lệnh bên dưới truy vấn bộ số liệu `linelist` và nhóm các hàng theo giá trị duy nhất trong cột `outcome`, lưu kết quả đầu ra dưới dạng bộ dữ liệu mới có tên `ll_by_outcome`. (Các) cột được nhóm được đặt bên trong dấu ngoặc đơn của hàm `group_by()`.

```{r}
ll_by_outcome <- linelist %>% 
  group_by(outcome)
```

**Lưu ý rằng không có thay đổi dễ nhận thấy nào đối với bộ dữ liệu** sau khi chạy lệnh `group_by()`, *cho đến khi* phối hợp thêm một số hàm từ **dplyr** khác như `mutate()`, `summarise()`, hoặc `arrange()` trong bộ dữ liệu "đã được nhóm".

Tuy nhiên, bạn có thể "xem" các nhóm bằng cách in bộ dữ liệu. Khi bạn in một bộ dữ liệu được nhóm, bạn sẽ thấy nó đã được chuyển đổi thành một [đối tượng dạng `tibble`](https://tibble.tidyverse.org/), mà khi được in ra, sẽ hiển thị những nhóm nào đã được áp dụng và có bao nhiêu nhóm - được viết ngay phía trên hàng tiêu đề.

```{r}
# print to see which groups are active
ll_by_outcome
```

### Nhóm duy nhất {.unnumbered}

**Các nhóm được tạo phản ánh từng tổ hợp giá trị duy nhất dọc theo các cột được sử dụng để nhóm.**

Để xem các nhóm *và số hàng trong mỗi nhóm*, hãy chuyển tiếp dữ liệu được nhóm đến hàm `tally()`. Nếu chỉ cần xem các nhóm duy nhất mà không cần số lượng, bạn có thể sử dụng hàm `group_keys()`.

Dưới đây là ba giá trị duy nhất trong cột được nhóm là `outcome`: "Death", "Recover", và `NA`. Ta thấy rằng đã có `nrow(linelist %>% filter(outcome == "Death"))` tử vong, `nrow(linelist %>% filter(outcome == "Recover"))` hồi phục, và `nrow(linelist %>% filter(is.na(outcome)))` không có outcome nào được ghi nhận.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally()
```

Bạn có thể nhóm nhiều hơn một cột. Dưới đây, bộ dữ liệu được nhóm theo `outcome` và `gender`, sau đó được đánh số. Lưu ý cách mỗi kết hợp duy nhất của `outcome` và `gender` được tổ hợp thành nhóm riêng - bao gồm cả các giá trị bị thiếu ở một trong hai cột.

```{r}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally()
```

### Cột mới {.unnumbered}

Bạn cũng có thể tạo một cột mới dùng để nhóm *trong* câu lệnh `group_by()`. Điều này tương đương với việc sử dụng hàm `mutate()` trước khi sử dụng hàm `group_by()`. Để tạo cột nhanh, cách này có thể hữu ích, nhưng để rõ ràng hơn trong code của bạn, hãy cân nhắc cách tạo cột này ở bước `mutate()` và sau đó chuyển tiếp đến hàm `group_by()`.

```{r}
# group dat based on a binary column created *within* the group_by() command
linelist %>% 
  group_by(
    age_class = ifelse(age >= 18, "adult", "child")) %>% 
  tally(sort = T)
```

### Thêm/bỏ cột được nhóm {.unnumbered}

Mặc định, nếu bạn chạy lệnh `group_by()` trên dữ liệu đã được nhóm, các nhóm cũ sẽ bị xóa và (các) nhóm mới sẽ được áp dụng. Nếu bạn muốn thêm nhóm mới vào nhóm hiện có, hãy thêm đối số `.add = TRUE`.

```{r, eval=F}
# Grouped by outcome
by_outcome <- linelist %>% 
  group_by(outcome)

# Add grouping by gender in addition
by_outcome_gender <- by_outcome %>% 
  group_by(gender, .add = TRUE)
```

## Giữ tất cả các nhóm

Nếu bạn nhóm trên một cột dạng factor, có thể có các thứ bậc của factor mà không có trong dữ liệu. Nếu bạn nhóm trên cột này, mặc định, những thứ bậc không có trong dữ liệu đó sẽ bị loại bỏ và không thuộc dạng nhóm. Để thay đổi điều này để tất cả các thứ bậc xuất hiện dưới dạng nhóm (ngay cả khi không có trong dữ liệu), đặt `.drop = FALSE` trong lệnh `group_by()`.

## Loại bỏ nhóm

Dữ liệu đã được nhóm sẽ vẫn được nhóm cho đến khi hủy nhóm bởi lệnh `ungroup()`. Nếu bạn quên hủy nhóm, nó có thể gây ra tính toán không chính xác! Dưới đây là ví dụ về việc loại bỏ tất cả các nhóm:

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup()
```

Bạn cũng có thể loại bỏ nhóm với các cột cụ thể, bằng cách đặt tên cột bên trong lệnh `ungroup()`.

```{r, eval=F}
linelist %>% 
  group_by(outcome, gender) %>% 
  tally() %>% 
  ungroup(gender) # remove the grouping by gender, leave grouping by outcome
```

[***GHI CHÚ***: Hàm `count()` tự động hủy nhóm dữ liệu sau khi đếm.]{style="color: black;"}

## Tổng hợp {#group_summarise}

Xem package **dplyr** trong chương [Bảng mô tả] để biết mô tả chi tiết về cách tạo bảng tổng hợp với hàm `summarise()`. Ở đây chúng ta giải quyết ngắn gọn cách hoạt động thay đổi khi áp dụng cho dữ liệu được nhóm.

Hàm **dplyr** `summarise()` (hoặc `summarize()`) lấy một data frame và chuyển nó thành một data frame tổng hợp *mới*, với các cột chứa thông tin các giá trị thống kê do bạn xác định. Trên bộ dữ liệu chưa nhóm, các tổng hợp thống kê sẽ được tính toán từ tất cả các hàng. Việc áp dụng hàm `summarise()` vào dữ liệu được nhóm sẽ tổng hợp những giá trị thống kê cho từng nhóm.

Cú pháp của hàm `summarise()` là bạn cung cấp tên của (các) cột tổng hợp mới, một dấu bằng và sau đó là một hàm thống kê để áp dụng cho dữ liệu, như được trình bày bên dưới. Ví dụ: `min()`, `max()`, `median()`, hoặc `sd()`. Trong hàm thống kê, hãy liệt kê cột sẽ được áp dụng và bất kỳ đối số nào có liên quan (ví dụ: `na.rm = TRUE`). Bạn có thể sử dụng hàm `sum()` để đếm số hàng đáp ứng tiêu chí logic (với dấu bằng kép `==`).

Dưới đây là một ví dụ về hàm `summarise()` được áp dụng mà *không có dữ liệu được nhóm*. Các giá trị thống kê trả về được tạo ra từ toàn bộ bộ dữ liệu.

```{r}
# summary statistics on ungrouped linelist
linelist %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males  = sum(gender == "m", na.rm=T))
```

Ngược lại, bên dưới là câu lệnh `summarise()` tương tự được áp dụng cho dữ liệu được nhóm. Các số liệu thống kê được tính toán cho từng nhóm kết quả. Lưu ý cách các cột dùng để nhóm sẽ chuyển sang data frame mới.

```{r}
# summary statistics on grouped linelist
linelist %>% 
  group_by(outcome) %>% 
  summarise(
    n_cases  = n(),
    mean_age = mean(age_years, na.rm=T),
    max_age  = max(age_years, na.rm=T),
    min_age  = min(age_years, na.rm=T),
    n_males    = sum(gender == "m", na.rm=T))
```

[***MẸO***: Hàm tổng hợp hoạt động với cả cách viết của kiểu Anh và Mỹ - `summarise()` và `summarize()` đều chỉ định cùng cùng một hàm.]{style="color: darkgreen;"}

## Counts và tallies

`count()` và `tally()` đều cung cấp tính năng tương tự nhưng thực chất là khác nhau. Đọc thêm về sự khác biệt giữa `tally()` và `count()` [tại đây](https://dplyr.tidyverse.org/reference/tally.html).

### `tally()` {.unnumbered}

`tally()` là viết tắt của `summarise(n = n())` và *không* nhóm dữ liệu. Do đó, để có thể kiểm đếm theo nhóm, nó phải theo sau lệnh `group_by()`. Bạn có thể thêm `sort = TRUE` để xem các nhóm lớn nhất trước tiên.

```{r}
linelist %>% 
  tally()
```

```{r}
linelist %>% 
  group_by(outcome) %>% 
  tally(sort = TRUE)
```

### `count()` {.unnumbered}

Ngược lại, hàm `count()` hoạt động như sau:

1)  Áp dụng `group_by()` trên (các) cột đã chỉ định\
2)  Áp dụng `summarise()` và trả về cột `n` với số lượng dòng mỗi nhóm\
3)  Áp dụng `ungroup()`

```{r}
linelist %>% 
  count(outcome)
```

Cũng giống như với hàm `group_by()`, bạn có thể tạo một cột mới trong lệnh `count()`:

```{r}
linelist %>% 
  count(age_class = ifelse(age >= 18, "adult", "child"), sort = T)
```

`count()` có thể được sử dụng nhiều lần, với tính năng "cuộn lên". Ví dụ: để tổng hợp số lượng bệnh viện hiện có cho mỗi giới tính, hãy chạy lệnh như sau. Lưu ý, tên của cột cuối cùng đã được thay đổi từ tên mặc định là "n" để cho rõ ràng (với `name  =`).

```{r}
linelist %>% 
  # produce counts by unique outcome-gender groups
  count(gender, hospital) %>% 
  # gather rows by gender (3) and count number of hospitals per gender (6)
  count(gender, name = "hospitals per gender" ) 
```

### Thêm giá trị đếm {.unnumbered}

Ngược lại với `count()` và `summarise()`, bạn có thể sử dụng `add_count()` để *thêm* một cột mới `n` với số lượng hàng cho mỗi nhóm *trong khi vẫn giữ lại tất cả các cột khác trong dữ liệu*.

Điều này có nghĩa là số lượng của nhóm, trong cột mới `n`, sẽ được in ra trong mỗi hàng của nhóm. Với mục đích minh họa, chúng tôi thêm cột này và sau đó sắp xếp lại các cột để dễ xem hơn. Xem mục bên dưới về [bộ lọc theo kích thước nhóm](#group_filter_grp_size) để biết một ví dụ khác.

```{r}
linelist %>% 
  as_tibble() %>%                   # convert to tibble for nicer printing 
  add_count(hospital) %>%           # add column n with counts by hospital
  select(hospital, n, everything()) # re-arrange for demo purposes
```

### Thêm giá trị tổng {.unnumbered}

Để dễ dàng thêm *tổng* các hàng hoặc cột sau khi sử dụng `tally()` hoặc `count()`, hãy xem mục **janitor** trong chương [Bảng mô tả](#tbl_janitor). Package này cung cấp các hàm như `adorn_totals()` và `adorn_percentages()` để thêm tổng và chuyển đổi sang hiển thị tỷ lệ phần trăm. Dưới đây là một ví dụ ngắn gọn:

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts of two columns
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions with column denominator
  adorn_pct_formatting() %>%                  # convert proportions to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```

Để thêm các hàng tổng phức tạp hơn bao gồm các thống kê tổng hợp khác, hãy xem [mục sau trong chương Bảng mô tả](#tbl_dplyr_totals).

## Nhóm theo ngày

Khi nhóm dữ liệu theo ngày, bạn phải có (hoặc tạo) một cột cho đơn vị ngày quan tâm - ví dụ: "ngày", "tuần dịch tễ", "tháng", v.v. Bạn có thể tạo cột này bằng cách sử dụng `floor_date()` từ **lubridate**, như được giải thích trong phần [Tuần dịch tễ học](#dates_epi_wks) trong chương [Làm việc với ngày tháng]. Khi bạn có cột này, bạn có thể sử dụng `count()` từ **dplyr** để nhóm các hàng theo các giá trị ngày duy nhất đó và thu về giá trị số lượng tổng hợp.

Một bước bổ sung phổ biến cho các tình huống với ngày/tháng, là "điền vào" bất kỳ ngày nào trong chuỗi ngày không có trong dữ liệu. Sử dụng `complete()` từ **tidyr** để chuỗi ngày tổng hợp được *hoàn chỉnh* bao gồm *tất cả các đơn vị ngày có thể có* trong phạm vi. Nếu không có bước này, một tuần không có trường hợp nào được báo cáo có thể không xuất hiện trong dữ liệu của bạn!

Trong `complete()`, bạn *xác định lại* cột ngày của mình dưới dạng một *chuỗi* ngày `seq.Date()` từ giá trị nhỏ nhất đến giá trị lớn nhất - do đó mà ngày/tháng được mở rộng. Mặc định, giá trị số lượng trong bất kỳ hàng "mở rộng" mới nào sẽ là `NA`. Bạn có thể đặt chúng thành 0 bằng cách sử dụng argument `fill =` của hàm `complete()`, trong đó yêu cầu một danh sách được đặt tên (nếu cột số lượng của bạn được đặt tên là `n`, hãy thêm `fill = list(n = 0)`). Xem `?complete` để biết chi tiết và xem ví dụ trong chương [Làm việc với ngày tháng](#dates_epi_wks).

### Các trường hợp trong `linelist` theo ngày {.unnumbered}

Dưới đây là một ví dụ về nhóm các trường hợp theo ngày mà *không* sử dụng `complete()`. Lưu ý các hàng đầu tiên bỏ qua các ngày mà không có trường hợp nào.

```{r}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%        # remove that were missing date_onset
  count(date_onset)              # count number of rows per unique date
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Dưới đây, chúng ta thêm lệnh `complete()` để đảm bảo mỗi ngày trong phạm vi đều được hiển thị.

```{r, eval=F}
daily_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove case missing date_onset
  count(date_onset) %>%                   # count number of rows per unique date
  complete(                               # ensure all days appear even if no cases
    date_onset = seq.Date(                # re-define date colume as daily sequence of dates
      from = min(date_onset, na.rm=T), 
      to = max(date_onset, na.rm=T),
      by = "day"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

```{r message=FALSE, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Các trường hợp trong `linelist` theo tuần {.unnumbered}

Nguyên tắc tương tự có thể được áp dụng cho tuần. Đầu tiên, hãy tạo một cột mới các trường hợp theo tuần bằng cách sử dụng `floor_date()` với `unit = "week"`. Sau đó, sử dụng `count()` như trên để đạt được số lượng ca hàng tuần. Kết thúc bằng hàm `complete()` để đảm bảo rằng tất cả các tuần đều được hiển thị, ngay cả khi chúng không chứa ca nào.

```{r}
# Make dataset of weekly case counts
weekly_counts <- linelist %>% 
  drop_na(date_onset) %>%                 # remove cases missing date_onset
  mutate(week = lubridate::floor_date(date_onset, unit = "week")) %>%  # new column of week of onset
  count(week) %>%                         # group data by week and count rows per group
  complete(                               # ensure all days appear even if no cases
    week = seq.Date(                      # re-define date colume as daily sequence of dates
      from = min(week, na.rm=T), 
      to = max(week, na.rm=T),
      by = "week"),
    fill = list(n = 0))                   # set new filled-in rows to display 0 in column n (not NA as default) 
```

Đây là 50 hàng đầu tiên của bộ dữ liệu khi trả kết quả:

```{r message=FALSE, echo=F}
DT::datatable(weekly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Các trường hợp trong `linelist` theo tháng{.unnumbered}

Để tổng hợp các trường hợp theo tháng, hãy sử dụng lại `floor_date()` từ package **lubridate**, nhưng với argument `unit = "months"`. Điều này làm tròn xuống các ngày thành ngày đầu tiên của tháng. Đầu ra sẽ là định dạng ngày. Lưu ý rằng trong bước `complete()`, chúng ta cũng sử dụng `by = "months"`.

```{r}
# Make dataset of monthly case counts
monthly_counts <- linelist %>% 
  drop_na(date_onset) %>% 
  mutate(month = lubridate::floor_date(date_onset, unit = "months")) %>%  # new column, 1st of month of onset
  count(month) %>%                          # count cases by month
  complete(
    month = seq.Date(
      min(month, na.rm=T),     # include all months with no cases reported
      max(month, na.rm=T),
      by="month"),
    fill = list(n = 0))
```

```{r message=FALSE, echo=F}
DT::datatable(monthly_counts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Số lượng đếm hàng ngày theo tuần {.unnumbered}

Để tổng hợp số lượng hàng ngày thành số lượng hàng tuần, hãy sử dụng `floor_date()` như trên. Tuy nhiên, hãy sử dụng `group_by()` và `summarize()` thay vì `count()` bởi vì chúng ta cần tính tổng `sum()` số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tuần.

### Số lượng đếm hàng ngày theo tuần {.unnumbered}

Để tổng hợp số lượng hàng ngày thành số lượng hàng tháng, hãy sử dụng `floor_date()` với `unit = "month"` như trên. Tuy nhiên, hãy sử dụng `group_by()` và `summarize()` thay vì `count()` bởi vì chúng ta cần tính tổng `sum()` số lượng trường hợp hàng ngày thay vì chỉ đếm số hàng mỗi tháng.

## Sắp xếp dữ liệu đã nhóm

Sử dụng hàm **dplyr** `arrange()` để sắp xếp các hàng trong bộ dữ liệu tương tự khi dữ liệu được nhóm lại, *trừ khi* bạn thiết lập đối số `.by_group =TRUE`. Trong trường hợp này, các hàng được sắp xếp thứ tự đầu tiên theo các cột nhóm và sau đó theo bất kỳ cột nào khác mà bạn chỉ định để `arrange()`.

## Lọc trên nhóm dữ liệu đã nhóm

### `filter()` {.unnumbered}

Khi được áp dụng cùng với các hàm đánh giá bộ dữ liệu (như `max()`, `min()`, `mean()`), các hàm này sẽ được áp dụng cho các nhóm. Ví dụ: nếu bạn muốn lọc và giữ các hàng có bệnh nhân trên độ tuổi trung vị, hàm này sẽ áp dụng cho mỗi nhóm - lọc để giữ các hàng trên độ tuổi trung bình của *nhóm*.

### Cắt hàng theo nhóm {.unnumbered}

Hàm **dplyr** `slice()`, mà [lọc hàng dựa trên vị trí](https://dplyr.tidyverse.org/reference/slice.html) trong dữ liệu, cũng có thể được áp dụng cho mỗi nhóm. Hãy nhớ sắp xếp dữ liệu trong mỗi nhóm để có được "lát cắt" mong muốn.

Ví dụ: chỉ lấy 5 lần nhập viện gần nhất từ mỗi bệnh viện:

1)  Nhóm bộ số liệu `linelist` theo cột `hospital`\
2)  Sắp xếp bản ghi từ gần nhất đến xa nhất theo `date_hospitalisation` *trong mỗi nhóm bệnh viện*\
3)  Cắt để lấy 5 hàng đầu tiên từ mỗi bệnh viện

```{r,}
linelist %>%
  group_by(hospital) %>%
  arrange(hospital, date_hospitalisation) %>%
  slice_head(n = 5) %>% 
  arrange(hospital) %>%                            # for display
  select(case_id, hospital, date_hospitalisation)  # for display
```

`slice_head()` - chọn n hàng từ trên xuống dưới\
`slice_tail()` - chọn n hàng từ dưới lên trên\
`slice_sample()` - chọn ngẫu nhiên n dòng\
`slice_min()` - chọn n dòng với giá trị cao nhất trong cột `order_by =`, sử dụng `with_ties = TRUE` để giữ mối liên hệ\
`slice_max()` - chọn n dòng với giá trị thấp nhất trong cột `order_by =`,sử dụng `with_ties = TRUE` để giữ mối liên hệ

Xem chương [Loại bỏ trùng lặp] để tham khảo thêm ví dụ và chi tiết về hàm `slice()`.

### Lọc theo quy mô nhóm {#group_filter_grp_size .unnumbered}

Hàm `add_count()` thêm một cột `n` vào dữ liệu gốc cho biết số hàng trong nhóm của hàng đó.

Như trình bày bên dưới, `add_count()` được áp dụng cho cột `hospital`, vì vậy các giá trị trong cột mới `n` phản ánh số hàng trong nhóm bệnh viện của hàng đó. Lưu ý cách các giá trị trong cột `n` được lặp lại. Trong ví dụ dưới đây, tên cột `n` có thể được thay đổi bằng cách sử dụng đối số `name =` trong `add_count()`. Với mục đích diễn giải, chúng ta sắp xếp lại các cột với `select()`.

```{r}
linelist %>% 
  as_tibble() %>% 
  add_count(hospital) %>%          # add "number of rows admitted to same hospital as this row" 
  select(hospital, n, everything())
```

Sau đó, nó trở nên dễ dàng để lọc các hàng trường hợp nhập viện tại một bệnh viện "nhỏ", chẳng hạn như một bệnh viện tiếp nhận ít hơn 500 bệnh nhân:

```{r, eval=F}
linelist %>% 
  add_count(hospital) %>% 
  filter(n < 500)
```

## Tạo cột mới trên dữ liệu được nhóm

Để giữ lại tất cả các cột và hàng (không tổng hợp) và *thêm một cột mới chứa thống kê theo nhóm*, hãy sử dụng hàm `mutate()` sau `group_by()` thay vì `summarise()`.

Điều này hữu ích nếu bạn muốn nhóm thống kê trong bộ dữ liệu gốc *với tất cả các cột khác được hiển thị* - ví dụ: cho các phép tính so sánh một hàng với nhóm của nó.

Ví dụ: code dưới đây tính toán sự khác biệt giữa thời gian trễ nhập viện của một hàng và thời gian chậm trễ trung vị đối với bệnh viện đó. Các bước lần lượt là:

1)  Nhóm dữ liệu theo bệnh viện\
2)  Sử dụng cột `days_onset_hosp` (nhập viện trễ) để tạo một cột mới chứa giá trị trễ trung bình tại bệnh viện của *hàng đó*\
3)  Tính toán sự khác biệt giữa hai cột

Chúng ta chỉ lựa chọn `select()` những cột cần hiển thị, cho mục đích diễn giải.

```{r}
linelist %>% 
  # group data by hospital (no change to linelist yet)
  group_by(hospital) %>% 
  
  # new columns
  mutate(
    # mean days to admission per hospital (rounded to 1 decimal)
    group_delay_admit = round(mean(days_onset_hosp, na.rm=T), 1),
    
    # difference between row's delay and mean delay at their hospital (rounded to 1 decimal)
    diff_to_group     = round(days_onset_hosp - group_delay_admit, 1)) %>%
  
  # select certain rows only - for demonstration/viewing purposes
  select(case_id, hospital, days_onset_hosp, group_delay_admit, diff_to_group)
```

## Chọn trên dữ liệu được nhóm

Hàm `select()` hoạt động trên dữ liệu được nhóm, nhưng các cột được nhóm luôn được bao gồm (ngay cả khi không được đề cập trong `select()`). Nếu bạn không muốn nhóm các cột này, trước tiên hãy bỏ nhóm bằng hàm `ungroup()`.

<!-- ======================================================= -->

## Tài nguyên học liệu

Dưới đây là một số tài nguyên hữu ích cung cấp thêm thông tin:

Bạn có thể thực hiện bất kỳ hàm tổng hợp nào trên dữ liệu được nhóm; xem [RStudio cheat sheet về biến đổi dữ liệu](https://github.com/rstudio/cheatsheets/blob/master/data-transformation.pdf)

Trang Data Carpentry của [**dplyr**](https://datacarpentry.org/R-genomics/04-dplyr.html)\
Chương tham khảo hệ sinh thái **tidyverse** về [group_by()](https://dplyr.tidyverse.org/reference/group_by.html) và [grouping](https://dplyr.tidyverse.org/articles/grouping.html)

Trang này về [Thao tác dữ liệu](https://itsalocke.com/files/DataManipulationinR.pdf)

[Tổng hợp có điều kiện với dplyr](https://stackoverflow.com/questions/23528862/summarize-with-conditions-in-dplyr)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/grouping.Rmd-->

# Nối dữ liệu {#joining-matching}

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
```

*Ở trên: một ví dụ động về phép nối bên trái ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))*

Chương này mô tả các cách "nối (join)", "khớp (match)", "liên kết (link), "gắn (bind)" và các cách khác để kết hợp các data frame.

Việc phân tích hay quy trình làm việc dịch tễ học của bạn liên quan đến nhiều nguồn dữ liệu và sự liên kết của nhiều bộ dữ liệu với nhau là phổ biến. Có thể bạn cần kết nối dữ liệu phòng thí nghiệm với kết quả lâm sàng của bệnh nhân, hoặc dữ liệu di động của Google với các xu hướng bệnh truyền nhiễm hay thậm chí là bộ dữ liệu ở một giai đoạn phân tích với phiên bản đã biến đổi của chính nó.

Trong chương này chúng ta trình bày code nhằm:

-   Hướng dẫn *nối* hai data frame sao cho các hàng khớp với nhau dựa trên các giá trị chung trong cột định danh\
-   Nối hai data frame dựa trên sự phù hợp (có khả năng) *theo xác suất* giữa các giá trị\
-   Mở rộng một data frame bằng cách *gắn* hoặc ("thêm vào") trực tiếp các hàng hoặc cột từ một data frame khác

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị những package cần gọi cho các phân tích. Trong sổ tay này, chúng ta nhấn mạnh đến hàm `p_load()` từ **pacman**, hàm sẽ cài đặt package nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để có thêm thông tin về các R package.

```{r}
pacman::p_load(
  rio,            # import and export
  here,           # locate files 
  tidyverse,      # data management and visualisation
  RecordLinkage,  # probabilistic matches
  fastLink        # probabilistic matches
)
```

### Nhập dữ liệu {.unnumbered}

Để bắt đầu, chúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, [bấm để tải xuống linelist "đã được làm sạch"](https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds) (tệp .rds). Nhập dữ liệu với hàm `import()` từ package **rio** (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của linelist được hiển thị dưới đây.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### Bộ dữ liệu mẫu {.unnumbered}

Trong phần nối dữ liệu dưới đây, chúng ta sẽ sử dụng các bộ dữ liệu sau:

1)  Một phiên bản "thu nhỏ" của bộ dữ liệu `linelist`, chỉ chứa các cột `case_id`, `date_onset`, `hospital` và chỉ 10 hàng đầu tiên\
2)  Một data frame riêng biệt có tên `hosp_info`, chứa thêm thông tin chi tiết của từng bệnh viện

Trong phần ghép theo xác suất, chúng ta sẽ sử dụng hai bộ dữ liệu nhỏ khác nhau. Code để tạo các bộ dữ liệu này được đưa ra trong phần đó.

#### Dữ liệu linelist "thu nhỏ" {#joins_llmini .unnumbered}

Dưới đây là bộ dữ liệu linelist thu nhỏ, bao gồm 10 hàng và chỉ chứa các cột `case_id`, `date_onset` và `hospital`.

```{r}
linelist_mini <- linelist %>%                 # start with original linelist
  select(case_id, date_onset, hospital) %>%   # select columns
  head(10)                                    # only take the first 10 rows
```

```{r message=FALSE, echo=F}
DT::datatable(linelist_mini, rownames = FALSE, options = list(pageLength = nrow(10)))
```

#### Data frame thông tin bệnh viện {#joins_hosp_info .unnumbered}

Dưới đây là code để tạo một data frame riêng biệt với thông tin bổ sung của bảy bệnh viện (số lượng người dân có thể tiếp cận và mức độ chăm sóc hiện có). Lưu ý rằng tên "Bệnh viện Quân đội (Military Hospital)" thuộc về hai bệnh viện khác nhau - một bệnh viện cấp 1 phục vụ 10000 cư dân và một bệnh viện cấp hai phục vụ 40500 cư dân.

```{r}
# Make the hospital information data frame
hosp_info = data.frame(
  hosp_name     = c("central hospital", "military", "military", "port", "St. Mark's", "ignace", "sisters"),
  catchment_pop = c(1950280, 40500, 10000, 50280, 12000, 5000, 4200),
  level         = c("Tertiary", "Secondary", "Primary", "Secondary", "Secondary", "Primary", "Primary")
)
```

Đây là data frame này:

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(hosp_info, rownames = FALSE, options = list(pageLength = nrow(hosp_info)))
```

<!-- ======================================================= -->

### Làm sạch trước {.unnumbered}

Các phương pháp nối truyền thống (không theo xác suất) phân biệt chữ hoa, chữ thường và yêu cầu khớp các ký tự chính xác giữa các giá trị trong hai data frame. Để minh họa một số bước làm sạch mà bạn có thể cần làm trước khi bắt đầu nối, chúng ta sẽ làm sạch và căn chỉnh bộ dữ liệu `linelist_mini` và `hosp_info` ngay bây giờ.

**Xác định điểm khác biệt**

Chúng ta cần các giá trị của cột `hosp_name` trong data frame `hosp_info` để khớp với các giá trị của cột `hospital` trong data frame `linelist_mini`.

Dưới đây là các giá trị trong data frame `linelist_mini`, được in bằng hàm `unique()`trong **base** R:

```{r}
unique(linelist_mini$hospital)
```

và đây là các giá trị trong data frame `hosp_info`:

```{r}
unique(hosp_info$hosp_name)
```

Bạn có thể thấy rằng mặc dù một số bệnh viện tồn tại trong cả hai data frame, nhưng có nhiều điểm khác biệt về chính tả.

**Căn chỉnh giá trị**

Chúng ta bắt đầu bằng cách làm sạch các giá trị trong data frame `hosp_info`. Như đã được giải thích trong chương [Làm sạch số liệu và các hàm quan trọng], chúng ta có thể code lại các giá trị với tiêu chí logic bằng cách sử dụng hàm `case_when()` của **dplyr**. Đối với bốn bệnh viện tồn tại trong cả hai data frame, chúng ta thay đổi các giá trị để phù hợp với các giá trị trong `linelist_mini`. Các bệnh viện khác chúng ta để nguyên giá trị (`TRUE ~ hosp_name`).

[***CẨN TRỌNG:*** Thông thường khi làm sạch, chúng ta nên tạo một cột mới (ví dụ: `hosp_name_clean`), nhưng để dễ dàng giải thích, chúng ta hiển thị các thay đổi trên cột cũ]{style="color: orange;"}

```{r}
hosp_info <- hosp_info %>% 
  mutate(
    hosp_name = case_when(
      # criteria                         # new value
      hosp_name == "military"          ~ "Military Hospital",
      hosp_name == "port"              ~ "Port Hospital",
      hosp_name == "St. Mark's"        ~ "St. Mark's Maternity Hospital (SMMH)",
      hosp_name == "central hospital"  ~ "Central Hospital",
      TRUE                             ~ hosp_name
      )
    )
```

Tên bệnh viện xuất hiện trong cả hai data frame đều được căn chỉnh. Có hai bệnh viện trong dữ liệu `hosp_info` không có trong `linelist_mini` - chúng ta sẽ giải quyết những trường hợp này sau, trong phần nối dữ liệu.

```{r}
unique(hosp_info$hosp_name)
```

Trước một phép nối, việc chuyển đổi một cột thành tất cả chữ thường hoặc tất cả chữ hoa thường dễ dàng nhất. Nếu bạn cần chuyển đổi tất cả các giá trị trong một cột thành CHỮ HOA hoặc chữ thường, hãy sử dụng `mutate()` và đặt cột bên trong một trong những hàm từ package **stringr**, như ã được trình bày trong chương [Ký tự và chuỗi].

`str_to_upper()`\
`str_to_upper()`\
`str_to_title()`

<!-- ======================================================= -->

## **Nối bằng dplyr**

Package **dplyr** cung cấp một số hàm nối khác nhau. **dplyr** là một package thuộc hệ sinh thái **tidyverse**. Các hàm nối này được mô tả ở bên dưới, trong các trường hợp sử dụng đơn giản.

Rất cảm ơn [https://github.com/gadenbuie](https://github.com/gadenbuie/tidyexplain/tree/master/images) vì những tấm ảnh động bổ ích!

<!-- ======================================================= -->

### Cú pháp chung {.unnumbered}

Các lệnh nối có thể được chạy dưới dạng các lệnh độc lập để nối hai data frame thành một đối tượng mới, hoặc chúng có thể được sử dụng trong một chuỗi pipe (`%>%`) để hợp nhất một data frame vào một data frame khác khi nó đang được làm sạch hoặc chỉnh sửa.

Trong ví dụ dưới đây, hàm `left_join()` được sử dụng như một lệnh độc lập để tạo một data frame `joined_data` mới. Các dữ liệu đầu vào là data frame 1 và 2 (`df1` và `df2`). Data frame đầu tiên được liệt kê là data frame cơ sở và data frame thứ hai được liệt kê là data frame sẽ nối *với* data frame thứ nhất.

Đối số thứ ba `by =` là nơi bạn xác định các cột trong mỗi data frame mà sẽ được sử dụng để căn chỉnh các hàng trong hai data frame. Nếu tên của các cột này khác nhau, hãy đặt chúng trong một vectơ `c()` như được trình bày dưới đây, nơi mà các hàng được khớp trên cơ sở các giá trị chung giữa cột `ID` trong `df1` và cột `identifier` trong `df2`.

```{r, eval=F}
# Join based on common values between column "ID" (first data frame) and column "identifier" (second data frame)
joined_data <- left_join(df1, df2, by = c("ID" = "identifier"))
```

Nếu các cột `by` trong cả hai data frame có cùng tên, bạn chỉ cần cung cấp tên này, đặt trong dấu ngoặc kép.

```{r, eval=F}
# Joint based on common values in column "ID" in both data frames
joined_data <- left_join(df1, df2, by = "ID")
```

Nếu bạn đang nối các data frame dựa trên các giá trị chung của nhiều trường, hãy liệt kê các trường này trong vectơ `c()`. Ví dụ dưới đây nối các hàng nếu các giá trị trong ba cột trong mỗi bộ dữ liệu căn chỉnh chính xác.

```{r, eval=F}
# join based on same first name, last name, and age
joined_data <- left_join(df1, df2, by = c("name" = "firstname", "surname" = "lastname", "Age" = "age"))
```

Các lệnh nối cũng có thể được chạy trong một chuỗi pipe. Điều này sẽ thực hiện sửa đổi data frame trong chuỗi pipe.

Trong ví dụ dưới đây, `df1` được đưa qua các pipe, `df2` được nối vào đó và vì thế `df1` được chỉnh sửa và xác định lại.

```{r eval=F}
df1 <- df1 %>%
  filter(date_onset < as.Date("2020-03-05")) %>% # miscellaneous cleaning 
  left_join(df2, by = c("ID" = "identifier"))    # join df2 to df1
```

[***CẨN TRỌNG:*** Nối dựa trên những trường hợp cụ thể! Do đó, rất hữu ích khi chuyển đổi tất cả các giá trị thành chữ thường hoặc chữ hoa trước khi nối. Xem thêm chương về ký tự/chuỗi.]{style="color: orange;"}

<!-- ======================================================= -->

### Nối trái và phải {.unnumbered}

**Nối trái hoặc phải thường được sử dụng để thêm thông tin vào data frame** - thông tin mới chỉ được thêm vào các hàng đã tồn tại trong data frame cơ sở. Đây là những phép nối phổ biến trong hoạt động dịch tễ học vì chúng được sử dụng để thêm thông tin từ một bộ dữ liệu vào một bộ dữ liệu khác.

Khi sử dụng các phép nối này, thứ tự viết của các data frame trong lệnh rất quan trọng\*.

-   Trong *phép nối trái*, data frame *đầu tiên* được viết là data frame cơ sở\
-   Trong *phép nối phải*, data frame *thứ hai* được viết là data frame cơ sở

**Tất cả các hàng của data frame cơ sở được giữ lại.** Thông tin trong data frame (thứ cấp) khác được kết hợp với data frame cơ sở *chỉ khi có sự trùng khớp của (các) cột định danh*. Ngoài ra:

-   Các hàng trong data frame thứ cấp không khớp sẽ bị loại bỏ.\
-   Nếu có nhiều hàng cơ sở khớp với một hàng trong data frame thứ cấp (nhiều-khớp-một), thông tin phụ sẽ được thêm vào *mỗi hàng cơ sở được khớp*.\
-   Nếu một hàng cơ sở khớp với nhiều hàng trong data frame thứ cấp (một-khớp-nhiều), tất cả các kết hợp sẽ được đưa ra, nghĩa là *các hàng mới* *có thể được thêm vào data frame trả về của bạn!*

Sau đây là các ví dụ động về phép nối trái và phải ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "left-join.gif"))
knitr::include_graphics(here::here("images", "right-join.gif"))
```

**Ví dụ**

Dưới đây là kết quả đầu ra của phép nối trái `left_join()` của bộ dữ liệu `hosp_info` (data frame thứ cấp, [xem tại đây](#joins_hosp_info)) *vào* `linelist_mini` (data frame cơ sở, [xem tại đây](#joins_llmini)). `linelist_mini` gốc có `nrow(linelist_mini)` hàng. `linelist_mini` đã chỉnh sửa được hiển thị. Lưu ý những điều dưới đây:

-   Hai cột mới `catchment_pop` và `level` đã được thêm vào bên trái của `linelist_mini`\
-   Tất cả các hàng gốc của data frame cơ sở `linelist_mini` đều được giữ lại\
-   Bất kỳ hàng gốc nào của `linelist_mini` cho "Military Hospital" đều bị trùng lặp vì nó khớp với *hai hàng* trong data frame thứ cấp, do đó cả hai sự kết hợp đều được trả về\
-   Cột định danh kết hợp của bộ dữ liệu thứ cấp (`hosp_name`) đã biến mất vì nó thừa so với cột định danh trong bộ dữ liệu chính (`hospital`)\
-   Khi một hàng cơ sở không khớp với bất kỳ hàng thứ cấp nào (ví dụ: khi `hospital` là "Other" hoặc "Missing"), `NA` (trống) sẽ điền vào các cột từ data frame thứ cấp\
-   Các hàng trong data frame thứ cấp không khớp với data frame cơ sở (bệnh viện "sisters" và "ignace") đã bị loại bỏ

```{r, eval=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  left_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

#### "Tôi nên sử dụng phép nối phải hay phép nối trái?" {.unnumbered}

Để trả lời câu hỏi trên, hãy tự hỏi "data frame nào nên giữ lại tất cả các hàng của nó?" - hãy sử dụng cái này làm data frame cơ sở. *Phép nối trái* giữ tất cả các hàng trong data frame đầu tiên được viết trong lệnh, trong khi *phép nối phải* giữ tất cả các hàng trong data frame thứ hai.

Hai lệnh bên dưới đạt cùng một kết quả đầu ra - 10 hàng `hosp_info` được nối *vào* bộ dữ liệu cơ sở `linelist_mini`, tuy nhiên chúng sử dụng các phép nối khác nhau. Kết quả là thứ tự cột sẽ khác nhau dựa trên việc `hosp_info` đến từ bên phải (trong phép nối bên trái) hay đến từ bên trái (trong phép nối bên phải). Thứ tự của các hàng cũng có thể thay đổi tương ứng. Nhưng cả hai hệ quả này đều có thể được giải quyết bằng cách sử dụng `select()` để sắp xếp lại các cột hoặc `arrange()` để sắp xếp các hàng.

```{r, eval=F}
# The two commands below achieve the same data, but with differently ordered rows and columns
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name"))
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital"))
```

Đây là kết quả nối `hosp_info` vào `linelist_mini` qua phép nối trái (các cột mới đến từ bên phải)

```{r message=FALSE, echo=F}
left_join(linelist_mini, hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Đây là kết quả nối `hosp_info` vào `linelist_mini` qua phép nối phải (các cột mới đến từ bên trái)

```{r message=FALSE, echo=F}
right_join(hosp_info, linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 11))
```

Ngoài ra, hãy xem xét liệu trường hợp-đang sử dụng của bạn có nằm trong một chuỗi pipe (`%>%`) hay không. Nếu bộ dữ liệu nằm trong pipe là đường cơ sở, bạn có thể sẽ sử dụng một phép nối trái để thêm dữ liệu vào đó.

<!-- ======================================================= -->

### Nối hoàn toàn {.unnumbered}

**Nối hoàn toàn là phép nối *bao hàm* nhất trong tất cả các phép nối** - nó trả về tất cả các hàng từ cả hai data frame.

Nếu có bất kỳ hàng nào chỉ hiện diện duy nhất trong một data frame (khi không tìm thấy hàng nào phù hợp), data frame sẽ bao gồm các hàng đó và trở nên dài hơn. Các giá trị missing `NA` được sử dụng để điền-vào bất kỳ khoảng trống nào đã tạo. Khi bạn nối, hãy kiểm tra số cột và số hàng cẩn thận để khắc phục lỗi về phân biệt chữ hoa với chữ thường và đảm bảo các kết quả khớp ký tự chính xác.

Data frame "cơ sở" là data frame được viết đầu tiên trong lệnh. Việc điều chỉnh data frame này sẽ không ảnh hưởng đến những bản ghi nào được trả về bởi phép nối, nhưng nó có thể ảnh hưởng đến thứ tự cột kết quả, thứ tự hàng và cột định danh nào được giữ lại.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "full-join.gif"))
```

Ví dụ động về một phép nối hoàn toàn ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Ví dụ**

Dưới đây kết quả đầu ra của phép nối hoàn toàn `full_join()` của `hosp_info` (ban đầu là `nrow(hosp_info)`, [xem tại đây](#joins_hosp_info)) *vào* `linelist_mini` (ban đầu là `nrow(linelist_mini)`, [xem tại đây](#joins_llmini)). Lưu ý những điều dưới đây:

-   Tất cả các hàng cơ sở đều được giữ nguyên (`linelist_mini`)\
-   Các hàng trong data frame thứ cấp không khớp với data frame cơ sở được giữ lại ("ignace" và "sisters"), với các giá trị trong các cột cơ sở tương ứng `case_id` và `onset` điền-vào các giá trị missing\
-   Tương tự, các hàng trong data frame cơ sở không khớp với hàng trong data frame thứ cấp ("Other" và "Missing") được giữ lại, với các cột phụ `catchment_pop` và `level` điền-vào các giá trị missing\
-   Trong trường hợp khớp một-với-một hoặc nhiều-với-một (ví dụ: các hàng của "Military Hospital"), tất cả các kết hợp có thể có được trả về (kéo dài thêm data frame cuối cùng)\
-   Chỉ cột định danh từ data frame cơ sở được giữ lại (`hospital`)

```{r, eval=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  full_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 15))
```

<!-- ======================================================= -->

### Nối bên trong {.unnumbered}

**Nối bên trong là phép nối *hạn chế* nhất trong tất cả các phép nối** - nó chỉ trả về các hàng có kết quả khớp trên cả hai data frame.\
Điều này có nghĩa là số hàng trong data frame cơ sở có thể thực sự *giảm xuống*. Việc điều chỉnh data frame nào là "cơ sở" (được viết đầu tiên trong hàm) sẽ không ảnh hưởng đến hàng nào được trả về, nhưng nó sẽ ảnh hưởng đến thứ tự cột, thứ tự hàng và cột định danh nào được giữ lại.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "inner-join.gif"))
```

Ví dụ động về một phép nối bên trong ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))

**Ví dụ**

Dưới đây kết quả đầu ra việc nối `inner_join()` của `linelist_mini` (cơ sở) với `hosp_info` (thứ cấp). Lưu ý những điều dưới đây:

-   Các hàng cơ sở không khớp với dữ liệu thứ cấp sẽ bị xóa (các hàng mà `hospital` nhận giá trị "Missing" hoặc "Other")\
-   Tương tự, các hàng từ data frame thứ cấp không khớp trong data frame cơ sở sẽ bị xóa (các hàng mà `hosp_name` nhận giá trị "sisters" hoặc "ignace")\
-   Chỉ cột định danh từ data frame cơ sở được giữ lại (`hospital`)

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

<!-- ======================================================= -->

### Nối một phần {.unnumbered}

Nối một phần là một "phép nối chọn lọc" mà sử dụng bộ dữ liệu khác *không nhằm để thêm hàng hay cột, mà để lọc dữ liệu*.

**Phép nối-một phần giữ lại tất cả các quan sát trong data frame cơ sở mà có sự trùng khớp với data frame thứ cấp** (nhưng không thêm cột mới cũng như không sao chép bất kỳ hàng nào cho các dữ liệu khớp). Đọc thêm về những phép nối "chọn lọc" này [tại đây](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "semi-join.gif"))
```

Ví dụ động về phép nối một phần ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))

Như một ví dụ, code dưới đây trả về các hàng từ data frame `hosp_info` mà khớp với `linelist_mini` theo tên bệnh viện.

```{r}
hosp_info %>% 
  semi_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

<!-- ======================================================= -->

### Anti join {.unnumbered}

**Anti join là một "phép nối chọn lọc" khác trả về các hàng trong data frame cơ sở *không* khớp với data frame thứ cấp.**

Đọc thêm về những phép nối "chọn lọc" này [tại đây](https://towardsdatascience.com/level-up-with-semi-joins-in-r-a068426096e0).

Các tình huống phổ biến của anti join bao gồm xác định các bản ghi không tồn tại trong một data frame khác, khắc phục lỗi chính tả trong một phép nối (xem xét các bản ghi *đáng lẽ sẽ* khớp) và kiểm tra các bản ghi đã bị loại trừ sau một phép nối khác.

**Như với `right_join()` và `left_join()`, quan trọng là data frame *cơ sở* (được liệt kê đầu tiên)**. Các hàng được trả về chỉ từ data frame cơ sở. Lưu ý trong ảnh động bên dưới, hàng trong data frame thứ cấp (hàng 4 màu tím) không được trả về mặc dù nó không khớp với hàng cơ sở.

```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "anti-join.gif"))
```

Ví dụ động về anti join ([nguồn ảnh](https://github.com/gadenbuie/tidyexplain/tree/master/images))

#### Ví dụ `anti_join()` đơn giản {.unnumbered}

Một ví dụ đơn giản, hãy tìm bệnh viện trong `hosp_info` mà không tồn tại trong `linelist_mini`. chúng ta liệt kê `hosp_info` trước, như một data frame cơ sở. Các bệnh viện không có trong `linelist_mini` sẽ được trả về.

```{r, eval=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital"))
```

```{r message=FALSE, echo=F}
hosp_info %>% 
  anti_join(linelist_mini, by = c("hosp_name" = "hospital")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 12))
```

#### Ví dụ `anti_join()` phức tạp {.unnumbered}

Một ví dụ khác, giả sử chúng ta đã chạy một `inner_join()` giữa `linelist_mini` và `hosp_info`. Lệnh này chỉ trả về một tập con các bản ghi của `linelist_mini` gốc, vì một số bản ghi không có trong `hosp_info`.

```{r, eval=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  inner_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

Để xem lại các bản ghi `linelist_mini` đã bị loại trừ trong phép nối bên trong, chúng ta có thể chạy một phép nối anti-join với cùng thiết lập (`linelist_mini` là data frame cơ sở).

```{r, eval = F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name"))
```

```{r message=FALSE, echo=F}
linelist_mini %>% 
  anti_join(hosp_info, by = c("hospital" = "hosp_name")) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 8))
```

Để xem các bản ghi `hosp_info` đã bị loại trừ trong phép nối bên trong, chúng ta cũng có thể chạy một phép nối anti-join với `hosp_info` là data frame cơ sở.

<!-- ======================================================= -->

## Khớp theo xác suất

Nếu bạn không có thông tin định danh duy nhất chung trên các bộ dữ liệu để nối, hãy xem xét sử dụng thuật toán khớp theo xác suất. Phương pháp này sẽ tìm thấy các bản ghi khớp với nhau dựa trên sự tương đồng (ví dụ: khoảng cách chuỗi Jaro-Winkler hoặc khoảng cách số). Dưới đây là một ví dụ đơn giản sử dụng package **fastLink**.

**Gọi package**

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualization
  fastLink        # record matching
  )
```

Dưới đây là hai bộ dữ liệu mẫu nhỏ mà chúng ta sẽ sử dụng để giải thích phương pháp khớp theo xác suất (`cases` và `test_results`):

Đây là code được sử dụng để tạo bộ dữ liệu:

```{r}
# make datasets

cases <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural"
)

results <- tribble(
  ~gender,  ~first,     ~middle,     ~last,          ~yr, ~mon, ~day, ~district, ~result,
  "M",      "Amir",     NA,          "Khan",         1989, 11,   22,  "River", "positive",
  "M",      "Tony",   "B",         "Smith",          1970, 09,   19,  "River", "positive",
  "F",      "Maria",    "Contreras", "Rodriguez",    1972, 04,   15,  "Cty",   "negative",
  "F",      "Betty",    "Castel",   "Chase",        1954,  03,   30,  "City",  "positive",
  "F",      "Andrea",   NA,          "Kumaraswamy",  2001, 01,   05,  "Rural", "positive",      
  "F",      "Caroline", NA,          "Wang",         1988, 12,   11,  "Rural", "negative",
  "F",      "Trang",    NA,          "Nguyen",       1981, 06,   10,  "Rural", "positive",
  "M",      "Olivier" , "Laurent",   "De Bordeaux",  NA,   NA,   NA,  "River", "positive",
  "M",      "Mike",     "Murphy",    "O'Callaghan",  1969, 04,   12,  "Rural", "negative",
  "F",      "Cassidy",  "Jones",     "Davis",        1980, 07,   02,  "City",  "positive",
  "M",      "Mohammad", NA,          "Ali",          1942, 01,   17,  "City",  "negative",
  NA,       "Jose",     "Sanchez",   "Lopez",        1995, 01,   06,  "City",  "negative",
  "M",      "Abubakar", NA,          "Abullahi",     1960, 01,   01,  "River", "positive",
  "F",      "Maria",    "Salinas",   "Contreras",    1955, 03,   03,  "River", "positive"
  )

```

**Bộ dữ liệu `cases` có 9 bản ghi** của những bệnh nhân đang chờ kết quả xét nghiệm.

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(cases, rownames = FALSE, options = list(pageLength = nrow(cases), scrollX=T), class = 'white-space: nowrap')
```

**Bộ dữ liệu `test_results`** có 14 bản ghi và chứa cột `result`, cột mà chúng ta muốn thêm vào các bản ghi trong `cases` dựa trên các bản ghi khớp theo xác xuất.

```{r message=FALSE, echo=F}
# display the hospital data as a table
DT::datatable(results, rownames = FALSE, options = list(pageLength = nrow(results), scrollX=T), class = 'white-space: nowrap')
```

### Khớp theo xác suất {.unnumbered}

Hàm `fastLink()` từ package **fastLink** có thể được sử dụng để áp dụng một thuật toán so khớp. Đây là thông tin cơ bản. Bạn có thể đọc chi tiết thêm bằng cách nhập `?fastLink` trong console của mình.

-   Xác định hai data frame để so sánh với các đối số `dfA =` và `dfB =`\
-   Trong `varnames =` cung cấp tất cả các tên cột được sử dụng để khớp. Tất cả tên cột phải tồn tại trong cả hai `dfA` và `dfB`.\
-   Trong `stringdist.match =` cung cấp các cột từ những cột trong `varnames` được đánh giá trên chuỗi "distance".\
-   Trong `numeric.match =` cung cấp các cột từ những cột trong `varnames` được đánh giá trên khoảng.\
-   Các giá trị missing sẽ bị bỏ qua\
-   Theo mặc định, mỗi hàng từ một trong hai data frame sẽ được khớp với nhiều nhất một hàng trong data frame còn lại. Nếu bạn muốn xem tất cả các kết quả khớp được đánh giá, hãy đặt `dedupe.matches = FALSE`. Việc loại bỏ trùng lặp được thực hiện bằng giải pháp gán tuyến tính của Winkler.

*Mẹo: tách một cột ngày thành ba cột số riêng biệt bằng cách sử dụng `day()`, `month()` và `year()` từ package **lubridate***

Ngưỡng mặc định cho các kết quả khớp là 0,94 (`threshold.match =`) nhưng bạn có thể điều chỉnh nó cao hơn hoặc thấp hơn. Nếu bạn xác định ngưỡng, hãy cân nhắc việc ngưỡng cao hơn có thể mang lại nhiều âm tính giả hơn (các hàng không khớp sẽ thực sự khớp) và tương tự như vậy, ngưỡng thấp hơn có thể mang lại nhiều kết quả dương tính giả hơn.

Dưới đây, dữ liệu được đối sánh trên khoảng cách chuỗi trên các cột tên (name) và quận (district), cũng như khoảng cách số cho ngày (day), tháng month), năm sinh (year). Ngưỡng đối sánh với xác suất là 95% được thiết lập.

```{r, message=F, warning=F}
fl_output <- fastLink::fastLink(
  dfA = cases,
  dfB = results,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district"),
  stringdist.match = c("first", "middle", "last", "district"),
  numeric.match = c("yr", "mon", "day"),
  threshold.match = 0.95)
```

**Xem lại các kết quả khớp**

chúng ta đã định nghĩa đối tượng được trả về từ `fastLink()` là `fl_output`. Nó thuộc nhóm `list`, và nó thực sự chứa một số data frame bên trong nó, mô tả chi tiết kết quả của việc so khớp. Một trong những data frame này là `matches`, chứa các kết quả khớp có nhiều khả năng nhất giữa `cases` và `results`. Bạn có thể truy cập data frame "khớp" này với `fl_output$matches`. Dưới đây, nó được lưu dưới dạng `my_matches` để tiện cho việc truy cập sau này.

Khi `my_matches` được in, bạn sẽ thấy hai vectơ cột: các cặp số/chỉ số hàng (còn được gọi là "tên hàng (rownames)") trong `cases` ("inds.a") và trong `results` ("inds.b") đại diện cho các kết quả khớp phù hợp nhất. Nếu số hàng từ data frame bị thiếu, có nghĩa là không tìm thấy kết quả khớp nào trong data frame khác ở ngưỡng đối sánh đã chỉ định.

```{r}
# print matches
my_matches <- fl_output$matches
my_matches
```

Những điều cần lưu ý:

-   Các kết quả trùng khớp đã xảy ra mặc dù có sự khác biệt nhỏ về cách viết tên cũng như ngày sinh:

    -   "Tony B. Smith" khớp với "Anthony B Smith"\
    -   "Maria Rodriguez" khớp với "Marialisa Rodrigues"\
    -   "Betty Chase" khớp với "Elizabeth Chase"\
    -   "Olivier Laurent De Bordeaux" khớp với "Oliver Laurent De Bordow" (ngày sinh missing bị bỏ qua)\

-   Một hàng trong `cases` (đối với "Blessing Adebayo", hàng 9) không có kết quả khớp tốt trong `results`, vì vậy nó không tồn tại `my_matches`.

**Nối dựa trên việc khớp theo xác suất**

Để sử dụng các kết quả khớp này nhằm nối `results` vào `cases`, chiến lược là:

1)  Sử dụng `left_join()` để nối `my_matches` vào `cases` (khớp tên hàng (rowname) trong `cases` với "inds.a" trong `my_matches`)\
2)  Sau đó sử dụng `left_join()` khác để nối `results` vào `cases` (khớp với "inds.b" mới có được trong `cases` với rowname trong `results`)

Trước khi nối, chúng ta nên làm sạch ba data frame:

-   Cả `dfA` và `dfB` nên có số hàng của chúng ("rowname") được chuyển đổi thành một cột thích hợp.\
-   Cả hai cột trong `my_matches` đều được chuyển đổi thành nhóm ký tự, vì vậy chúng có thể được nối với ký tự rownames

```{r}
# Clean data prior to joining
#############################

# convert cases rownames to a column 
cases_clean <- cases %>% rownames_to_column()

# convert test_results rownames to a column
results_clean <- results %>% rownames_to_column()  

# convert all columns in matches dataset to character, so they can be joined to the rownames
matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))



# Join matches to dfA, then add dfB
###################################
# column "inds.b" is added to dfA
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))

# column(s) from dfB are added 
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

Như được trình bày bằng cách sử dụng code trên, data frame kết quả `complete` sẽ chứa *tất cả* các cột từ cả `cases` và `results`. Nhiều cột sẽ được thêm vào bằng các hậu tố ".x" và ".y", vì nếu không, tên cột sẽ bị trùng lặp.

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Ngoài ra, để chỉ lấy 9 bản ghi "gốc" trong `cases` với (các) cột mới từ `results`, hãy sử dụng `select()` trên `results` trước khi nối, để nó chỉ chứa rownames và cột mà bạn muốn thêm vào `cases` (ví dụ: cột `result`).

```{r}
cases_clean <- cases %>% rownames_to_column()

results_clean <- results %>%
  rownames_to_column() %>% 
  select(rowname, result)    # select only certain columns 

matches_clean <- my_matches %>%
  mutate(across(everything(), as.character))

# joins
complete <- left_join(cases_clean, matches_clean, by = c("rowname" = "inds.a"))
complete <- left_join(complete, results_clean, by = c("inds.b" = "rowname"))
```

```{r message=FALSE, echo=F}
DT::datatable(complete, rownames = FALSE, options = list(pageLength = nrow(complete), scrollX=T), class = 'white-space: nowrap')
```

Nếu bạn chỉ muốn lấy một trong hai bộ dữ liệu cho các hàng khớp, bạn có thể sử dụng code bên dưới:

```{r}
cases_matched <- cases[my_matches$inds.a,]  # Rows in cases that matched to a row in results
results_matched <- results[my_matches$inds.b,]  # Rows in results that matched to a row in cases
```

Hoặc, để chỉ xem các hàng **không** khớp::

```{r}
cases_not_matched <- cases[!rownames(cases) %in% my_matches$inds.a,]  # Rows in cases that did NOT match to a row in results
results_not_matched <- results[!rownames(results) %in% my_matches$inds.b,]  # Rows in results that did NOT match to a row in cases
```

### Loại bỏ trùng lặp theo xác suất {.unnumbered}

Khớp theo xác suất cũng có thể được sử dụng để loại bỏ trùng lặp trong một bộ dữ liệu. Xem chương về Loại bỏ trùng lặp để biết các phương pháp loại bỏ trùng lặp khác.

Ở đây chúng ta đã bắt đầu với bộ dữ liệu `cases`, nhưng bây giờ đang được gọi là `cases_dup`, vì nó có 2 hàng bổ sung mà có thể là bản trùng lặp của các hàng trước đó: Xem "Tony" với "Anthony", và "Marialisa Rodrigues" với "Maria Rodriguez".

```{r, echo=F}
## Add duplicates
#cases_dup <- rbind(cases, cases[sample(1:nrow(cases), 3, replace = FALSE),])

cases_dup <- tribble(
  ~gender, ~first,      ~middle,     ~last,        ~yr,   ~mon, ~day, ~district,
  "M",     "Amir",      NA,          "Khan",       1989,  11,   22,   "River",
  "M",     "Anthony",   "B.",        "Smith",      1970, 09, 19,      "River", 
  "F",     "Marialisa", "Contreras", "Rodrigues",  1972, 04, 15,      "River",
  "F",     "Elizabeth", "Casteel",   "Chase",      1954, 03, 03,      "City",
  "M",     "Jose",      "Sanchez",   "Lopez",      1996, 01, 06,      "City",
  "F",     "Cassidy",   "Jones",      "Davis",     1980, 07, 20,      "City",
  "M",     "Michael",   "Murphy",     "O'Calaghan",1969, 04, 12,      "Rural", 
  "M",     "Oliver",    "Laurent",    "De Bordow" , 1971, 02, 04,     "River",
  "F",      "Blessing",  NA,          "Adebayo",   1955,  02, 14,     "Rural",
  "M",     "Tony",   "B.",        "Smith",         1970, 09, 19,      "River", 
  "F",     "Maria",  "Contreras", "Rodriguez",     1972, 04, 15,      "River",
)

```

```{r message=FALSE, echo=F}
DT::datatable(cases_dup, rownames = FALSE, options = list(pageLength = nrow(cases_dup)))
```

Chạy `fastLink()` giống nhu trước, nhưng so sánh data frame `cases_dup` với chính nó. Khai hai data frames được cung cấp giống hệt nhau, hàm sẽ giả định rằng bạn muốn loại bỏ trùng lặp. Lưu ý rằng chúng ta không chỉ định `stringdist.match =` hoặc `numeric.match =` như chúng ta đã làm trước đây.

```{r, message = F, warning = F}
## Run fastLink on the same dataset
dedupe_output <- fastLink(
  dfA = cases_dup,
  dfB = cases_dup,
  varnames = c("gender", "first", "middle", "last", "yr", "mon", "day", "district")
)
```

Bây giờ, bạn có thể xem xét các bản trùng lặp có thể xảy ra với `getMatches()`. Cung cấp data frame dưới dạng cả `dfA =` và `dfB =,` đồng thời cung cấp kết quả đầu ra của hàm `fastLink()` là `fl.out =`. `fl.out =` phải thuộc nhóm `fastLink.dedupe`, hay nói cách khác, là kết quả của `fastLink()`.

```{r}
## Run getMatches()
cases_dedupe <- getMatches(
  dfA = cases_dup,
  dfB = cases_dup,
  fl.out = dedupe_output)
```

Xem cột ngoài cùng bên phải, cột cho biết ID trùng lặp - hai hàng cuối cùng được xác định có thể là trùng lặp ở hàng 2 và 3.

```{r message=FALSE, echo=F}
DT::datatable(cases_dedupe, rownames = FALSE, options = list(pageLength = nrow(cases_dedupe)))
```

Để trả về số hàng của những hàng có khả năng trùng lặp, bạn có thể đếm số hàng trên mỗi giá trị duy nhất trong cột `dedupe.ids`, sau đó lọc để chỉ giữ lại những hàng có nhiều hơn một hàng. Trong trường hợp này, nó để lại hàng 2 và 3.

```{r}
cases_dedupe %>% 
  count(dedupe.ids) %>% 
  filter(n > 1)
```

Để kiểm tra toàn bộ các hàng có khả năng trùng lặp, hãy đặt số hàng trong lệnh này:

```{r}
# displays row 2 and all likely duplicates of it
cases_dedupe[cases_dedupe$dedupe.ids == 2,]   
```

## Gắn vào và căn chỉnh

Một phương pháp khác để kết hợp hai data frame là "ràng buộc" chúng với nhau. Bạn cũng có thể coi đây là hàng hoặc cột được "gắn vào" hoặc "thêm".

Phần này cũng sẽ thảo luận về cách "căn chỉnh" thứ tự các hàng của một data frame với thứ tự các hàng trong data frame khác. Chủ đề này được thảo luận dưới đây trong phần về Gắn các cột.

### Gắn các hàng {.unnumbered}

Để gắn các hàng của một data frame này với phần cuối của một data frame khác, hãy sử dụng `bind_rows()` từ **dplyr**. Hàm này có tính dung nạp, vì vậy bất kỳ cột nào có trong một trong hai data frame sẽ được đưa vào kết quả đầu ra. Một số lưu ý:

-   Không giống như `row.bind()` của phiên bản **base** R, `bind_rows()` của **dplyr** không yêu cầu thứ tự của các cột phải giống nhau trong cả hai data frame. Miễn là các tên cột được viết giống nhau, nó sẽ căn chỉnh chúng một cách chính xác. \
-   Bạn có thể tùy chọn xác định đối số `.id =`. Cung cấp một tên cột ký tự. Điều này sẽ tạo ra một cột mới dùng để xác định mỗi hàng ban đầu đến từ data frame nào.\
-   Bạn có thể sử dụng`bind_rows()` trên một `list` các data frame có cấu trúc tương tự để kết hợp chúng thành một. Xem ví dụ trong chương [Lặp, vòng lặp và danh sách] về việc nhập nhiều linelist với **purrr**.

Một ví dụ phổ biến về row binding là gắn một hàng "tổng (total)" vào một bảng mô tả được tạo bằng hàm `summarise()` của **dplyr**. Dưới đây, chúng ta tạo một bảng đếm số trường hợp và giá trị CT trung bình theo bệnh viện với một hàng tổng.

Hàm `summarise()` được sử dụng trên dữ liệu đã nhóm theo bệnh viện để trả về một data frame tóm tắt theo bệnh viện. Nhưng hàm `summarise()` không tự động tạo ra hàng "tổng", vì vậy chúng ta tạo ra nó bằng cách tổng hợp *lại* dữ liệu, nhưng với dữ liệu không bị nhóm theo bệnh viện. Điều này tạo ra một data frame thứ hai chỉ gồm một hàng. Sau đó, chúng ta có thể liên kết các data frame này với nhau để có được bảng cuối cùng.

Xem các ví dụ hoạt động khác tương tự như thế này trong chương [Bảng mô tả] và [Trình bày bảng].

```{r}
# Create core table
###################
hosp_summary <- linelist %>% 
  group_by(hospital) %>%                        # Group data by hospital
  summarise(                                    # Create new summary columns of indicators of interest
    cases = n(),                                  # Number of rows per hospital-outcome group     
    ct_value_med = median(ct_blood, na.rm=T))     # median CT value per group
```

Đây là data frame `hosp_summary`:

```{r message=FALSE, echo=F}
DT::datatable(hosp_summary, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Tạo một data frame với thống kê "tổng" (*không bị nhóm theo bệnh viện*). Điều này sẽ trả về chỉ một hàng.

```{r}
# create totals
###############
totals <- linelist %>% 
  summarise(
    cases = n(),                               # Number of rows for whole dataset     
    ct_value_med = median(ct_blood, na.rm=T))  # Median CT for whole dataset
```

Và dưới đây là data frame `totals`. Lưu ý cách mà chỉ tạo ra hai cột. Những cột này cũng nằm trong `hosp_summary`, nhưng có một cột trong `hosp_summary` mà không nằm trong `totals` (`hospital`).

```{r message=FALSE, echo=F}
DT::datatable(totals, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Bây giờ chúng ta có thể gắn các hàng với nhau bằng `bind_rows()`.

```{r}
# Bind data frames together
combined <- bind_rows(hosp_summary, totals)
```

Bây giờ chúng ta có thể xem kết quả. Xem cách mà trong hàng cuối cùng, giá trị `NA` trống được điền vào cột trong `hospital` mà không có trong `hosp_summary`. Như đã giải thích trong chương [Trình bày bảng], bạn có thể "điền" vào ô này với "Tổng" bằng cách sử dụng `replace_na()`.

```{r message=FALSE, echo=F}
DT::datatable(combined, rownames = FALSE, options = list(pageLength = nrow(10)))
```

### Gắn các cột {.unnumbered}

Có một hàm **dplyr** tuơng tự là `bind_cols()`, hàm mà bạn có thể sử dụng để kết hợp hai data frame theo chiều ngang. Lưu ý rằng các hàng được khớp với nhau theo *vị trí* (khác với *phép nối* ở trên) - ví dụ: hàng thứ 12 trong mỗi data frame sẽ được căn chỉnh.

Ví dụ, chúng ta liên kết một số bảng tóm tắt với nhau. Để làm điều này, chúng ta cũng trình bày cách sắp xếp lại thứ tự của các hàng trong một data frame để khớp với thứ tự hàng trong một data frame khác, với `match()`.

Ở đây chúng ta định nghĩa `case_info` là một data frame tóm tắt về các trường hợp trong linelist theo bệnh viện, với số trường hợp và số ca tử vong.

```{r}
# Case information
case_info <- linelist %>% 
  group_by(hospital) %>% 
  summarise(
    cases = n(),
    deaths = sum(outcome == "Death", na.rm=T)
  )
```

```{r message=FALSE, echo=F}
DT::datatable(case_info, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Và giả sử rằng đây là một data frame `contact_fu` khác chứa thông tin về phần trăm số liên hệ bị phơi nhiễm được điều tra và "theo dõi", lại một lần nữa bởi bệnh viện.

```{r}
contact_fu <- data.frame(
  hospital = c("St. Mark's Maternity Hospital (SMMH)", "Military Hospital", "Missing", "Central Hospital", "Port Hospital", "Other"),
  investigated = c("80%", "82%", NA, "78%", "64%", "55%"),
  per_fu = c("60%", "25%", NA, "20%", "75%", "80%")
)
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Lưu ý rằng các bệnh viện đều như nhau, nhưng theo thứ tự khác nhau trong mỗi data frame. Giải pháp đơn giản nhất là sử dụng `left_join()` trên cột `hospital`, nhưng bạn cũng có thể sử dụng `bind_cols()` với một bước bổ sung.

#### Sử dụng `match()` để sắp xếp thứ tự {.unnumbered}

Do thứ tự hàng khác nhau, một lệnh `bind_cols()` đơn giản sẽ dẫn đến khớp sai dữ liệu. Để khắc phục điều này, chúng ta có thể sử dụng hàm `match()` trong **base** R để căn chỉnh các hàng của data frame theo thứ tự giống với thứ tự trong data frame khác. Chúng ta giả định đối với phương pháp này rằng không có giá trị trùng lặp nào trong cả hai data frame.

Khi chúng ta sử dụng `match()`, với cú pháp là `match(TARGET ORDER VECTOR, DATA FRAME COLUMN TO CHANGE)`, trong đó đối số đầu tiên là thứ tự mong muốn (hoặc là một vectơ độc lập, hoặc trong trường hợp này là một cột trong data frame), và đối số thứ hai là cột data frame trong data frame mà sẽ được sắp xếp lại. Kết quả đầu ra của `match()` sẽ là một vectơ số đại diện cho thứ tự vị trí chính xác. Bạn có thể đọc thêm với `?match`.

```{r}
match(case_info$hospital, contact_fu$hospital)
```

Bạn có thể sử dụng vectơ số này để sắp xếp lại thứ tự data frame - đặt nó trong tập con của dấu ngoặc `[ ]` *trước dấu phẩy*. Đọc thêm về cú pháp tập con của dấu ngoặc **base** R trong chương [R cơ bản]. Lệnh bên dưới tạo ra một data frame mới, được định nghĩa là data frame cũ mà trong đó các hàng được sắp xếp theo thứ tự trong vectơ số ở trên.

```{r}
contact_fu_aligned <- contact_fu[match(case_info$hospital, contact_fu$hospital),]
```

```{r message=FALSE, echo=F}
DT::datatable(contact_fu_aligned, rownames = FALSE, options = list(pageLength = nrow(10)))
```

Bây giờ chúng ta có thể gắn các cột data frame với nhau, với thứ tự hàng chính xác. Lưu ý rằng một số cột bị trùng lặp và sẽ yêu cầu làm sạch bằng `rename()`. Đọc thêm về `bind_rows()` [tại đây](https://dplyr.tidyverse.org/reference/bind.html).

```{r}
bind_cols(case_info, contact_fu)
```

Một hàm trong **base** R thay thế cho `bind_cols` là `cbind()`, hàm này hoạt động tương tự với `bind_cols`.

<!-- ======================================================= -->

## Tài nguyên học liệu

[tidyverse page on joins](https://dplyr.tidyverse.org/reference/join.html)

[R for Data Science page on relational data](https://r4ds.had.co.nz/relational-data.html)

[tidyverse page on dplyr](https://dplyr.tidyverse.org/reference/bind.html) về ràng buộc dữ liệu

Đặc trưng của [fastLink](https://github.com/kosukeimai/fastLink) tại trang Github package

Xuất bản mô tả phương pháp luận của [fastLink](https://imai.fas.harvard.edu/research/files/linkage.pdf)

Xuất bản mô tả [package RecordLinkage](https://journal.r-project.org/archive/2010/RJ-2010-017/RJ-2010-017.pdf)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/joining_matching.Rmd-->

# Loại bỏ trùng lặp {#deduplication}

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "deduplication.png"))
```

Chương này đề cập đến các kỹ thuật loại bỏ trùng lặp sau:

1.  Xác định và loại bỏ các hàng trùng lặp\
2.  "Cắt" một số hàng để chỉ giữ lại những hàng nhất định (ví dụ: tối thiểu hoặc tối đa) từ mỗi nhóm hàng\
3.  "Rolling-up" hoặc kết hợp các giá trị từ nhiều hàng thành một hàng

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ **pacman**, hàm sẽ cài đặt package nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với `library()` từ **base** R. Xem chương [R cơ bản] để có thêm thông tin về các R package.

```{r}
pacman::p_load(
  tidyverse,   # deduplication, grouping, and slicing functions
  janitor,     # function for reviewing duplicates
  stringr)      # for string searches, can be used in "rolling-up" values
```

### Nhập dữ liệu {.unnumbered}

Để minh họa, chúng tôi sẽ sử dụng một bộ dữ liệu mẫu được tạo bằng code R bên dưới.

Dữ liệu là các bản ghi về những cuộc gọi truy vết COVID-19, bao gồm những cuộc gọi truy vết với các liên hệ và với các trường hợp. Các cột bao gồm `recordID` (mã bản ghi) (do máy tính tạo), `personID` (mã người truy vết), `name` (tên), `date` (ngày) truy vết, `time` (thời gian) truy vết, `purpose` (mục đích) truy vết (phỏng vấn một trường hợp hoặc một liên hệ) và `symptoms_ever` (liệu người được truy vết đã *từng* được báo cáo có triệu chứng hay không).

Đây là code để tạo bộ dữ liệu `obs`:

```{r}
obs <- data.frame(
  recordID  = c(1,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18),
  personID  = c(1,1,2,2,3,2,4,5,6,7,2,1,3,3,4,5,5,7,8),
  name      = c("adam", "adam", "amrish", "amrish", "mariah", "amrish", "nikhil", "brian", "smita", "raquel", "amrish",
                "adam", "mariah", "mariah", "nikhil", "brian", "brian", "raquel", "natalie"),
  date      = c("1/1/2020", "1/1/2020", "2/1/2020", "2/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020", "5/1/2020","5/1/2020", "2/1/2020",
                "5/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "6/1/2020", "7/1/2020", "7/1/2020", "7/1/2020"),
  time      = c("09:00", "09:00", "14:20", "14:20", "12:00", "16:10", "13:01", "15:20", "14:20", "12:30", "10:24",
                "09:40", "07:25", "08:32", "15:36", "15:31", "07:59", "11:13", "17:12"),
  encounter = c(1,1,1,1,1,3,1,1,1,1,2,
                2,2,3,2,2,3,2,1),
  purpose   = c("contact", "contact", "contact", "contact", "case", "case", "contact", "contact", "contact", "contact", "contact",
                "case", "contact", "contact", "contact", "contact", "case", "contact", "case"),
  symptoms_ever = c(NA, NA, "No", "No", "No", "Yes", "Yes", "No", "Yes", NA, "Yes",
                    "No", "No", "No", "Yes", "Yes", "No","No", "No")) %>% 
  mutate(date = as.Date(date, format = "%d/%m/%Y"))
```

#### Đây là data frame {#dedup_data .unnumbered}

Sử dụng bộ lọc của các box ở trên cùng để xem lại các cuộc gọi truy vết theo từng người.

```{r message=FALSE, echo=F}
DT::datatable(obs, rownames = FALSE, filter = "top", options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```

Một số điều cần lưu ý khi bạn xem xét dữ liệu:

-   Hai bản ghi đầu tiên hoàn toàn 100% là trùng lặp, bao gồm cả `recordID` (hẳn là một lỗi máy tính!)\
-   Hai hàng thứ hai trùng lặp trong tất cả các cột *ngoại trừ `recordID`*\
-   Một vài cá nhân có nhiều cuộc gọi truy vết, vào những ngày, giờ khác nhau, được tính là những liên hệ và/hoặc những trường hợp\
-   Ở mỗi cuộc gọi truy vết, người được truy vết được hỏi đã **từng** mắc các triệu chứng chưa và một số thông tin này bị missing.

Và đây là bản tóm tắt nhanh về những người truy vết và mục đích các cuộc gọi truy vết của họ, sử dụng hàm `tabyl()` từ **janitor**:

```{r}
obs %>% 
  tabyl(name, purpose)
```

<!-- ======================================================= -->

## Loại bỏ trùng lặp

Phần này mô tả cách xem xét và loại bỏ các hàng trùng lặp trong data frame. Đồng thời cũng chỉ ra cách xử lý các phần tử trùng lặp trong một vectơ.

<!-- ======================================================= -->

### Kiểm tra hàng trùng lặp {.unnumbered}

Để nhanh chóng xem lại các hàng có trùng lặp, bạn có thể sử dụng `get_dupes()` từ package **janitor**. *Theo mặc định*, tất cả các cột được xem xét khi đánh giá trùng lặp - các hàng được hàm trả về là trùng lặp 100% nếu xét đến các giá trị trong *tất cả* các cột.

Trong data frame `obs`, hai hàng đầu tiên *trùng lặp 100%* - chúng có cùng giá trị trong tất cả các cột (bao gồm cả cột `recordID`, vốn *được cho* là duy nhất - hẳn là một số trục trặc máy tính). Data frame được trả về tự động bao gồm một cột mới `dupe_count` ở phía bên phải, hiển thị số hàng có sự kết hợp của các giá trị trùng lặp đó.

```{r, eval=F}
# 100% duplicates across all columns
obs %>% 
  janitor::get_dupes()
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes() %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```

Xem [dữ liệu gốc](#dedup_data)

Tuy nhiên, nếu chúng ta chọn bỏ qua `recordID`, thì hàng thứ 3 và thứ 4 cũng là bản trùng lặp của nhau. Nghĩa là chúng có cùng giá trị trong tất cả các cột *ngoại trừ* `recordID`. Bạn có thể xác định các cột cụ thể bị bỏ qua trong hàm bằng ký hiệu `-` (dấu trừ).

```{r, eval=F}
# Duplicates when column recordID is not considered
obs %>% 
  janitor::get_dupes(-recordID)         # if multiple columns, wrap them in c()
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(-recordID) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = nrow(obs), scrollX=T), class = 'white-space: nowrap' )
```

Bạn cũng có thể xác định rõ các cột cần xem xét. Dưới đây, chỉ các hàng có cùng giá trị trong cột `name` và `purpose` được trả về. Lưu ý rằng "amrish" hiện có `dupe_count` bằng 3 cho thấy ba cuộc gọi truy vết "liên hệ" của anh ta.

*Cuộn sang trái để xem thêm hàng*

```{r, eval=F}
# duplicates based on name and purpose columns ONLY
obs %>% 
  janitor::get_dupes(name, purpose)
```

```{r message=FALSE, echo=F}
obs %>% 
  janitor::get_dupes(name, purpose) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 7, scrollX=T), class = 'white-space: nowrap' )
```

Xem [dữ liệu gốc](#dedup_data).

Xem `?get_dupes` để biết thêm chi tiết hoặc xem tài liệu [tham khảo trực tuyến](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes) này

<!-- ======================================================= -->

### Chỉ giữ lại các hàng duy nhất {.unnumbered}

Để chỉ giữ lại các hàng duy nhất của một data frame, hãy sử dụng `distinct()` từ **dplyr** (đã được giải thích trong chương [Làm sạch số liệu và các hàm quan trọng]). Các hàng trùng lặp sẽ bị loại bỏ sao cho chỉ giữ lại hàng đầu tiên trong số các hàng đó. Theo mặc định, hàng "đầu tiên" có nghĩa là hàng có `rownumber` cao nhất (thứ tự của các hàng từ trên-xuống-dưới). Chỉ các hàng duy nhất được giữ lại.

Trong ví dụ dưới đây, chúng tôi chạy lệnh `distinct()` sao cho cột `recordID` bị loại trừ khỏi việc xem xét - do đó **hai hàng trùng lặp sẽ bị loại bỏ**. Hàng đầu tiên (đối với "adam") bị trùng lặp 100% và đã bị loại bỏ. Bên cạnh đó, hàng 3 (cho "amrish") là một bản bị trùng lặp trong tất cả các cột *ngoại trừ* `recordID` (đang không được xét) và do đó cũng bị loại bỏ. Bộ dữ liệu `obs` bây giờ có số dòng là `nrow(obs)-2`, không phải là `nrow(obs)`).

*Cuộn sang trái để xem toàn bộ data frame*

```{r, eval=F}
# added to a chain of pipes (e.g. data cleaning)
obs %>% 
  distinct(across(-recordID), # reduces data frame to only unique rows (keeps first one of any duplicates)
           .keep_all = TRUE) 

# if outside pipes, include the data as first argument 
# distinct(obs)
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(across(-recordID), # reduces data frame to only unique rows (keeps first one of any duplicates)
           .keep_all = TRUE) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX=T), class = 'white-space: nowrap' )
```

[***CHÚ Ý:*** Nếu sử dụng `distinct()` trên nhóm dữ liệu, hàm sẽ áp dụng cho từng nhóm.]{style="color: orange;"}

**Loại bỏ trùng lặp dựa trên cột cụ thể**

Bạn cũng có thể xác định các cột cơ sở để loại bỏ trùng lặp. Theo cách này, loại bỏ trùng lặp chỉ áp dụng cho các hàng trùng lặp trong các cột được chỉ định. Trừ khi bạn đặt `.keep_all = TRUE`, tất cả các cột không được đề cập sẽ bị loại bỏ.

Trong ví dụ dưới đây, loại bỏ trùng lặp chỉ áp dụng cho các hàng có giá trị giống nhau trong các cột `name` và `purpose`. Do đó, "brian" chỉ có 2 hàng thay vì 3 - cuộc gọi truy vết "liên hệ" *đầu tiên* và cuộc gọi truy vết "trường hợp" duy nhất của anh ta. Để điều chỉnh sao cho cuộc gọi truy vết *mới nhất* của brian đối với từng mục đích được lưu giữ, hãy xem mục Cắt theo nhóm.

*Cuộn sang trái để xem toàn bộ data frame*

```{r, eval=F}
# added to a chain of pipes (e.g. data cleaning)
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # keep rows unique by name and purpose, retain all columns
  arrange(name)                                  # arrange for easier viewing
```

```{r message=FALSE, echo=F}
obs %>% 
  distinct(name, purpose, .keep_all = TRUE) %>%  # keep rows unique by name and purpose, retain all columns
  arrange(name) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 6, scrollX=T), class = 'white-space: nowrap' )
```

Xem [dữ liệu gốc](#dedup_data).

<!-- ======================================================= -->

### Loại bỏ phần tử trùng lặp trong một vectơ {.unnumbered}

Hàm `duplicated()` từ **base** R sẽ đánh giá một vectơ (cột) và trả về một vectơ logic có cùng độ dài (TRUE/FALSE). Lần đầu tiên một giá trị xuất hiện, nó sẽ trả về giá trị FALSE (không phải là một bản trùng lặp) và những lần tiếp theo giá trị đó xuất hiện, nó sẽ trả về giá trị TRUE. Lưu ý giá trị `NA` được xử lý giống như bất kỳ giá trị nào khác.

```{r}
x <- c(1, 1, 2, NA, NA, 4, 5, 4, 4, 1, 2)
duplicated(x)
```

Để chỉ trả về các phần tử bị trùng lặp, bạn có thể sử dụng dấu ngoặc để đặt vectơ gốc:

```{r}
x[duplicated(x)]
```

Để chỉ trả về các phần tử duy nhất, hãy sử dụng hàm `unique()` từ **base** R. Để loại bỏ các `NA` khỏi kết quả đầu ra, hãy lồng `na.omit()` trong `unique()`.

```{r}
unique(x)           # alternatively, use x[!duplicated(x)]
unique(na.omit(x))  # remove NAs 
```

<!-- ======================================================= -->

### Sử dụng **base** R {.unnumbered}

**Để trả về các hàng trùng lặp**

Trong **base** R, bạn cũng có thể xem những hàng nào là trùng lặp 100% trong data frame `df` bằng lệnh `duplicated(df)` (trả về một vectơ logic của các hàng).

Do đó, bạn cũng có thể sử dụng tập con cơ sở `[ ]` trên data frame để xem các hàng *trùng lặp* với `df[duplicated(df),]` (đừng quên dấu phẩy, điều đó có nghĩa là bạn muốn xem tất cả các cột!).

**Để trả về các hàng duy nhất**

Xem các ghi chú ở trên. Để xem các hàng *duy nhất*, bạn thêm dấu phủ định logic `!` ở trước hàm `duplicated()`:\
`df[!duplicated(df),]`

**Để trả về các hàng trùng lặp chỉ với một số cột nhất định**

Đặt `df` nằm *trong dấu ngoặc đơn hàm* *`duplicated()`*, hàm này sẽ chỉ hoạt động trên một số cột nhất định của `df`.

Để xác định các cột, hãy cung cấp số thứ tự hoặc tên cột sau dấu phẩy (nhớ rằng đặt tất cả những thông tin này *trong* hàm `duplicated()`).

Hãy chắc chắn đặt dấu phẩy `,` *bên ngoài* và sau hàm `duplicated()`!

Ví dụ: Để chỉ đánh giá các cột từ 2 đến 5 cho các bản trùng lặp: `df[!duplicated(df[, 2:5]),]`\
Để chỉ đánh giá các cột `name` và `purpose` cho các bản trùng lặp: `df[!duplicated(df[, c("name", "purpose)]),]`

<!-- ======================================================= -->

## Cắt dòng

"Cắt" một data frame nhằm áp dụng bộ lọc trên các hàng theo số/vị trí hàng. Điều này trở nên đặc biệt hữu ích nếu bạn có nhiều hàng cho mỗi nhóm chức năng (ví dụ: mỗi "người") và bạn chỉ muốn giữ một hoặc một số hàng trong số đó.

Hàm `slice()` cơ bản chấp nhận các số và trả về các hàng ở những vị trí đó. Nếu các số được cung cấp là số dương, chỉ có chúng được trả về. Nếu là số âm, những hàng đó *không* được trả về. Tất cả các số đều phải là số dương hoặc đều là số âm.

```{r}
obs %>% slice(4)  # return the 4th row
```

```{r}
obs %>% slice(c(2,4))  # return rows 2 and 4
#obs %>% slice(c(2:4))  # return rows 2 through 4
```

Xem [dữ liệu gốc](#dedup_data).

Có một số biến thể: Chúng phải được cung cấp với một cột và một số hàng để trả về (tới `n =`).

-   `slice_min()` và `slice_max()` chỉ giữ (các) hàng có (các) giá trị nhỏ nhất hoặc lớn nhất của cột được chỉ định. Hàm này cũng hoạt động để trả về "tối thiểu" và "tối đa" của các biến factor có thứ tự.\
-   `slice_head()` và `slice_tail()` - chỉ giữ (các) hàng *đầu tiên* hoặc *cuối cùng*.\
-   `slice_sample()` - chỉ giữ một mẫu ngẫu nhiên của các hàng.

```{r}
obs %>% slice_max(encounter, n = 1)  # return rows with the largest encounter number
```

Sử dụng đối số `n =` hoặc `prop =` để xác định số lượng hoặc tỷ lệ hàng cần giữ. Nếu không sử dụng hàm trong chuỗi pipe, trước tiên hãy cung cấp đối số dữ liệu (ví dụ: `slice(data, n = 2)`). Xem `?slice` để biết thêm thông tin.

Các đối số khác:

`.order_by =` được sử dụng trong `slice_min()` và `slice_max()`, sắp xếp thứ tự theo một cột trước khi cắt.\
`with_ties =` TRUE theo mặc định, nghĩa là các ràng buộc bị giữ lại.\
`.preserve =` FALSE theo mặc định. Nếu TRUE thì cấu trúc nhóm được tính toán lại sau khi cắt.\
`weight_by =` Tùy chọn, cột dữ liệu kiểu số được tính theo trọng số (số lớn hơn có nhiều khả năng được lấy mẫu hơn). Đồng thời `replace =` cho việc lấy mẫu liệu có được thực hiện mà có/không có sự thay thế.

[***MẸO:*** Khi sử dụng `slice_max()` và `slice_min()`, hãy chắc chắn bạn cụ thể/ghi `n =` (ví dụ: `n = 2`, không chỉ `2`). Nếu không, bạn có thể gặp lỗi `Error:`...`is not empty`.]{style="color: darkgreen;"}

[***LƯU Ý:*** Bạn có thể gặp hàm [`top_n()`](https://dplyr.tidyverse.org/reference/top_n.html), hàm mà đã bị thay thế bởi các hàm `slice`.]{style="color: black;"}

<!-- ======================================================= -->

### Cắt theo nhóm {.unnumbered}

Các hàm `slice_*()` có thể rất hữu ích nếu được áp dụng cho một data frame được nhóm lại vì thao tác cắt được thực hiện trên từng nhóm riêng biệt. Sử dụng **hàm** `group_by()` kết hợp với `slice()` nhằm nhóm dữ liệu để lấy một lát cắt từ mỗi nhóm.

Điều này rất hữu ích cho việc loại bỏ trùng lặp nếu bạn có nhiều hàng cho mỗi người nhưng chỉ muốn giữ một trong số chúng. Trước tiên, bạn sử dụng `group_by()` với các cột chính mà giống nhau cho mỗi người, sau đó sử dụng một hàm slice trên một cột, điều này sẽ khác nhau giữa các hàng được nhóm.

Trong ví dụ dưới đây, để chỉ giữ lại cuộc gọi truy vết *mới nhất* *theo mỗi người*, chúng ta nhóm các hàng theo cột `name` và sau đó sử dụng `slice_max()` với `n = 1` trên cột `date`. Hãy lưu ý! Để áp dụng một hàm như `slice_max()` vào dates (ngày tháng), cột ngày tháng phải thuộc nhóm Date.

Theo mặc định, "các ràng buộc" (ví dụ: cùng ngày trong trường hợp này) được giữ lại và chúng tôi sẽ vẫn nhận được nhiều hàng cho một số người (ví dụ: adam). Để tránh tình huống này, chúng tôi đặt `with_ties = FALSE`. Chúng tôi sẽ chỉ nhận lại một hàng cho mỗi người.

[***CHÚ Ý:*** Nếu sử dụng `arrange()`, xác định `.by_group = TRUE` để sắp xếp dữ liệu trong mỗi nhóm.]{style="color: orange;"}

[***THẬN TRỌNG:*** Nếu `with_ties = FALSE`, hàng đầu tiên có ràng buộc được giữ lại. Điều này có thể là sự nhầm lẫn. Hãy xem trường hợp của Mariah, cô ấy có hai cuộc gọi truy vết vào ngày gần nhất (ngày 06/01) và cuộc gọi truy vết đầu tiên (sớm nhất) được giữ lại. Rất có thể, chúng ta muốn giữ lại cuộc gọi truy vết muộn hơn của cô ấy vào ngày đó. Xem cách "phá vỡ" những ràng buộc này trong ví dụ tiếp theo.]{style="color: red;"}

```{r, eval=F}
obs %>% 
  group_by(name) %>%       # group the rows by 'name'
  slice_max(date,          # keep row per group with maximum date value 
            n = 1,         # keep only the single highest row 
            with_ties = F) # if there's a tie (of date), take the first row
```

```{r message=FALSE, echo=F}
obs %>% 
  group_by(name) %>%       # group the rows by 'name'
  slice_max(date,          # keep row per group with maximum date value 
            n = 1,         # keep only the single highest row 
            with_ties = F) %>%  # if there's a tie (of date), take the first row
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

Ví dụ ở trên, chúng ta có thể thấy rằng chỉ hàng của Amrish vào ngày 05/01 được giữ lại và chỉ hàng của Brian vào ngày 07/01 được giữ lại. Xem [dữ lịệu gốc](#dedup_data).

**Phá vỡ "ràng buộc"**

Nhiều câu lệnh cắt (slice) có thể được chạy để "phá vỡ các ràng buộc". Trong trường hợp này, nếu một người có nhiều cuộc gọi truy vết vào *ngày* gần nhất, cuộc gọi truy vết với *thời gian* gần nhất sẽ được giữ lại (`lubridate::hm()` được sử dụng để chuyển đổi ký tự thời gian thành một lớp thời gian có thể sắp xếp).\
Lưu ý rằng bây giờ, một hàng được giữ cho "Mariah" vào ngày 06/01 là cuộc gọi truy vết thứ 3 từ 08:32, không phải cuộc gọi truy vết thứ 2 lúc 07:25.

```{r, eval=F}
# Example of multiple slice statements to "break ties"
obs %>%
  group_by(name) %>%
  
  # FIRST - slice by latest date
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # SECOND - if there is a tie, select row with latest time; ties prohibited
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE)
```

```{r message=FALSE, echo=F}
# Example of multiple slice statements to "break ties"
obs %>%
  group_by(name) %>%
  
  # FIRST - slice by latest date
  slice_max(date, n = 1, with_ties = TRUE) %>% 
  
  # SECOND - if there is a tie, select row with latest time; ties prohibited
  slice_max(lubridate::hm(time), n = 1, with_ties = FALSE) %>% 
  
  DT::datatable(rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

*Trong ví dụ trên, cũng có thể cắt theo số lần `encounter`, nhưng chúng tôi đã hiển thị cách cắt theo `date` và `time` cho mục đích ví dụ.*

[***MẸO:*** Để sử dụng `slice_max()` hoặc `slice_min()` trên một cột "kí tự", hãy biến đối nó thành một lớp yếu tố *được sắp xếp theo thứ tự*!]{style="color: darkgreen;"}

Xem [dữ liệu gốc](#dedup_data).

<!-- ======================================================= -->

### Giữ lại tất cả nhưng đánh dấu các dòng {.unnumbered}

Nếu bạn muốn giữ lại tất cả các bản ghi nhưng chỉ đánh dấu một số để phân tích, hãy cân nhắc cách tiếp cận hai bước sử dụng một số recordID/encounter duy nhất:

1)  Giảm/cắt data frame gốc thành chỉ bao gồm các hàng cho phân tích. Lưu/giữ lại data frame đã được thu gọn này.\
2)  Trong data frame gốc, hãy đánh dấu các hàng là thích hợp với `case_when()`, dựa trên việc liệu mã định danh duy nhất của những bản ghi này (recordID trong ví dụ này) có trong data frame thu gọn hay không.

```{r}
# 1. Define data frame of rows to keep for analysis
obs_keep <- obs %>%
  group_by(name) %>%
  slice_max(encounter, n = 1, with_ties = FALSE) # keep only latest encounter per person


# 2. Mark original data frame
obs_marked <- obs %>%

  # make new dup_record column
  mutate(dup_record = case_when(
    
    # if record is in obs_keep data frame
    recordID %in% obs_keep$recordID ~ "For analysis", 
    
    # all else marked as "Ignore" for analysis purposes
    TRUE                            ~ "Ignore"))

# print
obs_marked
```

```{r, echo=F}
DT::datatable(obs_marked, rownames = FALSE, options = list(pageLength = 8, scrollX=T), class = 'white-space: nowrap' )
```

Xem [dữ liệu gốc](#dedup_data).

<!-- ======================================================= -->

### Tính toán độ hoàn chỉnh của hàng {.unnumbered}

Tạo một cột chứa số liệu về độ hoàn chỉnh (không bị thiếu) của hàng. Điều này có thể hữu ích khi quyết định ưu tiên hàng nào hơn hàng nào khi loại bỏ trùng lặp/cắt.

Trong ví dụ này, các cột "chính" mà bạn muốn đo lường mức độ hoàn chỉnh được lưu trong một vectơ tên cột.

Sau đó, cột mới `key_completeness` được tạo bằng hàm `mutate()`. Giá trị mới của mỗi hàng được xác định dưới dạng phân số được tính toán bằng: số giá trị không bị thiếu trong hàng đó trong số các cột chính, chia cho số cột chính.

Điều này cần thêm hàm `rowSums()` từ **base** R. Data frame sử dụng được đại diện bởi dấu `.`, tức là tham chiếu đến data frame nguồn trong một chuỗi pipe (trong trường hợp này, nó sẽ được tách thành tập con với dấu ngoặc vuông `[]`).

*Cuộn sang phải để xem các hàng khác*

```{r, eval=F}
# create a "key variable completeness" column
# this is a *proportion* of the columns designated as "key_cols" that have non-missing values

key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) 
```

```{r message=FALSE, echo=F}
key_cols = c("personID", "name", "symptoms_ever")

obs %>% 
  mutate(key_completeness = rowSums(!is.na(.[,key_cols]))/length(key_cols)) %>% 
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Xem [dữ liệu gốc](#dedup_data).

<!-- ======================================================= -->

## Gộp các giá trị {#str_rollup}

Phần này miêu tả:

1)  Cách "gộp (roll-up)" các giá trị từ nhiều hàng chỉ thành một hàng, với một số biến thể\
2)  Khi bạn có các giá trị "đã được gộp", cách để ghi đè/ưu tiên các giá trị trong mỗi ô

Tab này sử dụng bộ dữ liệu mẫu từ tab Chuẩn bị.

<!-- ======================================================= -->

### Gộp các giá trị thành một hàng {.unnumbered}

Code ví dụ bên dưới sử dụng `group_by()` và `summarise()` để nhóm các hàng theo từng người, rồi dán (paste) tất cả các giá trị duy nhất trong các hàng được nhóm lại với nhau. Do đó, bạn nhận được một hàng tóm tắt cho mỗi người. Một số lưu ý:

-   Một hậu tố được thêm vào tất cả các cột mới ("\_roll" trong ví dụ này)\
-   Nếu bạn chỉ muốn hiển thị các giá trị duy nhất trên mỗi ô, thì hãy đặt `na.omit()` trong `unique()`\
-   `na.omit()` loại bỏ các giá trị `NA`, nhưng nếu đây là điều không mong muốn, nó có thể bị loại bỏ bởi `paste0(.x)`...

```{r, eval=F}
# "Roll-up" values into one row per group (per "personID") 
cases_rolled <- obs %>% 
  
  # create groups by name
  group_by(personID) %>% 
  
  # order the rows within each group (e.g. by date)
  arrange(date, .by_group = TRUE) %>% 
  
  # For each column, paste together all values within the grouped rows, separated by ";"
  summarise(
    across(everything(),                           # apply to all columns
           ~paste0(na.omit(.x), collapse = "; "))) # function is defined which combines non-NA values
```

Kết quả là một hàng cho mỗi nhóm (`ID`), với các mục đã nhập được sắp xếp theo ngày và được dán cùng nhau. *Cuộn sang trái để xem các hàng khác*

```{r message=FALSE, echo=F}
# "Roll-up" values into one row per group (per "personID") 
obs %>% 
  
  # create groups by name
  group_by(personID) %>% 
  
  # order the rows within each group (e.g. by date)
  arrange(date, .by_group = TRUE) %>% 
  
  # For each column, paste together all values within the grouped rows, separated by ";"
  summarise(
    across(everything(),                                # apply to all columns
           ~paste0(na.omit(.x), collapse = "; "))) %>%  # function is defined which combines non-NA values

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Xem [dữ liệu gốc](#dedup_data).

**Biến thể này chỉ hiển thị các giá trị duy nhất:**

```{r}
# Variation - show unique values only 
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # apply to all columns
           ~paste0(unique(na.omit(.x)), collapse = "; "))) # function is defined which combines unique non-NA values
```

```{r message=FALSE, echo=F}
# Variation - show unique values only 
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                                   # apply to all columns
           ~paste0(unique(na.omit(.x)), collapse = "; "))) %>%  # function is defined which combines unique non-NA values

  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**Biến thể này thêm hậu tố vào mỗi cột.**\
Trong trường hợp này, "\_roll" được dùng để biểu thị rằng nó đã được gộp:

```{r, eval=F}
# Variation - suffix added to column names 
cases_rolled <- obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) # _roll is appended to column names
```

```{r message=FALSE, echo=F}
# display the linelist data as a table
# Variation - suffix added to column names 
obs %>% 
  group_by(personID) %>% 
  arrange(date, .by_group = TRUE) %>% 
  summarise(
    across(everything(),                
           list(roll = ~paste0(na.omit(.x), collapse = "; ")))) %>%  # _roll is appended to column names
  DT::datatable(rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### Ghi đè các giá trị/hệ thống phân cấp {.unnumbered}

Sau đó, nếu bạn muốn đánh giá tất cả các giá trị đã gộp và chỉ giữ một giá trị cụ thể (ví dụ: giá trị "tốt nhất (best)" hoặc "tối đa (maximum)"), bạn có thể sử dụng hàm `mutate()` trên các cột mong muốn, để triển khai các điều kiện rẽ nhánh với `case_when()` và `str_detect()` từ package **stringr** để tìm kiếm tuần tự các mẫu chuỗi và ghi đè nội dung ô.

```{r}
# CLEAN CASES
#############
cases_clean <- cases_rolled %>% 
    
    # clean Yes-No-Unknown vars: replace text with "highest" value present in the string
    mutate(across(c(contains("symptoms_ever")),                     # operates on specified columns (Y/N/U)
             list(mod = ~case_when(                                 # adds suffix "_mod" to new cols; implements case_when()
               
               str_detect(.x, "Yes")       ~ "Yes",                 # if "Yes" is detected, then cell value converts to yes
               str_detect(.x, "No")        ~ "No",                  # then, if "No" is detected, then cell value converts to no
               str_detect(.x, "Unknown")   ~ "Unknown",             # then, if "Unknown" is detected, then cell value converts to Unknown
               TRUE                        ~ as.character(.x)))),   # then, if anything else if it kept as is
      .keep = "unused")                                             # old columns removed, leaving only _mod columns
```

Bây giờ bạn có thể thấy trong cột `symptoms_ever` rằng nếu người đó TỪNG trả lời "Yes" với các triệu chứng, thì chỉ "Yes" được hiển thị.

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(cases_clean, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap')
```

Xem [dữ liệu gốc](#dedup_data).

## Loại bỏ trùng lặp theo xác suất

Đôi khi, bạn có thể muốn xác định các bản trùng lặp "có khả năng xảy ra" dựa trên sự tương đồng (ví dụ: chuỗi "distance (khoảng cách)") trên một số cột như name (tên), age (tuổi), sex (giới tính), date of birth (ngày sinh), v.v. Bạn có thể áp dụng thuật toán so khớp theo xác suất để xác định các bản trùng lặp có khả năng xảy ra.

Xem chương [Nối dữ liệu] để được giải thích về phương pháp này. Mục So sánh theo xác suất chứa một ví dụ về việc áp dụng các thuật toán này để so sánh một data frame với *chính nó*, do đó thực hiện loại bỏ trùng lặp theo xác suất.

<!-- ======================================================= -->

## Tài nguyên học liệu

Phần lớn thông tin trong chương này được điều chỉnh từ các tài nguyên và vignette trực tuyến sau:

[datanovia](https://www.datanovia.com/en/lessons/identify-and-remove-duplicate-data-in-r/)

[dplyr tidyverse reference](https://dplyr.tidyverse.org/reference/slice.html)

[cran janitor vignette](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html#explore-records-with-duplicated-values-for-specific-combinations-of-variables-with-get_dupes)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/deduplication.Rmd-->


# Lặp, vòng lặp, và danh sách {#iteration}  

Các nhà dịch tễ học thường phải phân tích lặp lại trên các phân nhóm như quốc gia, quận hoặc nhóm tuổi. Đây chỉ là một vài trong số rất nhiều tình huống yêu cầu việc *lặp lại*. Mã hóa các thao tác lặp lại của bạn bằng cách sử dụng các phương pháp bên dưới sẽ giúp bạn thực hiện các tác vụ lặp đi lặp lại như vậy nhanh hơn, giảm khả năng xảy ra lỗi và giảm độ dài code.  

Chương này sẽ giới thiệu hai cách tiếp cận đối với các thao tác lặp lại - sử dụng các *vòng lặp for* và package **purrr**.  

1) *vòng lặp for* lặp lại code trên một loạt đầu vào, nhưng ít phổ biến hơn trong R so với các ngôn ngữ lập trình khác. Tuy nhiên, chúng tôi giới thiệu chúng ở đây như một công cụ học tập và tham khảo  
2) Package **purrr** là phương pháp tiếp cận **tidyverse** đối với các thao tác lặp lại - nó hoạt động bằng cách "maps" (áp dụng) một hàm trên nhiều đầu vào (giá trị, cột, datasets, v.v.)  

Trong chương này, chúng tôi sẽ lấy một số ví dụ như:  

* Nhập và xuất nhiều tệp  
* Tạo các đường cong dịch bệnh cho nhiều tỉnh  
* Chạy T-tests cho nhiều cột trong dataframe  

Trong [phần](#iter_purrr) **purrr**, chúng tôi cũng sẽ cung cấp một số ví dụ về cách tạo và xử lý danh sách `lists`.    



## Chuẩn bị {  }
     
     
### Gọi packages {.unnumbered}  

Đoạn code này hiển thị cách gọi các packages cần thiết cho phần phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt package nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về packages R.    

```{r}
pacman::p_load(
     rio,         # import/export
     here,        # file locator
     purrr,       # iteration
     tidyverse    # data management and visualization
)
```


### Nhập dữ liệu {.unnumbered}  

Chúng tôi nhập dataset về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn làm theo, hãy <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>nhấp để tải xuống linelist "sạch"</a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương [Nhập xuất dữ liệu] để biết chi tiết).  

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của linelist được hiển thị bên dưới.  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



<!-- ======================================================= -->

## *vòng lặp for* {  }

### *vòng lặp for* trong R {#iter_loops .unnumbered}  

*Vòng lặp for* không được nhấn mạnh trong R, nhưng phổ biến trong các ngôn ngữ lập trình khác. Khi mới bắt đầu, chúng có thể hữu ích để học và thực hành vì chúng dễ "khám phá", "gỡ lỗi" hơn và nắm bắt chính xác những gì đang xảy ra cho mỗi lần lặp, đặc biệt là khi bạn chưa cảm thấy thoải mái khi viết các hàm của riêng mình.  

Bạn có thể chuyển nhanh qua phần *vòng lặp for* tới phần lặp với các hàm được tạo với **purrr** (xem [phần bên dưới](#iter_purrr)).  


### Cấu phần cốt lõi {.unnumbered}   

Một *vòng lặp for* có ba phần cốt lõi: 
     
1) **Chuỗi** các phần tử cần lặp lại
2) Các **thao tác** để tiến hành cho mỗi phần tử trong chuỗi  
3) **Vùng chứa** cho kết quả (tùy chọn)  

Cú pháp cơ bản là: `for (phần tử trong chuỗi) {các thao tác thực hiện với phần tử}`. Lưu ý dấu ngoặc đơn và dấu ngoặc nhọn. Kết quả có thể được in ra console hoặc được lưu trữ trong một đối tượng vùng chứa.  

Dưới đây là một ví dụ đơn giản về *vòng lặp for*.   

```{r}
for (num in c(1,2,3,4,5)) {  # the SEQUENCE is defined (numbers 1 to 5) and loop is opened with "{"
  print(num + 2)             # The OPERATIONS (add two to each sequence number and print)
}                            # The loop is closed with "}"                            
                             # There is no "container" in this example
```



### Chuỗi {.unnumbered}  

Đây là phần "for" của *vòng lặp for* - các thao tác sẽ chạy "cho (for)" từng phần tử trong chuỗi. Chuỗi có thể là một loạt các giá trị (ví dụ: tên của khu vực pháp lý, bệnh, tên cột, phần tử danh sách, v.v.) hoặc nó có thể là một chuỗi các số liên tiếp (ví dụ: 1,2,3,4,5). Mỗi cách tiếp cận được mô tả dưới đây có các tiện ích riêng của chúng.  

Cấu trúc cơ bản của biểu thức chuỗi là `item in vector`.  

* Bạn có thể viết bất kỳ ký tự hoặc từ nào thay cho "item" (ví dụ: "i", "num", "hosp", "district", v.v.). Giá trị của "item" này thay đổi theo từng lần lặp lại của vòng lặp, tiếp tục qua từng giá trị trong vector.  
* *Vector* có thể là các giá trị ký tự, tên cột hoặc có thể là một chuỗi số - đây là những giá trị sẽ thay đổi theo mỗi lần lặp. Bạn có thể sử dụng chúng trong các thao tác *vòng lặp for* bằng cách sử dụng thuật ngữ "item".  

**Ví dụ: chuỗi giá trị ký tự**

Trong ví dụ này, một vòng lặp được thực hiện cho mỗi giá trị được xác định trước trong một vector ký tự của tên bệnh viện.  

```{r}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)
hospital_names # print
```

Chúng tôi đã chọn thuật ngữ `hosp` để đại diện cho các giá trị từ vector `hospital_names`. Đối với lần lặp đầu tiên của vòng lặp, giá trị của `hosp` sẽ là `hospital_names[[1]]`. Đối với vòng lặp thứ hai, nó sẽ là `hospital_names[[2]]`. Và cứ như thế...  

```{r, eval=F}
# a 'for loop' with character sequence

for (hosp in hospital_names){       # sequence
  
       # OPERATIONS HERE
  }
```

**Ví dụ: chuỗi tên cột**  
     
Đây là một biến thể của chuỗi ký tự ở trên, trong đó tên của một đối tượng R hiện có được trích xuất và trở thành vector. Ví dụ, tên cột của dataframe. Trong code hoạt động của *vòng lặp for*, tên cột có thể được sử dụng để *lập chỉ mục* (tập hợp con) dataframe ban đầu của chúng.  

Dưới đây, chuỗi là `names()` (tên cột) của dataframe `linelist`. Tên "item" của chúng ta là `col`, sẽ đại diện cho từng tên cột khi các vòng lặp diễn ra.  

Với ví dụ này, chúng tôi bao gồm code thao tác bên trong *vòng lặp for*, được chạy cho mọi giá trị trong chuỗi. Trong code này, các giá trị trình tự (tên cột) được sử dụng để *chỉ mục* (tập hợp con) từng phần tử một trong `linelist`. Như đã dạy trong chương [R cơ bản], dấu ngoặc vuông kép `[[]]` được sử dụng cho tập hợp con. Cột kết quả được chuyển đến `is.na()`, sau đó đến `sum()` để tạo ra số giá trị trong cột bị thiếu. Kết quả được in ra console - một số cho mỗi cột.  

Một lưu ý về lập chỉ mục với tên cột - bất cứ khi nào tham chiếu đến chính cột đó, *đừng chỉ viết "col"!* `col` chỉ đại diện cho tên cột ký tự! Để tham chiếu đến toàn bộ cột, bạn phải sử dụng tên cột dưới dạng *chỉ mục* trên `linelist` thông qua `linelist[[col]]`.  

```{r}
for (col in names(linelist)){        # loop runs for each column in linelist; column name represented by "col" 
  
  # Example operations code - print number of missing values in column
  print(sum(is.na(linelist[[col]])))  # linelist is indexed by current value of "col"
     
}
```



**Dãy số**  
     
Theo cách tiếp cận này, dãy số là một chuỗi các số liên tiếp. Do đó, giá trị của "item" không phải là giá trị ký tự (ví dụ: "Central Hospital" hoặc "date_onset") mà là một số. Điều này rất hữu ích cho việc lặp qua các dataframes, vì bạn có thể sử dụng số "item" bên trong *vòng lặp for* để lập chỉ mục dataframe theo *số hàng*.  

Ví dụ: giả sử bạn muốn lặp qua mọi hàng trong dataframe của mình và trích xuất thông tin nhất định. "Item" của bạn sẽ là số hàng số. Thông thường, "item" trong trường hợp này được viết là `i`.  

Quá trình *vòng lặp for* có thể được giải thích bằng lời là "đối với mọi mục trong chuỗi số từ 1 đến tổng số hàng trong dataframe của tôi, hãy thực hiện X". Đối với lần lặp đầu tiên của vòng lặp, giá trị của "item" `i` sẽ là 1. Đối với lần lặp thứ hai,` i` sẽ là 2, v.v.  

Đây là hình thức của chuỗi trong code: `for (i in 1:nrow(linelist)) {OPERATIONS CODE}` trong đó `i` đại diện cho "item"và `1:nrow(linelist)` tạo ra một chuỗi liên tiếp số từ 1 đến số hàng trong `linelist`.  


```{r, eval=F}
for (i in 1:nrow(linelist)) {  # use on a data frame
  # OPERATIONS HERE
}  
```

Nếu bạn muốn chuỗi là số, nhưng bạn đang bắt đầu từ một vector (không phải dataframe), hãy sử dụng hàm tắt `seq_along()` để trả về một dãy số cho mỗi phần tử trong vector. Ví dụ: `for (i in seq_along(hospital_names) {OPERATIONS CODE}`.  

Đoạn code dưới đây thực sự trả về các số, sẽ trở thành giá trị của `i` trong vòng lặp tương ứng của chúng.    

```{r}
seq_along(hospital_names)  # use on a named vector
```

Một lợi thế của việc sử dụng các số trong chuỗi là cũng dễ dàng sử dụng số `i` để lập chỉ mục *vùng chứa* lưu trữ các kết quả đầu ra của vòng lặp. Có một ví dụ về điều này trong phần Thao tác bên dưới.  

### Các thao tác  {.unnumbered}  

Đây là code trong dấu ngoặc nhọn `{}` của *vòng lặp for*. Bạn muốn code này chạy cho từng "item" trong *chuỗi*. Do đó, hãy thận trọng với mọi phần code của bạn thay đổi bởi "item" đều được mã hóa chính xác để nó thực sự thay đổi! Ví dụ. nhớ sử dụng `[[ ]]` để lập chỉ mục.  

Trong ví dụ dưới đây, chúng tôi lặp lại từng hàng trong `linelist`. Giá trị `gender` và `age` của mỗi hàng được dán lại với nhau và được lưu trữ trong vector ký tự vùng chứa `cases_demographics`. Lưu ý cách chúng tôi cũng sử dụng lập chỉ mục `[[i]]` để lưu đầu ra của vòng lặp vào vị trí chính xác trong vector "container".  

```{r}
# create container to store results - a character vector
cases_demographics <- vector(mode = "character", length = nrow(linelist))

# the for loop
for (i in 1:nrow(linelist)){
  
  # OPERATIONS
  # extract values from linelist for row i, using brackets for indexing
  row_gender  <- linelist$gender[[i]]
  row_age     <- linelist$age_years[[i]]    # don't forget to index!
     
  # combine gender-age and store in container vector at indexed location
  cases_demographics[[i]] <- str_c(row_gender, row_age, sep = ",") 

}  # end for loop


# display first 10 rows of container
head(cases_demographics, 10)
```


### Vùng chứa {.unnumbered}

Đôi khi kết quả của *vòng lặp for* của bạn sẽ được in ra console hoặc cửa sổ RStudio Plots. Lần khác, bạn sẽ muốn lưu trữ các kết quả đầu ra trong một "vùng chứa" để sử dụng sau này. Một vùng chứa như vậy có thể là một vector, một data frame hoặc thậm chí là một danh sách.  

Hiệu quả nhất là tạo vùng chứa cho các kết quả thậm chí *trước* khi bắt đầu *vòng lặp for*. Trong thực tế, điều này có nghĩa là tạo một vector, data frame hoặc danh sách trống. Chúng có thể được tạo bằng các hàm `vector()` cho vectors hoặc danh sách, hoặc với `matrix()` và `data.frame()` cho một data frame.  

**Vector trống**  

Sử dụng `vector()` và chỉ định `mode =` dựa trên lớp phân loại dự kiến của các đối tượng mà bạn sẽ chèn - "double" (để giữ số), "ký tự" hoặc "logic". Bạn cũng nên đặt trước `length = `. Đây phải là độ dài chuỗi *vòng lặp for* của bạn.  

Giả sử bạn muốn lưu trữ thời gian nhập viện trễ trung bình cho mỗi bệnh viện. Bạn sẽ sử dụng "double" và đặt độ dài là số đầu ra dự kiến (số bệnh viện duy nhất trong data set).  

```{r}
delays <- vector(
  mode = "double",                            # we expect to store numbers
  length = length(unique(linelist$hospital))) # the number of unique hospitals in the dataset
```

**Data frame trống**  
     
Bạn có thể tạo một data frame trống bằng cách chỉ định số hàng và cột như sau:  
     
```{r, eval=F}
delays <- data.frame(matrix(ncol = 2, nrow = 3))
```


**Danh sách trống**  
     
Bạn có thể muốn lưu trữ một số biểu đồ được tạo bởi *vòng lặp for* trong danh sách. Một danh sách giống như vector, nhưng chứa các đối tượng R khác bên trong nó có thể thuộc các lớp khác nhau. Các phần tử trong danh sách có thể là một số, một dataframe, một vector và thậm chí là một danh sách khác.  

Bạn thực sự khởi tạo một danh sách trống bằng cách sử dụng cùng một lệnh `vector()` như trên, nhưng với `mode = "list"`. Chỉ định độ dài như bạn muốn.  

```{r, eval=F}
plots <- vector(mode = "list", length = 16)
```




### In {.unnumbered}  

Lưu ý rằng để in từ bên trong *vòng lặp for*, bạn có thể sẽ cần phải đưa hàm `print()` vào.  

Trong ví dụ dưới đây, chuỗi là một vector ký tự rõ ràng, được sử dụng để đặt linelist con theo bệnh viện. Kết quả không được lưu trữ trong vùng chứa mà được in ra console với hàm `print()`.  

```{r}
for (hosp in hospital_names){ 
     hospital_cases <- linelist %>% filter(hospital == hosp)
     print(nrow(hospital_cases))
}
```


### Kiểm tra vòng lặp for {.unnumbered}

Để kiểm tra vòng lặp của mình, bạn có thể chạy lệnh để gán tạm thời "item", chẳng hạn như `i <- 10` hoặc `hosp <- "Central Hospital"`. Thực hiện việc này *bên ngoài vòng lặp* và sau đó chỉ chạy code thao tác của bạn (code trong dấu ngoặc nhọn) để xem liệu kết quả mong đợi có được tạo ra hay không.  




### Lặp lại biểu đồ {.unnumbered}

Để đặt tất cả ba thành phần lại với nhau (vùng chứa, trình tự và thao tác), chúng ta hãy cố gắng vẽ biểu đồ đường cong dịch bệnh cho mỗi bệnh viện (xem chương [Đường cong dịch bệnh]).  

Chúng tôi có thể tạo ra một đường cong dịch bệnh đẹp về *tất cả* các trường hợp theo giới tính bằng cách sử dụng package **incidence2** như bên dưới:  

```{r, warning=F, message=F}
# create 'incidence' object
outbreak <- incidence2::incidence(   
     x = linelist,                   # dataframe - complete linelist
     date_index = date_onset,        # date column
     interval = "week",              # aggregate counts weekly
     groups = gender,                # group values by gender
     na_as_group = TRUE)             # missing gender is own group

# plot epi curve
plot(outbreak,                       # name of incidence object
     fill = "gender",                # color bars by gender
     color = "black",                # outline color of bars
     title = "Outbreak of ALL cases" # title
     )
```

Để tạo ra một biểu đồ riêng cho từng trường hợp của bệnh viện, chúng ta có thể đặt code đường cong dịch bệnh này trong *vòng lặp for*.   


Đầu tiên, chúng tôi lưu một vector được đặt tên duy nhất của các tên bệnh viện, `hospital_names`. *Vòng lặp for* sẽ chạy một lần cho mỗi tên sau: `for (hosp in hospital_names)`. Mỗi lần lặp lại của *vòng lặp for*, tên bệnh viện hiện tại từ vector sẽ được biểu diễn dưới dạng `hosp` để sử dụng trong vòng lặp. 

Trong các thao tác vòng lặp, bạn có thể viết code R như bình thường, nhưng cần biết rằng giá trị của "item" (`hosp` trong trường hợp này) sẽ thay đổi. Trong vòng lặp này:  
     
* Một `filter()` được áp dụng cho `linelist`, sao cho cột `hospital` phải bằng giá trị hiện tại của `hosp`  
* Đối tượng tỷ lệ mắc được tạo trên linelist đã lọc  
* Biểu đồ cho bệnh viện hiện tại được tạo, với tiêu đề tự động điều chỉnh sử dụng `hosp`  
* Biểu đồ cho bệnh viện hiện tại được lưu tạm thời và sau đó được in  
* Sau đó, vòng lặp di chuyển tiếp để lặp lại với bệnh viện tiếp theo trong `hospital_names`  

```{r, out.width='50%', message = F}
# make vector of the hospital names
hospital_names <- unique(linelist$hospital)

# for each name ("hosp") in hospital_names, create and print the epi curve
for (hosp in hospital_names) {
     
     # create incidence object specific to the current hospital
     outbreak_hosp <- incidence2::incidence(
          x = linelist %>% filter(hospital == hosp),   # linelist is filtered to the current hospital
          date_index = date_onset,
          interval = "week", 
          groups = gender,
          na_as_group = TRUE
     )
     
     # Create and save the plot. Title automatically adjusts to the current hospital
     plot_hosp <- plot(
       outbreak_hosp,
       fill = "gender",
       color = "black",
       title = stringr::str_glue("Epidemic of cases admitted to {hosp}")
     )
     
     # print the plot for the current hospital
     print(plot_hosp)
     
} # end the for loop when it has been run for every hospital in hospital_names 
```



### Theo dõi tiến trình của một vòng lặp {.unnumbered} 

Một vòng lặp có nhiều lần lặp có thể chạy trong nhiều phút hoặc thậm chí hàng giờ. Do đó, có thể hữu ích khi in tiến trình ra R console. Câu lệnh `if` dưới đây có thể được đặt *trong* các thao tác vòng lặp để in mỗi số thứ 100. Chỉ cần điều chỉnh nó để `i` là "item" trong vòng lặp của bạn.  

```{r, eval=F}
# loop with code to print progress every 100 iterations
for (i in seq_len(nrow(linelist))){

  # print progress
  if(i %% 100==0){    # The %% operator is the remainder
    print(i)

}
```





<!-- ======================================================= -->
## **purrr** và các danh sách {#iter_purrr}
     
Một cách tiếp cận khác đối với các thao tác lặp là package **purrr** - nó là phương pháp **tidyverse** để lặp lại.  

Nếu bạn phải thực hiện cùng một tác vụ nhiều lần, có lẽ bạn nên tạo một giải pháp tổng thể có thể sử dụng trên nhiều đầu vào. Ví dụ: tạo các biểu đồ cho nhiều khu vực pháp lý, hoặc nhập và kết hợp nhiều tệp.  

Ngoài ra còn có một số lợi thế khác đối với **purrr** - bạn có thể sử dụng nó với các pipes `%>%`, nó xử lý lỗi tốt hơn *vòng lặp for* bình thường, và có cú pháp khá rõ ràng và đơn giản! Nếu bạn đang sử dụng *vòng lặp for*, bạn có thể tạo vòng lặp rõ ràng và ngắn gọn hơn với **purrr**!  
   
Hãy nhớ rằng **purrr** là một *công cụ lập trình theo hàm*. Có nghĩa là, các thao tác lặp đi lặp lại được gói gọn trong *các hàm*. Xem chương [Viết hàm] để tìm hiểu cách viết hàm của riêng bạn.  

**purrr** cũng gần như hoàn toàn dựa trên *danh sách* và *vectors* - vì vậy hãy nghĩ về nó như là áp dụng một hàm cho mỗi phần tử của danh sách/vector đó!  
     
### Tải packages {.unnumbered}  
     
**purrr** là một phần của **tidyverse**, vì vậy không cần cài đặt/tải một package riêng biệt.  

```{r}
pacman::p_load(
     rio,            # import/export
     here,           # relative filepaths
     tidyverse,      # data mgmt and viz
     writexl,        # write Excel file with multiple sheets
     readxl          # import Excel with multiple sheets
)
```


### `map()` {.unnumbered}  

Một hàm cốt lõi của **purrr** là `map()`, hàm này "maps" (áp dụng) một hàm cho từng phần tử đầu vào của danh sách/vector bạn cung cấp.  

Cú pháp cơ bản là `map(.x = SEQUENCE, .f = HÀM, CÁC ĐỐI SỐ KHÁC)`. Chi tiết hơn như sau:  
     
* `.x = ` là các *đầu vào* mà hàm `.f` sẽ được áp dụng lặp đi lặp lại - ví dụ: vector của tên các khu vực pháp lý, các cột trong data frame hoặc danh sách các data frame  
* `.f = ` là *hàm* áp dụng cho từng phần tử của đầu vào `.x` - nó có thể là một hàm như `print()` đã tồn tại hoặc một hàm tùy chỉnh mà bạn xác định. Hàm thường được viết sau dấu ngã `~` (chi tiết bên dưới).  

Thêm một số lưu ý về cú pháp:  
     
* Nếu hàm không cần chỉ định thêm đối số, nó có thể được viết không có dấu ngoặc đơn và không có dấu ngã (ví dụ: `.f = mean`). Để cung cấp các đối số sẽ có cùng giá trị cho mỗi lần lặp, hãy cung cấp chúng trong `map()` nhưng bên ngoài đối số `.f =`, chẳng hạn như `na.rm = T` trong `map(.x = my_list, .f = mean, na.rm=T)`.  
* Bạn có thể sử dụng `.x` (hoặc đơn giản là `.`) *bên trong* hàm `.f =` làm trình giữ chỗ cho giá trị `.x` của lần lặp đó  
* Sử dụng cú pháp dấu ngã (`~`) để kiểm soát hàm nhiều hơn - viết hàm như bình thường với dấu ngoặc đơn, chẳng hạn như: `map(.x = my_list, .f = ~mean(., na.rm = T))`. Sử dụng cú pháp này đặc biệt nếu giá trị của một đối số sẽ thay đổi mỗi lần lặp lại hoặc nếu nó là chính giá trị `.x` (xem ví dụ bên dưới)  

** Đầu ra của việc sử dụng `map()` là một *danh sách*** - một danh sách là một lớp đối tượng giống như một vector nhưng các phần tử của nó có thể thuộc các lớp khác nhau. Vì vậy, một danh sách được tạo bởi `map()` có thể chứa nhiều data frames, hoặc nhiều vector, nhiều giá trị đơn lẻ, hoặc thậm chí nhiều danh sách! Có các phiên bản thay thế của `map()` được giải thích bên dưới, tạo ra các loại kết quả khác (ví dụ: `map_dfr()` để tạo data frame, `map_chr()` để tạo vectors ký tự và `map_dbl()` để tạo vectors số).  

#### Ví dụ - nhập và kết hợp các trang tính Excel {#iter_combined .unnumbered}  

**Hãy biểu diễn với một công việc thường gặp của nhà dịch tễ học:** - *Bạn muốn nhập một Excel workbook với dữ liệu trường hợp bệnh, nhưng dữ liệu được chia thành các trang tính có tên khác nhau trong workbook. Làm cách nào để bạn nhập và kết hợp các trang tính vào một data frame một cách hiệu quả?*  

Giả sử chúng tôi được gửi Excel workbook bên dưới. Mỗi trang tính chứa các trường hợp từ một bệnh viện nhất định.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "hospital_linelists_excel_sheets.png"))
```

Đây là một cách tiếp cận sử dụng `map()`:  
     
1) `map()` hàm `import()` để nó chạy qua mỗi trang tính Excel  
2) Kết hợp các data frames đã nhập thành một bằng cách sử dụng `bind_rows()`  
3) Trong khi đó, hãy giữ nguyên tên trang tính ban đầu cho mỗi hàng, lưu trữ thông tin này trong một cột mới trong data frame cuối cùng  

Đầu tiên, chúng ta cần trích xuất tên trang tính và lưu chúng. Chúng tôi cung cấp đường dẫn tệp của Excel workbook tới hàm `excel_sheets()` từ package **readxl**, sẽ trích xuất tên trang tính. Chúng tôi lưu trữ chúng trong một vector ký tự được gọi là `sheet_names`.  

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

```

```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")
```

Đây là các tên trang tính:  

```{r}
sheet_names
```

Bây giờ chúng ta có tên của vector này, `map()` có thể cung cấp từng cái một cho hàm `import()`. Trong ví dụ này, `sheet_names` là `.x` và `import()` là hàm `.f`.  

Nhớ lại từ chương [Nhập và xuất dữ liệu], khi sử dụng trên Excel workbooks, `import()` có thể chấp nhận đối số `which = ` để chỉ định trang tính để nhập. Trong hàm `import()` của `.f`, chúng tôi cung cấp `which = .x`, giá trị của nó sẽ thay đổi theo mỗi lần lặp thông qua vector `sheet_names` - đầu tiên là "Central Hospital", sau đó là "Military Hospital", v.v.  

Lưu ý - bởi vì chúng tôi đã sử dụng `map()`, dữ liệu trong mỗi trang tính Excel sẽ được lưu thành một data frame riêng biệt trong danh sách. Chúng tôi muốn mỗi phần tử danh sách này (data frames) có một *tên*, vì vậy trước khi chuyển `sheet_names` đến `map()`, chúng tôi chuyển nó qua `set_names()` từ **purrr**, điều này đảm bảo rằng mỗi phần tử danh sách nhận được tên thích hợp.  

Chúng tôi lưu danh sách đầu ra dưới dạng `combined`.  

```{r, echo=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x))
```

```{r, eval=F}
combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import("hospital_linelists.xlsx", which = .x))
```

Khi kiểm tra đầu ra, chúng ta thấy rằng dữ liệu từ mỗi trang tính Excel được lưu trong danh sách với một tên. Điều này là tốt, nhưng chúng ta chưa kết thúc ở đây.  


```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_list.png"))
```

Cuối cùng, chúng tôi sử dụng hàm `bind_rows()` (từ **dplyr**) chấp nhận danh sách các data frames có cấu trúc tương tự và kết hợp chúng thành một data frame. Để tạo một cột mới từ phần tử danh sách *tên*, chúng tôi sử dụng đối số `.id = ` và cung cấp cho nó tên mong muốn cho cột mới.  

Dưới đây là toàn bộ chuỗi lệnh:  

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
  purrr::set_names() %>% 
  map(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x)) %>% 
  bind_rows(.id = "origin_sheet")
```


```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")  # extract sheet names
 
combined <- sheet_names %>%                                     # begin with sheet names
  purrr::set_names() %>%                                        # set their names
  map(.f = ~import("hospital_linelists.xlsx", which = .x)) %>%  # iterate, import, save in list
  bind_rows(.id = "origin_sheet") # combine list of data frames, preserving origin in new column  
```

Và bây giờ chúng ta có một data frame với một cột chứa trang tính ban đầu!  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "sheets_as_df.png"))
```

Có những biến thể của `map()` mà bạn nên biết. Ví dụ: `map_dfr()` trả về data frame, không phải danh sách. Vì vậy, chúng ta có thể đã sử dụng nó cho tác vụ ở trên và không cần phải ràng buộc các hàng. Nhưng sau đó chúng ta sẽ không thể nắm bắt được trường hợp nào đến từ trang tính nào (bệnh viện).  

Các biến thể khác bao gồm `map_chr()`, `map_dbl()`. Đây là những hàm rất hữu ích vì hai lý do. Trước hết, chúng tự động chuyển đổi đầu ra của một hàm lặp thành một vector (không phải danh sách). Thứ hai, chúng có thể kiểm soát rõ ràng lớp mà dữ liệu quay trở lại - bạn đảm bảo rằng dữ liệu của bạn quay trở lại dưới dạng vector ký tự với `map_chr()`, hoặc vector số với `map_dbl()`. Hãy quay lại những hàm này sau trong phần sau!  

Các hàm `map_at()` và `map_if()` cũng rất hữu ích để lặp lại - chúng cho phép bạn chỉ định phần tử nào của danh sách nên lặp lại! Chúng hoạt động đơn giản bằng cách áp dụng một vector gồm các chỉ mục/tên (với `map_at()`) hoặc một phép kiểm tra logic (với `map_if()`).  

Ví dụ, chúng tôi không muốn đọc trang tính đầu tiên chứa dữ liệu của bệnh viện. Chúng tôi sử dụng `map_at()` thay vì `map()` và chỉ định đối số `.at = ` thành `c(-1)` có nghĩa là *không* sử dụng phần tử đầu tiên của `.x`. Ngoài ra, bạn có thể cung cấp một vector gồm các số dương hoặc tên cho `.at = ` để chỉ định phần tử nào sẽ sử dụng.  

```{r, echo=F}
sheet_names <- readxl::excel_sheets(here::here("data", "example", "hospital_linelists.xlsx"))

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # exclude the first sheet
     map_at(.f = ~import(here::here("data", "example", "hospital_linelists.xlsx"), which = .x),
            .at = c(-1))
```


```{r, eval=F}
sheet_names <- readxl::excel_sheets("hospital_linelists.xlsx")

combined <- sheet_names %>% 
     purrr::set_names() %>% 
     # exclude the first sheet
     map_at(.f = ~import( "hospital_linelists.xlsx", which = .x),
            .at = c(-1))
```

Lưu ý rằng tên trang tính đầu tiên sẽ vẫn xuất hiện như một phần tử của danh sách đầu ra - nhưng nó chỉ là một tên ký tự đơn lẻ (không phải là một data frame). Bạn sẽ cần phải loại bỏ phần tử này trước khi liên kết các hàng. Chúng tôi sẽ trình bày cách xóa và sửa đổi các phần tử danh sách trong phần sau.  

### Tách và xuất bộ dữ liệu {.unnumbered}  

Dưới đây, chúng tôi đưa ra một ví dụ về cách tách bộ dữ liệu thành các phần và sau đó sử dụng phép lặp `map()` để xuất từng phần dưới dạng trang tính Excel riêng biệt hoặc dưới dạng tệp CSV riêng biệt.  

#### Tách bộ dữ liệu {.unnumbered}  

Giả sử chúng ta có toàn bộ trường hợp `linelist` làm data frame và bây giờ chúng ta muốn tạo một linelist riêng biệt cho từng bệnh viện và xuất từng trường hợp dưới dạng tệp CSV riêng biệt. Dưới đây, chúng tôi thực hiện các bước sau:  
     
Sử dụng `group_split()` (từ **dplyr**) để tách data frame `linelist` theo các giá trị duy nhất trong cột `hospital`. Đầu ra là một danh sách chứa một data frame cho mỗi tập hợp con của bệnh viện.   

```{r}
linelist_split <- linelist %>% 
     group_split(hospital)
```

Chúng ta có thể chạy `View(linelist_split)` và thấy rằng danh sách này chứa 6 data frames ("tibbles"), mỗi khung đại diện cho các trường hợp từ một bệnh viện.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split.png"))
```

Tuy nhiên, lưu ý rằng các data frames trong danh sách không có tên theo mặc định! Chúng tôi muốn mỗi người có một tên và sau đó sử dụng tên đó khi lưu tệp CSV.  

Một cách tiếp cận để trích xuất các tên là sử dụng `pull()` (từ **dplyr**) để trích xuất cột `hospital` từ mỗi data frame trong danh sách. Sau đó, để an toàn, chúng tôi chuyển đổi các giá trị thành ký tự và sau đó sử dụng `unique()` để lấy tên cho data frame cụ thể đó. Tất cả các bước này được áp dụng cho từng data frame thông qua `map()`.  

```{r}
names(linelist_split) <- linelist_split %>%   # Assign to names of listed data frames 
     # Extract the names by doing the following to each data frame: 
     map(.f = ~pull(.x, hospital)) %>%        # Pull out hospital column
     map(.f = ~as.character(.x)) %>%          # Convert to character, just in case
     map(.f = ~unique(.x))                    # Take the unique hospital name
```

Bây giờ chúng ta có thể thấy rằng mỗi phần tử trong danh sách đều có một tên. Những tên này có thể được truy cập thông qua `names(linelist_split)`.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_linelist_split_named.png"))
```

```{r}
names(linelist_split)
```


##### Nhiều hơn một cột `group_split()` {.unnumbered}  

Nếu bạn muốn chia linelist theo *nhiều hơn một nhóm cột*, chẳng hạn như để tạo tập hợp con linelist theo giao điểm của bệnh viện VÀ giới tính, bạn sẽ cần một cách tiếp cận khác để đặt tên cho các phần tử danh sách. Điều này liên quan đến việc thu thập các "nhóm chính (group keys)" duy nhất bằng cách sử dụng `group_keys()` từ **dplyr** - chúng được trả về dưới dạng một data frame. Sau đó, bạn có thể kết hợp các nhóm chính thành các giá trị với `unite()` như được hiển thị bên dưới và gán các tên tập nhóm này cho `linelist_split`.  

```{r}
# split linelist by unique hospital-gender combinations
linelist_split <- linelist %>% 
     group_split(hospital, gender)

# extract group_keys() as a dataframe
groupings <- linelist %>% 
     group_by(hospital, gender) %>%       
     group_keys()

groupings      # show unique groupings 
```

Bây giờ chúng ta kết hợp các nhóm với nhau, được phân tách bằng dấu gạch ngang và gán chúng làm tên của các phần tử danh sách trong `linelist_split`. Thao tác này sẽ mất thêm vài dòng khi chúng ta thay thế `NA` bằng "Missing", sử dụng `unite()` từ **dplyr** để kết hợp các giá trị cột với nhau (phân tách bằng dấu gạch ngang), sau đó chuyển đổi thành vector không tên để nó có thể được dùng làm tên của `linelist_split`.  

```{r, eval=F}
# Combine into one name value 
names(linelist_split) <- groupings %>% 
     mutate(across(everything(), replace_na, "Missing")) %>%  # replace NA with "Missing" in all columns
     unite("combined", sep = "-") %>%                         # Unite all column values into one
     setNames(NULL) %>% 
     as_vector() %>% 
     as.list()
```



#### Xuất dưới dạng trang tính Excel {.unnumbered}  

Để xuất linelists bệnh viện dưới dạng *Excel workbook với một linelist trên mỗi trang tính*, chúng tôi chỉ có thể cung cấp danh sách có tên `linelist_split` cho hàm `write_xlsx()` từ package **writexl**. Điều này có khả năng lưu một Excel workbook với nhiều trang tính. Tên phần tử danh sách được tự động áp dụng làm tên trang tính.  

```{r, eval=F}
linelist_split %>% 
     writexl::write_xlsx(path = here("data", "hospital_linelists.xlsx"))
```

Bây giờ bạn có thể mở tệp Excel và thấy rằng mỗi bệnh viện có một trang tính riêng.  

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_sheets.png"))
```

#### Xuất dưới dạng tệp CSV {.unnumbered}  

Đây là lệnh phức tạp hơn một chút, nhưng bạn cũng có thể xuất từng linelist dành riêng cho bệnh viện dưới dạng tệp CSV riêng biệt, với tên tệp dành riêng cho bệnh viện.  

Một lần nữa, chúng tôi sử dụng `map()`: chúng tôi lấy vector của tên phần tử danh sách (được hiển thị ở trên) và sử dụng `map()` để lặp lại chúng, áp dụng `export()` (từ package **rio**, xem chương [Nhập và xuất dữ liệu]) trên data frame với danh sách `linelist_split` có tên đó. Chúng tôi cũng sử dụng tên để tạo một tên tệp duy nhất. Đây là các bước thực hiện:  
     
* Chúng ta bắt đầu với vector tên kí tự, được chuyển tới `map()` dưới dạng `.x`  
* Hàm `.f` là `export()`, hàm này yêu cầu một data frame và một đường dẫn tệp để ghi vào  
* Đầu vào `.x` (tên bệnh viện) được sử dụng *trong* `.f` để trích xuất/lập chỉ mục phần tử cụ thể đó của danh sách `linelist_split`. Điều này làm cho mỗi lần chỉ một data frame được cung cấp cho `export()`.    
* Ví dụ: khi `map()` lặp lại cho "Military Hospital", thì `linelist_split[[.x]]` sẽ là `linelist_split[["Military Hospital"]]`, do đó trả về phần tử thứ hai của `linelist_split` - đó là tất cả các trường hợp từ Military Hospital.  
* Đường dẫn tệp được cung cấp cho `export()` là động thông qua việc sử dụng `str_glue()` (xem chương [Ký tự và chuỗi]):  
     * `here()` được sử dụng để lấy cơ sở của đường dẫn tệp và chỉ định thư mục "data" (lưu ý dấu nháy đơn để không làm gián đoạn dấu ngoặc kép `str_glue()`)  
* Sau đó là dấu gạch chéo `/`, rồi lại `.x` in tên bệnh viện hiện tại để làm cho tệp có thể nhận dạng được  
* Cuối cùng là phần mở rộng ".csv" mà `export()` sử dụng để tạo tệp CSV  

```{r, eval=F, message = F, warning=F}
names(linelist_split) %>%
     map(.f = ~export(linelist_split[[.x]], file = str_glue("{here('data')}/{.x}.csv")))
```
Bây giờ bạn có thể thấy rằng mỗi tệp được lưu trong thư mục "data" của Dự án R "Epi_R_handbook"!  
     
```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "purrr_export_csv.png"))
```



### Hàm tùy chỉnh {.unnumbered}  

Bạn có thể muốn tạo một hàm của riêng mình để đưa vào `map()`.  

Giả sử chúng ta muốn tạo đường cong dịch bệnh cho từng trường hợp của bệnh viện. Để thực hiện việc này với **purrr**, hàm `.f` của chúng ta có thể là `ggplot()` và các phần mở rộng bằng `+` như bình thường. Vì đầu ra của `map()` luôn là một danh sách nên các biểu đồ được lưu trữ trong một danh sách. Bởi vì chúng là các biểu đồ, chúng có thể được trích xuất và vẽ bằng hàm `ggarrange()` từ package **ggpubr**  ([documentation](https://rpkgs.datanovia.com/ggpubr/reference/ggarrange.html)).  


```{r, message = F, warning=F}

# load package for plotting elements from list
pacman::p_load(ggpubr)

# map across the vector of 6 hospital "names" (created earlier)
# use the ggplot function specified
# output is a list with 6 ggplots

hospital_names <- unique(linelist$hospital)

my_plots <- map(
  .x = hospital_names,
  .f = ~ggplot(data = linelist %>% filter(hospital == .x)) +
                geom_histogram(aes(x = date_onset)) +
                labs(title = .x)
)

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```

Nếu code `map()` này trông quá lộn xộn, bạn có thể đạt được kết quả tương tự bằng cách lưu lệnh `ggplot()` cụ thể của mình dưới dạng một hàm tùy chỉnh do người dùng xác định, ví dụ, chúng ta có thể đặt tên nó là `make_epicurve()`. Hàm này sau đó được sử dụng trong `map()`. `.x` sẽ được thay thế lặp lại bằng tên bệnh viện và được sử dụng làm `hosp_name` trong hàm `make_epicurve()`. Xem chương về [Viết hàm].  

```{r, eval=F}
# Create function
make_epicurve <- function(hosp_name){
  
  ggplot(data = linelist %>% filter(hospital == hosp_name)) +
    geom_histogram(aes(x = date_onset)) +
    theme_classic()+
    labs(title = hosp_name)
  
}
```

```{r, eval=F}
# mapping
my_plots <- map(hospital_names, ~make_epicurve(hosp_name = .x))

# print the ggplots (they are stored in a list)
ggarrange(plotlist = my_plots, ncol = 2, nrow = 3)
```




### Áp dụng một hàm qua nhiều cột {.unnumbered}  

Một trường hợp sử dụng phổ biến khác là áp dụng một hàm trên nhiều cột. Dưới đây, chúng tôi `map()` hàm `t.test()` qua các cột số trong data frame `linelist`, so sánh các giá trị số theo giới tính.  

Nhớ lại từ chương về [Các kiểm định thống kê cơ bản] rằng `t.test()` có thể nhận đầu vào ở định dạng công thức, chẳng hạn như `t.test(numeric column ~ binary column)`. Trong ví dụ này, chúng tôi làm như sau:  
     
* Các cột số được chọn từ `linelist` - những cột này trở thành đầu vào `.x` cho `map()`  
* Hàm `t.test()` được cung cấp dưới dạng hàm `.f`, được áp dụng cho mỗi cột số  
* Trong dấu ngoặc đơn của `t.test()`:  
  * dấu `~` đầu tiên đứng trước `.f` mà `map()` sẽ lặp qua` .x`  
  * `.x` đại diện cho cột hiện tại được cung cấp cho hàm `t.test()`  
  * dấu `~` thứ hai là một phần của phương trình t-test được mô tả ở trên  
  * hàm `t.test()` yêu cầu một cột nhị phân ở phía bên phải của phương trình. Chúng tôi đưa vector `linelist$gender` một cách độc lập và có ý nghĩa thống kê (lưu ý rằng nó không được bao gồm trong `select()`).  

`map()` trả về một danh sách, vì vậy đầu ra là một danh sách các kết quả t-test - một danh sách phần tử cho mỗi cột số được phân tích.  

```{r}
# Results are saved as a list
t.test_results <- linelist %>% 
  select(age, wt_kg, ht_cm, ct_blood, temp) %>%  # keep only some numeric columns to map across
  map(.f = ~t.test(.x ~ linelist$gender))        # t.test function, with equation NUMERIC ~ CATEGORICAL
```

Đây là danh sách `t.test_results` trông như thế nào khi được mở (Cửa sổ Viewer) trong RStudio. Chúng tôi đã đánh dấu các phần quan trọng đối với các ví dụ trong trang này.  

* Ở trên cùng, bạn có thể thấy toàn bộ danh sách được đặt tên là `t.test_results` và có năm phần tử. Năm phần tử đó được đặt tên là `age`, `wt_km`, `ht_cm`, `ct_blood`, `temp` theo mỗi biến được sử dụng trong t-test với `gender` từ `linelist`.  
* Mỗi phần tử trong số năm phần tử đó đều là danh sách, với các phần tử bên trong chúng, chẳng hạn như `p.value` và `conf.int`. Một số phần tử như `p.value` là các số đơn lẻ, trong khi một số phần tử như `estimate` bao gồm hai hoặc nhiều phần tử (`mean in group f` và `mean in group m`).  

```{r, out.height="150%", echo=F}
knitr::include_graphics(here::here("images", "purrr_ttest.png"))
```


Lưu ý: Hãy nhớ rằng nếu bạn chỉ muốn áp dụng một hàm cho một số cột nhất định trong data frame, bạn cũng có thể chỉ cần sử dụng `mutate()` và `across()`, như được giải thích trong chương [Làm sạch số liệu và các hàm quan trọng]. Dưới đây là một ví dụ về việc áp dụng `as.character()` cho chỉ các cột "age". Lưu ý vị trí của dấu ngoặc đơn và dấu phẩy.  

```{r, eval=F}
# convert columns with column name containing "age" to class Character
linelist <- linelist %>% 
  mutate(across(.cols = contains("age"), .fns = as.character))  
```


### Trích xuất từ danh sách {.unnumbered}  

Khi `map()` tạo ra một đầu ra của lớp danh sách, chúng ta sẽ dành một chút thời gian thảo luận về cách trích xuất dữ liệu từ danh sách bằng cách sử dụng các hàm **purrr** đi kèm. Để minh họa điều này, chúng tôi sẽ sử dụng danh sách `t.test_results` từ phần trước. Đây là danh sách gồm 5 danh sách - mỗi danh sách trong số 5 danh sách chứa kết quả của t-test giữa một cột từ data frame `linelist` và cột nhị phân `gender` của nó. Xem hình ảnh trong phần trên để có hình ảnh về cấu trúc danh sách.  

#### Tên của các phần tử {.unnumbered}  

Để trích xuất tên của chính các phần tử, chỉ cần sử dụng `names()` từ **base** R. Trong trường hợp này, chúng tôi sử dụng `names()` trên `t.test_results` để trả về tên của mỗi danh sách con, là tên của 5 biến đã thực hiện t-tests.  

```{r}
names(t.test_results)
```

#### Các phần tử theo tên hoặc vị trí {.unnumbered}  

Để trích xuất các phần tử danh sách theo tên hoặc theo vị trí, bạn có thể sử dụng dấu ngoặc `[[ ]]` như được mô tả trong chương [R cơ bản]. Dưới đây chúng tôi sử dụng dấu ngoặc kép để lập chỉ mục danh sách `t.tests_results` và hiển thị phần tử đầu tiên là kết quả của t-test trên `age`.  

```{r}
t.test_results[[1]] # first element by position
t.test_results[[1]]["p.value"] # return element named "p.value" from first element  
```

Tuy nhiên, dưới đây chúng tôi sẽ trình bày việc sử dụng các hàm `map()` và `pluck()` của **purrr** đơn giản và linh hoạt để đạt được kết quả tương tự.  

#### `pluck()` {.unnumbered}  

`pluck()` kéo ra các phần tử theo tên hoặc theo vị trí. Ví dụ - để trích xuất kết quả t-test cho độ tuổi, bạn có thể sử dụng `pluck()` như thế này:  

```{r}
t.test_results %>% 
  pluck("age")        # alternatively, use pluck(1)
```

Lập chỉ mục các cấp độ sâu hơn bằng cách chỉ định các cấp độ cao hơn bằng dấu phẩy. Dưới đây trích xuất phần tử có tên "p.value" từ danh sách `age` trong danh sách `t.test_results`. Bạn cũng có thể sử dụng số thay vì tên ký tự.  

```{r}
t.test_results %>% 
  pluck("age", "p.value")
```

Bạn có thể trích xuất các phần tử bên trong như vậy từ *tất cả* các phần tử cấp một bằng cách sử dụng `map()` để chạy hàm `pluck()` trên từng phần tử cấp một. Ví dụ, đoạn mã dưới đây trích xuất các phần tử "p.value" từ tất cả các danh sách trong `t.test_results`. Danh sách các kết quả t-test là `.x` được lặp qua,` pluck()` là hàm `.f` đang được lặp và giá trị "p-value" được cung cấp cho hàm.  

```{r}
t.test_results %>%
  map(pluck, "p.value")   # return every p-value
```

Một cách thay thế khác là `map()` viết tắt tên phần tử trong dấu ngoặc kép và nó sẽ ngắt nó ra. Nếu bạn sử dụng `map()`, đầu ra sẽ là một danh sách, trong khi nếu bạn sử dụng `map_chr()` thì nó sẽ là một vectơ ký tự được đặt tên và nếu bạn sử dụng `map_dbl()` nó sẽ là một vector số được đặt tên.  

```{r}
t.test_results %>% 
  map_dbl("p.value")   # return p-values as a named numeric vector
```

Bạn có thể đọc thêm về `pluck()` trong [tài liệu](https://purrr.tidyverse.org/reference/pluck.html) về **purrr**. Nó có một hàm tương tự là `chuck()` sẽ trả về lỗi thay vì NULL nếu một phần tử không tồn tại.  



### Chuyển đổi danh sách thành data frame {.unnumbered}  

Đây là một nội dung phức tạp - hãy xem phần Tài nguyên học liệu để có các hướng dẫn đầy đủ hơn. Tuy nhiên, chúng tôi sẽ minh họa việc chuyển đổi danh sách các kết quả t-test thành một data frame. Chúng tôi sẽ tạo một data frame với các cột cho biến, p-value của nó và giá trị trung bình từ hai nhóm (nam và nữ).  

Dưới đây là một số phương pháp và hàm mới sẽ được sử dụng:  

* Hàm `tibble()` sẽ được sử dụng để tạo một tibble (giống như một data frame)  
  * Chúng tôi bao quanh hàm `tibble()` bằng dấu ngoặc nhọn `{ }` để ngăn toàn bộ `t.test_results` được lưu trữ dưới dạng cột nhỏ đầu tiên  
* Trong `tibble()`, mỗi cột được tạo một cách rõ ràng, tương tự như cú pháp của `mutate()`:  
  * Dấu `.` đại diện cho `t.test_results`   
  * Để tạo một cột với các tên biến t-test (tên của mỗi phần tử danh sách), chúng tôi sử dụng `names()` như đã mô tả ở trên  
  * Để tạo một cột với các p-values, chúng tôi sử dụng `map_dbl()` như được mô tả ở trên để kéo các phần tử `p.value` và chuyển đổi chúng thành một vector số  

```{r}
t.test_results %>% {
  tibble(
    variables = names(.),
    p         = map_dbl(., "p.value"))
  }
```

Nhưng bây giờ hãy thêm các cột chứa trung bình cho mỗi nhóm (nam và nữ).  

Chúng tôi sẽ cần trích xuất phần tử `estimate`, nhưng điều này thực sự chứa *hai* phần tử bên trong nó (`mean in group f` và `mean in group m`). Vì vậy, nó không thể được đơn giản hóa thành một vector với `map_chr()` hoặc `map_dbl()`. Thay vào đó, chúng tôi sử dụng `map()`, được sử dụng trong `tibble()`, sẽ tạo *một cột lớp danh sách trong tibble*! Vâng, điều này là có thể!  

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate"))}
```

Sau khi bạn có cột danh sách này, có một số hàm **tidyr** (một phần của **tidyverse**) giúp bạn "gỡ rối" hoặc "gỡ bỏ" các cột "danh sách lồng nhau" này. Đọc thêm về chúng [tại đây]() hoặc bằng cách chạy `vignette("rectangle")`. Tóm lại:  

* `unnest_wider()` - đưa mỗi phần tử của mỗi danh sách cột một cột riêng của nó  
* `unnest_longer()` - đưa mỗi phần tử của mỗi danh sách cột một hàng riêng của nó  
* `hoist()` - hoạt động giống như `unnest_wider()` nhưng bạn chỉ định phần tử nào cần gỡ bỏ  

Dưới đây, chúng tôi chuyển tibble sang `unnest_wider()` để chỉ định cột `means` của tibble (là một danh sách lồng nhau). Kết quả là `means` được thay thế bằng hai cột mới, mỗi cột phản ánh hai phần tử trước đó trong mỗi ô `means`.  

```{r}
t.test_results %>% 
  {tibble(
    variables = names(.),
    p = map_dbl(., "p.value"),
    means = map(., "estimate")
    )} %>% 
  unnest_wider(means)
```



### Loại bỏ, giữ lại và thu gọn danh sách {.unnumbered}  

Vì làm việc với **purrr** nên thường liên quan đến danh sách, chúng ta sẽ khám phá ngắn gọn một số hàm **purrr** để sửa đổi danh sách. Xem phần Tài nguyên học liệu để có hướng dẫn đầy đủ hơn về các hàm **purrr**.  

* `list_modify()` có nhiều cách sử dụng, một trong số đó có thể là xóa một phần tử danh sách  
* `keep()` giữ lại các phần tử được chỉ định cho `.p = ` hoặc trong đó một hàm được cung cấp cho `.p = ` đánh giá là TRUE  
* `discard()` loại bỏ các phần tử được chỉ định cho `.p` hoặc trong đó một hàm được cung cấp cho `.p = ` đánh giá là TRUE  
* `compact()` loại bỏ tất cả các phần tử trống  

Dưới đây là một số ví dụ sử dụng danh sách `combined` được tạo trong phần trên về [sử dụng map() để nhập và kết hợp nhiều tệp](# iter_combined) (nó chứa 6 trường hợp linelist thuộc data frames):  

Các phần tử có thể được xóa bằng tên với `list_modify()` và đặt tên bằng `NULL`.  

```{r, eval=F}
combined %>% 
  list_modify("Central Hospital" = NULL)   # remove list element by name
```

Bạn cũng có thể loại bỏ các phần tử theo tiêu chí, bằng cách cung cấp phương trình "định trước" cho `.p = ` (một phương trình đánh giá là TRUE hoặc FALSE). Đặt dấu ngã `~` trước hàm và sử dụng `.x` để đại diện cho phần tử danh sách. Sử dụng `keep()`, các phần tử danh sách đánh giá là TRUE sẽ được giữ lại. Ngược lại, nếu sử dụng `discard()`, các phần tử danh sách đánh giá là TRUE sẽ bị loại bỏ.  

```{r, eval=F}
# keep only list elements with more than 500 rows
combined %>% 
  keep(.p = ~nrow(.x) > 500)  
```

Trong ví dụ dưới đây, các phần tử danh sách bị loại bỏ nếu lớp của chúng không phải là data frames.  

```{r, eval=F}
# Discard list elements that are not data frames
combined %>% 
  discard(.p = ~class(.x) != "data.frame")
```

Hàm định trước của bạn cũng có thể tham chiếu các phần tử/cột trong mỗi mục danh sách. Ví dụ, bên dưới, liệt kê các phần tử có giá trị trung bình của cột `ct_blood` trên 25 sẽ bị loại bỏ.  

```{r, eval=F}
# keep only list elements where ct_blood column mean is over 25
combined %>% 
  discard(.p = ~mean(.x$ct_blood) > 25)  
```

Lệnh này sẽ xóa tất cả các phần tử danh sách trống:    

```{r, eval=F}
# Remove all empty list elements
combined %>% 
  compact()
```



### `pmap()` {.unnumbered}

PHẦN NÀY ĐANG ĐƯỢC XÂY DỰNG  



## Các hàm apply   

Nhóm hàm "apply" là một hàm R **base** thay thế cho **purrr** với các thao tác lặp lại. Bạn có thể đọc thêm về chúng [tại đây](https://www.datacamp.com/community/tutorials/r-tutorial-apply-family).  





<!-- ======================================================= -->
## Tài nguyên học liệu { }

[for loops with Data Carpentry](https://datacarpentry.org/semester-biology/materials/for-loops-R/)  

The [R for Data Science page on iteration](https://r4ds.had.co.nz/iteration.html#iteration)  

[Vignette on write/read Excel files](https://martinctc.github.io/blog/vignette-write-and-read-multiple-excel-files-with-purrr/)  

A purrr [tutorial](https://jennybc.github.io/purrr-tutorial/index.html) by jennybc 

Another purrr [tutorial](http://www.rebeccabarter.com/blog/2019-08-19_purrr/) by Rebecca Barter  

A purrr [tutorial](http://zevross.com/blog/2019/06/11/the-power-of-three-purrr-poseful-iteration-in-r-with-map-pmap-and-imap/) on map, pmap, and imap  

[purrr cheatsheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/pngs/thumbnails/purrr-cheatsheet-thumbs.png)

[purrr tips and tricks](https://www.hvitfeldt.me/blog/purrr-tips-and-tricks/)

[keep and discard](https://hookedondata.org/going-off-the-map/#keep-and-discard)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/iteration.Rmd-->

# (PART) Phân tích dữ liệu {.unnumbered}

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_analysis.Rmd-->

# Bảng mô tả {#tables-descriptive}

```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "descriptive_tables.png"))
```

Chương này minh họa cách sử dụng các package **janitor**, **dplyr**, **gtsummary**, **rstatix**, và **base** R để tóm tắt dữ liệu và tạo bảng với thống kê mô tả.

*Chương này bao gồm cách để tạo* bảng cơ bản, trong khi đó chương [Trình bày bảng] bao gồm cách để định dạng đẹp và in chúng.\*

Mỗi package này đều có những ưu và nhược điểm trong từng khía cạnh như sự đơn giản, khả năng tiếp cận kết quả, chất lượng kết quả được hiển thị. Sử dụng chương này để quyết định cách tiếp cận nào phù hợp với trường hợp của bạn.

Bạn có một số lựa chọn khi tạo bảng tóm tắt và bảng chéo. Một số yếu tố cần xem xét bao gồm tính đơn giản của code, khả năng tùy chỉnh, đầu ra mong muốn (được in ra R console, dưới dạng dataframe hoặc dưới dạng hình ảnh "đẹp" .png/.jpeg /.html) và dễ xử lý hậu kỳ. Hãy xem xét các điểm dưới đây khi bạn chọn công cụ cho tình huống của mình.

-   Dùng `tabyl()` từ **janitor** để tạo và "làm đẹp" cho bảng và bảng chéo\
-   Dùng `get_summary_stats()` từ **rstatix** để dễ dàng tạo data frame các tóm tắt thống kê dạng số cho nhiều cột và / hoặc nhóm\
-   Dùng `summarise()` và `count()` từ **dplyr** dành choo các thống kê phức tạp hơn, đầu ra của tidy dataframe hoặc chuẩn bị dữ liệu cho `ggplot()`\
-   Dùng `tbl_summary()` từ **gtsummary** để tạo ra các bảng chi tiết sẵn sàng xuất bản\
-   Dùng `table()` từ **base** R nếu bạn không có khả năng truy cập vào các package trên

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đoạn code này hiển thị việc gọi các packages cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến lệnh `p_load()` từ **pacman**, giúp cài đặt các package nếu cần *và* gọi chúng để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt với `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package của R.

```{r, warning=F, message=F}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics 
  gtsummary,    # summary statistics and tests
  rstatix,      # summary statistics and statistical tests
  janitor,      # adding totals and percents to tables
  scales,       # easily convert proportions to percents  
  flextable     # converting tables to pretty images
  )
```

### Nhập dữ liệu {.unnumbered}

Chúng ta sẽ nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải xuống dữ liệu linelist "đã làm sạch"</a> (as .rds file). Nhập dữ liệu của bạn bằng hàm `import()` từ package **rio** (chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - xem thêm chi tiết tại chương [Nhập xuất dữ liệu]).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của linelist được hiển thị như dưới đây.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Duyệt dữ liệu

### **skimr** package {.unnumbered}

Khi sử dụng package **skimr** package, bạn có thể có được cái nhìn tổng quan chi tiết và đẹp về mặt thẩm mỹ của từng biến trong tập dữ liệu của mình. Đọc thêm về **skimr** tại [trang github](https://github.com/ropensci/skimr) của nhà phát triển.

Dưới đây, hàm `skim()` được áp dụng cho toàn bộ data frame `linelist` giúp bạn có cái nhìn tổng quan về data frame và tóm tắt của tất cả các cột (theo lớp).

```{r eval=F}
## get information about each variable in a dataset 
skim(linelist)
```

```{r  echo=F}
# sparkline histograms not showing correctly, so avoiding them.
skim_without_charts(linelist)
```

Bạn cũng có thể sử dụng hàm `summary()` từ **base** R, để lấy thông tin về toàn bộ tập dữ liệu, nhưng kết quả đầu ra có thể khó đọc hơn so với sử dụng **skimr**. Do đó, kết quả không được hiển thị bên dưới để tiết kiệm không gian trang.

```{r, eval=F}
## get information about each column in a dataset 
summary(linelist)
```

### Thống kê tóm tắt {.unnumbered}

Bạn có thể sử dụng các hàm **base** R để trả về thống kê tóm tắt trên một cột dữ liệu dạng số. Bạn có thể trả về hầu hết các thống kê tóm tắt hữu ích cho một cột dạng số bằng cách sử dụng hàm `summary()`, như dưới đây. Lưu ý rằng tên data frame cũng phải được xác định như hình dưới đây.

```{r}
summary(linelist$age_years)
```

Bạn có thể truy cập và lưu một phần cụ thể của nó bằng dấu ngoặc vuông [ ]:

```{r}
summary(linelist$age_years)[[2]]            # return only the 2nd element
# equivalent, alternative to above by element name
# summary(linelist$age_years)[["1st Qu."]]  
```

Bạn có thể trả về các thống kê riêng lẻ với các hàm **base** R như `max()`, `min()`, `median()`, `mean()`, `quantile()`, `sd()`, và `range()`. Xem chương [R cơ bản] để có danh sách đầy đủ.

[***THẬN TRỌNG:*** Nếu dữ liệu của bạn chứa các giá trị missing, R muốn bạn biết điều này và do đó sẽ trả về `NA` trừ khi bạn chỉ định cho các hàm toán học ở trên mà bạn muốn R bỏ qua các giá trị bị thiếu, thông qua đối số `na.rm = TRUE`.]{style="color: orange;"}

Bạn có thể sử dụng hàm `get_summary_stats()` từ package **rstatix** để trả về thống kê tóm tắt *ở định dạng data frame*. Điều này có thể hữu ích cho việc thực hiện các hoạt động tiếp theo hoặc vẽ biểu đồ trên các con số. Xem chương [Các kiểm định thống kê cơ bản] để biết thêm chi tiết về package **rstatix** và các hàm của nó.

```{r}
linelist %>% 
  get_summary_stats(
    age, wt_kg, ht_cm, ct_blood, temp,  # columns to calculate for
    type = "common")                    # summary stats to return

```

## **janitor** package {#tbl_janitor}

Package **janitor** cung cấp hàm `tabyl()` giúp tạo ra các bảng đơn và bảng chéo, có thể được "tô điểm" hoặc sửa đổi bằng các hàm trợ giúp để hiển thị phần trăm, tỷ lệ, số đếm, v.v.

Sau đây, chúng ta sẽ pipe `linelist` data frame tới các hàm của **janitor** và in kết quả. Nếu muốn, bạn cũng có thể lưu các bảng kết quả bằng toán tử gán `<-`.

### tabyl đơn giản {.unnumbered}

Cách sử dụng mặc định của hàm `tabyl()` trên một cột cụ thể tạo ra các giá trị duy nhất, số lượng và "phần trăm" (tỷ lệ thực tế) theo cột. Tỷ lệ có thể có nhiều chữ số thập phân. Bạn có thể điều chỉnh số lượng số thập phân với hàm `adorn_rounding()` như được mô tả bên dưới.

```{r}
linelist %>% tabyl(age_cat)
```

Như bạn có thể thấy ở trên, các giá trị missing sẽ được hiển thị trong một hàng có nhãn `<NA>`. Bạn có thể ngăn điều này bằng cách thêm `show_na = FALSE`. Nếu không có giá trị missing, hàng này sẽ không xuất hiện. Nếu có giá trị missing, tất cả các tỷ lệ sẽ được trình bày dưới dạng thô (mẫu số bao gồm cả `NA`) và "hợp lý" (mẫu số không bao gồm `NA`).

Nếu giá trị cột là dạng Factor và chỉ một vài level nhất định có trong dữ liệu của bạn, thì tất cả các level sẽ vẫn xuất hiện trong bảng. Bạn có thể loại bỏ tính năng này bằng cách thêm `show_missing_levels = FALSE`. Đọc thêm trong chương [Factors].

### Bảng chéo {.unnumbered}

Bảng chéo được tạo bằng cách thêm một hoặc nhiều cột vào hàm `tabyl()`. Lưu ý rằng bây giờ chỉ có số lượng được hiện thị - tỷ lệ và phần trăm có thể được thêm vào bằng các bước bổ sung sẽ được trình bày bên dưới.

```{r}
linelist %>% tabyl(age_cat, gender)
```

### "Tô điểm" cho tabyl {#tbl_adorn .unnumbered}

Sử dụng các hàm "tô điểm" của **janitor** để thêm tổng hoặc chuyển đổi thành tỷ lệ, phần trăm hoặc điều chỉnh hiển thị. Thông thường, bạn sẽ pipe tabyl thông qua một số hàm này..

+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Hàm                      | Đầu ra                                                                                                                                                             |
+==========================+====================================================================================================================================================================+
| `adorn_totals()`         | Thêm tổng (`where =` "row", "col", or "both"). Đặt `name =` cho "Tổng".                                                                                            |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_percentages()`    | Chuyển đổi số lượng thành tỷ lệ, với `denominator =` "row", "col", hoặc "all"                                                                                      |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_pct_formatting()` | Chuyển đổi tỷ lệ thành tỷ lệ phần trăm. Chỉ rõ `digits =`. Loại bỏ ký hiệu "%" bằng `affix_sign = FALSE`.                                                          |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_rounding()`       | Làm tròn tỷ lệ bằng `digits =`. Để làm tròn tỷ lệ phần trăm, sử dụng hàm `adorn_pct_formatting()` với `digits =`.                                                  |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_ns()`             | Thêm số lượng vào bảng tỷ lệ hoặc phần trăm. Chỉ định `position =` "rear" để hiện thị số lượng trong ngoặc đơn, hoặc "front" để đặt phần trăm vào trong ngoặc đơn. |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| `adorn_title()`          | Thêm tiều đề thông qua đối số `row_name =` và/hoặc `col_name =`                                                                                                    |
+--------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------+

Hãy cẩn trọng về thứ tự bạn áp dụng các hàm trên. Dưới đây là một số ví dụ.

Bảng một chiều đơn giản với phần trăm thay vì tỷ lệ mặc định.

```{r}
linelist %>%               # case linelist
  tabyl(age_cat) %>%       # tabulate counts and proportions by age category
  adorn_pct_formatting()   # convert proportions to percents
```

Bảng chéo với tổng hàng và phần trăm hàng.

```{r}
linelist %>%                                  
  tabyl(age_cat, gender) %>%                  # counts by age and gender
  adorn_totals(where = "row") %>%             # add total row
  adorn_percentages(denominator = "row") %>%  # convert counts to proportions
  adorn_pct_formatting(digits = 1)            # convert proportions to percents
```

Bảng chéo được điều chỉnh để cả số lượng và phần trăm đều được hiển thị.

```{r}
linelist %>%                                  # case linelist
  tabyl(age_cat, gender) %>%                  # cross-tabulate counts
  adorn_totals(where = "row") %>%             # add a total row
  adorn_percentages(denominator = "col") %>%  # convert to proportions
  adorn_pct_formatting() %>%                  # convert to percents
  adorn_ns(position = "front") %>%            # display as: "count (percent)"
  adorn_title(                                # adjust titles
    row_name = "Age Category",
    col_name = "Gender")
```

### In với tabyl {.unnumbered}

Theo mặc định, lệnh tabyl sẽ in kết quả thô vào R console của bạn.

Ngoài ra, bạn có thể chuyển tabyl sang **flextable** hoặc package tương tự để in dưới dạng hình ảnh “đẹp” trong RStudio Viewer, có thể được xuất dưới dạng .png, .jpeg, .html, v.v. Điều này đã được thảo luận trong chương Trình bày bảng . Lưu ý rằng nếu in theo cách này và sử dụng `adorn_titles()`, bạn cần thêm vào `placement = "combined"`.

```{r}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% # this is necessary to print as image
  flextable::flextable() %>%    # convert to pretty image
  flextable::autofit()          # format to one line per row 

```

### Sử dụng trên các bảng khác {.unnumbered}

Bạn có thể sử dụng các hàm`adorn_*()` của **janitor** lên các bảng khác, chẳng hạn các bảng được tạo bởi hàm `summarise()` và `count()` của **dplyr**, hoặc `table()` từ **base** R. Đơn giản chỉ cần pipe bảng đến hàm mong muốn của package **janitor**. Ví dụ:


```{r}
linelist %>% 
  count(hospital) %>%   # dplyr function
  adorn_totals()        # janitor function
```

### Lưu với tabyl {.unnumbered}

Nếu bạn muốn chuyển đổi bảng thành một hình ảnh “đẹp” với package **flextable**, bạn có thể lưu nó bằng các hàm như `save_as_html()`, `save_as_word()`, `save_as_ppt()`, và `save_as_image()` từ package **flextable** (sẽ được bàn luận kỹ hơn ở chương [Trình bày bảng]). Ví dụ dưới đây, bảng được lưu lại dưới dạng tệp Word, và có khả năng chỉnh sửa được.

```{r, eval=F}
linelist %>%
  tabyl(age_cat, gender) %>% 
  adorn_totals(where = "col") %>% 
  adorn_percentages(denominator = "col") %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front") %>% 
  adorn_title(
    row_name = "Age Category",
    col_name = "Gender",
    placement = "combined") %>% 
  flextable::flextable() %>%                     # convert to image
  flextable::autofit() %>%                       # ensure only one line per row
  flextable::save_as_docx(path = "tabyl.docx")   # save as Word document to filepath
```

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "tabyl_word.png"))
```

### Thống kê {#janitor_age_out_stats .unnumbered}

Bạn có thể áp dụng các kiểm định thống kê bằng tabyls, ví dụ như `chisq.test()` hoặc `fisher.test()` từ package **stats**, như được trình bày dưới đây. Chú ý là giá trị missing không được cho phép vì vậy chúng được loại bỏ khỏi tabyl bằng tùy chọn `show_na = FALSE`.

```{r, warning=F, message=F}
age_by_outcome <- linelist %>% 
  tabyl(age_cat, outcome, show_na = FALSE) 

chisq.test(age_by_outcome)
```

Xem chương [Các kiểm định thống kê cơ bản] để có thêm code và các mẹo liên quan đến thống kê.

### Các mẹo khác {.unnumbered}

-   Thêm đối số `na.rm = TRUE` để loại bỏ các giá trị missing.\
-   Nếu áp dụng bất kỳ hàm trợ giúp `adorn_*()` nào cho các bảng không được tạo bởi `tabyl()`, bạn có thể chỉ định (các) cột cụ thể để áp dụng chúng chẳng hạn như `adorn_percentage(,,,c(cases,deaths))` (chỉ định chúng cho đối số không tên thứ 4). Thay vào đó, hãy cân nhắc sử dụng hàm `summarise()`.\
-   Bạn có thể tìm đọc thêm ở [janitor page](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) và [tabyl vignette](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html).

## **dplyr** package

**dplyr** là một phần của package **tidyverse** và là một công cụ quản lý dữ liệu rất phổ biến. Tạo bảng với các hàm của **dplyr** như `summarise()` và `count()` là một cách tiếp cận hữu ích để tính toán các tóm tắt thống kê, tổng hợp *theo nhóm*, hoặc chuyển bảng tới `ggplot()`.

`summarise()` tạo một *data frame tổng hợp mới*. Nếu dữ liệu được *tách nhóm*, nó sẽ trả về data frame có một hàng với thống kê tóm tắt được chỉ định cho toàn bộ data frame. Nếu dữ liệu được *nhóm lại*, data frames sẽ có một hàng cho từng *nhóm* (xem chương [Nhóm dữ liệu]).

Bên trong dấu ngoặc đơn của hàm `summarise()`, bạn sẽ cung cấp tên của từng cột cần tổng hợp mới, theo sau là dấu bằng và một hàm thống kê để áp dụng.

[***MẸO:*** Hàm summarise hoạt động được với cả cách viết Anh-Anh và Anh-Mỹ (`summarise()` và `summarize()`).]{style="color: darkgreen;"}

### Lấy số lượng {.unnumbered}

Hàm đơn giản nhất để áp dụng cùng với hàm `summarise()` là `n()`. Để trống dấu ngoặc đơn để đếm số hàng.

```{r}
linelist %>%                 # begin with linelist
  summarise(n_rows = n())    # return new summary dataframe with column n_rows
```

Điều này sẽ thú vị hơn nếu chúng ta đã nhóm dữ liệu trước đó.

```{r}
linelist %>% 
  group_by(age_cat) %>%     # group data by unique values in column age_cat
  summarise(n_rows = n())   # return number of rows *per group*
```

Lệnh trên có thể được rút ngắn bằng cách sử dụng hàm`count()` thay thế. `count()` làm những việc sau:

1)  Nhóm dữ liệu theo các cột được cung cấp cho nó\
2)  Tổng hợp chúng với `n()` (tạo cột `n`)\
3)  Tách nhóm dữ liệu

```{r}
linelist %>% 
  count(age_cat)
```

Bạn có thể thay đổi tên của cột đếm từ mặc định là `n` thành một cái gì đó cụ thể chẳng hạn như `name =`.

Tạo bảng đếm cho hai hoặc nhiều cột sẽ vẫn trả về địng dạng "dọc", với số lượng ở cột `n`. Xem chương [Pivoting dữ liệu] để hiểu thêm về định dạng dữ liệu "dọc" và "ngang".

```{r}
linelist %>% 
  count(age_cat, outcome)
```

### Hiện tất cả các cấp độ {.unnumbered}

Nếu bạn tạo bảng cho một cột có kiểu dữ liệu là *factor*, bạn có thể chắc chắng rằng *tất cả* các cấp độ được trình bày (không chỉ các cấp có giá trị trong dữ liệu) bằng cách thêm `.drop = FALSE` vào lệnh `summarise()` hoặc `count()`.

Kỹ thuật này rất hữu ích để chuẩn hóa các bảng/biểu đồ của bạn. Ví dụ: nếu bạn đang tạo số liệu cho nhiều nhóm con, hoặc liên tục tạo số liệu cho các báo cáo thường quy. Trong các trường hợp này, sự hiện diện của các giá trị trong dữ liệu có thể dao động, nhưng bạn có thể xác định các mức không đổi.

Xem chương [Factors] để có nhiều thông tin hơn.

### Tỷ lệ {#tbl_dplyr_prop .unnumbered}

Tỷ lệ có thể được thêm vào bằng cách piping bảng tới hàm `mutate()` để tạo một cột mới. Định nghĩa cột mới là thương của số quan sát của từng yếu tố (mặc định là `n`) và tổng số quan sát `sum()` của cột (sẽ trả về giá trị là một tỷ lệ).

Lưu ý trong trường hợp này, `sum()` trong lệnh `mutate()` sẽ trả về giá trị của toàn bộ cột `n` để dùng làm mẫu số của tỷ lệ. Như đã được giải thích [trong chương Nhóm dữ liệu](#group_summarise), *nếu* `sum()` được sử dụng với dữ liệu *đã được nhóm* (vd: nếu hàm `mutate()` được theo ngay phía sai hàm `group_by()`), nó sẽ trả về kết quả tổng hợp *theo nhóm*. Như đã nếu ở trên, `count()` hoàn thành nhiệm vụ của mình bằng cách *tách nhóm*. Vì vậy, trong trường hợp này chúng ta sẽ lấy toàn bộ tỷ lệ của cột.

Để dễ dàng hiển thị phần trăm, bạn có thể đưa tỷ lệ vào trong hàm `percent()` từ package **scales** (lưu ý là điều nãy sẽ chuyển kết quả thành dạng ký tự (character)).

```{r}
age_summary <- linelist %>% 
  count(age_cat) %>%                     # group and count by gender (produces "n" column)
  mutate(                                # create percent of column - note the denominator
    percent = scales::percent(n / sum(n))) 

# print
age_summary
```

Dưới đây là phương pháp tính tỷ lệ *trong nhóm*. Nó dựa trên các cấp độ nhóm dữ liệu khác nhau được áp dụng và loại bỏ một cách có chọn lọc. Đầu tiên, dữ liệu được nhóm theo `outcome` thông qua hàm `group_by()`. Sau đó, hàm `count()` được áp dụng. Hàm này sẽ tiếp tục nhóm dữ liệu phân theo `age_cat` và trả vế số lượng theo từng tổ hợp `outcome`-`age-cat`. Quan trọng là - khi nó kết thúc quy trình của mình, hàm `count()` sẽ *tách nhóm* theo `age_cat`, nên nhóm dữ liệu duy nhất còn lại là nhóm ban đầu theo `outcome`. Do đó, bước cuối cùng để tính toán tỷ lệ (mẫu số là `sum(n)`) vẫn được nhóm theo `outcome`.

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

### Vẽ biểu đồ {.unnumbered}

Để hiển thị kết quả từ một bảng "dài" như trên thì vẽ biểu đồ bằng hàm `ggplot()` tương đối trực quan. Dữ liệu một cách tự nhiên có định dạng "dọc", nên tương thích với `ggplot()` một cách tự nhiên. Xem thêm các ví dụ ở chương [ggplot cơ bản] và [Các tips với ggplot].

```{r, warning=F, message=F}
linelist %>%                      # begin with linelist
  count(age_cat, outcome) %>%     # group and tabulate counts by two columns
  ggplot()+                       # pass new data frame to ggplot
    geom_col(                     # create bar plot
      mapping = aes(   
        x = outcome,              # map outcome to x-axis
        fill = age_cat,           # map age_cat to the fill
        y = n))                   # map the counts column `n` to the height
```

### Tổng hợp thống kê {.unnumbered}

Một điểm mạnh của **dplyr** và `summarise()` là khả năng trả về các bảng tổng hợp thống kê nâng cao hơn như `median()`, `mean()`, `max()`, `min()`, `sd()` (độ lệch chuẩn), và phân vị. Bạn cũng có thể sử dụng `sum()` để trả vể số lượng dòng thỏa mãn một điều kiện logic nào đó. Như trên, các kết quả đầu ra này có thể được tạo cho toàn bộ data frame hoặc theo nhóm.

Cú pháp là tương tự- bên trong dấu ngoặc hàm `summarise()` bạn cung cấp tên của từng cột tổng hợp được theo sau bởi dâu bằng và hàm thống kê được áp dụng. Trong hàm thống kê, cung cấp (các) cột sẽ được tính toán và bất kỳ các đối số có liên quan (vd: `na.rm = TRUE` cho tất cả các hàm toán học).

Bạn cũng có thể sử dụng hàm `sum()` để trả vể số lượng dòng thỏa mãn một điều kiện logic cụ thể. Biểu thức điều kiện sẽ được đếm nếu nó được đánh giá là `TRUE`. Ví dụ:

-   `sum(age_years < 18, na.rm=T)`\
-   `sum(gender == "male", na.rm=T)`\
-   `sum(response %in% c("Likely", "Very Likely"))`

Dưới đây, bộ dữ liệu `linelist` được tổng hợp để mô tả những ngày trì hoãn từ khi bắt đầu có triệu chứng đến khi nhập viện (cột `days_onset_hosp`), phân theo bệnh viện.

```{r}
summary_table <- linelist %>%                                        # begin with linelist, save out as new object
  group_by(hospital) %>%                                             # group all calculations by hospital
  summarise(                                                         # only the below summary columns will be returned
    cases       = n(),                                                # number of rows per group
    delay_max   = max(days_onset_hosp, na.rm = T),                    # max delay
    delay_mean  = round(mean(days_onset_hosp, na.rm=T), digits = 1),  # mean delay, rounded
    delay_sd    = round(sd(days_onset_hosp, na.rm = T), digits = 1),  # standard deviation of delays, rounded
    delay_3     = sum(days_onset_hosp >= 3, na.rm = T),               # number of rows with delay of 3 or more days
    pct_delay_3 = scales::percent(delay_3 / cases)                    # convert previously-defined delay column to percent 
  )

summary_table  # print
```

Một vài mẹp:

-   Sử dụng `sum()` với một biểu thức logic để "đếm" các dòng đáp ứng các tiêu chí nhất định (`==`)\

-   Lưu ý cách sử dụng của `na.rm = TRUE` bên trong biểu thức toán học như là `sum()`, nếu không `NA` sẽ được trả lại nếu dữ liệu có giá trị missing\

-   Sử dụng hàm `percent()` từ package **scales** để dễ dàng chuyển đổi tỷ lệ phần trăm

    -   Thiết lập `accuracy =` bằng 0.1 hoặc 0.01 để đảm bảo kết quả hiển thị 1 hoặc 2 chữ số thập phân sau dấ phẩy\

-   Sử dụng hàm `round()` từ **base** R để chỉ định số thập phân\

-   Để tính toán các thống kê này trên toàn bộ tập dữ liệu, sử dụng `summarise()` và không có `group_by()`\

-   Bạn có thể tạo các cột cho các mục đích tính toán sau này (ví dụ: mẫu số) mà thậm chí bạn bỏ ra khỏi data frame của mình với hàm `select()`.

### Thống kê có điều kiện {.unnumbered}

Bạn có thể sẽ muốn trả về các *thống kê có điều kiện* - vd: số hàng tối đa đáp ứng các tiêu chí nhất định. Điều này có thể thực hiện được bằng cáhc subsetting cột bằng dấu ngoặc vuông `[ ]`. Ví dụ dưới đây trả về nhiệt độ tối đa cho những bệnh nhân được phân loại là có hoặc không bị sốt. Tuy nhiên hãy lưu ý - có thể thích hợp hơn nếu thêm một cột khác vào hàm `group_by()` và `pivot_wider()` (như được minh họa [dưới đây](#tbls_pivot_wider)).

```{r}
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    max_temp_fvr = max(temp[fever == "yes"], na.rm = T),
    max_temp_no = max(temp[fever == "no"], na.rm = T)
  )
```

### Gắn với nhau {.unnumbered}

Hàm `str_glue()` từ package **stringr** rất hữu ích để kết hợp các giá trị từ một số cột thành một cột mới. Trong trường hợp này nó được sử dụng *sau* hàm `summarise()`.

Trong chương [Ký tự và chuỗi], có nhiều lựa chọn khác nhau để kết hợp các cột được thảo luận, bao gồm cả `unite()`, và `paste0()`. Trong trường hợp sử dụng này, chúng tôi ủng hộ `str_glue()` bởi vì nó linh hoạt hơn `unite()` và có cú pháp đơn giẩn hơn `paste0()`.

Dưới đây, data frame `summary_table` (được tạo bên trên) được biến đổi để kết hợp cột `delay_mean` và `delay_sd`, định dạng dấu ngoặc đơn được thêm vào cột mới, và các cột cũ tương ứng của chúng bị xóa.

Sau đó, để làm cho bảng dễ nhìn hơn, tổng hàng được thêm vào bằng hàm `adorn_totals()` từ **janitor** (bỏ qua các cột không phải số). Cuối cùng, chúng tôi sử dụng hàm `select()` từ **dplyr** để sắp xếp và đặt tên lại cho các cột.

Bây giờ bạn có thể chuyển kết quả tới **flextable** và in chúng thành bảng trong Word, .png, .jpeg, .html, Powerpoint, RMarkdown, v.v.! (xem chương [Trình bày bảng]).

```{r}
summary_table %>% 
  mutate(delay = str_glue("{delay_mean} ({delay_sd})")) %>%  # combine and format other values
  select(-c(delay_mean, delay_sd)) %>%                       # remove two old columns   
  adorn_totals(where = "row") %>%                            # add total row
  select(                                                    # order and rename cols
    "Hospital Name"   = hospital,
    "Cases"           = cases,
    "Max delay"       = delay_max,
    "Mean (sd)"       = delay,
    "Delay 3+ days"   = delay_3,
    "% delay 3+ days" = pct_delay_3
    )
```

#### Bách phân vị {.unnumbered}

*Bách phân vị* và tứ phân vị trong **dplyr** xứng đáng được đề cập tới. Để trả về tứ phân vị, sử dụng `quantile()` với các giá trị mặc định hoặc chỉ rõ giá trị bạn muốn bằng đối số `probs =`.

```{r}
# get default percentile values of age (0%, 25%, 50%, 75%, 100%)
linelist %>% 
  summarise(age_percentiles = quantile(age_years, na.rm = TRUE))

# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  summarise(
    age_percentiles = quantile(
      age_years,
      probs = c(.05, 0.5, 0.75, 0.98), 
      na.rm=TRUE)
    )
```

Nếu bạn muốn trả về phân vị *theo nhóm*, bạn có thể gặp phải các kết quả đầu ra dài và ít hữu ích hơn nếu bạn chỉ cần thêm cột vào `group_by()`. Thay vào đó, hãy thử cách tiếp cận này - tạo một cột cho mỗi mức phân vị mong muốn.

```{r}
# get manually-specified percentile values of age (5%, 50%, 75%, 98%)
linelist %>% 
  group_by(hospital) %>% 
  summarise(
    p05 = quantile(age_years, probs = 0.05, na.rm=T),
    p50 = quantile(age_years, probs = 0.5, na.rm=T),
    p75 = quantile(age_years, probs = 0.75, na.rm=T),
    p98 = quantile(age_years, probs = 0.98, na.rm=T)
    )
```

Mặc dù **dplyr** `summarise()` chắc chắn cung cấp khả năng kiểm soát tốt hơn, bạn có thể thấy rằng tất cả các thống kê tổng hợp mà bạn cần có thể được tạo ra với hàm `get_summary_stat()` từ package **rstatix**. Nếu thực hiện trên dữ liệu đã được nhóm, nó sẽ trả về các phân vị 0%, 25%, 50%, 75%, và 100%. If applied to ungrouped data, you can specify the percentiles with `probs = c(.05, .5, .75, .98)`.

```{r}
linelist %>% 
  group_by(hospital) %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

```{r}
linelist %>% 
  rstatix::get_summary_stats(age, type = "quantile")
```

### Tóm tắt dữ liệu tổng hợp {.unnumbered}

*Nếu bạn bắt đầu với dữ liệu tổng hợp (aggregated data)*, sử dụng `n()` để trả về số lượng các *dòng*, không phải là tổng của các số lượng được đếm. Để lấy tổng, sử dụng `sum()` trên cột của dữ liệu đếm.

Ví dụ, giả sử bạn đang bắt đầu với data frame đếm số lượng như bên dưới, gọi là `linelist_agg` - nó hiển thị ở định dạng "dọc", các trường hợp được tính theo outcome và giới tính.

Sau đây chúng ta sẽ tạo data frame minh hoạt số trường hợp của `linelist` được đếm theo outcome và gender (các giá trị missing được loại bỏ để rõ ràng).

```{r}
linelist_agg <- linelist %>% 
  drop_na(gender, outcome) %>% 
  count(outcome, gender)

linelist_agg
```

Để tính tổng số lượng (trong cột `n`) theo nhóm bạn có thể sử dụng hàm `summarise()` nhưng đặt cột mới bằng `sum(n, na.rm=T)`. Để thêm phần tử điều kiện vào phép toán tổng, bạn có thể sử dụng cú pháp dấu ngoặc vuông tập hợp con [ ] trên cột đếm.

```{r}
linelist_agg %>% 
  group_by(outcome) %>% 
  summarise(
    total_cases  = sum(n, na.rm=T),
    male_cases   = sum(n[gender == "m"], na.rm=T),
    female_cases = sum(n[gender == "f"], na.rm=T))
```

### `across()` trên nhiều cột {.unnumbered}

Bạn có thể sử dụng `summarise()` trên nhiều cột bằng hàm `across()`. Điều này làm cho mọi thứ dễ dàng hơn khi bạn muốn tính toán các thống kê giống nhau cho nhiều cột. Đặt `across()` bên trong `summarise()` và chỉ rõ những điều sau:

-   `.cols =` tên cột viết dưới dạng vector `c()` hoặc sử dụng các hàm trợ giúp chọn cột "tidyselect" (được giải thích bên dưới)\
-   `.fns =` hàm thực hiện (không có dấu ngoặc) - bạn có thể đưa nhiều hàm vào thông qua `list()`

Ví dụ dưới đây, `mean()` được áp dụng cho các cột dữ liệu dạng số. Một vectơ tên của các cột được gán cho `.cols =` và hàm duy nhất `mean` được xác định (không có dấu ngoặc) cho `.fns =`. Bất kỳ đối số bổ sung nào cho hàm (vd: `na.rm=TRUE`) được cung cấp phía sau `.fns =`, ngăn cách bởi dấu phẩy.

Có thể khó để hiểu được thứ tự của dấu ngoặc đơn và dấu phẩy chính xác khi sử dụng `across()`. Hãy nhớ là bên trong hàm `across()` bạn phải bao gồm các cột, các hàm, và tất cả những đối số cần thiết cho các hàm.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm),  # columns
                   .fns = mean,                               # function
                   na.rm=T))                                  # extra arguments
```

Nhiều hàm có thể được chạy cùng một lúc. Dưới đây hàm `mean` và `sd` được cung cấp cho `.fns =` bên trong một `list()`. Bạn có cơ hội cung cấp tên ký tự (vd: "mean" và "sd") để thêm vào tên các cột mới.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(.cols = c(age_years, temp, wt_kg, ht_cm), # columns
                   .fns = list("mean" = mean, "sd" = sd),    # multiple functions 
                   na.rm=T))                                 # extra arguments
```

Dưới đây là danh sách các hàm trợ giúp "tidyselect" bạn có thể cung cấp cho `.cols =` để lựa chọn cột:

-   `everything()` - tất cả các cột khác không được đề cập\
-   `last_col()` - cột cuối cùng\
-   `where()` - áp dụng một hàm cho tất cả các cột và chọn những cột trả về giá trị TRUE\
-   `starts_with()` - khớp với một tiền tố được chỉ định. Ví dụ: `starts_with("date")`
-   `ends_with()` - khớp với một hậu tố được chỉ định. Ví dụ: `ends_with("_end")`\
-   `contains()` - cột chứa một chuỗi ký tự. Ví dụ: `contains("time")`
-   `matches()` - áp dụng một biểu thức chính quy (regex). Ví dụ: `contains("[pt]al")`\
-   `num_range()` - khoảng giá trị số
-   `any_of()` - khớp nếu cột được đặt tên. Hữu ích nếu tên có thể không tồn tại. Ví dụ: `any_of(date_onset, date_death, cardiac_arrest)`

Ví dụ, để trả về giá trị trung bình của tất cả các cột dạng số, sử dụng `where()` và thêm vào hàm `is.numeric()` (không có dấu ngoặc). Tất cả những thứ này vẫn được đặt trong hàm `across()`.

```{r}
linelist %>% 
  group_by(outcome) %>% 
  summarise(across(
    .cols = where(is.numeric),  # all numeric columns in the data frame
    .fns = mean,
    na.rm=T))
```

### Xoay trục ngang (Pivot wider) {#tbls_pivot_wider .unnumbered}

Nếu bạn thích bảng của mình ở định dạng "rộng", bạn có thể biến đổi nó sử dụng hàm **tidyr** `pivot_wider()`. Bạn có thể sẽ cần đặt lại tên cho các cột bằng `rename()`. Để tìm hiểu thêm, vui lòng xem chương [Pivoting dữ liệu].

Ví dụ sau đây bắt đầu bằng một bảng "dài" `age_by_outcome` từ mục [Tỷ lệ](#tbl_dplyr_prop). Để dễ hình dung, chúng ta tạo lại bảng và in ra:

```{r}
age_by_outcome <- linelist %>%                  # begin with linelist
  group_by(outcome) %>%                         # group by outcome 
  count(age_cat) %>%                            # group and count by age_cat, and then remove age_cat grouping
  mutate(percent = scales::percent(n / sum(n))) # calculate percent - note the denominator is by outcome group
```

```{r, echo=F}
DT::datatable(age_by_outcome, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Để xoay trục ngang, chúng ta tạo các cột mới từ các *giá trị* trong cột hiện có `age_cat` (bằng cách đặt `names_from = age_cat`). Chúng ta cũng chỉ định rằng các giá trị bảng mới sẽ đến từ cột hiện có `n`, với `values_from = n`. Các cột không được đề cập trong lệnh pivoting (`outcome`) sẽ không thay đổi ở phía ngoài cùng bên trái.

```{r}
age_by_outcome %>% 
  select(-percent) %>%   # keep only counts for simplicity
  pivot_wider(names_from = age_cat, values_from = n)  
```

### Tổng các hàng {#tbl_dplyr_totals .unnumbered}

Khi hàm `summarise()` vận hành trên dữ liệu đã được nhóm, nó không tính "tổng" một cách tự động. Sau đây là hai cách tiếp cận giúp bạn thêm tổng hàng:

#### **janitor**'s `adorn_totals()` {.unnumbered}

Nếu bảng của bạn chỉ chứa duy nhất số lượng hoặc tỷ lệ/tỷ lệ phần trăm có thể được tổng hợp thành một tổng, thì bạn có thể tính *tổng* sử dụng hàm `adorn_totals()` của package **janitor** như đã được mô tả bên trên. Lưu ý là hàm này chỉ có thể tính tổng của các cột định dạng là số - nếu bạn muốn tính các loại tổng khác, vui lòng xem cách tiếp cận tiếp theo bằng **dplyr**.

Dưới đây, bộ dữ liệu `linelist` được nhóm theo giới và tóm tắt thành một bảng mô tả số trường hợp có outcome đã biết, tử vong và phục hồi. Piping bảng tới hàm `adorn_totals()` để thêm tổng các hàng ở hàng dưới cùng thể hiện giá trị tổng của từng cột. Các hàm `adorn_*()` khác điều chỉnh cách kết quả được hiển thị như được comment trong phần code.

```{r}
linelist %>% 
  group_by(gender) %>%
  summarise(
    known_outcome = sum(!is.na(outcome)),           # Number of rows in group where outcome is not missing
    n_death  = sum(outcome == "Death", na.rm=T),    # Number of rows in group where outcome is Death
    n_recover = sum(outcome == "Recover", na.rm=T), # Number of rows in group where outcome is Recovered
  ) %>% 
  adorn_totals() %>%                                # Adorn total row (sums of each numeric column)
  adorn_percentages("col") %>%                      # Get column proportions
  adorn_pct_formatting() %>%                        # Convert proportions to percents
  adorn_ns(position = "front")                      # display % and counts (with counts in front)
```

#### `summarise()` trên dữ liệu "tổng" rồi sau đó `bind_rows()` {.unnumbered}

Nếu bảng của bạn chứa các phép tính thống kế chẳng hạn như `median()`, `mean()`, v.v, thì cách tiếp cận dùng hàm `adorn_totals()` bên trên sẽ *không* đủ. Thay vào đó, để có được thống kê tóm tắt cho toàn bộ tập dữ liệu, bạn phải tính toán chúng bằng lệnh `summarise()` một cách độc lập sau đó gắn các kết quả này với bảng tổng hợp theo nhóm ban đầu. Để làm điều này, bạn có thể sử dụng hàm `bind_rows()` từ **dplyr** như được mô tả trong chương [Nối dữ liệu]. Dưới đây là một ví dụ:

Bạn có thể tạo bảng tổng hợp của outcome *theo bệnh viện* với `group_by()` và `summarise()` như sau:

```{r, warning=F, message=F}
by_hospital <- linelist %>% 
  filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T))               # median CT value per group
  
by_hospital # print table
```

Để tính tổng, vẫn sử dụng hàm `summarise()` nhưng chỉ nhóm dữ liệu theo outcome (không theo bệnh viện), như dưới đây:

```{r}
totals <- linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # These statistics are now by outcome only     
        ct_value = median(ct_blood, na.rm=T))

totals # print table
```

Bây giờ chúng ta có thể nối hai data frames này lại với nhau. Lưu ý là bảng `by_hospital` có 4 cột trong khi đó bảng kết quả `totals` có 3 cột. Bằng việc sử dụng `bind_rows()`, các cột được kết hợp theo tên, và bất kỳ khoảng trống nào sẽ được điền vào bằng giá trị `NA` (ví dụ ở cột `hospital` là các giá trị cho hai hàng `totals` mới). Sau khi gắn các hàng, chúng ta chuyển các khoảng trống đó thành "Tổng" bằng cách sử dụng `replace_na()` (xem chương [Làm sạch số liệu và các hàm quan trọng]).

```{r}
table_long <- bind_rows(by_hospital, totals) %>% 
  mutate(hospital = replace_na(hospital, "Total"))
```

Đây là bảng mới với các hàng "Tổng" ở các hàng dưới cùng của bảng.

```{r, message=FALSE, echo=F}
DT::datatable(table_long, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Bảng này đang có định dạng "dài", có thể là những gì bạn muốn. *Tuy nhiên*, bạn có thể *xoay* bảng này *rộng hơn* theo chiều ngang để dễ đọc. Xem thêm ở phần Xoay trục ngang (Pivot wider) bên trên, và chương [Xoay trục dữ liệu]. Bạn cũng có thêm nhiều cột nữa, và sắp xếp chúng một cách đẹp mắt. Phần code được trình bày bên dưới.

```{r}
table_long %>% 
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known)                                  # Arrange rows from lowest to highest (Total row at bottom)

```

Tiếp đó bạn có thể in bảng kết quả dưới dạng một bức ảnh đẹp - sau đây là output được in bằng **flextable**. Bạn có thể đọc chuyên sâu hơn về ví dụ này và cách tạo được bảng "đẹp" tương tự thế này trong chương [Trình bày bảng].

```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make pretty images of tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

table <- linelist %>% 
  # filter
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  
  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)

  # formatting
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  colformat_num(., j = c(4,7), digits = 1) %>% 
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 6, bold = TRUE, part = "body")


table
```

## **gtsummary** package {#tbl_gt}

Nếu bạn muốn in các thống kê tóm tắt của mình dưới dạng đồ họa đẹp mắt, sẵn sàng xuất bản, bạn có thể sử dụng package **gtsummary** và hàm của nó `tbl_summary()`. Phần code ban đầu có thể trông phức tạp một chút, nhưng kết quả đầu ra trông rất đẹp và in ra Viewer panel của RStudio dưới dạng một ảnh HTML. Đọc [bản tóm tắt ở đây](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html).

Bạn cũng có thể thêm kết quả của các kiểm định thống kê vào các bảng của **gtsummary**. Quy trình này được trình bày ở mục **gtsummary** trong chương [Các kiểm định thống kê cơ bản](#stats_gt).

Để giới thiệu về `tbl_summary()`, trước tiên chúng ta sẽ chỉ ra các quy trình cơ bản nhất, giúp bạn thực sự tạo ra một bảng lớn và đẹp. Sau đó, chúng ta sẽ tìm hiểu chi tiết hơn về cách thực hiện các điều chỉnh và các bảng được thiết kế sẵn.

### Bảng tổng hợp {.unnumbered}

Cách làm việc mặc định của `tbl_summary()` khá kinh ngạc - nó lấy các cột bạn cung cấp và tạo một bảng tóm tắt chỉ trong một lệnh. Hàm in ra số liệu thống kê phù hợp với lớp cột: trung vị và khoảng tứ phân vị (IQR) cho các cột số, và số lượng (%) cho các cột danh mục. Giá trị missing được chuyển đổi thành "Unknown". Chú thích được thêm vào cuối bảng để giải thích các phép tính thống kê, trong khi tổng N được hiển thị ở trên cùng.

```{r, warning=F, message=F}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>%  # keep only the columns of interest
  tbl_summary()                                                  # default
```

### Các điều chỉnh {.unnumbered}

Bây giờ chúng tôi sẽ giải thích cách hoạt động của hàm và cách điều chỉnh. Các đối số chính được trình bày chi tiết bên dưới:

**`by =`**\
Bạn có thể phân tầng bảng của mình theo một cột (ví dụ theo `outcome`), để tạo thành bảng 2 chiều.

**`statistic =`**\
Sử dụng phương trình để chỉ định thống kê nào sẽ được hiển thị và cách hiển thị chúng. Có hai vế của phương trình, được ngăn cách bởi dấu `~`. Ở vế phải, trong dấu ngoặc kép, là hiển thị phép toán thống kê mong muốn, và ở vế trái là các cột mà phép thống kê đó sẽ áp dụng.

-   Vế phải của phương trình sử dụng cú pháp của hàm `str_glue()` từ **stringr** (xem [Ký tự và chuỗi]), với chuỗi hiển thị mong muốn trong dấu ngoặc kép và các phép toán thống kê trong dấu ngoặc nhọn. Bạn có thể thêm các phép thống kê như là "n" (số lượng), "N" (mẫu số), "mean", "median", "sd", "max", "min", phân vị "p\#\#" như là  "p25", hoặc phần trăm của một tổng như là "p". Xem `?tbl_summary` để biết thêm chi tiết.\
-   Đối với phía bên trái của phương trình, bạn có thể chỉ định các cột theo tên (ví dụ: `age` hoặc `c(age, gender)`) hoặc sử dụng các hàm trợ giúp như `all_continuous()`, `all_categorical()`, `contains()`, `starts_with()`, v.v.

Một ví dụ đơn giản về phương trình `statistic =` có thể tham khảo ở bên dưới, để chỉ in giá trị trung bình của cột `age_years`:

```{r}
linelist %>% 
  select(age_years) %>%         # keep only columns of interest 
  tbl_summary(                  # create summary table
    statistic = age_years ~ "{mean}") # print mean of age
```

Một phương trình phức tạp hơn một chút có thể như`"({min}, {max})"`, kết hợp các giá trị max và min trong dấu ngoặc đơn và được phân tách bằng dấu phẩy:

```{r}
linelist %>% 
  select(age_years) %>%                       # keep only columns of interest 
  tbl_summary(                                # create summary table
    statistic = age_years ~ "({min}, {max})") # print min and max of age
```

Bạn cũng có thể phân biệt cú pháp cho các cột hoặc loại cột riêng biệt. Trong ví dụ phức tạp hơn bên dưới, giá trị được cung cấp cho `statistc =` là một **danh sách** chỉ ra rằng đối với tất cả các cột dạng số thì bảng sẽ in ra giá trị trung bình và độ lệch chuẩn bên trong ngoặc, trong khi các cột dạng danh sách thì sẽ in ra n, mẫu số, và phần trăm.

**`digits =`**\
Điều chỉnh các chữ số và làm tròn. Theo tùy chọn, điều này có thể được chỉ định chỉ dành cho các cột dạng số liên tục (như bên dưới).

**`label =`**\
Điều chỉnh cách hiển thị tên cột. Cung cấp tên cột và nhãn mong muốn của nó được phân tách bằng dấu ngã. Theo mặc định thì tên cột được hiển thị.

**`missing_text =`**\
Điều chỉnh cách giá trị missing được hiển thị. Mặc định hiển thị là "Unknown".

**`type =`**\
Sử dụng để điều chỉnh số lượng cấp độ của thống kê được hiển thị Cú pháp tương tự như `statistic =` trong đó bạn cung cấp một phương trình với các cột ở bên trái và một giá trị ở bên phải. Hai trường hợp phổ biến bao gồm:

-   `type = all_categorical() ~ "categorical"` Buộc các cột nhị phân (ví dụ: `fever` có/không) hiển thị tất cả các cấp độ thay vì chỉ hiện thị hàng "có"\
-   `type = all_continuous() ~ "continuous2"` Cho phép các kết quả thống kê được trình bày theo nhiều dòng cho mỗi biến, như được trình bày trong phần sau

Trong ví dụ dưới đây, mỗi đối số này được sử dụng để điều chỉnh bảng ban đầu:

```{r}
linelist %>% 
  select(age_years, gender, outcome, fever, temp, hospital) %>% # keep only columns of interest
  tbl_summary(     
    by = outcome,                                               # stratify entire table by outcome
    statistic = list(all_continuous() ~ "{mean} ({sd})",        # stats and format for continuous columns
                     all_categorical() ~ "{n} / {N} ({p}%)"),   # stats and format for categorical columns
    digits = all_continuous() ~ 1,                              # rounding for continuous columns
    type   = all_categorical() ~ "categorical",                 # force all categorical levels to display
    label  = list(                                              # display labels for column names
      outcome   ~ "Outcome",                           
      age_years ~ "Age (years)",
      gender    ~ "Gender",
      temp      ~ "Temperature",
      hospital  ~ "Hospital"),
    missing_text = "Missing"                                    # how missing values should display
  )
```

### Thống kê nhiều dòng cho các biến liên tục {.unnumbered}

Nếu bạn muốn in nhiều dòng thống kê cho các biến liên tục, bạn có thể thiết lập `type =` thành "continuous2". Bạn có thể kết hợp tất cả các yếu tố được hiển thị trước đó trong một bảng bằng cách chọn thống kê bạn muốn hiển thị. Để làm điều này, bạn cần cho hàm biết rằng bạn muốn khôi phục bảng bằng cách nhập type là "continuous2". Số lượng các giá trị missing được hiển thị là "Unknown".

```{r}
linelist %>% 
  select(age_years, temp) %>%                      # keep only columns of interest
  tbl_summary(                                     # create summary table
    type = all_continuous() ~ "continuous2",       # indicate that you want to print multiple statistics 
    statistic = all_continuous() ~ c(
      "{mean} ({sd})",                             # line 1: mean and SD
      "{median} ({p25}, {p75})",                   # line 2: median and IQR
      "{min}, {max}")                              # line 3: min and max
    )
```

Có nhiều cách khác để chỉnh sửa các bảng này, bao gồm thêm giá trị p, chỉnh sửa màu sắc và tiêu đề, v.v. Các phần này được đề cập trong tài liệu trợ giúp đính kèm (nhập `?tbl_summary` trong cửa sổ Console), và một số được đề cập trong chương [Các kiểm định thống kê cơ bản](#stat-tests).

## **base** R

Bạn có thể sử dụng hàm `table()` để tạo bảng đơn và bảng chéo các cột. Không giống như các cách ở trên, bạn phải chỉ định data frame mỗi khi bạn tham chiếu đến tên cột, như được trình bày dưới đây.

[***THẬN TRỌNG:*** Giá trị `NA` (missing) sẽ **không** sẽ không được lập bảng trừ khi bạn bao gồm đối số `useNA = "always"` (cũng có thể được đặt thành "no" hoặc "ifany").]{style="color: orange;"}

[***MẸO:*** Bạn có thể sử dụng `%$%` từ package **magrittr** để loại bỏ việc lặp lại các data frame trong các hàm **base**. Chẳng hạn, ví dụ bên dưới có thể được viết lại thành `linelist %$% table(outcome, useNA = "always")` ]{style="color: darkgreen;"}

```{r}
table(linelist$outcome, useNA = "always")
```

Có thể lập bảng chéo từ nhiều cột bằng cách liệt kê chúng nối tiếp nhau, phân tách bằng dấu phẩy. Hoặc là, bạn có thể gán cho mỗi cột một “tên” như `Outcome = linelist$outcome`.

```{r}
age_by_outcome <- table(linelist$age_cat, linelist$outcome, useNA = "always") # save table as object
age_by_outcome   # print table
```

### Tỷ lệ {.unnumbered}

Để trả về tỷ lệ, hãy chuyển bảng trên vào hàm `prop.table()`. Sử dụng đối số `margins =` để chỉ định xem bạn muốn tỷ lệ của hàng (1), của cột (2) hay của toàn bảng (3). Để dễ nhìn, chúng ta pipe bảng trên vào hàm `round()` của **base** R, chỉ định 2 chữ số sau dấu phẩy.

```{r}
# get proportions of table defined above, by rows, rounded
prop.table(age_by_outcome, 1) %>% round(2)
```

### Tổng {.unnumbered}

Để thêm tổng hàng và tổng cột, hãy chuyển bảng vào hàm `addmargins()`. Cách này hoạt động cho cả số lượng và tỷ lệ.

```{r}
addmargins(age_by_outcome)
```

### Chuyển đổi thành data frame {.unnumbered}

Chuyển đổi trực tiếp một đối tượng dạng `table()` sang một data frame không phải là một đường thẳng. Cách tiếp cận được trình bày như dưới đây:

1)  Tạo một bảng, mà *không sử dụng* `useNA = "always"`. Thay vào đó chuyển giá trị `NA` thành “(Missing)” với hàm `fct_explicit_na()` của package **forcats**.\
2)  Thêm tổng (tùy chọn) bằng cách piping tới `addmargins()`\
3)  Pipe tới hàm `as.data.frame.matrix()` của **base** R\
4)  Pipe bảng trên vào hàm `rownames_to_column()` của package **tibble**, ghi rõ tên cho cột đầu tiên\
5)  In, Xem hoặc xuất bảng như mong muốn. Trong ví dụ này, chúng ta sử dụng hàm `flextable()` từ package **flextable** như đã được mô tả trong chương Kết quả sẽ được in ra cửa sổ RStudio viewer dưới dạng một hình ảnh HTML đẹp.

```{r, warning=F, message=F}
table(fct_explicit_na(linelist$age_cat), fct_explicit_na(linelist$outcome)) %>% 
  addmargins() %>% 
  as.data.frame.matrix() %>% 
  tibble::rownames_to_column(var = "Age Category") %>% 
  flextable::flextable()
```

<!-- ======================================================= -->

## Nguồn

Phần lớn thông tin trong chương này được tham khảo từ các nguồn và bản tóm tắt trực tuyến dưới đây:

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)

[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/tables_descriptive.Rmd-->

# Các kiểm định thống kê cơ bản {#stat-tests}


Chương này sẽ trình bày cách để thực hiện các phép kiểm định thống kê cơ bản bằng cách sử dụng **base** R, **rstatix**, và **gtsummary**.  

* Kiểm định t  
* Kiểm định Shapiro-Wilk  
* Kiểm định tổng thứ hạng Wilcoxon   
* Kiểm định Kruskal-Wallis  
* Kiểm định Chi-squared (Chi bình phương)  
* Tương quan giữa các biến định lượng 

...nhiều kiểm định khác có thể được thực hiện, nhưng chúng tôi chỉ trình bày các kiểm định thông dụng và kết nối với các phần khác trong cuốn sổ tay này.  

Mỗi package được đề cập bên trên đều có một số ưu điểm và khuyết điểm nhất định:  

* Sử dụng các câu lệnh của **base** để in các kết quả đầu ra thống kê trong R Console  
* Sử dụng các câu lệnh của **rstatix** để cho kết quả dưới dạng data frame hoặc khi muốn thực hiện các kiểm định theo nhóm  
* Sử dụng các câu lệnh của **gtsummary** khi muốn kết quả là các bảng biểu có thể sử dụng được ngay  



<!-- ======================================================= -->
## Các bước chuẩn bị {  }


### Gọi các packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` trong package **pacman**, cài đặt gói lệnh nếu cần thiết *và* gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng `library()` từ **base** R. Xem thêm thông tin các package của R trong chương [R cơ bản].  


```{r}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics, 
  gtsummary,    # summary statistics and tests
  rstatix,      # statistics
  corrr,        # correlation analayis for numeric variables
  janitor,      # adding totals and percents to tables
  flextable     # converting tables to HTML
  )
```

### Nhập số liệu {.unnumbered}

Chúng ta nhập bộ số liệu của các ca bệnh về một vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải bộ số liệu linelist "đã được làm sạch"</a> (as .rds file). Nhập số liệu bằng hàm `import()` từ package **rio** package (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).  


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





## Các kiểm định trong **base** R {}

Các lệnh trong **base** R functions to conduct statistical tests. có thể được sử dụng để thực hiện các kiểm định thống kê. Các câu lệnh tương đối đơn giản và kết quả sẽ hiển thị trong bảng điều khiển R Console. Tuy nhiên, kết quả đầu ra thường dưới dạng liệt kê, vì thế sẽ khó thao tác hơn nếu muốn sử dụng kết quả trong các thao tác tiếp theo. 

### Kiểm định t {.unnumbered} 

Một [kiểm định t](https://en.wikipedia.org/wiki/Student%27s_t-test), hay còn được gọi là "Student's t-Test", thường được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của hai nhóm. Bên dưới là cú pháp để thực hiện kiểm định này tùy thuộc vào các cột có trong cùng một data frame hay không.

**Cú pháp 1:** Đây là cú pháp khi cột của biến liên tục và phân loại nằm trong cùng một data frame. Đặt biến liên tục bên trái và biến phân loại bên phải của phương trình. Ghi rõ bộ số liệu sau `data = `. Các tùy chọn khác như số liệu bắt cặp, viết thêm `paired = TRUE`,  khoảng tin cậy, viết thêm `conf.level = ` (mặc định là 0.95), và giả thuyết thay thế `alternative = ` (hai đuôi - “two.sided”, hoặc một đuôi nhỏ hơn hay lớn hơn - “less”, or “greater”). Gõ `?t.test` để biết thêm chi tiết.  

```{r}
## compare mean age by outcome group with a t-test
t.test(age_years ~ gender, data = linelist)
```

**Cú pháp 2:** Đây là cú pháp khi so sánh hai véc tơ dạng số. Ví dụ như hai cột nằm trong hai bộ số liệu khác nhau.  

```{r, eval=F}
t.test(df1$age_years, df2$age_years)
```

Kiểm định t cũng được sử dụng để xác định có sự khác biệt có ý nghĩa thống kê giữa giá trị trung bình của mẫu với một số giá trị cụ thể. Đây là phép kiểm định t cho một mẫu với trung bình quần thể giả thuyết/đã biết như `mu = `:  

```{r, eval=F}
t.test(linelist$age_years, mu = 45)
```

### Kiểm định Shapiro-Wilk {.unnumbered}  

[Kiểm định Shapiro-Wilk](https://en.wikipedia.org/wiki/Shapiro%E2%80%93Wilk_test) có thể được sử để xác định xem một mẫu có phân bố bình thường/phân bố chuản hay không (một giả định của nhiều kiểm định khác, ví dụ như kiểm định t). Tuy nhiên, phép kiểm định này chỉ có thể được sử dụng cho một mẫu có từ 3 đến 5000 quan sát. Đối với cỡ mẫu lớn hơn, nên sử dụng biểu đồ [quantile-quantile plot](https://ggplot2.tidyverse.org/reference/geom_qq.html). 


```{r, eval=F}
shapiro.test(linelist$age_years)
```

### Kiểm định tổng thứ hạng Wilcoxon {.unnumbered}

Kiểm định tổng thứ hạng Wilcoxon, hay còn gọi là [kiểm định Mann–Whitney U](https://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U_test), thường được sử dụng để giúp xác định xem hai mẫu có cùng phân bố hay không khi quần thể của chúng không có phân bố chuẩn hoặc có phương sai không bằng nhau.

```{r wilcox_base}

## compare age distribution by outcome group with a wilcox test
wilcox.test(age_years ~ outcome, data = linelist)

```


### Kiểm định Kruskal-Wallis {.unnumbered}


[Kiểm định Kruskal-Wallis](https://en.wikipedia.org/wiki/Kruskal%E2%80%93Wallis_one-way_analysis_of_variance) là một phần mở rộng của kiểm định tổng thứ hạng Wilcoxon mà có thể được sử dụng để kiểm định sự khác biệt trong phân bố của nhiều hơn hai mẫu. Khi có hai mẫu được sử dụng, nó cho kết quả giống như của kiểm định tổng thứ hạng Wilcoxon. 

```{r }

## compare age distribution by outcome group with a kruskal-wallis test
kruskal.test(age_years ~ outcome, linelist)

```

### Kiểm định Chi bình phương {.unnumbered} 

[Kiểm định Chi bình phương của Pearson](https://en.wikipedia.org/wiki/Chi-squared_test) được sử dụng trong kiểm tra sự khác biệt có ý nghĩa thống kê giữa các biến phân loại. 

```{r}

## compare the proportions in each group with a chi-squared test
chisq.test(linelist$gender, linelist$outcome)

```



## **rstatix** package {}

Package **rstatix** cho phép thực hiện các kiểm định thống kê và truy xuất kết quả "dễ sử dụng cho các tính toán tiếp theo". Có nghĩa là kết quả xuất tự động thành một data frame để có thể thực hiện các thao tác tiếp theo. Nó cũng dễ dàng để nhóm dữ liệu mà sẽ được chuyền vào các hàm, ở đó các thống kê được thực hiện cho từng nhóm.  


### Tóm tắt thống kê {.unnumbered}  

Hàm `get_summary_stats()` là một cách thực hiện tóm tắt thống kê nhanh. Chỉ cần đưa bộ số liệu và chỉ định các cột muốn phân tích vào hàm này. Nếu không có cột nào được cụ thể, tóm tắt thống kê sẽ tính toán cho tất cả các cột.  

Tóm tắt thống kê đầy đủ sẽ cho kết quả mặc định như sau: số quan sát (n), giá trị nhỏ nhất, giá trị lớn nhất, trung vị, giá trị tứ phân vị thứ nhất (25%), giá trị tứ phân vị thứ ba (75%), khoảng tứ phân vị, độ lệch tuyệt đối của trung vị (mad), trung bình, độ lệch chuẩn, sai số chuẩn và khoảng tin cậy của trung bình. 


```{r}
linelist %>%
  rstatix::get_summary_stats(age, temp)
```

Có thể tóm tắt một số giá trị thống kê bằng cách cung cấp một trong số các giá trị sau đến `type = `: "full", "common", "robust", "five_number", "mean_sd", "mean_se", "mean_ci", "median_iqr", "median_mad", "quantile", "mean", "median", "min", "max".  

Nó cũng có thể được sử dụng để nhóm số liệu, sao cho một hàng được trả về cho mỗi biến nhóm:  

```{r}
linelist %>%
  group_by(hospital) %>%
  rstatix::get_summary_stats(age, temp, type = "common")
```

Bạn cũng có thể sử dụng **rstatix** để thực hiện các kiểm định thống kê:  

### Kiểm định t {.unnumbered}  

USử dụng cú pháp để chỉ định cột biến liên tục và cột biến phân loại:  

```{r}
linelist %>% 
  t_test(age_years ~ gender)
```

Hoặc sử dụng `~ 1` và ghi rõ `mu = ` cho kiểm định t một mẫu. Cú pháp này có thể sử dụng để thực hiện cho nhóm.  

```{r}
linelist %>% 
  t_test(age_years ~ 1, mu = 30)
```

Nếu có thể, các kiểm định thống kê có thể thực hiện theo nhóm, như được trình bày bên dưới.  

```{r}
linelist %>% 
  group_by(gender) %>% 
  t_test(age_years ~ 1, mu = 18)
```

### Kiểm định Shapiro-Wilk {.unnumbered}  

Như đã đề cập bên trên, cỡ mẫu phải nằm trong khoảng từ 3 đến 5000.  

```{r}
linelist %>% 
  head(500) %>%            # first 500 rows of case linelist, for example only
  shapiro_test(age_years)
```

### Kiểm định tổng thứ hạng Wilcoxon {.unnumbered}  

```{r}
linelist %>% 
  wilcox_test(age_years ~ gender)
```


### Kiểm định Kruskal-Wallis {.unnumbered}  

Cũng được biết như kiểm định Mann-Whitney U.  

```{r}
linelist %>% 
  kruskal_test(age_years ~ outcome)
```


### Kiểm định Chi bình phương {.unnumbered}  

Hàm kiểm định Chi bình phương chấp nhận một bảng, vì vậy đầu tiên là tạo một bảng chéo. Có nhiều cách để tạo một bảng chéo (xem chương [Bảng mô tả]) nhưng ở đây chúng ta sử dụng hàm `tabyl()` từ **janitor** avà bỏ cột ngoài cùng bên trái của nhãn giá trị trước khi đưa vào hàm `chisq_test()`.  

```{r}
linelist %>% 
  tabyl(gender, outcome) %>% 
  select(-1) %>% 
  chisq_test()

```

Có rất nhiều hàm và kiểm định thống kê có thể được thực hiện bằng các hàm trong package **rstatix**. Đọc các tài liệu về **rstatix** [online ở đây](https://github.com/kassambara/rstatix) hoặc gõ ?rstatix.  





## `gtsummary` package {#stats_gt}

Sử dụng package **gtsummary** nếu bạn đang muốn thêm kết quả của một kiểm định thống kê vào một bảng đẹp được tạo ra bằng package này (như đã được mô tả trong phần **gtsummary** của chương [Bảng mô tả](#tbl_gt)).  

Khi thực hiện các kiểm định so sánh bằng hàm `tbl_summary`, dùng thêm hàm `add_p` để đưa cột giá trị p và kiểm định được sử dụng vào bảng. Có thể xuất nhiều giá trị p mà được hiệu chỉnh cho nhiều kiểm định bằng cách dùng thêm hàm `add_q`. Gõ lệnh `?tbl_summary` để biết thêm chi tiết.  

### Kiểm định Chi bình phương {.unnumbered}

Được sử dụng để so sánh các tỷ lệ của một biến phân loại trong hai nhóm. Kiểm định thống kê mặc định cho biến phân loại trong hàm `add_p()` là kiểm định Chi bình phương về tính độc lập với hiệu chỉnh liên tục, nhưng nếu có bất kỳ giá trị kỳ vọng nào nhỏ hơn 5 thì kiểm định chính xác của Fisher sẽ được sử dụng. 

```{r chi_gt}
linelist %>% 
  select(gender, outcome) %>%    # keep variables of interest
  tbl_summary(by = outcome) %>%  # produce summary table and specify grouping variable
  add_p()                        # specify what test to perform
```


### Kiểm định t {.unnumbered} 

Được sử dụng để so sánh sự khác biệt về trung bình của một biến trung bình trong hai nhóm. Ví dụ như so sánh tuổi trung bình với kết cục của bệnh nhân. 
```{r ttest_gt}

linelist %>% 
  select(age_years, outcome) %>%             # keep variables of interest
  tbl_summary(                               # produce summary table
    statistic = age_years ~ "{mean} ({sd})", # specify what statistics to show
    by = outcome) %>%                        # specify the grouping variable
  add_p(age_years ~ "t.test")                # specify what tests to perform


```

### Kiểm định tổng thứ hạng Wilcoxon {.unnumbered}

Được dùng để so sánh sự phân bố của một biến liên tục trong hai nhóm. Kiểm định mặc định là kiểm định tổng thứ hang Wilcoxon và trung vị (khoảng tứ phân vị IQR) khi so sánh hai nhóm. Tuy nhiên, đối với số liệu không có phân bố chuẩn hoặc so sánh nhiều nhóm, kiểm định Kruskal-wallis là kiểm định thích hợp hơn. 

```{r wilcox_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (this is default so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "wilcox.test")                     # specify what test to perform (default so could leave brackets empty)


```

### Kiểm định Kruskal-wallis {.unnumbered}

Được sử dụng để so sánh sự phân bố của một biến liên tục trong hai hay nhiều nhóm, bất kể số liệu có phân bố chuẩn hay không. 

```{r kruskal_gt}

linelist %>% 
  select(age_years, outcome) %>%                       # keep variables of interest
  tbl_summary(                                         # produce summary table
    statistic = age_years ~ "{median} ({p25}, {p75})", # specify what statistic to show (default, so could remove)
    by = outcome) %>%                                  # specify the grouping variable
  add_p(age_years ~ "kruskal.test")                    # specify what test to perform


```




<!-- ## `dplyr` package {} -->

<!-- Performing statistical tests in `dplyr` alone is very dense, again because it  -->
<!-- does not fit within the tidy-data framework. It requires using `purrr` to create -->
<!-- a list of dataframes for each of the subgroups you want to compare. See the page on [Iteration, loops, and lists] to learn about **purrr**.   -->

<!-- An easier alternative may be the `rstatix` package.  -->

<!-- ### T-tests {.unnumbered}  -->

<!-- ```{r ttest_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the mean age for the death group -->
<!--     Death_mean = map(Death, ~mean(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_sd = map(Death, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the mean age for the recover group -->
<!--     Recover_mean = map(Recover, ~mean(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_sd = map(Recover, ~sd(.x$age, na.rm = TRUE)), -->
<!--     ## using both grouped data sets compare mean age with a t-test -->
<!--     ## keep only the p.value -->
<!--     t_test = map2(Death, Recover, ~t.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->


<!-- ### Wilcoxon rank sum test {.unnumbered} -->

<!-- ```{r wilcox_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the median age for the death group -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## calculate the median age for the recover group -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## using both grouped data sets compare age distribution with a wilcox test -->
<!--     ## keep only the p.value -->
<!--     wilcox = map2(Death, Recover, ~wilcox.test(.x$age, .y$age)$p.value) -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Kruskal-wallis test {.unnumbered} -->


<!-- ```{r kruskal_dplyr} -->

<!-- linelist %>%  -->
<!--   ## only keep variables of interest -->
<!--   select(age, outcome) %>%  -->
<!--   ## drop those missing outcome  -->
<!--   filter(!is.na(outcome)) %>%  -->
<!--   ## specify the grouping variable -->
<!--   group_by(outcome) %>%  -->
<!--   ## create a subset of data for each group (as a list) -->
<!--   nest() %>%  -->
<!--   ## spread in to wide format -->
<!--   pivot_wider(names_from = outcome, values_from = data) %>%  -->
<!--   mutate( -->
<!--     ## calculate the median age for the death group -->
<!--     Death_median = map(Death, ~median(.x$age, na.rm = TRUE)), -->
<!--     ## calculate the sd among dead  -->
<!--     Death_iqr = map(Death, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## calculate the median age for the recover group -->
<!--     Recover_median = map(Recover, ~median(.x$age, na.rm = TRUE)),  -->
<!--     ## calculate the sd among recovered  -->
<!--     Recover_iqr = map(Recover, ~str_c( -->
<!--       quantile(.x$age, probs = c(0.25, 0.75), na.rm = TRUE),  -->
<!--       collapse = ", " -->
<!--       )), -->
<!--     ## using the original data set compare age distribution with a kruskal test -->
<!--     ## keep only the p.value -->
<!--     kruskal = kruskal.test(linelist$age, linelist$outcome)$p.value -->
<!--   ) %>%  -->
<!--   ## drop datasets  -->
<!--   select(-Death, -Recover) %>%  -->
<!--   ## return a dataset with the medians and p.value (drop missing) -->
<!--   unnest(cols = everything()) -->

<!-- ``` -->

<!-- ### Chi-squared test {.unnumbered}  -->


<!-- ```{r} -->
<!-- linelist %>%  -->
<!--   ## do everything by gender  -->
<!--   group_by(outcome) %>%  -->
<!--   ## count the variable of interest -->
<!--   count(gender) %>%  -->
<!--   ## calculate proportion  -->
<!--   ## note that the denominator here is the sum of each gender -->
<!--   mutate(percentage = n / sum(n) * 100) %>%  -->
<!--   pivot_wider(names_from = outcome, values_from = c(n, percentage)) %>%  -->
<!--   filter(!is.na(gender)) %>%  -->
<!--   mutate(pval = chisq.test(linelist$gender, linelist$outcome)$p.value) -->
<!-- ``` -->


<!-- ======================================================= -->

## Tương quan 

Mối tương quan giữa các biến định lượng có thể được kiển bằng cách sử dụng lệnh **corrr** từ package **tidyverse**. Lệnh này cũng cho phép tính các hệ số tương quan bằng phương pháp Pearson, Kendall hoặc Spearman. Gói lệnh này tạo ra một bảng kết quả và cũng có chức năng tự động vẽ các giá trị. 

```{r, warning=F, message=F}

correlation_tab <- linelist %>% 
  select(generation, age, ct_blood, days_onset_hosp, wt_kg, ht_cm) %>%   # keep numeric variables of interest
  correlate()      # create correlation table (using default pearson)

correlation_tab    # print

## remove duplicate entries (the table above is mirrored) 
correlation_tab <- correlation_tab %>% 
  shave()

## view correlation table 
correlation_tab

## plot correlations 
rplot(correlation_tab)
```


<!-- ======================================================= -->

## Nguồn {  }

Phần lớn thông tin trong phần này được phỏng theo các nguồn sau:  

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_summary.html)
[dplyr](https://dplyr.tidyverse.org/articles/grouping.html)
[corrr](https://corrr.tidymodels.org/articles/using-corrr.html)
[sthda correlation](http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/stat_tests.Rmd-->

# Hồi quy đơn và đa biến {#regression}

<!-- ======================================================= -->

Trong chương này, chúng tôi trình bày cách sử dụng các hàm hồi quy trong **base** R rnhư hàm `glm()` và package **gtsummary** để xem xét các mối liên quan giữa các biến (ví dụ như tỷ số chênh, tỷ số nguy cơ, tỷ số rủi ro). Chúng tôi cũng trình bày cách sử dụng các hàm như `tidy()` trong package **broom** để sắp xếp các kết quả hồi quy.

1.  Phân tích đơn biến: bảng 2 x 2
2.  Phân tích phân tầng: ước lượng của mantel-haenszel\
3.  Phân tích đa biến: lựa chọn biến số, lựa chọn mô hình, mô hình cuối cùng
4.  Biểu đồ Forest plot

Đối với hồi quy Cox, xem chương [Phân tích sống còn].

[***CHÚ Ý:*** Chúng tôi sử dụng thuật ngữ *đa biến (multivariable)* để nói đến một hồi quy có nhiều biến giải thích. Thuật ngữ này khác với mô hình *đa biến* (multivariate model), là một mô hình đa biến có nhiều biến kết cục -- xem chi tiết trong [bài xã luận](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3518362/) này ]{style="color: black;"}

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đoạn mã này hiển thị cách tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh hàm `p_load()` thuộc package **pacman**, giúp cài đặt package khi cần thiết *và* gọi nó ra để sử dụng. Có thể gọi các package đã cài đặt bằng hàm `library()` trong **base** R. Xem thêm thông tin về các package của R trong chương [R cơ bản].

```{r}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  tidyverse,    # data management + ggplot2 graphics, 
  stringr,      # manipulate text strings 
  purrr,        # loop over objects in a tidy way
  gtsummary,    # summary statistics and tests 
  broom,        # tidy up results from regressions
  lmtest,       # likelihood-ratio tests
  parameters,   # alternative to tidy up results from regressions
  see          # alternative to visualise forest plots
  )
```

### Nhập số liệu {.unnumbered}

Chúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải số liệu linelist "đã được làm sạch"</a> (dưới dạng tệp .rds ). Nhập số liệu này bằng hàm `import()` trong package **rio** (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv -- xem chi tiết trong chương [Nhập xuất dữ liệu]).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

Bên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T) )
```

### Làm sạch số liệu {.unnumbered}

#### Lưu trữ các biến giải thích {.unnumbered}

Tên của các biến giải thích sẽ được lưu trữ dưới dạng một véc tơ ký tự. Véc tơ này sẽ được đề cập về sau.

```{r}
## define variables of interest 
explanatory_vars <- c("gender", "fever", "chills", "cough", "aches", "vomit")
```

#### Chuyển đổi sang số 1 và số 0 {.unnumbered}

Sau đây, giá trị của các biến giải thích được chuyển đổi từ "có"/"không", "nam"/"nữ" và "chết"/"sống" thành 1 / 0, để hợp với các đặc tính của mô hình hồi quy logistic. TĐể thực hiện việc này một cách hiệu quả, sử dụng hàm `across()` từ **dplyr** để chuyển đổi nhiều biến cùng một lúc. Để áp dụng cho mỗi biến, dùng hàm `case_when()` (cũng trong package **dplyr**) để chuyển đổi các giá trị cụ thể thành 1 và 0. Xem các mục về `across()` và `case_when()` trong chương [Làm sạch số liệu và các hàm quan trọng](#clean_across)).

Chú ý: dấu "." bên dưới đại diện cho cột\`\`\`\`\``đang được xử lý trong hàm`across()\` tại thời điểm đó.

```{r}
## convert dichotomous variables to 0/1 
linelist <- linelist %>%  
  mutate(across(                                      
    .cols = all_of(c(explanatory_vars, "outcome")),  ## for each column listed and "outcome"
    .fns = ~case_when(                              
      . %in% c("m", "yes", "Death")   ~ 1,           ## recode male, yes and death to 1
      . %in% c("f", "no",  "Recover") ~ 0,           ## female, no and recover to 0
      TRUE                            ~ NA_real_)    ## otherwise set to missing
    )
  )

       
      
```

#### Loại bỏ các hàng có giá trị missing {.unnumbered}

Để bỏ các hàng có giá trị missing, dùng hàm `drop_na()` trong package **tidyr**. Tuy nhiên, chúng ta chỉ muốn thực hiện điều này cho các hàng có giá trị missing đối với các cột đang được quan tâm.

Trước hết, chúng ta phải đảm bảo rằng vectơ `explanatory_vars` bao gồm các biến `age` (`age` có thể tạo ra một lỗi trong thao tác của hàm `case_when()` trước đó, mà chỉ dành cho biến nhị phân). Sau đó chúng ta pipe bộ dữ liệu `linelist` tới hàm `drop_na()` để bỏ các hàng có giá trị missing cho biến `outcome` hoặc bất kỳ biển giải thích `explanatory_vars` nào.

Trước khi thực hiện các lệnh này, kiểm tra số hàng trong bộ số liệu `linelist` bằng hàm `nrow(linelist)`.

```{r}
## add in age_category to the explanatory vars 
explanatory_vars <- c(explanatory_vars, "age_cat")

## drop rows with missing information for variables of interest 
linelist <- linelist %>% 
  drop_na(any_of(c("outcome", explanatory_vars)))

```

Kiểm tra số hàng còn lại của `linelist` bằng hàm `nrow(linelist)`.

<!-- ======================================================= -->

## Phân tích đơn biến

Cũng giống như chương [Bảng mô tả](#tables-descriptive), chúng ta cần xác định packahe nào trong R mà chúng ta muốn sử dụng. Chúng tôi trình bày hai chọn lựa để thực hiện các phân tích đơn biến:

-   Dùng hàm có sẵn trong **base** để in nhanh kết quả ra console. Sử dụng package **broom** để làm gọn kết quả.\
-   Dùng package **gtsummary** để lập mô hình và nhận các kết quả đầu ra sẵn sàng để công bố

<!-- ======================================================= -->

### **base** R {.unnumbered}

#### Hồi quy tuyến tính {.unnumbered}

Hàm `lm()` trong **base** cho phép thực hiện hồi quy tuyến tính để đánh giá mối quan hệ giữa biến đầu ra dạng số (numeric) và các biến giải thích mà được giả định là có mối quan hệ tuyến tính.

Cung cấp phương trình dưới dạng công thức với tên của biến đầu ra và các biến giải thích được phân tách bằng dấu ngã `~`. Bên cạnh đó, chỉ rõ bộ số liệu nào được sử dụng với `data =`. Kết quả của mô hình được định nghĩa dưới dạng đối tượng của R để sử dụng về sau.

```{r lin_reg}
lm_results <- lm(ht_cm ~ age, data = linelist)
```

Sau đó tóm tắt kết quả của mô hình bằng hàm `summary()` để xem các hệ số (ước tính), P-value, phần dư và các đo lường khác.

```{r lin_reg_res}
summary(lm_results)
```

Ngoài ra, có thể dùng hàm `tidy()` trong package **broom** để xuất kết quả vào trong một bảng. Kết quả bên dưới cho chúng ta biết khi tăng thêm một tuổi thì chiều cao tăng 3,5 cm và mối quan hệ này có ý nghĩa thống kê.

```{r lin_reg_res_tidy}
tidy(lm_results)
```

Sau đó, có thể sử dụng kết quả hồi quy này để đưa vào **ggplot**. Để thực hiện điều này, trước tiên chúng ta đưa các giá trị quan sát và đường thẳng hồi quy (fitted line) vào một data frame bằng cách dùng hàm `augment()` trong package **broom**.

```{r lin_reg_res_plot}

## pull the regression points and observed data in to one dataset
points <- augment(lm_results)

## plot the data using age as the x-axis 
ggplot(points, aes(x = age)) + 
  ## add points for height 
  geom_point(aes(y = ht_cm)) + 
  ## add your regression line 
  geom_line(aes(y = .fitted), colour = "red")

```

Bạn cũng có thể vẽ đường hồi quy tuyến tính đơn bằng package **ggplot** thông qua hàm `geom_smooth()`.

```{r geom_smooth}

## add your data to a plot 
 ggplot(linelist, aes(x = age, y = ht_cm)) + 
  ## show points
  geom_point() + 
  ## add a linear regression 
  geom_smooth(method = "lm", se = FALSE)
```

Xem thêm các hướng dẫn chi tiết trong mục Nguồn ở cuối chương này.

#### Hồi quy Logistic {.unnumbered}

Hàm `glm()` trong package **stats** (một phần của **base** R) được sử dụng để fit (chọn mô hình dự đoán tối ưu dựa trên số liệu quan sát) đối với Mô hình Tuyến tính Tổng quát (GLM).

`glm()` có thể được sử dụng cho cả hồi quy logistic đơn biến và đa biến (ví dụ như để tính tỷ số chênh OR). Sau đây là những thành phần chính của hàm:

```{r, eval=F}
# arguments for glm()
glm(formula, family, data, weights, subset, ...)
```

-   `formula =` Mô hình được cung cấp cho `glm()` dưới dạng một phương trình với biến kết cục ở bên trái và biến giải thích ở bên phải dấu ngã `~`.\
-   `family =` Xác định loại mô hình sẽ thực hiện. Đối với hồi quy logistic, sử dụng `family = "binomial"`, đối với hồi quy poisson sử dụng `family = "poisson"`. Các ví dụ khác được trình bày trong bảng bên dưới.\
-   `data =` Cụ thể bộ số liệu

Nếu cần, có thể cụ thể hàm liên kết bằng cú pháp `family = familytype(link = "linkfunction"))`. Bạn có thể tìm đọc thêm về các họ hồi quy khác và các tùy chọn đối số như là `weights =` và `subset =` bằng cách gõ (`?glm`).

| Họ                   | Hàm liên kết mặc định                        |
|----------------------|----------------------------------------------|
| `"binomial"`         | `(link = "logit")`                           |
| `"gaussian"`         | `(link = "identity")`                        |
| `"Gamma"`            | `(link = "inverse")`                         |
| `"inverse.gaussian"` | `(link = "1/mu^2")`                          |
| `"poisson"`          | `(link = "log")`                             |
| `"quasi"`            | `(link = "identity", variance = "constant")` |
| `"quasibinomial"`    | `(link = "logit")`                           |
| `"quasipoisson"`     | `(link = "log")`                             |

Khi thực hiện `glm()` , phổ biến nhất là lưu kết quả dưới dạng một đối tượng của R được đặt tên. Sau đó, có thể xuất kết quả ra console bằng cách sử dụng hàm `summary()` như được trình bày bên dưới, hoặc thực hiện các thao tác khác từ kết quả (ví dụ như lấy lũy thừa).

Nếu cần thực hiện một hồi quy nhị thức âm, có thể sử dụng package **MASS**. Hàn `glm.nb()` uses cũng sử dụng cùng cú pháp như `glm()`. Để xem qua các hồi quy khác, xem trên [trang thống kê của UCLA](https://stats.idre.ucla.edu/other/dae/).

#### Phân tích đơn biến sử dụng `glm()` {.unnumbered}

Trong ví dụ này, chúng tôi đánh giá mối liên quan giữa nhóm tuổi và biến kết cục tử vong (được mã hóa là 1 trong phần chuẩn bị). Bên dưới là một mô hình đơn biến của biến kết cục `outcome` theo `age_cat`. Chúng tôi lưu kết quả đầu ra được đặt tên là `model` và sau đó in kết quả đến console bằng hàm `summary()`. Lưu ý, các ước tính được tạo ra là các giá trị *lôgarít của tỷ số chênh (log odds)* và giá trị tham chiếu là giá trị đầu tiên của biến `age_cat` ("0-4").

```{r}
model <- glm(outcome ~ age_cat, family = "binomial", data = linelist)
summary(model)
```

Để thay đổi giá trị tham chiếu của một biến Factor và chuyển giá trị mong muốn lên vị trí đầu tiên, dùng hàm `fct_relevel()` (xem chương [Factors]). Ở ví dụ bên dưới, chúng tôi lấy biến `age_cat` và đặt nhóm tuổi "20-29" làm giá trị tham chiếu trước khi chuyển số liệu đã sửa đổi vào hàm `glm()`.

```{r}
linelist %>% 
  mutate(age_cat = fct_relevel(age_cat, "20-29", after = 0)) %>% 
  glm(formula = outcome ~ age_cat, family = "binomial") %>% 
  summary()
```

#### In kết quả {.unnumbered}

Đối với hầu hết các mục đích sử dụng, kết quả đầu ra cần phải có một số sửa đổi. Hàm làm gọn `tidy()` trong package **broom** có những tiện lợi để hiển thị kết quả của mô hình.

Ở đây, chúng tôi trình bày cách để kết hợp các kết quả đầu ra của mô hình vào trong một bảng.

1)  Lấy *lũy thừa* logarit của ước lượng tỉ số chênh OR và khoảng tin cậy  bằng cách đưa mô hình vào hàm `tidy()` và thiết lập lũy thừa `exponentiate = TRUE` và `conf.int = TRUE`.

```{r odds_base_single}

model <- glm(outcome ~ age_cat, family = "binomial", data = linelist) %>% 
  tidy(exponentiate = TRUE, conf.int = TRUE) %>%        # exponentiate and produce CIs
  mutate(across(where(is.numeric), round, digits = 2))  # round all numeric columns
```

Bên dưới là bảng kết quả đầu ra của `model`:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(model, rownames = FALSE, options = list(pageLength = nrow(model), scrollX=T), class = 'white-space: nowrap' )
```

2)  Kết hợp các kết quả của mô hình vào trong một bảng đếm. Dưới đây, chúng tôi tạo một bảng đếm bằng hàm `tabyl()` từ package **janitor**, như được đề cập trong chương [Bảng mô tả].

```{r}
counts_table <- linelist %>% 
  janitor::tabyl(age_cat, outcome)
```

<!-- * Group rows by outcome, and get counts by age category   -->

<!-- * Pivot wider so the column are `age_cat`, `0`, and `1`   -->

<!-- * Remove row for `NA` `age_cat`, if applicable, to align with the model results   -->

<!-- ```{r} -->

<!-- counts_table <- linelist %>%  -->

<!--   filter(!is.na(outcome) & !is.na(age_cat)) %>%    # ensure outcome and age_cat are present  -->

<!--   group_by(outcome) %>%                            # get counts of variable of interest grouped by outcome -->

<!--   count(age_cat) %>%   ## gets number or rows by unique outcome-age category combinations   -->

<!--   pivot_wider(names_from = outcome, values_from = n)    ## spread data to wide format (as in cross-tabulation) -->

<!-- ``` -->

Đây là cách mà bảng `counts_table` được hiển thị:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(counts_table, rownames = FALSE, options = list(pageLength = nrow(counts_table), scrollX=T), class = 'white-space: nowrap' )
```

Bây giờ chúng ta có thể nối bảng `counts_table` và kết quả của mô hình `model` lại với nhau theo chiều ngang bằng hàm nối cột `bind_cols()` (**dplyr**). Hãy nhớ rằng đối với hàm `bind_cols()` các hàng trong hai cấu trúc dữ liệu trên phải được căn chỉnh hoàn hảo. Trong đoạn code này, bởi vì chúng ta đang thực hiện một chuỗi các thuật toán pipe, chúng ta sử dụng dấu `.` để đại diện cho đối tượng được nối trong bảng đếm `counts_table` khi chúng tôi nối nó với kết quả mô hình `model`. Để kết thúc quy trình này, chúng ta sử dụng hàm `select()` để chọn các cột mong muốn và thứ tự của nó, và cuối cùng áp dụng hàm `round()` trong **base** R để làm tròn với hai chữ số thập phân cho tất cả các cột.

```{r, message=F, warning=F}
combined <- counts_table %>%           # begin with table of counts
  bind_cols(., model) %>%              # combine with the outputs of the regression 
  select(term, 2:3, estimate,          # select and re-order cols
         conf.low, conf.high, p.value) %>% 
  mutate(across(where(is.numeric), round, digits = 2)) ## round to 2 decimal places
```

Đây là hiển thị của cấu trúc đã được kết hợp, nó được xuất gọn gẽ dưới dạng một hình bằng thông qua một hàm trong package **flextable**. Chương [Trình bày bảng] giải thích cách tùy chỉnh các bảng như vậy bằng **flextable**, hoặc có thể sử dụng các gói lệnh khác như **knitr** hoặc **GT**.

```{r}
combined <- combined %>% 
  flextable::qflextable()
```

#### Vòng lặp cho nhiều mô hình đơn biến {.unnumbered}

Sau đây chúng tôi trình bày một phương pháp sử dụng `glm()` và `tidy()` để có một cách tiếp cận đơn giản hơn, xem thêm ở phần **gtsummary**.

Để thực hiện các mô hình cho một số biến giải thích và cho ra các tỷ số chênh trong phân tích đơn biến (nghĩa là không có kiểm soát lẫn nhau), chúng ta có thể sử dụng các cách tiếp cận dưới đây. Sử dụng hàm `str_c()` từ package **stringr** để tạo ra các công thức cho phân tích đơn biến (xem chương [Ký tự và chuỗi]), thực hiện hàm `glm()` cho mỗi công thức, chuyển mỗi kết quả đầu ra của `glm()` đến hàm `tidy()` và cuối cùng thu gọn lại tất các kết quả đầu ra của mô hình bằng hàm nối dòng `bind_rows()` từ **tidyr**. Phương pháp này sử dụng hàm `map()` từ package **purrr** để lặp - xem chương [Lặp, vòng lặp và danh sách] để biết thêm thông tin về công cụ này.

1)  Tạo một véctơ tên các cột của biến giải thích. Chúng ta đã tạo biến này `explanatory_vars` trong phần chuẩn bị của chương này.

2)  Sử dụng hàm `str_c()` để tạo các công thức chuỗi với biến kết cục `outcome` ở bên trái và tên một cột của véctơ `explanatory_vars` ở bên phải. Dấu chấm `.` trong hàm này thay thế cho tên cột trong véctơ `explanatory_vars`.

```{r}
explanatory_vars %>% str_c("outcome ~ ", .)
```

3)  Đưa các công thức chuỗi này vào hàm `map()` và đặt `~glm()` làm hàm áp dụng cho mỗi đầu vào. Bên trong hàm `glm()`, thiết lập công thức hồi quy `as.formula(.x)` trong đó `.x` sẽ được thay thế bằng các công thức chuỗi đã được tạo bên trên. Hàm `map()` sẽ lặp từng công thức chuỗi và thực hiện hồi quy cho từng công thức.

4)  Kết quả đầu ra của hàm `map()` đầu tiên sẽ được chuyển đến hàm `map()` thứ hai mà sử dụng hàm `tidy()` để làm gọn các kết quả đầu ra.

5)  Cuối cùng, kết quả đầu ra của hàm `map()` thứ hai (một danh sách các data frames đã được làm gọn) được tóm tắt bằng hàm nối dòng `bind_rows()`, kết quả cho ra một data frame với tất cả các kết quả đơn biến.

```{r odds_base_multiple}

models <- explanatory_vars %>%       # begin with variables of interest
  str_c("outcome ~ ", .) %>%         # combine each variable into formula ("outcome ~ variable of interest")
  
  # iterate through each univariate formula
  map(                               
    .f = ~glm(                       # pass the formulas one-by-one to glm()
      formula = as.formula(.x),      # within glm(), the string formula is .x
      family = "binomial",           # specify type of glm (logistic)
      data = linelist)) %>%          # dataset
  
  # tidy up each of the glm regression outputs from above
  map(
    .f = ~tidy(
      .x, 
      exponentiate = TRUE,           # exponentiate 
      conf.int = TRUE)) %>%          # return confidence intervals
  
  # collapse the list of regression outputs in to one data frame
  bind_rows() %>% 
  
  # round all numeric columns
  mutate(across(where(is.numeric), round, digits = 2))
```

Lúc này, kết quả xuất ra của `models` dài hơn bởi vì kết quả bây giờ bao gồm các kết quả đầu ra của một số hồi quy đơn biến.  Nhấp nút tiếp theo để xem tất cả các hàng của `model`.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(models, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Như lúc trước, chúng ta có thể tạo một bảng đếm từ bộ số liệu `linelist` cho mỗi biến giải thích, gắn chúng với `models`, và tạo ra một bảng đẹp. Chúng ta bắt đầu với các biến giải thích này, và lặp lại các biến này thông qua hàm `map()`. Chúng ta lặp lại qua một hàm do người dùng tạo ra mà liên quan đến việc tạo ra một bảng đếm bằng cách dùng các hàm trong package **dplyr** Sau đó, kết quả được kết nối trình tự với kết quả của mô hình `models`.

```{r, warning=F, message=F}

## for each explanatory variable
univ_tab_base <- explanatory_vars %>% 
  map(.f = 
    ~{linelist %>%                ## begin with linelist
        group_by(outcome) %>%     ## group data set by outcome
        count(.data[[.x]]) %>%    ## produce counts for variable of interest
        pivot_wider(              ## spread to wide format (as in cross-tabulation)
          names_from = outcome,
          values_from = n) %>% 
        drop_na(.data[[.x]]) %>%         ## drop rows with missings
        rename("variable" = .x) %>%      ## change variable of interest column to "variable"
        mutate(variable = as.character(variable))} ## convert to character, else non-dichotomous (categorical) variables come out as factor and cant be merged
      ) %>% 
  
  ## collapse the list of count outputs in to one data frame
  bind_rows() %>% 
  
  ## merge with the outputs of the regression 
  bind_cols(., models) %>% 
  
  ## only keep columns interested in 
  select(term, 2:3, estimate, conf.low, conf.high, p.value) %>% 
  
  ## round decimal places
  mutate(across(where(is.numeric), round, digits = 2))

```

Bên dưới là cấu trúc số liệu kết nối được tạo ra. Xem chương [Trình bày bảng] để có thêm ý tưởng về cách chuyển đổi bảng số liệu này thành một bảng đẹp trên HTML (ví dụ như với package **flextable**).

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(univ_tab_base, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### **gtsummary** package {#reg_gt_uni .unnumbered}

Sau đây chúng tôi sẽ trình bày cách sử dụng hàm `tbl_uvregression()` từ package **gtsummary**. Cũng giống như trong chương [Bảng mô tả](https://epirhandbook.com/descriptive-tables.html), các hàm trong **gtsummary** thực hiện tốt các thống kê *và* xuất ra các kết quả khá chuyên nghiệp. Hàm này xuất ra một bảng kết quả của hồi quy đơn biến.

Chúng ta chỉ chọn các cột cần thiết từ bộ số liệu `linelist` (ecác biến giải thích và biến kết cục) và pipe chúng vào hàm `tbl_uvregression()`. Chúng ta sẽ thực hiện hồi quy đơn biến cho mỗi cột như được xác định trong véctơ `explanatory_vars` trong mục Chuẩn bị (gender, fever, chills, cough, aches, vomit, và age_cat).

Trong hàm này, chúng ta cung cấp thêm phương pháp thực hiện `method =` là `glm` (không có dấu ngoặc kép), biến kết cục `y =` cột kết quả (biến `outcome`), cụ thể `method.args =` mà chúng ta muốn thực hiện hồi quy logistic qua `family = binomial`, và lấy lũy thừa của kết quả.

Kết quả đầu ra dưới dạng HTML và chứa cột đếm

```{r odds_gt, message=F, warning=F}

univ_tab <- linelist %>% 
  dplyr::select(explanatory_vars, outcome) %>% ## select variables of interest

  tbl_uvregression(                         ## produce univariate table
    method = glm,                           ## define regression want to run (generalised linear model)
    y = outcome,                            ## define outcome variable
    method.args = list(family = binomial),  ## define what type of glm want to run (logistic)
    exponentiate = TRUE                     ## exponentiate to produce odds ratios (rather than log odds)
  )

## view univariate results table 
univ_tab
```

Chúng ta có thể sửa đổi đối với kết quả đầu ra của bảng này, ví dụ như điều chỉnh các nhãn, tô đậm các hàng theo giá trị p, .v.v. Xem hướng dẫn [tại đây](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html) và các tài liệu trực tuyến khác.

<!-- ======================================================= -->

## Phân tích phân tầng

Hiện tại, phân tích phần tầng sử dụng package **gtsummary** đang được xây dựng, phần này sẽ được cập nhật trong thời gian thích hợp.

## Phân tích đa biến

Đối với phân tích đa biến, chúng tôi trình bày hai cách tiếp cận:

-   `glm()` và `tidy()`\
-   Package **gtsummary** 

Quy trình thực hiện khá tương tự và chỉ khác ở bước cuối cùng để kết nối kết quả lại với nhau.

### Thực hiện phân tích đa biến {.unnumbered}

Ở đây chúng tôi sử dụng hàm `glm()` nhưng thêm nhiều biến hơn vào bên phải của phương trình và được phân tách với nhau bằng dấu cộng (`+`).

Để thực hiện mô hình với tất cả các biến giải thích, chúng ta thực hiện lệnh sau:

```{r}
mv_reg <- glm(outcome ~ gender + fever + chills + cough + aches + vomit + age_cat, family = "binomial", data = linelist)

summary(mv_reg)
```

Nếu muốn bao gồm hai biến và tương tác của hai biến này, chúng ta có thể phân tách chúng bằng dấu hoa thị `*` thay cho dấu `+`. Nếu chúng ta chỉ muốn cụ thể sự tương tác, phân tách chúng bằng dấu hai chấm `:`. Ví dụ:

```{r, eval=F}
glm(outcome ~ gender + age_cat * fever, family = "binomial", data = linelist)
```

*Một tùy chọn khác*, chúng ta có thể sử dụng đoạn mã này để sử dụng một véc tơ đã được định nghĩa trước của các cột và tạo lại lệnh trên bằng cách sử dụng hàm `str_c()`. Điều này có thể hữu ích nếu chúng ta thay đổi tên các biến giải thích, hoặc bạn không muốn gõ lại tất cả mọi thứ.

```{r mv_regression}

## run a regression with all variables of interest 
mv_reg <- explanatory_vars %>%  ## begin with vector of explanatory column names
  str_c(collapse = "+") %>%     ## combine all names of the variables of interest separated by a plus
  str_c("outcome ~ ", .) %>%    ## combine the names of variables of interest with outcome in formula style
  glm(family = "binomial",      ## define type of glm as logistic,
      data = linelist)          ## define your dataset
```

#### Xây dựng mô hình {.unnumbered}

Chúng ta có thể xây dựng mô hình theo từng bước, lưu các mô hình khác nhau với một số biến giải thích. Chúng ta có thể sử dụng kiểm định tỷ số khả dĩ (likelihood-ratio tests) để so sánh các mô hình này bằng cách sử dụng hàm `lrtest()` từ package **lmtest**, như dưới đây:

[***CHÚ Ý:*** Sử dụng hàn `anova(model1, model2, test = "Chisq)` trong **base** R cũng cho kết quả tương tự ]{style="color: black;"}

```{r}
model1 <- glm(outcome ~ age_cat, family = "binomial", data = linelist)
model2 <- glm(outcome ~ age_cat + gender, family = "binomial", data = linelist)

lmtest::lrtest(model1, model2)
```

Một tùy chọn khác là lấy đối tượng của mô hình và sử dụng hàm `step()` từ package **stats**. Chỉ rõ hướng lựa chọn biến mà chúng ta muốn sử dụng khi xây dựng mô hình.

```{r}
## choose a model using forward selection based on AIC
## you can also do "backward" or "both" by adjusting the direction
final_mv_reg <- mv_reg %>%
  step(direction = "forward", trace = FALSE)
```

Để hiển thị rõ số, chúng ta có thể tắt ký hiệu khoa học trong R bằng lệnh sau

```{r}
options(scipen=999)
```

Như được mô tả trong phần phân tích đơn biến, chuyển kết quả đầu ra của mô hình vào hàm `tidy()` để lấy lũy thừa cho các hệ số và khoảng tin cậy (CIs). Cuối cùng, làm tròn tất cả các cột số với hai số thập phân. Kéo qua để xem tất cả các hàng.

```{r mv_regression_base}

mv_tab_base <- final_mv_reg %>% 
  broom::tidy(exponentiate = TRUE, conf.int = TRUE) %>%  ## get a tidy dataframe of estimates 
  mutate(across(where(is.numeric), round, digits = 2))          ## round 
```

Đây là hiển thị kết quả dưới dạng data frame looks:

```{r, message=FALSE, echo=F}
DT::datatable(mv_tab_base, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

### Gộp kết quả phân tích đơn biến và đa biến {.unnumbered}

#### Gộp bằng package **gtsummary** {.unnumbered}

Hàm `tbl_regression()` trong package **gtsummary** sẽ lấy kết quả đầu tra từ một hồi quy (hàm `glm()` trong trường hợp này) và tạo ra một bảng tóm tắt đẹp.

```{r mv_regression_gt}
## show results table of final regression 
mv_tab <- tbl_regression(final_mv_reg, exponentiate = TRUE)
```

Hãy xem bảng sau:

```{r}
mv_tab
```

Chúng ta cũng có thể kết hợp một số bảng kết quả đầu ra bằng cách dùng hàm `tbl_merge()` trong package **gtsummary**. Bây giờ chúng ta hộp các kết quả đa biến với kết quả *đơn biến* đã được tạo [bên trên](#reg_gt_uni) bằng package **gtsummary**:

```{r}
## combine with univariate results 
tbl_merge(
  tbls = list(univ_tab, mv_tab),                          # combine
  tab_spanner = c("**Univariate**", "**Multivariable**")) # set header names
```

#### Gộp bằng package **dplyr** {.unnumbered}

Một cách khác để gộp các kết quả đơn biến và đa biến từ các hàm `glm()`/`tidy()` bằng cách sử dụng các hàm kết nối từ package **dplyr**.

-   Kết nối kết quả đơn biến trước đó (`univ_tab_base`, chứa được các cột đếm) với kết quả đa biến đã được làm gọn `mv_tab_base`\
-   Sử dụng hàm `select()` để giữ lại, sắp xếp lại thứ tự và đặt lại tên các cột mà chúng ta muốn\
-   Sử dụng hàm `round()` để làm tròn tất cả các cột với hai số thập phân

```{r, warning=F, message=F}
## combine univariate and multivariable tables 
left_join(univ_tab_base, mv_tab_base, by = "term") %>% 
  ## choose columns and rename them
  select( # new name =  old name
    "characteristic" = term, 
    "recovered"      = "0", 
    "dead"           = "1", 
    "univ_or"        = estimate.x, 
    "univ_ci_low"    = conf.low.x, 
    "univ_ci_high"   = conf.high.x,
    "univ_pval"      = p.value.x, 
    "mv_or"          = estimate.y, 
    "mvv_ci_low"     = conf.low.y, 
    "mv_ci_high"     = conf.high.y,
    "mv_pval"        = p.value.y 
  ) %>% 
  mutate(across(where(is.double), round, 2))   

```

<!-- ======================================================= -->

## Biểu đồ Forest plot

Phần này hướng dẫn cách tạo ra một biểu đồ của các kết quả hồi quy. Có hai lựa chọn để tạo biểu đồ, chúng ta có thể tự tạo một biểu đồ bằng cách sử dụng package **ggplot2** hoặc sử dụng một meta-package có tên **easystats** (một package gồm nhiều package).

Nếu chưa quen thuộc với gói lệnh tạo biểu đồ **ggplot2**, xem thêm chương [ggplot cơ bản].

<!-- ======================================================= -->

### **ggplot2** package {.unnumbered}

Bạn có thể xây dựng một forest plot với hàm `ggplot()` bằng cách vẽ các thành phần của kết quả hồi quy đa biến. Thêm các lớp của biều đồ bằng cách sử dụng các "geoms":

-   Các ước lượng bằng hàm `geom_point()`\
-   Khoảng tin cậy bằng hàm `geom_errorbar()`\
-   Đường thẳng đứng ở vị trí OR = 1 bằng hàm `geom_vline()`

Trước khi tạo biểu đồ, chúng ta sử dụng hàm `fct_relevel()` từ package **forcats** để đặt thứ tự các biến trên trục y. Hàm `ggplot()` cho phép hiển thị theo thứ tự chữ-số mà có thể không hiển thị tốt cho các giá trị của biến tuổi (“30” có thể hiển thị trước “5”). Xem chương [Factors] để biết thêm chi tiết.

```{r ggplot_forest}

## remove the intercept term from your multivariable results
mv_tab_base %>% 
  
  #set order of levels to appear along y-axis
  mutate(term = fct_relevel(
    term,
    "vomit", "gender", "fever", "cough", "chills", "aches",
    "age_cat5-9", "age_cat10-14", "age_cat15-19", "age_cat20-29",
    "age_cat30-49", "age_cat50-69", "age_cat70+")) %>%
  
  # remove "intercept" row from plot
  filter(term != "(Intercept)") %>% 
  
  ## plot with variable on the y axis and estimate (OR) on the x axis
  ggplot(aes(x = estimate, y = term)) +
  
  ## show the estimate as a point
  geom_point() + 
  
  ## add in an error bar for the confidence intervals
  geom_errorbar(aes(xmin = conf.low, xmax = conf.high)) + 
  
  ## show where OR = 1 is for reference as a dashed line
  geom_vline(xintercept = 1, linetype = "dashed")
  
```

<!-- ======================================================= -->

### **easystats** packages {.unnumbered}

Lựa chọn thứ hai là sử dụng một sự kết hợp của các package trong **easystats**, nếu chúng ta không muốn mức độ kiểm soát chặt chẽ mà package **ggplot2** cung cấp.

Hàm `model_parameters()` từ package **parameters** thực hiện tương đương với hàm `tidy()` trong package **broom** . Sau đó, package **see** chấp nhận các kết quả đầu ra và tạo một biểu đồ forest plot mặc định giống như cho một đối tượng `ggplot()`.

```{r easystats_forest}
pacman::p_load(easystats)

## remove the intercept term from your multivariable results
final_mv_reg %>% 
  model_parameters(exponentiate = TRUE) %>% 
  plot()
  
```

<!-- ======================================================= -->

## Nguồn

Nội dung của chương này được tham khảo từ các nguồn sau:

[Linear regression in R](https://www.datacamp.com/community/tutorials/linear-regression-R)

[gtsummary](http://www.danieldsjoberg.com/gtsummary/articles/tbl_regression.html)

[UCLA stats page](https://stats.idre.ucla.edu/other/dae/)

[sthda stepwise regression](http://www.sthda.com/english/articles/36-classification-methods-essentials/150-stepwise-logistic-regression-essentials-in-r/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/regression.Rmd-->

# Dữ liệu Missing {#missing-data}

```{r, out.width=c("50%"), echo=F}
knitr::include_graphics(here::here("images", "missingness.png"))
knitr::include_graphics(here::here("images", "missingness_overview.png"))
```

Chương này sẽ bao gồm cách để:

1)  Đánh giá số liệu bị thiếu\
2)  Lọc ra các hàng có số liệu bị thiếu\
3)  Vẽ biểu đồ số liệu bị thiếu theo thời gian\
4)  Xử lý cách `NA` được hiển thị trong biểu đồ\
5)  Thực hiện gán số liệu bị thiếu: MCAR, MAR, MNAR

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị cách gọi các package cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, mà hàm này sẽ cài đặt package khi cần thiết và gọi nó ra để sử dụng. Bạn cũng có thể gọi các gói lệnh đã cài đặt bằng hàm `library()` trong **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các R packages.

```{r}
pacman::p_load(
  rio,           # import/export
  tidyverse,     # data mgmt and viz
  naniar,        # assess and visualize missingness
  mice           # missing data imputation
)
```

### Nhập số liệu {.unnumbered}

Chúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải số liệu linelist "đã làm sạch"</a> (as .rds file). Nhập số liệu này bằng hàm `import()` trong package **rio** (nó chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv -- xem chi tiết trong chương [Nhập xuất dữ liệu]).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

Bên dưới là hiển thị của 50 hàng đầu tiên của bộ số liệu linelist.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Chuyển đổi missing khi nhập dữ liệu {.unnumbered}

Khi nhập số liệu, hãy lưu ý các giá trị có thể được phân loại là các giá trị missing. Ví dụ: 99, 999, "Missing", ô trống (""), hoặc các ô có khoảng trống (" "). Bạn có thể chuyển đổi các giá trị này thành `NA` (cách R lưu trữ số liệu missing) trong khi thực hiện lệnh nhập số liệu.\
Xem phần nhập số liệu trong chương [Dữ liệu missing](#import_missing) để biết thêm chi tiết, vì cú pháp chính xác sẽ khác nhau tùy theo loại tệp.

<!-- ======================================================= -->

## Giá trị missing trong R

Sau đây chúng ta sẽ khảo sát rõ cách số liệu bị thiếu được trình bày và đánh giá trong R bởi các giá trị liền kề và các hàm.

### `NA` {.unnumbered}

Trong R, giá trị bị thiếu được đại diện bởi một giá trị dành riêng (đặc biệt) - `NA`. Lưu ý rằng giá trị này được nhập *không có* dấu ngoặc kép. "NA" là khác biệt và cũng chỉ là một giá trị ký tự bình thường (như lời bài hát của Beatles trong bài Hey Jude).

Số liệu của chúng ta có thể có các cách khác để biểu thị giá trị bị thiếu, như là "99", hoặc "Giá trị bị thiếu / Missing", hoặc "Không biết / Unknown", thậm chí chúng ta có giá trị ký tự trống "" như "để trống / blank", hoặc một khoảng trắng " ". Cần lưu ý những giá trị này và xem xét có nên [chuyển đổi chúng thành NA khi nhập vào R](#import_missing) hoặc trong khi làm sạch số liệu bằng hàm `na_if()` hay không.

Trong lúc làm sạch số liệu, chúng ta cũng có thể muốn chuyển đổi số liệu theo một cách khác -- chuyển đổi tất cả `NA` thành "Missing" hoặc làm tương tự với hàm `replace_na()` hoặc với hàm `fct_explicit_na()` cho các factors.

### Các phiên bản của `NA` {.unnumbered}

Trong hầu hết trường hợp, `NA` đại diện cho giá trị bị thiếu và mọi thứ đều vận hành tốt. Tuy nhiên, trong một số trường hợp, chúng ta có thể gặp phải những tình huống khó khăn đối với *các biến thể* của `NA` mà đặc trưng cho một lớp đối tượng (ký tự, số, .v.v.). Điều này rất hiếm, nhưng chúng ta cần phải lưu ý.\
Tình huống điển hình cho trường hợp này là khi tạo một cột mới bằng hàm `case_when()` trong package **dplyr**. Như được mô tả trong chương [Làm sạch số liệu và các hàm quan trọng](#clean_case_when), hàm này lượng giá mọi hàng trong data frame, đánh giá xem các hàng có đáp ứng với các tiêu chí logic cụ thể hay không (phía bên phải của code), và gán giá trị chính xác mới (phía bên trái của code). *Quan trọng: tất cả các giá trị bên phải phải cùng một lớp biến số*.

```{r, eval=F}
linelist <- linelist %>% 
  
  # Create new "age_years" column from "age" column
  mutate(age_years = case_when(
    age_unit == "years"  ~ age,       # if age is given in years, assign original value
    age_unit == "months" ~ age/12,    # if age is given in months, divide by 12
    is.na(age_unit)      ~ age,       # if age UNIT is missing, assume years
    TRUE                 ~ NA_real_)) # any other circumstance, assign missing
```

Nếu bạn muốn `NA` ở phía bên phải, có thể cần phải chỉ định một trong các tùy chọn đặc biệt của `NA` được liệt kê bên dưới. Nếu các giá trị bên phải khác là ký tự, cân nhắc sử dụng "Missing" hoặc sử dụng `NA_character_`. Nếu chúng là các giá trị số, sử dụng `NA_real_`. Nếu tất cả các giá trị là ngày tháng hoặc logic, chúng ta có thể sử dụng `NA`.

-   `NA` - dùng cho biến ngày tháng hoặc biến số logic TRUE/FALSE
-   `NA_character_` - dùng cho biến số ký tự\
-   `NA_real_` - dùng cho biến dạng số

Một lần nữa, chúng ta sẽ không gặp các loại biến thể này *trừ khi* chúng ta sử dụng hàm `case_when()` để tạo biến mới. Xem phần [Tài liệu về NA trong R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/NA.html) để biết thêm thông tin.

### `NULL` {.unnumbered}

`NULL` là một giá trị dành riêng khác nữa trong R. Nó đại điện cho một mệnh đề không đúng cũng không sai. Nó là kết quả của các biểu thức hoặc hàm có giá trị không xác định. Nói chung, không gán NULL như một giá trị, trừ khi viết hàm hoặc khi viết mộ [Ứng dụng **shiny**][Dashboards with Shiny] để trả về `NULL` trong các tình huống cụ thể.

Null có thể được đánh giá bằng cách sử dụng hàm `is.null()` và có thể chuyển đổi thành bằng hàm `as.null()`.

Xem [bài viết trên blog này](https://www.r-bloggers.com/2010/04/r-na-vs-null/) on để biết về sự khác biệt giữa `NULL` và `NA`.

### `NaN` {.unnumbered}

Các giá trị không thể được đại diện bằng một giá trị đặc biệt `NaN`. Một ví dụ cho giá trị này là khi chúng ta bắt buộc R chia 0 cho 0. Chúng ta có thể đánh giá giá trị này bằng cách dùng hàm `is.nan()`. Chúng ta cũng có thể gặp các hàm bổ sung bao gồm `is.infinite()` và `is.finite()`.

### `Inf` {.unnumbered}

`Inf` đại diện cho giá trị vô hạn như là khi chia một số nào đó cho 0.

Một ví dụ về cách mà giá trị này ảnh hưởng đến số liệu của chúng ta: giả sử chúng ta có một véctơ hay một cột `z` chứa các giá trị sau: `z <- c(1, 22, NA, Inf, NaN, 5)`

Nếu bạn muốn sử dụng hàm `max()` của cột bên trên để tìm giá trị lớn nhất, bạn có thể sử dụng `na.rm = TRUE` để loại bỏ `NA` khỏi phép tính, nhưng `Inf` và `NaN` vẫn còn, và `Inf` sẽ được trả về. Để giải quyết vấn đề này, chúng ta có thể sử dụng dấu ngoặc vuông `[ ]` và hàm `is.finite()` để tạo tập hợp con mà chỉ có các giá trị hữu hạn được sử dụng để tính toán: `max(z[is.finite(z)])`.

```{r, eval=F}
z <- c(1, 22, NA, Inf, NaN, 5)
max(z)                           # returns NA
max(z, na.rm=T)                  # returns Inf
max(z[is.finite(z)])             # returns 22
```

### Các ví dụ {.unnumbered}

+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+
| Lệnh trong R                                                                                                          | Đầu ra                                  |
+=======================================================================================================================+=========================================+
| `5 / 0`                                                                                                               | `Inf`                                   |
+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+
| `0 / 0`                                                                                                               | `NaN`                                   |
+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+
| `5 / NA`                                                                                                              | `NA`                                    |
+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+
| `5 / Inf |`0NA - 5`|`NAInf / 5`|`Infclass(NA)`| "logical"`class(NaN)`| "numeric"`class(Inf)`| "numeric"`class(NULL)\` | "NULL"                                  |
+-----------------------------------------------------------------------------------------------------------------------+-----------------------------------------+

"NAs introduced by coercion (NAs được tạo ra do ép buộc)" là một cảnh báo phổ biến. Điều này có thể xảy ra khi chúng ta cố gắng thực hiện một chuyển đổi không hợp lệ như chèn một giá trị ký tự vào trong một véctơ dạng số.

```{r}
as.numeric(c("10", "20", "thirty", "40"))
```

`NULL` được bỏ qua trong một véctơ.

```{r}
my_vector <- c(25, NA, 10, NULL)  # define
my_vector                         # print
```

Phương sai của một số cho kết quả là `NA`.

```{r}
var(22)
```

<!-- ======================================================= -->

## Các hàm hữu dụng

Dưới đây là các hàm hữu dụng trong **base** R khi đánh giá hoặc xử lý các giá trị bị thiếu:

### `is.na()` và `!is.na()` {.unnumbered}

Sử dụng hàm `is.na()` để nhận ra các giá trị bị thiếu hoặc sử dụng hàm đối của nó (với dấu `!` ở phía trước) để nhận ra các giá trị không phải là missing. Cả hai hàm trên đều trả kết quả về một giá trị logic (`TRUE` hoặc `FALSE`). Nhớ rằng bạn có thể dùng hàm `sum()` đối với véc tơ kết quả/đầu ra để đếm số lượng `TRUE`, vd: `sum(is.na(linelist$date_outcome))`.

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)
is.na(my_vector)
!is.na(my_vector)
sum(is.na(my_vector))
```

### `na.omit()` {.unnumbered}

Hàm này, nếu được áp dụng trên một data frame, sẽ loại bỏ các hàng có *bất kỳ*  giá trị nào bị thiếu. Hàm này cũng từ **base** R.\
Nếu áp dụng cho một véctơ, hàm này sẽ loại bỏ các giá trị `NA` của véctơ này. Ví dụ:

```{r}
na.omit(my_vector)
```

### `drop_na()` {.unnumbered}

Đây là một hàm của package **tidyr** mà rất hữu dụng trong một [pipeline làm sạch số liệu][Cleaning data and core functions]. Nếu thực hiện hàm với dấu ngoặc trống, nó sẽ loại bỏ các hàng có *bất kỳ* giá trị nào bị thiếu. Nếu cụ thể tên cột trong dấu ngoặc, các hàng nào có giá trị bị thiếu trong những cột này sẽ bị loại bỏ. Chúng ta có thể sử dụng cú pháp “tidyselect” để chỉ định các cột này.

```{r, eval=F}
linelist %>% 
  drop_na(case_id, date_onset, age) # drops rows missing values for any of these columns
```

### `na.rm = TRUE` {.unnumbered}

Khi chúng ta thực hiện một hàm toán học như `max()`, `min()`, `sum()` hoặc `mean()`, nếu có sự hiện diện của bất kỳ giá trị `NA`, kết quả sẽ là `NA`. Cách xử lý mặc định này là có chủ ý để cảnh báo chúng ta khi có số liệu bị thiếu.

Bạn có thể tránh việc này bằng cách loại bỏ các giá trị bị thiếu ra khỏi phép tính. Để thực hiện, hãy thêm đối số `na.rm = TRUE` ("na.rm" là viết tắt của "remove `NA`").

```{r}
my_vector <- c(1, 4, 56, NA, 5, NA, 22)

mean(my_vector)     

mean(my_vector, na.rm = TRUE)
```

<!-- ======================================================= -->

## Đánh giá tính không đầy đủ của một data frame

Bạn có thể sử dụng package **naniar** để đánh giá và trực quan hóa các giá trị bị thiếu trong bộ số liệu `linelist`.

```{r}
# install and/or load package
pacman::p_load(naniar)
```

### Định lượng tính không đầy đủ {.unnumbered}

Để tìm phần trăm của tất cả các giá trị bị thiếu, sử dụng hàm `pct_miss()`. Để biết số lượng bị thiếu, sử dụng hàm `n_miss()`.

```{r}
# percent of ALL data frame values that are missing
pct_miss(linelist)
```

Hai hàm bên dưới trả về phần trăm số hàng có bất kỳ giá trị bị thiếu hoặc hoàn toàn đầy đủ. Hãy nhớ rằng `NA` có nghĩa là giá trị missing, và \``""` hoặc `" "` sẽ không được đếm là giá trị missing.

```{r}
# Percent of rows with any value missing
pct_miss_case(linelist)   # use n_complete() for counts
```

```{r}
# Percent of rows that are complete (no values missing)  
pct_complete_case(linelist) # use n_complete() for counts
```

### Trực quan hóa tính không đầy đủ {.unnumbered}

Hàm `gg_miss_var()` sẽ hiển thị cho chúng ta số lượng (hoặc %) của các giá trị bị thiếu trong mỗi cột. Một vài sắc thái như sau:

-   Chúng ta có thể thêm tên cột (không ở trong dấu ngoặc kép) vào đối số `facet =` để xem biểu đồ theo nhóm\
-   Theo mặc định, số đếm sẽ được hiển thị thay vì con số phần trăm, để thay đổi điều này bằng cách sử dụng thêm `show_pct = TRUE`\
-   Chúng ta có thể thêm nhãn các trục và tiêu đề như đối với các hàm `ggplot()` thông thường với `+ labs(...)`

```{r}
gg_miss_var(linelist, show_pct = TRUE)
```

Ở đây số liệu được dẫn bằng ký hiệu `%>%` vào trong hàm. Đối số `facet =` cũng được sử dụng để phân chia số liệu.

```{r}
linelist %>% 
  gg_miss_var(show_pct = TRUE, facet = outcome)
```

Bạn có thể sử dụng hàm `vis_miss()` để hình ảnh hóa số liệu dưới dạng một bản đồ nhiệt, mà cho biết từng giá trị có bị thiếu hay không. Chúng ta cũng có thể sử dụng hàm `select()` để lựa chọn một số cột nhất định từ data frame và chỉ cung cấp các cột đó vào trong hàm.

```{r}
# Heatplot of missingness across the entire data frame  
vis_miss(linelist)
```

### Khám phá và trực quan hóa các mối quan hệ của dữ liệu bị thiếu {.unnumbered}

Làm thế nào chúng ta hình ảnh hóa một cái gì đó mà không có ở đó??? Theo mặc định, hàm `ggplot()` sẽ loại bỏ các giá trị bị thiếu ra khỏi biểu đồ.

Package **naniar**  cung cấp một giải pháp thông qua hàm `geom_miss_point()`. Khi tạo biểu đồ phân tán của hai cột, các bản ghi có một trong các giá trị bị thiếu và sự hiện diện của giá trị khác được hiển thị bằng cách đặt các giá trị bị thiếu thấp hơn 10% so với giá trị thấp nhất trong cột đó và và tô màu để dễ phân biệt.

Trong biểu đồ phân tán bên dưới, các chấm màu đỏ là các bản ghi khi có giá trị của một cột nhưng thiếu giá trị của cột còn lại. Điều này cho phép chúng ta thấy được sự phân bố của các giá trị bị thiếu tương quan với giá trị không bị thiếu.

```{r}
ggplot(
  data = linelist,
  mapping = aes(x = age_years, y = temp)) +     
  geom_miss_point()
```

Để đánh giá giá trị bị thiếu trong một data frame *được phân tầng bởi một cột khác*, hãy lưu ý đến hàm `gg_miss_fct()`, mà sẽ trả về một bản đồ nhiệt chứa thông tin về phần trăm giá trị bị thiếu trong một data frame *bởi một cột của biến số factor/phân loại (hoặc ngày)*:

```{r}
gg_miss_fct(linelist, age_cat5)
```

Hàm này cũng có thể được sử dụng đối với cột dạng ngày tháng để xem mức độ của số liệu bị thiếu thay đổi theo thời gian:

```{r}
gg_miss_fct(linelist, date_onset)
```

### Các cột “hình bóng” {.unnumbered}

Một cách khác để trực quan hóa số liệu bị thiếu trong một cột bởi các giá trị của cột thứ hai là sử dụng “hình bóng/shadow” mà package **naniar** có thể tạo ra. Hàm `bind_shadow()` tạo ra một cột biến số nhị phân `NA`/không `NA` cho mọi cột hiện có và liên kết tất cả các cột mới này với bộ số liệu gốc bằng phần phụ "\_NA". Điều này làm tăng gấp đôi số cột – xem bên dưới:

```{r}
shadowed_linelist <- linelist %>% 
  bind_shadow()

names(shadowed_linelist)
```

Các cột “hình bóng” này có thể được sử dụng để vẽ biểu đồ tỷ lệ các giá trị bị thiếu theo bất kỳ cột nào khác.

Ví dụ: biểu đồ bên dưới cho thấy tỷ lệ các giá trị bị thiếu của các bản ghi trong biến số `days_onset_hosp` (số ngày từ ngày khởi phát triệu chứng đến ngày nhập viện), theo giá trị của bản ghi đó trong biến số `date_hospitalisation`. Về bản chất là chúng ta đang vẽ biểu độ mật độ của cột này trên trục x, nhưng phân tầng kết quả (`color =`) bằng cột hình bóng đang được quan tâm. Phân tích này thể hiện tốt nhất khi trục x là cột số hoặc cột ngày.

```{r, message = F}
ggplot(data = shadowed_linelist,          # data frame with shadow columns
  mapping = aes(x = date_hospitalisation, # numeric or date column
                colour = age_years_NA)) + # shadow column of interest
  geom_density()                          # plots the density curves
```

Bạn cũng có thể sử dụng cột “hình bóng” để phân tầng một bảng tóm tắt thống kê, như được hiển thị bên dưới:

```{r}
linelist %>%
  bind_shadow() %>%                # create the shows cols
  group_by(date_outcome_NA) %>%    # shadow col for stratifying
  summarise(across(
    .cols = age_years,             # variable of interest for calculations
    .fns = list("mean" = mean,     # stats to calculate
                "sd" = sd,
                "var" = var,
                "min" = min,
                "max" = max),  
    na.rm = TRUE))                 # other arguments for the stat calculations
```

Bên dưới là một cách khác để vẽ biểu đồ tỷ lệ các giá trị bị thiếu của một cột theo thời gian. Nó *không* liên quan đến package **naniar**. Ví dụ này cho thấy phần trăm số liệu bị thiếu theo tuần.

1)  Tổng hợp số liệu thành một đơn vị thời gian muốn sử dụng (ngày, tuần, .v.v.), tóm tắt tỷ lệ quan sát theo `NA` (và bất kỳ các giá trị quan tâm khác)\
2)  Vẽ biểu đồ tỷ lệ giá trị bị thiếu dưới dạng một dòng bằng cách sử dụng hàm `ggplot()`

Bên dưới, chúng ta lấy bộ số liệu linelist, thêm một cột mới cho tuần, nhóm số liệu theo tuần và sau đó tính phần trăm của các bản ghi có số liệu bị thiếu theo tuần. (lưu ý: nếu chúng ta muốn % của 7 ngày, việc tính toán sẽ hơi khác một chút).

```{r}
outcome_missing <- linelist %>%
  mutate(week = lubridate::floor_date(date_onset, "week")) %>%   # create new week column
  group_by(week) %>%                                             # group the rows by week
  summarise(                                                     # summarize each week
    n_obs = n(),                                                  # number of records
    
    outcome_missing = sum(is.na(outcome) | outcome == ""),        # number of records missing the value
    outcome_p_miss  = outcome_missing / n_obs,                    # proportion of records missing the value
  
    outcome_dead    = sum(outcome == "Death", na.rm=T),           # number of records as dead
    outcome_p_dead  = outcome_dead / n_obs) %>%                   # proportion of records as dead
  
  tidyr::pivot_longer(-week, names_to = "statistic") %>%         # pivot all columns except week, to long format for ggplot
  filter(stringr::str_detect(statistic, "_p_"))                  # keep only the proportion values
```

Sau đó, chúng ta vẽ biểu đồ tỷ lệ các giá trị bị thiếu dưới dạng một dòng theo tuần. Xem thêm chương [ggplot cơ bản] nếu bạn chưa quen với package vẽ biểu đồ **ggplot2**.

```{r, message=F, warning=F}
ggplot(data = outcome_missing)+
    geom_line(
      mapping = aes(x = week, y = value, group = statistic, color = statistic),
      size = 2,
      stat = "identity")+
    labs(title = "Weekly outcomes",
         x = "Week",
         y = "Proportion of weekly records") + 
     scale_color_discrete(
       name = "",
       labels = c("Died", "Missing outcome"))+
    scale_y_continuous(breaks = c(seq(0,1,0.1)))+
  theme_minimal()+
  theme(legend.position = "bottom")
```

<!-- ======================================================= -->

## Sử dụng dữ liệu có giá trị missing

### Lọc bỏ các hàng có giá trị bị thiếu {.unnumbered}

Để loại bỏ nhanh các hàng có giá trị bị thiếu, sử dụng hàm `drop_na()` trong package **dplyr**.

Bộ số liệu gốc `linelist` có `nrow(linelist)` hàng. Số hàng sau khi hiệu chỉnh được hiển thị bên dưới:

```{r}
linelist %>% 
  drop_na() %>%     # remove rows with ANY missing values
  nrow()
```

Bạn có thể chỉ định loại bỏ các hàng có giá trị bị thiếu trong một số hàng nhất định:

```{r}
linelist %>% 
  drop_na(date_onset) %>% # remove rows missing date_onset 
  nrow()
```

Bạn có thể liệt kê lần lượt từng cột một, hoặc sử dụng [các hàm trợ giúp trong “tidyselect”](#clean_tidyselect):

```{r}
linelist %>% 
  drop_na(contains("date")) %>% # remove rows missing values in any "date" column 
  nrow()
```

<!-- ======================================================= -->

### Xử lý `NA` trong hàm `ggplot()` {.unnumbered}

Thường là khôn ngoan khi báo cáo số lượng các giá trị bị loại ra trong phần chú thích của biểu đồ. Bên dưới là một ví dụ:

Trong hàm `ggplot()`, bạn có thể thêm `labs()` và bên trong nó là một chú thích `caption =`. Trong phần chú thích này, chúng ta có thể sử dụng hàm `str_glue()` từ package **stringr** để dán các giá trị lại với nhau thành một câu có tính chất động (dynamic), vì vậy nó sẽ điều chỉnh theo số liệu. Bên dưới là một ví dụ:

-   Lưu ý sử dụng `\n` để tạo một hàng mới (ngắt chữ xuống hàng).\
-   Lưu ý rằng nếu nhiều cột góp phần tạo ra các giá trị, thì sẽ không vẽ được trên biểu đồ (ví dụ như tuổi hoặc giới nếu chúng được phản ánh trên biểu đồ, thì chúng ta cũng phải lọc trên các cột đó để tính toán chính xác số lượng không được hiển thị.

```{r, eval=F}
labs(
  title = "",
  y = "",
  x = "",
  caption  = stringr::str_glue(
  "n = {nrow(central_data)} from Central Hospital;
  {nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown."))  
```

Thỉnh thoảng, có thể dễ dàng hơn để lưu chuỗi này dưới dạng một đối tượng trong các lệnh trước khi dùng lệnh `ggplot()`, và chỉ cần tham chiếu tên của đối tượng chuỗi bên trong hàm `str_glue()`.

<!-- ======================================================= -->

### `NA` trong các factors {.unnumbered}

Nếu cột đang quan tâm là một factor, sử dụng hàm `fct_explicit_na()` thuộc package **forcats**  để chuyển đổi các giá trị `NA` thành giá trị ký tự. Xem thêm chi tiết trong chương [Factors]. Theo mặc định, giá trị mới là "(Missing)" nhưng nó có thể được điều chỉnh thông qua đối số `na_level =`.

```{r}
pacman::p_load(forcats)   # load package

linelist <- linelist %>% 
  mutate(gender = fct_explicit_na(gender, na_level = "Missing"))

levels(linelist$gender)
```

<!-- ======================================================= -->

## Thay thế missing - Imputation

Thỉnh thoảng, khi phân tích số liệu, điều quan trọng là phải “làm đầy khoảng trống” và gán giá trị cho số liệu bị thiếu. Trong khi chúng ta luôn luôn có thể chỉ cần phân tích một bộ số liệu sau khi đã loại bỏ tất cả các giá trị bị thiếu, nhưng điều này có thể đưa đến các vấn đề theo nhiều cách. Đây là các ví dụ:

1)  Bằng cách loại bỏ tất cả các quan sát có giá trị bị thiếu hoặc các biến số có một số lượng lớn giá trị bị thiếu, chúng ta có thể giảm lực thống kê hay khả năng thực hiện một số loại phân tích. Ví dụ như khi chúng ta đã phát hiện trước đó, chỉ có một phần nhỏ của các quan sát trong bộ số liệu linelist không có số liệu bị thiếu trên tất cả các biến số. Nếu chúng ta xóa phần lớn số liệu, chúng ta sẽ mất rất nhiều thông tin! Và hầu hết các biến của bộ số liệu trên đều có một số lượng dữ liệu missing – đối với hầu hết các phân tích, hầu như là không hợp lý để loại bỏ tất cả các biến có nhiều số liệu bị missing.

2)  Tùy thuộc vào lý do tại sao số liệu bị thiếu, nhưng chỉ phân tích số liệu không bị thiếu có thể dẫn đến kết quả sai lệch. Ví dụ như khi chúng ta đã biết trước đó, chúng ta đang thiếu số liệu của một số bệnh nhân về việc họ có một số triệu chứng quan trọng như sốt hoặc ho hay không. Nhưng có một khả năng là có thể thông tin đó không được ghi nhận đối với những người mà rõ ràng không bị bệnh nặng. Trong trường hợp đó, nếu chúng ta chỉ loại bỏ những quan sát này, chúng ta sẽ loại trừ một số người khỏe nhất trong bộ số liệu và điều đó thật sự có thể làm sai lệch bất kỳ kết quả nào.

Điều quan trọng là suy nghĩ tại sao số liệu có thể bị thiếu cũng như là thiếu bao nhiêu. Làm điều này có thể giúp chúng ta xác định mức độ quan trọng của việc gán giá trị bị thiếu và lựa chọn phương pháp tốt nhất để imputing giá trị missing trong tình huống của chúng ta.

### Các loại số liệu bị thiếu {.unnumbered}

Dưới đây là ba loại số liệu bị thiếu điển hình:

1)  **Missing Completely at Random** (MCAR): Số liệu bị thiếu hoàn toàn ngẫu nhiên. Điều này có nghĩa là không có mối quan hệ giữa xác suất số liệu bị thiếu và bất kỳ biến số nào trong bộ số liệu. Xác suất số liệu bị thiếu là ngang nhau đối với tất cả các trường hợp. Đây là một tình huống hiếm gặp. Nhưng nếu chúng ta có lý do chính đáng để tin rằng số liệu của chúng ta là MCAR, thì chỉ phân tích số liệu không bị thiếu (mà không imputing giá trị bị thiếu) sẽ không làm sai lệch kết quả (mặc dù chúng ta có thể mất một ít lực thống kê). [CẦN LÀM: lưu ý đến các thảo luận về các kiểm định thống kê cho MCAR]

2)  **Missing at Random** (MAR). Số liệu bị thiếu Ngẫu nhiên. Tên của loại số liệu này thực sự gây ra một ít hiểu lầm vì MAR có nghĩa là số liệu bị thiếu một cách có hệ thống, có thể dự đoán dựa trên các thông tin khác mà chúng ta có. Ví dụ như có lẽ giá trị bị thiếu đối với biến số sốt của mọi quan sát trong bộ số liệu là thật sự không được ghi nhận vì mọi bệnh nhân có ớn lạnh và đau nhức được giả định là bị sốt, vì vậy thân nhiệt của họ không bao giờ được đo. Nếu đúng như vậy, chúng ta có thể dễ dàng dự đoán rằng, mọi quan sát bị thiếu khi có ớn lạnh và đau nhức cũng sẽ bị sốt và chúng ta sẽ sử dụng thông tin này để gán các giá trị bị thiếu. Trong thực tế, đây là loại nhiều hơn. Có thể nếu một bệnh nhân có cả ớn lạnh và đau nhức, thì hầu như họ cũng sẽ bị sốt nếu thân nhiệt không được đo, nhưng không phải lúc nào cũng như vậy. Điều này vẫn có thể dự đoán được ngay cả khi nó không thể dự đoán một cách hoàn toàn, nhưng không phải là luôn luôn. Đây là một loại số liệu bị thiếu phổ biến

3)  **Missing not at Random** (MNAR): Số liệu bị thiếu không ngẫu nhiên. Thỉnh thoảng, loại này được gọi là **Not Missing at Random - Không bị Thiếu Ngẫu nhiên** (NMAR). Loại này giả định rằng xác suất của một giá trị bị thiếu là KHÔNG có hệ thống hoặc không thể dự đoán được bằng cách sử dụng thông tin khác mà chúng ta có, nhưng nó cũng không là giá trị bị thiếu một cách ngẫu nhiên. Trong tình huống này, số liệu bị thiếu không rõ lý do hoặc vì các lý do mà chúng ta không có bất kỳ thông tin nào. Ví dụ: trong bộ số liệu có thể thiếu thông tin về tuổi bởi vì một số bệnh nhân rất cao tuổi hoặc không biết hoặc từ chối cho biết tuổi. Trong tình huống này, số liệu bị thiếu về tuổi có liên quan đến giá trị của chính nó (và vì thế nó không phải là ngẫu nhiên) và không thể dự đoán được dựa trên các thông tin khác mà chúng ta có. MNAR là phức tạp và cách tốt nhất để giải quyết loại số liệu này thường là cố gắng thu thập thêm số liệu hoặc thông tin tại sao số liệu bị thiếu thay vì cố gắng gán giá trị cho nó.

Nhìn chung, việc gán số liệu cho MCAR thường khá đơn giản, trong khi cho MNAR là khá thách thức nếu không muốn nói là không thể. Có nhiều phương pháp gán số liệu phổ biến cho các số liệu được cho là MAR.

### Các packages hữu dụng {.unnumbered}

Một số package hữu dụng để gán số liệu bị thiếu là Mmisc, missForest (mà sử dụng kỹ thuật Random Forests để gán số liệu bị thiếu), và package mice (viết tắt của Multivariate Imputation by Chained Equations). Đối với phần này, chúng ta chỉ sử dụng package mice để thực hiện nhiều kỹ thuật khác nhau. Người bảo trì package mice xuất bản một cuốn sách trực tuyến về gán số liệu bị thiếu, xem chi tiết hơn tại đây (<https://stefvanbuuren.name/fimd/>).

Đây là code để tải package mice:

```{r}
pacman::p_load(mice)
```

### Gán bằng giá trị trung bình {.unnumbered}

Thỉnh thoảng, nếu chúng ta thực hiện một phân tích đơn giản hoặc chúng ta có một lý do chính đáng để nghĩ rằng chúng ta có thể giả định số liệu bị thiếu là hoàn toàn ngẫu nhiên (MCAR), chúng ta có thể chỉ cần gán các giá trị bị thiếu bằng giá trị trung bình của biến số đó. Có lẽ chúng ta có thể giả định rằng các giá trị bị thiếu của thân nhiệt trong bộ số liệu là MCAR hoặc chỉ là các giá trị bình thường. Đây là code để tạo một biến số mới để thay thế các giá trị thân nhiệt bị thiếu bằng giá trị thân nhiệt trung bình trong bộ số liệu. Tuy nhiên, trong nhiều tình huống, việc thay thế số liệu bằng giá trị trung bình có thể dẫn đến sai lệch, vì thế hãy cẩn thận.

```{r}
linelist <- linelist %>%
  mutate(temp_replace_na_with_mean = replace_na(temp, mean(temp, na.rm = T)))
```

Bạn cũng có thể thực hiện một quy trình tương tự để thay thế số liệu của biến phân loại bằng một giá trị cụ thể.  Đối với bộ số liệu linelist, giả sử là bạn đã biết tất cả các quan sát có giá trị bị thiếu của biến số kết cục (mà có thể là “Tử vong” hoặc “Hồi phục”) thực sự là những người đã chết (lưu ý: điều này không thực sự đúng đối với bộ số liệu này):

```{r}
linelist <- linelist %>%
  mutate(outcome_replace_na_with_death = replace_na(outcome, "Death"))
```

### Gán bằng hồi quy {.unnumbered}

Một phương pháp nâng hơi cao hơn là sử dụng một số loại mô hình thống kê để dự đoán giá trị có lẽ bị thiếu và thay thế nó bằng giá trị dự đoán. Đây là một ví dụ về việc tạo ra các giá trị dự đoán cho tất cả các quan sát bị thiếu của biến số thân nhiệt (temperature), nhưng biến số tuổi (age) và biến số sốt (fever) thì không bị thiếu, bằng cách sử dụng hồi quy tuyến tính đơn giản với biến số dự đoán là tình trạng sốt và tuổi theo năm. Trong thực tế, chúng ta muốn sử dụng một mô hình tốt hơn kiểu tiếp cận đơn giản này..

```{r, warning=F, message=F}
simple_temperature_model_fit <- lm(temp ~ fever + age_years, data = linelist)

#using our simple temperature model to predict values just for the observations where temp is missing
predictions_for_missing_temps <- predict(simple_temperature_model_fit,
                                        newdata = linelist %>% filter(is.na(temp))) 
```

Hoặc sử dụng cùng phương pháp mô hình hóa thông qua gói lệnh mice để tạo ra các giá trị gán cho các quan sát thân nhiệt bị thiếu:

```{r}
model_dataset <- linelist %>%
  select(temp, fever, age_years)  

temp_imputed <- mice(model_dataset,
                            method = "norm.predict",
                            seed = 1,
                            m = 1,
                            print = F)

temp_imputed_values <- temp_imputed$imp$temp

```

Cách trên có cùng cách tiếp cận với một số phương pháp nâng cao hơn như sử dụng package missForest để thay thế giá trị bị thiếu bằng các giá trị dự đoán. Trong trường hợp đó, mô hình dự đoán là một random forest thay vì là một hồi quy tuyến tính. Chúng ta cũng có thể sử dụng các loại mô hình khác để làm điều này. Tuy nhiên, phương pháp này thực hiện tốt với số liệu loại MCAR, nhưng chúng ta nên cẩn thận một chút nếu chúng ta tin rằng loại số liệu của chúng ta chính xác hơn là MAR hoặc MNAR. Chất lượng của việc gán giá trị bị thiếu sẽ phụ thuộc vào mô hình dự đoán tốt như thế nào, và ngay cả khi với một mô hình dự đoán rất tốt, tính biến thiên của số liệu được gán có thể đưa đến một ước lượng non.

### LOCF và BOCF {.unnumbered}

LOCF (viết tắt của Last observation carried forward) và BOCF (viết tắt của baseline observation carried forward) là các phương pháp gán số liệu bị thiếu đối với số liệu chuỗi thời gian/số liệu dọc. Ý tưởng là lấy giá trị được quan sát trước đó để thay thế cho số liệu bị thiếu. Khi có nhiều giá trị bị thiếu liên tiếp, phương pháp này sẽ tìm kiếm giá trị được quan sát cuối cùng.

Hàm `fill()` từ package **tidyr** có thể được sử dụng cho cả phương pháp gán LOCF và BOCF (tuy nhiên, các package khác như **HMISC**, **zoo**, và **data.table** cũng có các phương pháp để làm điều này). Để hiển thị cú pháp của hàm`fill()`,  chúng ta sẽ tạo một bộ số liệu chuỗi thời gian đơn giản mà bao gồm một số ca của một bệnh trong các quý của năm 2000 và 2001. Tuy nhiên, giá trị năm cho các quý tiếp theo sau Q1 bị thiếu, vì thế chúng ta cần gán các số liệu bị thiếu này. Hàm `fill()` cũng được trình bày chi tiết trong chương [Xoay trục dữ liệu].

```{r}
#creating our simple dataset
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",    2000,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",      NA,    21001,
  "Q1",    2001,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",      NA,    50197)

#imputing the missing year values:
disease %>% fill(year)

```

Lưu ý: cần đảm bảo số liệu được sắp xếp chính xác trước khi sử dụng hàm `fill()`. Mặc định của hàm `fill()`  là điền “xuống” nhưng chúng ta cũng có thể gán giá trị bị thiếu theo các hướng khác nhau bằng cách thay đổi tham số `.direction`. WChúng ta có thể tạo một tập số liệu tương tự mà giá trị của năm chỉ được ghi nhận vào cuối năm và bị thiếu ở các quý trước đó:

```{r}
#creating our slightly different dataset
disease <- tibble::tribble(
  ~quarter, ~year, ~cases,
  "Q1",      NA,    66013,
  "Q2",      NA,    69182,
  "Q3",      NA,    53175,
  "Q4",    2000,    21001,
  "Q1",      NA,    46036,
  "Q2",      NA,    58842,
  "Q3",      NA,    44568,
  "Q4",    2001,    50197)

#imputing the missing year values in the "up" direction:
disease %>% fill(year, .direction = "up")

```

Trong ví dụ này, rõ ràng LOCF và BOCF thực hiện đúng các công việc, nhưng trong những tình huống phức tạp hơn, có thể là khó khăn hơn để quyết định những phương pháp này có phù hợp hay không. Ví dụ: chúng ta có thể thiếu các giá trị xét nghiệm của một bệnh nhân nằm viện sau ngày đầu tiên. Đôi lúc, điều này có thể có nghĩa là các giá trị xét nghiệm không thay đổi ... nhưng cũng có thể là bệnh nhân đã hồi phục và những giá trị xét nghiệm của bệnh nhân này có thể là rất khác sau ngày đầu tiên! Hãy sử dụng những phương pháp này một cách thận trọng.

### Gán số liệu nhiều lần {.unnumbered}

Cuốn sách trực tuyến mà chúng tôi đã đề cập trước đây bởi tác giả của package mice (<https://stefvanbuuren.name/fimd/>) bao gồm một giải thích chi tiết về gán số liệu nhiều lần và lý do tại sao chúng ta muốn sử dụng nó. Dưới đây là một giải thích cơ bản của phương pháp này:

Khi chúng ta thực hiện gán nhiều lần, chúng ta tạo nhiều bộ số liệu với các giá trị bị thiếu mà được gán các giá trị hợp lý (tùy thuộc vào số liệu của chúng ta, chúng ta có thể muốn tạo nhiều hay ít các bộ số liệu được gán này, nhưng package mice đặt con số mặc định là 5). TSự khác biệt là thay vì một giá trị đơn lẻ cụ thể, mỗi giá trị được gán được rút ra từ một phân phối được ước tính (vì vậy nó bao gồm một số đặc tính ngẫu nhiên). Kết quả là, mỗi bộ số liệu này sẽ có các giá trị được gán khác nhau một chút (tuy nhiên, số liệu không bị thiếu sẽ giống nhau trong mỗi bộ số liệu được gán này). Chúng ta vẫn sử dụng một số loại mô hình dự đoán để thực hiện việc gán số liệu bị thiếu cho mỗi bộ số liệu mới này (package mice có nhiều tùy chọn cho các phương pháp dự đoán bao gồm *Predictive Mean Matching*, *logistic regression*, và *random forest*), nhưng package mice có thể đảm nhận nhiều chi tiết của mô hình.

Sau đó, một khi chúng ta đã tạo các bộ số liệu mới được gán giá trị bị thiếu này, chúng ta có thể áp dụng bất kỳ mô hình thống kê hoặc phân tích nào mà chúng ta dự định thực hiện cho mỗi bộ số liệu mới này và gộp kết quả của các mô hình này lại với nhau. Thao tác này rất tốt để giảm sai lệch đối với cả MCAR và MAR và thường cho các ước tính sai số chuẩn chính xác hơn.

Đây là một ví dụ về việc áp dụng quy trình Gán Nhiều lần để dự đoán thân nhiệt trong bộ số liệu linelist bằng cách sử dụng tuổi và sốt (bộ số liệu mô hình đơn giản hóa bên trên):


```{r}
# imputing missing values for all variables in our model_dataset, and creating 10 new imputed datasets
multiple_imputation = mice(
  model_dataset,
  seed = 1,
  m = 10,
  print = FALSE) 

model_fit <- with(multiple_imputation, lm(temp ~ age_years + fever))

base::summary(mice::pool(model_fit))
```

Ở đây, chúng tôi sử dụng phương pháp gán mặc định của gói lệnh mice, đó là Predictive Mean Matching. Sau đó, chúng tôi sử dụng các bộ số liệu đã được gán này để ước tính riêng rẽ và gộp kết quả từ các hồi quy tuyến tính đơn giản trên mỗi bộ số liệu này. Có nhiều chi tiết mà chúng tôi đã phớt lờ và nhiều chỗ mà chúng ta có thể điều chỉnh trong suốt quá trình Gán Nhiều lần trong khi sử dụng gói lệnh mice. Ví dụ: chúng ta không phải lúc nào cũng có số liệu dạng số và có thể cần các phương pháp gán khác (chúng ta vẫn có thể sử dụng gói lệnh mice cho nhiều loại số liệu và phương pháp khác). Để một phân tích thiết thực hơn khi số liệu bị thiếu là một mối quan tâm đáng chú ý, Gán số liệu Nhiều lần là một giải pháp tốt, nhưng không phải lúc nào cũng hiệu quả hơn việc thực hiện một phân tích của các trường hợp hoàn chỉnh.

<!-- ======================================================= -->

## Tài nguyên học liệu

Mô tả của [naniar package](https://cran.r-project.org/web/packages/naniar/vignettes/getting-started-w-naniar.html)

Thư viện [trực quan hóa giá trị Missing](https://cran.r-project.org/web/packages/naniar/vignettes/naniar-visualisation.html)

[Sách trực tuyến](https://stefvanbuuren.name/fimd/) về multiple imputation trong R bởi người bảo trì của package **mice**
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/missing_data.Rmd-->


# Tỷ suất chuẩn hóa {#standardization}  

Chương này sẽ hướng dẫn hai cách để chuẩn hóa một kết quả như là tỷ suất tử vong hoặc nhập viện theo các đặc điểm của tuổi và giới. 

* Sử dụng package **dsr** 
* Sử dụng package **PHEindicatormethods**  

Chúng ta bắt đầu bằng cách làm rõ quá trình chuẩn bị/làm sạch/kết nối số liệu, vì việc này thường được thực hiện khi kết nối số liệu dân số từ nhiều quốc gia, số liệu dân số chuẩn, tử vong,.v.v.  

## Tổng quan  

Có hai cách để chuẩn hóa: trực tiếp và gián tiếp. Giả sử chúng ta muốn chuẩn hóa tỷ suất tử vong theo tuổi và giới của quốc gia A và quốc gia B, và so sánh tỷ suất chuẩn hóa giữa hai quốc gia này

* Đối với chuẩn hóa trực tiếp, chúng ta phải biết dân số nguy cơ và số tử vong theo từng tầng của tuổi và giới của quốc gia A và B. Một tầng trong ví dụ của chúng ta là phụ nữ trong nhóm tuổi từ 15-44.  
* Đối với chuẩn hóa gián tiếp, chúng ta chỉ cần biết tổng số tử vong và cấu trúc tuổi và giới của mỗi quốc gia. Vì thế, phương án này là khả khi tỷ suất tử vong hoặc dân số theo tuổi và giới không có sẵn. Hơn nữa, chuẩn hóa gián tiếp được ưa chuộng hơn khi có số lượng nhỏ trong các tầng, vì các ước tính trong chuẩn hóa trực tiếp sẽ bị ảnh hưởng bởi các thay đổi quan trọng khi lấy mẫu. 

<!-- ======================================================= -->
## Chuẩn bị {  }

Để chỉ dẫn cách thực hiện chuẩn hóa, chúng ta tạo ra dân số và số tử vong của quốc gia A và B theo tuổi (trong các nhóm tuổi của mỗi 5 tuổi) và giới (nữ, nam). Để các bộ số liệu có thể sử dụng được, chúng ta sẽ thực hiện các bước chuẩn bị như sau:  

1. Gọi các packages  
2. Tải các bộ số liệu  
3. Nối số liệu dân số và tử vong của hai quốc gia
4. Xoay trục bộ số liệu dọc/dài hơn để có một hàng là một tầng theo tuổi-giới
5. Làm sạch quần thể tham chiếu (dân số thế giới chuẩn) và kết nối nó với số liệu của quốc gia  

Trong trường hợp này, số liệu của chúng ta có thể có các định dạng khác nhau. Có lẽ số liệu của chúng ta theo tỉnh, thành phố, hoặc khu vực dịch vụ khác. Chúng ta có thể có một hàng cho mỗi ca tử vong và các thông tin về tuổi và giới cho mỗi trường hợp (hoặc một tỷ lệ có ý nghĩa) của các ca tử vong này. Trong trường hợp này, hãy xem các chương về [Nhóm dữ liệu], [Xoay trục dữ liệu], và [Bảng mô tả] để tạo một bộ số liệu với số lượng tử vong và dân số theo tầng của tuổi-giới tính.  

Chúng ta cũng cần một quần thể tham chiếu, dân số chuẩn. Với mục đích của thực hành này, chúng ta sẽ sử dụng bộ số liệu `world_standard_population_by_sex`. Dân số chuẩn này dựa trên dân số của 46 quốc gia và được tạo ra vào năm 1960. Có rất nhiều dân số “chuẩn” – ví dụ, trang web của [NHS Scotland](https://www.opendata.nhs.scot/dataset/standard-populations) cung cấp khá nhiều thông tin về Dân số Chuẩn của châu  u, Dân số Chuẩn Thế giới, Dân số Chuẩn của Scotland. 

<!-- ======================================================= -->
### Gọi packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R. 

```{r}
pacman::p_load(
     rio,                 # import/export data
     here,                # locate files
     tidyverse,           # data management and visualization
     stringr,             # cleaning characters and strings
     frailtypack,         # needed for dsr, for frailty models
     dsr,                 # standardise rates
     PHEindicatormethods) # alternative for rate standardisation
```


<span style="color: orange;">**_CẨN TRỌNG:_** Nếu đang sử dụng một phiên bản mới hơn của R, chúng ta không thể tải gói lệnh **dsr** trực tiếp từ CRAN. Tuy nhiên, nó vẫn còn trong mục lưu trữ của CRAN. Chúng ta có thể cài đặt và sử dụng nó. </span>

Đối với người không sử dụng hệ điều hành Mac:  

```{r, eval=F} 
packageurl <- "https://cran.r-project.org/src/contrib/Archive/dsr/dsr_0.2.2.tar.gz"
install.packages(packageurl, repos=NULL, type="source")
```

```{r, eval=FALSE}
# Other solution that may work
require(devtools)
devtools::install_version("dsr", version="0.2.2", repos="http:/cran.us.r.project.org")
```

Đối với người sử dụng hệ điều hành Mac:  

```{r, eval=FALSE}
require(devtools)
devtools::install_version("dsr", version="0.2.2", repos="https://mac.R-project.org")
```




### Tải số liệu dân số {.unnumbered}  

Xem chương [Tải sách và dữ liệu] để biết các hướng dẫn về cách tải tất cả các bộ số liệu mẫu trong cuốn số tay này. Chúng ta có thể nhập trực tiếp dữ liệu trong chương Chuẩn hóa này tới R thông qua kho lưu trữ Github của chúng tôi bằng cách thực hiện lệnh sau `import()`:  

```{r, eval=F}
# import demographics for country A directly from Github
A_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics.csv")

# import deaths for country A directly from Github
A_deaths <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/deaths_countryA.csv")

# import demographics for country B directly from Github
B_demo <- import("https://github.com/appliedepi/epirhandbook_eng/raw/master/data/standardization/country_demographics_2.csv")

# import deaths for country B directly from Github
B_deaths <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/deaths_countryB.csv")

# import demographics for country B directly from Github
standard_pop_data <- import("https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/standardization/world_standard_population_by_sex.csv")

```


Trước tiên, chúng ta tải số liệu nhân khẩu (số lượng nam và nữ theo nhóm mỗi 5 tuổi) của hai quốc gia mà chúng ta sẽ so sánh, “Quốc gia A” và “Quốc gia B”.  

```{r, echo=F}
# Country A
A_demo <- rio::import(here::here("data", "standardization", "country_demographics.csv")) %>% 
     mutate(Country = "A") %>% 
     select(Country, everything()) %>% # re-arrange
     mutate(age_cat5 = str_replace_all(age_cat5, "\\+", "")) # remove + symbols
```

```{r, eval=F}
# Country A
A_demo <- import("country_demographics.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(A_demo, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


```{r, echo=F}
# Country B
B_demo <- rio::import(here::here("data", "standardization", "country_demographics_2.csv")) %>% 
     mutate(Country = "B") %>% 
     select(Country, everything()) # re-arrange
```

```{r, eval=F}
# Country B
B_demo <- import("country_demographics_2.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(B_demo, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```





### Tải số liệu tử vong {.unnumbered}  

Để thuận tiện cho việc thực hành, chúng ta cũng có số lượng tử vong theo tuổi và giới trong khoảng thời gian quan tâm. Số lượng tử vong của mỗi quốc gia nằm trong một tập tin riêng, được hiện thị bên dưới.  

```{r, echo=F}
A_males <- c(224, 257, 251, 245, 334, 245, 154, 189, 334, 342, 565, 432, 543, 432, 245, 543, 234, 354) # for males of country A
B_males <- c(34, 37, 51, 145, 434, 120, 100, 143, 307, 354, 463, 639, 706, 232, 275, 543, 234, 274) # for males of country B
A_females <- c(194, 254, 232, 214, 316, 224, 163, 167, 354, 354, 463, 574, 493, 295, 175, 380, 177, 392) # for females of country A
B_females <- c(54, 24, 32, 154, 276, 254, 123, 164, 254, 354, 453, 654, 435, 354, 165, 432, 287, 395) # for females of country B

age_cat5 <- c("0-4", "5-9", "10-14", "15-19", "20-24", "25-29",  "30-34", "35-39", "40-44",
                                                                                "45-49", "50-54", "55-59",
                                                                                "60-64", "65-69", "70-74",
                                                                                "75-79", "80-84", "85")
A_deaths <- data.frame(Country = "A", AgeCat = age_cat5, Male = A_males, Female = A_females)
B_deaths <- data.frame(Country = "B", AgeCat = age_cat5, Male = B_males, Female = B_females)
```

Số tử vong ở Quốc gia A
```{r message=FALSE, echo=F}
DT::datatable(A_deaths, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Số tử vong ở Quốc gia B

```{r message=FALSE, echo=F}
DT::datatable(B_deaths, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


```{r, echo=F}
rio::export(A_deaths, here::here("data", "standardization", "deaths_countryA.csv"))
rio::export(B_deaths, here::here("data", "standardization", "deaths_countryB.csv"))
```



### Làm sạch số liệu dân số và tử vong {.unnumbered}  


Chúng ta cần kết nối và chuyển đổi các số liệu này theo những cách sau:  

* Liên kết dân số của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàng  
* Liên kết số liệu tử vong của các quốc gia vào một bộ số liệu và xoay trục thành bộ số liệu dạng “dọc/dài” để mỗi tầng tuổi-giới là một hàng  
* Nối số liệu tử vong với số liệu dân số  

Đầu tiên, chúng ta liên kết các bộ số liệu dân số quốc gia, chuyển đổi thành số liệu dạng dọc/dài hơn, và làm sạch số liệu. Xem chương [Xoay trục dữ liệu] để biết thêm chi tiết.  

```{r}
pop_countries <- A_demo %>%  # begin with country A dataset
     bind_rows(B_demo) %>%        # bind rows, because cols are identically named
     pivot_longer(                       # pivot longer
          cols = c(m, f),                   # columns to combine into one
          names_to = "Sex",                 # name for new column containing the category ("m" or "f") 
          values_to = "Population") %>%     # name for new column containing the numeric values pivoted
     mutate(Sex = recode(Sex,            # re-code values for clarity
          "m" = "Male",
          "f" = "Female"))
```

Số liệu dân số đã liên kết bây giờ trông giống như sau (nhấp qua để xem cột quốc gia A và B):  

```{r message=FALSE, echo=F}
DT::datatable(pop_countries, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Và bây giờ, chúng ta thực hiện các thao tác tương tự trên hai bộ số liệu tử vong.

```{r}
deaths_countries <- A_deaths %>%    # begin with country A deaths dataset
     bind_rows(B_deaths) %>%        # bind rows with B dataset, because cols are identically named
     pivot_longer(                  # pivot longer
          cols = c(Male, Female),        # column to transform into one
          names_to = "Sex",              # name for new column containing the category ("m" or "f") 
          values_to = "Deaths") %>%      # name for new column containing the numeric values pivoted
     rename(age_cat5 = AgeCat)      # rename for clarity
```

Số liệu tử vong bây giờ trông giống như sau và chứa số liệu của cả hai quốc gia: 

```{r message=FALSE, echo=F}
DT::datatable(deaths_countries, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Bây giờ, chúng ta nối số liệu tử vong và số liệu dân số dựa trên các cột chung `Country`, `age_cat5`, và `Sex`. Thao tác này sẽ thêm cột `Deaths`.  

```{r}
country_data <- pop_countries %>% 
     left_join(deaths_countries, by = c("Country", "age_cat5", "Sex"))
```

Bây giờ, chúng ta có thể phân loại các biến số `Sex`, `age_cat5`, và `Country` thành dạng factors  và đặt thứ tự các giá trị của biến số bằng cách sử dụng hàm `fct_relevel()` từ package **forcats**, như được mô tả trong chương [Factors]. Lưu ý rằng việc phân loại giá trị biến không thay đổi số liệu một cách rõ ràng, nhưng lệnh `arrange()` sẽ sắp xếp nó theo Quốc gia, nhóm tuổi và giới tính.  

```{r, warning=F, message=F}
country_data <- country_data %>% 
  mutate(
    Country = fct_relevel(Country, "A", "B"),
      
    Sex = fct_relevel(Sex, "Male", "Female"),
        
    age_cat5 = fct_relevel(
      age_cat5,
      "0-4", "5-9", "10-14", "15-19",
      "20-24", "25-29",  "30-34", "35-39",
      "40-44", "45-49", "50-54", "55-59",
      "60-64", "65-69", "70-74",
      "75-79", "80-84", "85")) %>% 
          
  arrange(Country, age_cat5, Sex)

```

```{r message=FALSE, echo=F}
DT::datatable(country_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<span style="color: orange;">**_CẨN TRỌNG:_** Nếu số trường hợp tử vong mỗi tầng là nhỏ, hãy cân nhắc chia nhóm tuổi mỗi 10-15 năm thay vì mỗi 5 năm cho các nhóm.</span>




### Tải dân số tham chiếu {.unnumbered}  

Cuối cùng, để chuẩn hóa trực tiếp, chúng ta nhập dân số tham chiếu (“dân số chuẩn” thế giới theo giới tính)

```{r, echo=F}
# Reference population
standard_pop_data <- rio::import(here::here("data", "standardization", "world_standard_population_by_sex.csv")) %>% 
     rename(age_cat5 = AgeGroup)
```

```{r, eval=F}
# Reference population
standard_pop_data <- import("world_standard_population_by_sex.csv")
```

```{r message=FALSE, echo=F}
DT::datatable(standard_pop_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
### Làm sach dân số tham chiếu {.unnumbered}

Các giá trị của biến tuổi trong bộ số liệu `country_data` và `standard_pop_data` cần phải được căn chỉnh.  

Hiện tại, các giá trị của cột biến phân loại `age_cat5` trong bộ số liệu `standard_pop_data` có chứa từ “years” và “plus”, trong khi không có các từ này trong trong bộ số liệu `country_data`. Chúng ta cần phải chuyển đổi các giá trị này giống nhau. Chúng ta sẽ sử dụng hàm `str_replace_all()` từ package **stringr**, như được mô tả trong chương [Ký tự và chuỗi], để thay thế thành những kiểu mẫu không có khoảng trắng `""`.  

Hơn nữa, package **dsr** đòi hỏi cột chứa số lượng trong bộ số liệu dân số chuẩn phải được gọi là `"pop"`. Vì vậy, chúng ta đổi tên cột này cho phù hợp.  

```{r}
# Remove specific string from column values
standard_pop_clean <- standard_pop_data %>%
     mutate(
          age_cat5 = str_replace_all(age_cat5, "years", ""),   # remove "year"
          age_cat5 = str_replace_all(age_cat5, "plus", ""),    # remove "plus"
          age_cat5 = str_replace_all(age_cat5, " ", "")) %>%   # remove " " space
     
     rename(pop = WorldStandardPopulation)   # change col name to "pop", as this is expected by dsr package
```

<span style="color: orange;">**_CẨN TRỌNG:_** Nếu chúng ta cố gắng sử dụng hàm `str_replace_all()` để loại bỏ *biểu tượng* dấu cộng, hàm này sẽ không thực hiện bởi vì nó là một biểu tượng đặc biệt. “Xử lý” các biểu tượng này bằng cách đặt hai dấu gạch chéo phía trước như trong lệnh `str_replace_call(column, "\\+", "")`. </span>

### Tạo bộ số liệu với dân số chuẩn {#standard_all .unnumbered}  

Cuối cùng, sử dụng package **PHEindicatormethods**, được trình bày chi tiết [bên dưới](#standard_phe), để nối dân số chuẩn vào biến tử vong và dân số của các quốc gia. Vì vậy, chúng ta sẽ tạo một bộ số liệu với tên `all_data` cho mục đích đó.  

```{r}
all_data <- left_join(country_data, standard_pop_clean, by=c("age_cat5", "Sex"))
```

Bộ số liệu hoàn chỉnh trông sẽ như thế này:  

```{r message=FALSE, echo=F}
DT::datatable(all_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Package **dsr** {  }
 
Bên dưới, chúng tôi trình bày việc tính toán và so sánh các tỷ suất được chuẩn hóa trực tiếp bằng cách sử dụng package **dsr**. Package **dsr** cho phép chúng ta tính toán và so sánh các tỷ suất được chuẩn hóa trực tiếp (không phải các tỷ suất được chuẩn hóa gián tiếp!).
  
Trong phần Chuẩn bị số liệu, chúng ta đã tạo các bộ số liệu riêng biệt cho các quốc gia và dân số chuẩn:  

1) đối tượng `country_data` mà là một bảng dân số với số lượng dân số và số tử vong theo tầng cho mỗi quốc gia  
2) đối tượng `standard_pop_clean`, bao gồm số lượng dân số theo tầng cho dân số tham chiếu, Dân số Chuẩn Thế giới  

Chúng ta sẽ sử dụng các bộ số liệu riêng rẽ này cho cách tiếp cận sử dụng package **dsr**.  


<!-- ======================================================= -->
### Tỷ suất chuẩn hóa {.unnumbered}

Bên dưới, chúng ta tính toán các tỷ suất theo quốc gia được chuẩn hóa trực tiếp theo tuổi và giới. Chúng ta sử dụng hàm `dsr()`. 

Lưu ý - `dsr()` đòi hỏi một bộ số liệu dân số của các quốc gia và số lượng sự kiện (tử vong), *và một bộ số liệu* **riêng rẽ** *với dân số tham chiếu*. Nó cũng đòi hỏi trong bộ số liệu của dân số tham chiếu này tên cột đơn vị-thời gian là “pop” (chúng ta đã đảm bảo điều này trong phần Chuẩn bị số liệu).  

Có nhiều đối số, như được chú thích bên dưới. Đáng chú ý, đối số `event = ` được đặt thành cột `Deaths`, và đối số `fu = ` ("follow-up") được đặt thành cột `Population`. Chúng ta đặt các nhóm so sánh là cột `Country` và chuẩn hóa dựa trên cột `age_cat5` và `Sex`. Hai cột cuối cùng này không được gán với một đối số có tên cụ thể. Gõ `?dsr` để biết thêm chi tiết. 

```{r, warning=F, message=F}
# Calculate rates per country directly standardized for age and sex
mortality_rate <- dsr::dsr(
     data = country_data,  # specify object containing number of deaths per stratum
     event = Deaths,       # column containing number of deaths per stratum 
     fu = Population,      # column containing number of population per stratum
     subgroup = Country,   # units we would like to compare
     age_cat5,             # other columns - rates will be standardized by these
     Sex,
     refdata = standard_pop_clean, # reference population data frame, with column called pop
     method = "gamma",      # method to calculate 95% CI
     sig = 0.95,            # significance level
     mp = 100000,           # we want rates per 100.000 population
     decimals = 2)          # number of decimals)


# Print output as nice-looking HTML table
knitr::kable(mortality_rate) # show mortality rate before and after direct standardization
```

Bên trên, chúng ta thấy rằng tỷ suất tử vong thô của quốc gia A thấp hơn quốc gia B, nhưng tỷ suất được chuẩn hóa trực tiếp theo tuổi và giới thì cao hơn.




<!-- ======================================================= -->
### Tỷ số của các tỷ suất chuẩn hóa {.unnumbered}

```{r,warning=F, message=F}
# Calculate RR
mortality_rr <- dsr::dsrr(
     data = country_data, # specify object containing number of deaths per stratum
     event = Deaths,      # column containing number of deaths per stratum 
     fu = Population,     # column containing number of population per stratum
     subgroup = Country,  # units we would like to compare
     age_cat5,
     Sex,                 # characteristics to which we would like to standardize 
     refdata = standard_pop_clean, # reference population, with numbers in column called pop
     refgroup = "B",      # reference for comparison
     estimate = "ratio",  # type of estimate
     sig = 0.95,          # significance level
     mp = 100000,         # we want rates per 100.000 population
     decimals = 2)        # number of decimals

# Print table
knitr::kable(mortality_rr) 
```

Tỷ suất tử vong chuẩn hóa của quốc gia A cao gấp 1.22 lần so với quốc gia B (95% CI 1.17-1.27).

<!-- ======================================================= -->
### Khác biệt của các tỷ suất chuẩn hóa {.unnumbered}

```{r, warning=F, message=F}
# Calculate RD
mortality_rd <- dsr::dsrr(
     data = country_data,       # specify object containing number of deaths per stratum
     event = Deaths,            # column containing number of deaths per stratum 
     fu = Population,           # column containing number of population per stratum
     subgroup = Country,        # units we would like to compare
     age_cat5,                  # characteristics to which we would like to standardize
     Sex,                        
     refdata = standard_pop_clean, # reference population, with numbers in column called pop
     refgroup = "B",            # reference for comparison
     estimate = "difference",   # type of estimate
     sig = 0.95,                # significance level
     mp = 100000,               # we want rates per 100.000 population
     decimals = 2)              # number of decimals

# Print table
knitr::kable(mortality_rd) 
```

Quốc gia A có hơn 4,24 ca tử vong trên 100,000 dân (95% CI 3.24-5.24) so với quốc gia B.







<!-- ======================================================= -->
## Package **PHEindicatormethods** {#standard_phe  }

Một cách khác để tính tỷ suất chuẩn hóa là dùng package **PHEindicatormethods**. Package này cho phép chúng ta tính toán tỷ suất chuẩn hóa trực tiếp cũng như gián tiếp. Chúng tôi sẽ hướng dẫn cả hai.  

Phần này chúng ta sẽ sử dụng bộ số liệu `all_data` được tạo ở cuối phần Chuẩn bị. Bộ số liệu này bao gồm dân số quốc gia, số tử vong và dân số tham chiếu. Bạn có thể xem nó ở [đây](#standard_all).  



<!-- ======================================================= -->
### Tỷ suất chuẩn hóa trực tiếp {.unnumbered}

Đầu tiên, chúng ta nhóm số liệu theo Quốc gia như bên dưới và sau đó chuyển số liệu vào hàm `phe_dsr()` để có được tỷ suất chuẩn hóa trực tiếp theo quốc gia.

Lưu ý, dân số tham chiếu (chuẩn) có thể được cung cấp dưới dạng một **cột bên trong số liệu của một quốc gia cụ thể** hoặc dưới dạng một **véctơ riêng biệt**. Nếu được cung cấp bên trong số liệu của một quốc gia cụ thể, bạn phải đặt `stdpoptype = "field"`. Nếu được cung cấp như một véc tơ, đặt `stdpoptype = "vector"`. Trong trường hợp thứ hai, chúng ta phải đảm bảo thứ tự của các hàng theo tầng tương tự nhau trong cả khung số liệu quốc gia và dân số tham chiếu, vì vị trí các bản ghi/các hàng phải khớp với nhau. Trong ví dụ bên dưới, chúng tôi đã cung cấp dân số tham chiếu dưới dạng một cột bên trong khung số liệu của một quốc gia cụ thể.

Xem trợ giúp bằng cách gõ  `?phr_dsr` hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.

```{r}
# Calculate rates per country directly standardized for age and sex
mortality_ds_rate_phe <- all_data %>%
     group_by(Country) %>%
     PHEindicatormethods::phe_dsr(
          x = Deaths,                 # column with observed number of events
          n = Population,             # column with non-standard pops for each stratum
          stdpop = pop,               # standard populations for each stratum
          stdpoptype = "field")       # either "vector" for a standalone vector or "field" meaning std populations are in the data  

# Print table
knitr::kable(mortality_ds_rate_phe)
```

<!-- ======================================================= -->
### Tỷ suất chuẩn hóa gián tiếp {#standard_indirect .unnumbered}

Để chuẩn hóa gián tiếp, chúng ta cần dân số tham chiếu có số lượng tử vong và dân số theo tầng. Trong ví dụ này, chúng ta sẽ tính tỷ suất của quốc gia A bằng cách *sử dụng quốc gia B làm dân số tham chiếu*, vì dân số tham chiếu trong bộ số liệu `standard_pop_clean` không có số lượng tử vong theo tầng. 

Trước tiên, chúng ta tạo dân số tham chiếu từ quốc gia B như bên dưới. Sau đó, chúng ta chuyển số liệu tử vong và dân số của quốc gia A, kết nối nó với dân số tham chiếu và chuyển nó vào hàm `phe_isr()`, để có được tỷ suất chuẩn hóa gián tiếp. Dĩ nhiên, chúng ta cũng có thể làm ngược lại.

Lưu ý - trong ví dụ bên dưới, dân số tham chiếu được cung cấp dưới dạng một data frame riêng rẽ. Trong trường hợp này, chúng ta cần đảm bảo rằng các véctơ `x = `, `n = `, `x_ref = ` và `n_ref = ` tất cả được sắp đặt cùng giá trị với loại chuẩn hóa (theo đúng tầng) như được sắp đặt trong data frame quốc gia, vì vị trí các bản ghi/các hàng phải khớp với nhau.

Xem trợ giúp bằng cách gõ `?phr_isr` hoặc các liên kết trong phần Tài nguyên học liệu để biết thêm thông tin.  

```{r}
# Create reference population
refpopCountryB <- country_data %>% 
  filter(Country == "B") 

# Calculate rates for country A indirectly standardized by age and sex
mortality_is_rate_phe_A <- country_data %>%
     filter(Country == "A") %>%
     PHEindicatormethods::phe_isr(
          x = Deaths,                 # column with observed number of events
          n = Population,             # column with non-standard pops for each stratum
          x_ref = refpopCountryB$Deaths,  # reference number of deaths for each stratum
          n_ref = refpopCountryB$Population)  # reference population for each stratum

# Print table
knitr::kable(mortality_is_rate_phe_A)
```

<!-- ======================================================= -->
## Tài nguyên học liệu {  }

Nếu bạn muốn tìm thêm các ví dụ có thể tái lập được sử dụng package **dsr**, vui lòng xem [hướng dẫn này]( https://mran.microsoft.com/snapshot/2020-02-12/web/packages/dsr/vignettes/dsr.html)  

Với các ví dụ khác sử dụng package **PHEindicatormethods**, vui lòng xem tại [website này](https://mran.microsoft.com/snapshot/2018-10-22/web/packages/PHEindicatormethods/vignettes/IntroductiontoPHEindicatormethods.html)  

Xem thêm **PHEindicatormethods** [tài liệu dưới dạng tệp pdf](https://cran.r-project.org/web/packages/PHEindicatormethods/PHEindicatormethods.pdf)  


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/standardization.Rmd-->

# Đường trung bình động {#moving-average}

```{r, out.width=c("100%"), echo=F}
knitr::include_graphics(here::here("images", "moving_avg_epicurve.png"))
```

Chương này bao gồm hai phương pháp tính toán và biểu diễn đường trung bình động:

1)  Tính toán với package **slider**\
2)  Tính toán *bên trong* lệnh `ggplot()` với package **tidyquant**

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị những package cần tải cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ **pacman**, hàm sẽ cài đặt package nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với `library()` từ **base** R. Xem chương [R cơ bản] để có thêm thông tin về các R package.

```{r}
pacman::p_load(
  tidyverse,      # for data management and viz
  slider,         # for calculating moving averages
  tidyquant       # for calculating moving averages within ggplot
)
```

### Nhập dữ liệu {.unnumbered}

Chúng ta nhập các trường hợp trong linelist đã được làm sạch từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, [bấm để tải xuống linelist "đã được làm sạch"](https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds) (tệp .rds). Nhập dữ liệu với hàm `import()` từ package **rio** (hàm này xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.xlsx")
```

50 hàng đầu tiên của linelist được hiển thị dưới đây.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Tính toán với **slider**

**Sử dụng cách tiếp cận này để tính toán đường trung bình động trong một data frame trước khi vẽ biểu đồ.**

Package **slider** cung cấp một số hàm tạo "cửa sổ trượt" giúp tính toán trung bình động, tổng tích lũy, hồi quy động (rolling regression), v.v. Nó coi data frame như một vectơ của các hàng, cho phép lặp lại hàng qua một data frame.

Dưới đây là một số hàm phổ biến:

-   `slide_dbl()` - lặp qua một cột dạng *số* (từ "\_dbl") để thực hiện thao tác sử dụng cửa sổ trượt

    -   `slide_sum()` - hàm tắt tính tổng động (rolling sum) cho `slide_dbl()`\
    -   `slide_mean()` - hàm tắt tính trung bình động (rolling average) cho `slide_dbl()`

-   `slide_index_dbl()` - áp dụng cửa sổ cuộn trên một cột dạng số bằng cách sử dụng một cột riêng biệt để *lập chỉ mục* cửa sổ tiến trình (hữu ích nếu cuộn theo ngày mà một số ngày bị thiếu)

    -   `slide_index_sum()` - hàm tắt tính tổng động với chỉ mục\
    -   `slide_index_mean()` - hàm tắt tính trung bình động với chỉ mục

Package **slider** có nhiều hàm khác được đề cập đến trong phần Tài nguyên học liệu của chương này. Ở đây, chúng tôi sẽ đề cập ngắn gọn đến những điểm thông dụng nhất.

**Những đối số chính**

-   `.x`, đối số đầu tiên theo mặc định, là vectơ để lặp lại và để áp dụng hàm\

-   `.i =` cho các phiên bản "chỉ mục (index)" của hàm **slider** - cung cấp một cột để "lập chỉ mục" khi cuộn (xem phần [dưới đây](#roll_index))\

-   `.f =`, đối số thứ hai theo mặc định, có thể dùng theo một trong hai cách:

    -   Một hàm, được viết không có dấu ngoặc đơn, như `mean` hoặc\
    -   Một công thức, mà sẽ được chuyển đổi thành một hàm. Ví dụ `~ .x - mean(.x)` sẽ trả về kết quả của giá trị hiện tại trừ đi giá trị trung bình của cửa sổ giá trị

-   Để biết thêm chi tiết xem [tài liệu tham khảo](https://davisvaughan.github.io/slider/reference/slide.html) này

**Kích thước cửa sổ**

Xác định kích thước của cửa sổ bằng cách sử dụng một trong hai đối số `.before`, `.after`, hoặc cả hai đối số:

-   `.before =` - Cung cấp một số nguyên\
-   `.after =` - Cung cấp một số nguyên\
-   `.complete =` - Đặt giá trị này thành `TRUE` nếu bạn chỉ muốn tính toán được thực hiện trên các cửa sổ hoàn chỉnh

Ví dụ: Để có cửa sổ 7 ngày liên tục bao gồm giá trị hiện tại và sáu giá trị trước đó, hãy sử dụng `.before = 6`. Để có cửa sổ "trung tâm", hãy cung cấp cùng một giá trị số cho cả `.before =` và `.after =`.

Theo mặc định, `.complete =` sẽ nhận giá trị FALSE nên nếu cửa sổ hoàn chỉnh của các hàng không tồn tại, các hàm sẽ sử dụng các hàng sẵn có để thực hiện phép tính. Thiết lập giá trị thành TRUE giúp hạn chế việc các phép tính chỉ được thực hiện trên các cửa sổ hoàn chỉnh.

**Mở rộng cửa sổ**

Để có các tính toán *tích lũy*, hãy thiết lập đối số `.before =` thành `Inf`. Điều này giúp tiến hành tính toán cả trên giá trị hiện tại và tất cả các giá trị trước đó.

### Cuộn theo ngày {#roll_index .unnumbered}

Trường hợp sử dụng có khả năng xảy ra nhất của tính toán biến động trong dịch tễ học ứng dụng là kiểm tra một số liệu *theo thời gian*. Ví dụ: đo lường động các ca mới mắc, dựa trên số lượng trường hợp hàng ngày.

Nếu bạn có dữ liệu chuỗi thời gian đã được làm sạch với đủ giá trị cho tất cả các ngày, bạn có thể sử dụng hàm `slide_dbl()`, như đã được trình bày trong chương [Chuỗi thời gian và phát hiện ổ dịch](#timeseries_moving).

Tuy nhiên, trong nhiều trường hợp dịch tễ học ứng dụng, bạn có thể gặp những ngày trống trong dữ liệu của mình, những ngày mà không có sự kiện nào được ghi lại. Trong những trường hợp này, tốt nhất là sử dụng các phiên bản "chỉ mục" của các hàm **slider**.

### Dữ liệu được lập chỉ mục {.unnumbered}

Dưới đây, chúng tôi trình bày một ví dụ sử dụng `slide_index_dbl()` đối với các trường hợp của bộ dữ liệu linelist. Giả sử rằng mục tiêu của chúng ta là tính toán tỷ lệ mới mắc liên tục trong 7 ngày - tính tổng các trường hợp bằng cách sử dụng cửa sổ 7 ngày luân phiên. Nếu bạn đang tìm kiếm ví dụ về trung bình động, hãy xem phần bên dưới về [cuộn theo nhóm](#roll_slider_group).

Để bắt đầu, bộ dữ liệu `daily_counts` được tạo ra để phản ánh số lượng ca mắc hàng ngày từ `linelist`, như đã được tính toán với hàm `count()` trong **dplyr**.

```{r}
# make dataset of daily counts
daily_counts <- linelist %>% 
  count(date_hospitalisation, name = "new_cases")
```

Dưới đây là data frame `daily_counts` - bao gồm `nrow(daily_counts)` hàng, mỗi hàng đại diện cho một ngày, nhưng đặc biệt trong giai đoạn đầu của dịch, *có một số ngày không xuất hiện (không có ca mắc nào được tiếp nhận vào những ngày đó)*.

```{r, echo=F}
DT::datatable(daily_counts, rownames = FALSE, options = list(pageLength = 6, scrollX=T) )
```

Điều quan trọng là phải nhận ra rằng một hàm cuộn tiêu chuẩn (như `slide_dbl()` sẽ sử dụng cửa sổ của 7 *hàng*, không phải 7 *ngày*. Vì vậy, nếu có bất kỳ ngày nào trống, một số cửa sổ sẽ thực sự kéo dài hơn 7 ngày theo lịch!

Một cửa sổ động "thông minh" có thể được tạo với hàm `slide_index_dbl()`. "Chỉ mục" có nghĩa là hàm sử dụng một *cột riêng biệt* làm "chỉ mục" cho cửa sổ động. Cửa sổ đó không chỉ đơn giản dựa trên các hàng của data frame.

Nếu cột chỉ mục là ngày, bạn có thêm khả năng xác định phạm vi cửa sổ cho `.before =` và/hoặc `.after =` theo đơn vị `days()` và `months()` của **lubridate**. Nếu bạn thực hiện những điều này, hàm sẽ bao gồm những ngày trống trong cửa sổ như thể chúng ở đó (dưới dạng giá trị `NA`).

Hãy đưa ra một so sánh. Dưới đây, chúng tôi tính toán số trường hợp mới mắc biến động trong 7 ngày với các cửa sổ thông thường và được lập chỉ mục.

```{r}
rolling <- daily_counts %>% 
  mutate(                                # create new columns
    # Using slide_dbl()
    ###################
    reg_7day = slide_dbl(
      new_cases,                         # calculate on new_cases
      .f = ~sum(.x, na.rm = T),          # function is sum() with missing values removed
      .before = 6),                      # window is the ROW and 6 prior ROWS
    
    # Using slide_index_dbl()
    #########################
    indexed_7day = slide_index_dbl(
        new_cases,                       # calculate on new_cases
        .i = date_hospitalisation,       # indexed with date_onset 
        .f = ~sum(.x, na.rm = TRUE),     # function is sum() with missing values removed
        .before = days(6))               # window is the DAY and 6 prior DAYS
    )

```

Quan sát trong cột thông thường cho 7 hàng đầu tiên, cách số lượng ca mắc tăng đều đặn *mặc dù các hàng không cách nhau 7 ngày*! Cột "được lập chỉ mục" liền kề tính cho những ngày lịch trống này, vì vậy tổng 7 ngày của nó thấp hơn nhiều, ít nhất là khi khoảng thời gian các ca mắc cách nhau xa hơn trong thời kỳ dịch bệnh này.

```{r, echo=F}
DT::datatable(rolling, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```

Bây giờ bạn có thể vẽ biểu đồ những dữ liệu này bằng cách sử dụng `ggplot()`:

```{r}
ggplot(data = rolling)+
  geom_line(mapping = aes(x = date_hospitalisation, y = indexed_7day), size = 1)
```

<!-- ### Biến động theo tháng {.unnumbered} -->

<!-- Nếu bạn muốn tính toán thống kê theo tháng (ví dụ: tổng, trung bình, max), bạn có thể thực hiện điều này với **dplyr** như đã được mô tả trong chương [Nhóm dữ liệu]. Chỉ cần tạo cột "tháng", nhóm dữ liệu và chạy các phép tính của bạn với `summarise()`. -->

<!-- Tuy nhiên, nếu bạn muốn tính toán thống kê động trong vài tháng (ví dụ: cửa sổ động 2 tháng), bạn có thể sử dụng hàm `slide_period()` từ **slider**. -->

<!-- ```{r} -->
<!-- monthly_mean = function(data){ -->
<!--   summarise(data, mean = mean(new_cases, na.rm=T)) -->
<!-- } -->
<!-- linelist %>% -->
<!--   count(date_hospitalisation, name = "new_cases") %>% -->
<!--   mutate( -->
<!--     slide_period_dfr( -->
<!--       new_cases,  -->
<!--       .i = date_hospitalisation, -->
<!--       .period = "month", -->
<!--       .f = monthly_mean))  #~mean(.x, na.rm=T))) -->
<!--      #values_col = new_cases, -->
<!--       #index_col = date_hospitalisation -->
<!--     )) -->

<!-- ``` -->

### Biến động theo nhóm {.unnumbered}

Nếu bạn nhóm dữ liệu của mình trước khi sử dụng hàm **slider**, các cửa sổ trượt sẽ được áp dụng theo nhóm. Hãy cẩn thận để sắp xếp các hàng của bạn với thứ tự mong muốn *theo nhóm*.

Mỗi khi một nhóm mới được tạo, cửa sổ trượt sẽ bắt đầu lại. Do đó, một điều cần lưu ý là nếu dữ liệu của bạn được nhóm lại và bạn đã thiết lập `.complete = TRUE`, bạn sẽ có các giá trị trống ở mỗi lần dịch chuyển giữa các nhóm. Khi hàm di chuyển xuống dưới qua các hàng, mọi dịch chuyển trong cột được nhóm sẽ bắt đầu lại việc cộng dồn kích thước cửa sổ tối thiểu để cho phép tính toán.

Xem chương [Nhóm dữ liệu] trong sổ tay này để biết thêm chi tiết về nhóm dữ liệu.

Dưới đây, chúng tôi đếm các ca mắc trong linelist theo ngày *và* theo bệnh viện. Sau đó, chúng tôi sắp xếp các hàng theo thứ tự tăng dần, thứ tự đầu tiên theo bệnh viện và sau đó là theo ngày. Tiếp theo, chúng tôi đặt `group_by()`. Cuối cùng, chúng tôi có thể tạo trung bình động mới của mình.

```{r}
grouped_roll <- linelist %>%
     
  count(hospital, date_hospitalisation, name = "new_cases") %>% 
     
  arrange(hospital, date_hospitalisation) %>%   # arrange rows by hospital and then by date
     
  group_by(hospital) %>%              # group by hospital 
     
  mutate(                             # rolling average  
    mean_7day_hosp = slide_index_dbl(
      .x = new_cases,                 # the count of cases per hospital-day
      .i = date_hospitalisation,      # index on date of admission
      .f = mean,                      # use mean()                  
      .before = days(6)               # use the day and the 6 days prior
      )
  )

```

Đây là bộ dữ liệu mới:

```{r, echo=F}
DT::datatable(grouped_roll, rownames = FALSE, options = list(pageLength = 12, scrollX=T) )
```

Bây giờ chúng ta có thể vẽ các đường trung bình động, hiển thị dữ liệu theo nhóm bằng cách chỉ định `~ hospital` tới `facet_wrap()` trong `ggplot()`. Để giải trí, chúng tôi vẽ hai biểu đồ - một biểu đồ cột `geom_col()` thể hiện số lượng ca mắc hàng ngày và một biểu đồ đường `geom_line()` thể hiện đường trung bình động của 7 ngày.

```{r, warning=F, message=F}
ggplot(data = grouped_roll)+
  geom_col(                       # plot daly case counts as grey bars
    mapping = aes(
      x = date_hospitalisation,
      y = new_cases),
    fill = "grey",
    width = 1)+
  geom_line(                      # plot rolling average as line colored by hospital
    mapping = aes(
      x = date_hospitalisation,
      y = mean_7day_hosp,
      color = hospital),
    size = 1)+
  facet_wrap(~hospital, ncol = 2)+ # create mini-plots per hospital
  theme_classic()+                 # simplify background  
  theme(legend.position = "none")+ # remove legend
  labs(                            # add plot labels
    title = "7-day rolling average of daily case incidence",
    x = "Date of admission",
    y = "Case incidence")
```

[***NGUY HIỂM:*** Nếu bạn gặp lỗi cho biết *"slide() was deprecated in tsibble 0.9.0 and is now defunct. Please use slider::slide() instead."*, điều đó có nghĩa là hàm `slide()` từ package **tsibble** đang đè lên hàm `slide()` từ package **slider**. Khắc phục lỗi này bằng cách cụ thể tên package trong lệnh, ví dụ `slider::slide_dbl()`.]{style="color: red;"}

<!-- Bạn có thể nhóm dữ liệu trước khi sử dụng hàm **slider**. Ví dụ: nếu bạn muốn tính tổng động trong 7 ngày tương tự như trên, nhưng theo bệnh viện, trên trung bình động thời gian chậm trễ từ khi bắt đầu có triệu chứng cho đến khi nhập viện (cột `days_onset_hosp`). -->

<!-- Bạn có thể nhóm dữ liệu theo tháng khởi phát triệu chứng bằng cách sử dụng `floor_date()` của **lubridate** như đã được mô tả trong chương [Nhóm dữ liệu]. Sau đó, sử dụng `slide_index_dbl()` như trên nhưng thiết lập phạm vi cửa sổ của bạn bằng cách sử dụng `months()` (cũng từ **lubridate**). -->

<!-- Nếu bạn muốn tính trung bình động theo *tháng*, bạn có thể sử dụng **lubridate** để nhóm dữ liệu theo tháng và sau đó áp dụng `slide_index_dbl()` như được trình bày dưới đây cho giá trị trung bình động trong ba tháng: -->

<!-- ```{r} -->
<!-- months_delay <- linelist %>% -->
<!--   arrange(date_onset) %>%    # drop rows missing date of onset -->

<!--   group_by(hospital) %>%  -->

<!--   #group_by(month_onset = floor_date(date_onset, "month")) %>% # create and group by month of onset -->

<!--   mutate( -->
<!--      delay_7d = slide_index_dbl( -->
<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->
<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window -->
<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->
<!--       .before = days(7)), -->

<!--      delay_month = slide_index_dbl( -->
<!--       days_onset_hosp,                  # calculate avg based on value in new_cases column -->
<!--       .i = date_onset,                 # index column is date_onset, so non-present dates are included in 7day window  -->
<!--       .f = ~mean(.x, na.rm = TRUE),     # function is mean() with missing values removed -->
<!--       .before = months(1)))               # window is the month and the prior month -->

<!-- # window is the month and the prior month -->

<!-- ``` -->

<!-- ```{r} -->
<!-- ggplot(data = months_delay, mapping = aes(x = month_onset))+ -->
<!--   geom_line(mapping = aes(y = )) -->
<!-- ``` -->

<!-- ======================================================= -->

## Tính toán với **tidyquant** trong `ggplot()`

Package **tidyquant** cung cấp một cách tiếp cận khác để tính toán đường trung bình động - lần này chính là từ *bên trong* lệnh `ggplot()`.

Dữ liệu `linelist` dưới đây được đếm theo ngày khởi phát và được vẽ dưới dạng một đường mờ (`alpha` \<1). Được phủ lên trên là một đường được tạo bằng hàm `geom_ma()` từ package **tidyquant**, với cửa sổ được thiết lập là 7 ngày (`n = 7`) với màu sắc và độ dày được chỉ định.

Theo mặc định, `geom_ma()` sử dụng một đường trung bình động đơn giản (`ma_fun = "SMA"`), tuy nhiên, hàm này cũng có thể sử dụng các loại đường trung bình khác, chẳng hạn như:

-   "EMA" - đường trung bình động lũy thừa (exponential moving average) (thêm trọng số cho các quan sát gần đây)\
-   "WMA" - đường trung bình động có trọng số (weighted moving average) (`wts` được sử dụng để đánh trọng số các quan sát trong đường trung bình động)\
-   Các loại đường trung bình động khác có thể được tìm thấy trong tài liệu về hàm

```{r}
linelist %>% 
  count(date_onset) %>%                 # count cases per day
  drop_na(date_onset) %>%               # remove cases missing onset date
  ggplot(aes(x = date_onset, y = n))+   # start ggplot
    geom_line(                          # plot raw values
      size = 1,
      alpha = 0.2                       # semi-transparent line
      )+             
    tidyquant::geom_ma(                 # plot moving average
      n = 7,           
      size = 1,
      color = "blue")+ 
  theme_minimal()                       # simple background
```

Xem [tài liệu](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html) này để biết thêm chi tiết về các tùy chọn sẵn có trong **tidyquant**.

<!-- ## Hồi quy động -->

<!-- ```{r} -->
<!-- a <- linelist %>%  -->
<!--   separate(time_admission, into = c("hour", "minute"), sep = ":") %>%  -->

<!--   count(days_onset_hosp, hour) %>%  -->

<!--   mutate(reg_admit_hour = slide(., ~lm(days_onset_hosp ~ hour), .before = 3, .complete = T)) %>%  -->

<!--   mutate(coeff = reg_admit_hour[[1]]) -->

<!-- ggplot()+ -->
<!--   geom_point(aes(x = hour, y = days_onset_hosp)) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- linelist %>% -->
<!--   mutate( -->
<!--   ) -->
<!-- ``` -->

<!-- ======================================================= -->

## Tài nguyên học liệu

Xem thông tin trực tuyến hữu ích về [vignette for the **slider** package](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)

[Trang github](https://github.com/DavisVaughan/slider) về **Slider**

Một [vignette](https://davisvaughan.github.io/slider/articles/slider.html) **slider**

[tidyquant vignette](https://cran.r-project.org/web/packages/tidyquant/vignettes/TQ04-charting-with-tidyquant.html)

Nếu tình huống sử dụng của bạn yêu cầu "bỏ qua" các ngày cuối tuần và thậm chí là những ngày lễ, bạn có thể quan tâm đến package **almanac**.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/moving_average.Rmd-->


# Chuỗi thời gian và phát hiện ổ dịch {#time-series}  

<!-- ======================================================= -->
## Tổng quan {  }

Chương này minh họa cách sử dụng của một số packages cho phân tích chuỗi thời gian. Các packages chủ yếu đến từ hệ sinh thái [**tidyverts**](https://tidyverts.org/), ngoài ra cũng sử dụng RECON [**trending**](https://github.com/reconhub/trending) package để fit các mô hình dịch tễ học bệnh truyền nhiễm. 

VÍ dụ dưới đây chúng ta sẽ sử dụng bộ dữ liệu về Campylobacter ở Germanywe thuộc package **surveillance** (xem chương [Tải sách và dữ liệu] để biết thêm chi tiết). Tuy nhiên, nếu bạn muốn thử chạy code này trên bộ dữ liệu lớn hơn (nhiều quốc gia hoặc tầng), bạn có thể tham khảo code mẫu tại [repo github của r4epis](https://github.com/R4EPI/epitsa). 

Các chủ đề được đề cập bao gồm:  

1.  Dữ liệu chuỗi thời gian 
2.  Phân tích mô tả 
3.  Fitting đường hồi quy
4.  Mối liên hệ của hai chuỗi thời gian 
5.  Phát hiện dịch bệnh
6.  Chuỗi thời gian bị gián đoạn


<!-- ======================================================= -->
## Chuẩn bị {  }

### Packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R. 

```{r load_packages}
pacman::p_load(rio,          # File import
               here,         # File locator
               tidyverse,    # data management + ggplot2 graphics
               tsibble,      # handle time series datasets
               slider,       # for calculating moving averages
               imputeTS,     # for filling in missing values
               feasts,       # for time series decomposition and autocorrelation
               forecast,     # fit sin and cosin terms to data (note: must load after feasts)
               trending,     # fit and assess models 
               tmaptools,    # for getting geocoordinates (lon/lat) based on place names
               ecmwfr,       # for interacting with copernicus sateliate CDS API
               stars,        # for reading in .nc (climate data) files
               units,        # for defining units of measurement (climate data)
               yardstick,    # for looking at model accuracy
               surveillance  # for aberration detection
               )
``` 

### Nhập dữ liệu {.unnumbered}

Bạn có thể tải xuống tất cả dữ liệu được sử dụng trong sổ tay này thông qua các hướng dẫn trong chương [Tải sách và dữ liệu].  

Bộ dữ liệu minh họa được sử dụng trong phần này là số lượng các trường hợp campylobacter hàng tuần được báo cáo ở Đức từ năm 2001 đến 2011. <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/time_series/campylobacter_germany.xlsx' class='download-button'>Bạn có thể bấm vào đây để tải xuống<span> bộ dữ liệu này (.xlsx).</span></a> 

Bộ dữ liệu này là một phiên bản rút gọn của bộ dữ liệu có sẵn trong package [**surveillance**](https://cran.r-project.org/web/packages/surveillance/). (để biết chi tiết, hãy gọi surveillance package ra sau đó nhập `?campyDE`)

Nhập dữ liệu này với hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r read_data_hide, echo=F}
# import the counts into R
counts <- rio::import(here::here("data", "time_series", "campylobacter_germany.xlsx"))
```

```{r read_data_show, eval=F}
# import the counts into R
counts <- rio::import("campylobacter_germany.xlsx")
```

10 hàng đầu tiên được hiển thị như bên dưới.

```{r inspect_data, message=FALSE, echo=F}
# display the counts data as a table
DT::datatable(head(counts, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Làm sạch dữ liệu {.unnumbered}

Code dưới đây đảm bảo rằng cột ngày thág đã ở đúng định dạng. Trong chương này chúng ta sẽ sử dụng package **tsibble** và hàm `yearweek` sẽ được sử dụng để tạp biến lịch theo tuần. Có một số cách để thực hiện việc này (Xem chương [Làm việc với ngày tháng] để biết thêm chi tiết), tuy nhiên đối với dữ liệu chuỗi thời gian thì tốt nhất nên sử dụng thống nhất một framework (**tsibble**). 

```{r clean_data}

## ensure the date column is in the appropriate format
counts$date <- as.Date(counts$date)

## create a calendar week variable 
## fitting ISO definitons of weeks starting on a monday
counts <- counts %>% 
     mutate(epiweek = yearweek(date, week_start = 1))

```

### Tải xuống dữ liệu khí hậu {.unnumbered} 

Trong mục *mối tương quan của hai chuỗi thời gian* trong chương này, chúng ta sẽ so sánh số lượng trường hợp campylobacter với dữ liệu khí hậu. 
Dữ liệu khí hậu tại bất kỳ đâu trên thế giới đều có thể được tải xuống từ EU's Copernicus Satellite. Đây không phải là các phép đo chính xác, mà dựa trên một mô hình (tương tự như phép nội suy), tuy nhiên lợi ích là mức độ bao phủ toàn cầu hàng giờ cũng như các dự báo.

Bạn có thể tải xuống từng tệp dữ liệu khí hậu này từ chương [Tải sách và dữ liệu].  

Với mục đích minh họa ở đây, chúng tôi sẽ trình bày code để sử dụng package **ecmwfr** để lấy những dữ liệu này từ kho dữ liệu khí hậu Copernicus. Bạn sẽ cần tạo một tài khoản miễn phí để thực hiện. Trang web của package có một [hướng dẫn](https://github.com/bluegreen-labs/ecmwfr#use-copernicus-climate-data-store-cds) hữu ích về cách thực hiện việc này. Dưới đây là code minh họa về cách thực hiện việc này, khi bạn có các khóa API thích hợp. Bạn phải thay thế X bên dưới bằng ID tài khoản của mình. Bạn sẽ cần tải xuống một năm dữ liệu cùng một lúc nếu không máy chủ sẽ hết thời gian chờ. 

Nếu bạn không chắc chắn về tọa độ cho vị trí mà bạn muốn tải dữ liệu xuống, bạn có thể sử dụng gói **tmaptools** để lấy tọa độ ra từ open street maps. Một cách khác là dùng package [**photon**](https://github.com/rCarto/photon), tuy nhiên nó chưa được chính thức xuất bản lên trên CRAN; cái hay của **photon** là nó cung cấp nhiều dữ liệu ngữ cảnh hơn khi có một số kết quả phù hợp cho tìm kiếm của bạn.

```{r weather_data, eval = FALSE}

## retrieve location coordinates
coords <- geocode_OSM("Germany", geometry = "point")

## pull together long/lats in format for ERA-5 querying (bounding box) 
## (as just want a single point can repeat coords)
request_coords <- str_glue_data(coords$coords, "{y}/{x}/{y}/{x}")


## Pulling data modelled from copernicus satellite (ERA-5 reanalysis)
## https://cds.climate.copernicus.eu/cdsapp#!/software/app-era5-explorer?tab=app
## https://github.com/bluegreen-labs/ecmwfr

## set up key for weather data 
wf_set_key(user = "XXXXX",
           key = "XXXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXX",
           service = "cds") 

## run for each year of interest (otherwise server times out)
for (i in 2002:2011) {
  
  ## pull together a query 
  ## see here for how to do: https://bluegreen-labs.github.io/ecmwfr/articles/cds_vignette.html#the-request-syntax
  ## change request to a list using addin button above (python to list)
  ## Target is the name of the output file!!
  request <- request <- list(
    product_type = "reanalysis",
    format = "netcdf",
    variable = c("2m_temperature", "total_precipitation"),
    year = c(i),
    month = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"),
    day = c("01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12",
            "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24",
            "25", "26", "27", "28", "29", "30", "31"),
    time = c("00:00", "01:00", "02:00", "03:00", "04:00", "05:00", "06:00", "07:00",
             "08:00", "09:00", "10:00", "11:00", "12:00", "13:00", "14:00", "15:00",
             "16:00", "17:00", "18:00", "19:00", "20:00", "21:00", "22:00", "23:00"),
    area = request_coords,
    dataset_short_name = "reanalysis-era5-single-levels",
    target = paste0("germany_weather", i, ".nc")
  )
  
  ## download the file and store it in the current working directory
  file <- wf_request(user     = "XXXXX",  # user ID (for authentication)
                     request  = request,  # the request
                     transfer = TRUE,     # download the file
                     path     = here::here("data", "Weather")) ## path to save the data
  }

```

### Nhập dữ liệu khí hậu {.unnumbered}

Cho dù bạn đã tải xuống dữ liệu khí hậu thông qua sổ tay này hay sử dụng code ở trên, thì bạn cần phải các tệp dữ liệu khí hậu trong 10 năm có phần mở rộng là ".nc", được lưu trữ trong cùng một thư mục trong máy tính của bạn.  

Sử dụng mã bên dưới để nhập các tệp này vào R với package **stars**. 

```{r read_climate, warning = FALSE, message = FALSE}

## define path to weather folder 
file_paths <- list.files(
  here::here("data", "time_series", "weather"), # replace with your own file path 
  full.names = TRUE)

## only keep those with the current name of interest 
file_paths <- file_paths[str_detect(file_paths, "germany")]

## read in all the files as a stars object 
data <- stars::read_stars(file_paths)
```

Khi các tệp này đã được nhập vào một đối tượng có tên `data`, chúng ta sẽ chuyển chúng thành một data frame.  

```{r}
## change to a data frame 
temp_data <- as_tibble(data) %>% 
  ## add in variables and correct units
  mutate(
    ## create an calendar week variable 
    epiweek = tsibble::yearweek(time), 
    ## create a date variable (start of calendar week)
    date = as.Date(epiweek),
    ## change temperature from kelvin to celsius
    t2m = set_units(t2m, celsius), 
    ## change precipitation from metres to millimetres 
    tp  = set_units(tp, mm)) %>% 
  ## group by week (keep the date too though)
  group_by(epiweek, date) %>% 
  ## get the average per week
  summarise(t2m = as.numeric(mean(t2m)), 
            tp = as.numeric(mean(tp)))

```




<!-- ======================================================= -->
## Dữ liệu chuỗi thời gian {  }

Có một số package khác nhau để cấu trúc và xử lý dữ liệu chuỗi thời gian. Như đã nói, chúng ta sẽ tập trung vào họ các package thuộc **tidyverts** và sẽ sử dụng package **tsibble** để xác định đối tượng chuỗi thời gian. Việc có một tập dữ liệu được xác định là một đối tượng chuỗi thời gian có nghĩa là việc cấu trúc phân tích của chúng ta sẽ trở nên dễ dàng hơn nhiều.

Để thực hiện, chúng ta sử dụng hàm `tsibble()` và cụ thể "chỉ mục (index)", vd: biến số cụ thể đơn vị thời gian quan tâm. Trong trường hợp của chúng ta, biến số này có tên `epiweek`. 

Ví dụ: nếu chúng ta có một tập dữ liệu với số lượng hàng tuần theo tỉnh, chúng ta cũng có thể cụ thể biến nhóm bằng cách cụ sử dụng đối số `key = `. Điều này sẽ cho phép chúng ta thực hiện phân tích cho từng nhóm.


```{r ts_object}

## define time series object 
counts <- tsibble(counts, index = epiweek)

```

Nhìn vào `class(counts)`, ta thấy ngoài việc là một data frame gọn gàng ("tbl_df", "tbl", "data.frame"), nó có các thuộc tính bổ sung của một khung dữ liệu chuỗi thời gian ("tbl_ts"). 

Bạn có thể xem nhanh dữ liệu của mình bằng cách sử dụng **ggplot2**. Từ biểu đồ ta thấy có một xu hướng theo mùa, và không có bất kỳ giá trị bị thiếu nào. Tuy nhiên, dường như có vấn đề với việc báo cáo vào đầu mỗi năm; số ca mắc bệnh giảm vào tuần cuối cùng của năm và sau đó tăng vào tuần đầu tiên của năm tiếp theo.

```{r basic_plot}

## plot a line graph of cases by week
ggplot(counts, aes(x = epiweek, y = case)) + 
     geom_line()

```


<span style="color: red;">**_NGUY HIỂM:_** Không giống như ví dụ này, phần lớn các bộ dữ liệu sẽ chưa được làm sạch. Bạn sẽ cần phải kiểm tra các bản ghi trùng lặp và bản ghi bị thiếu như bên dưới.</span>

<!-- ======================================================= -->
### Trùng lặp {.unnumbered}

**tsibble** không cho phép các quan sát trùng lặp. Vì vậy, mỗi hàng sẽ cần phải là duy nhất, hoặc duy nhất trong nhóm (biến `key`). Package này có một số hàm để xác định các bản ghi trùng lặp. Chúng bao gồm các hàm: `are_duplicated()` trả về một vectơ có giá trị TRUE/FALSE vector, truy vấn xem hàng có là duy nhất không; và hàm `duplicates()` sẽ cung cấp cho bạn một data frame chứa các hàng trùng lặp. 

Xem chương [Loại bỏ trùng lặp] để biết thêm chi tiết về cách lựa chọn các hàng bạn muốn. 

```{r duplicates, eval = FALSE}

## get a vector of TRUE/FALSE whether rows are duplicates
are_duplicated(counts, index = epiweek) 

## get a data frame of any duplicated rows 
duplicates(counts, index = epiweek) 

```

<!-- ======================================================= -->
### Bản ghi bị thiếu {.unnumbered}

Chúng ta đã thấy từ cuộc khảo sát tóm tắt bên trên, không có bất kỳ giá trị missing nào được phát hiện, nhưng chúng ta cũng đã thấy rằng dường như có vấn đề với việc báo cáo chậm trễ vào khoảng năm mới. Một cách để giải quyết vấn đề này có thể là đặt các giá trị này thành missing và sau đó impute các giá trị. Dạng đơn giản nhất của khi impute chuỗi thời gian là vẽ một đường thẳng giữa giá trị không bị thiếu cuối cùng và giá trị không bị thiếu tiếp theo. Để làm điều này, chúng ta sẽ sử dụng hàm `na_interpolation()` từ package **imputeTS** . 

Xem chương [Dữ liệu Missing] để biết các tùy chọn khác của imputation.  

Một giải pháp thay thế khác sẽ là tính toán đường trung bình động, để thử và giải quyết các vấn đề báo cáo rõ ràng này (xem phần tiếp theo và chương [Đường trung bình động]. 

```{r missings}

## create a variable with missings instead of weeks with reporting issues
counts <- counts %>% 
     mutate(case_miss = if_else(
          ## if epiweek contains 52, 53, 1 or 2
          str_detect(epiweek, "W51|W52|W53|W01|W02"), 
          ## then set to missing 
          NA_real_, 
          ## otherwise keep the value in case
          case
     ))

## alternatively interpolate missings by linear trend 
## between two nearest adjacent points
counts <- counts %>% 
  mutate(case_int = imputeTS::na_interpolation(case_miss)
         )

## to check what values have been imputed compared to the original
ggplot_na_imputations(counts$case_miss, counts$case_int) + 
  ## make a traditional plot (with black axes and white background)
  theme_classic()

```




<!-- ======================================================= -->
## Phân tích mô tả {  }



<!-- ======================================================= -->
### Đường trung bình động {#timeseries_moving .unnumbered}

Nếu dữ liệu rất nhiễu (dao động lên và xuống), việc tính toán đường trung bình động có thể sẽ hữu ích. Trong ví dụ dưới đây, với mỗi tuần chúng ta sẽ tính toán số trường hợp trung bình từ bốn tuần trước đó. Việc này sẽ giúp dữ liệu dễ diễn giải hơn. Trong trường hợp của chúng ta, điều này không thực sự bổ sung nhiều, vì vậy chúng ta sẽ bám vào dữ liệu nội suy để phân tích thêm. Xem chương [Đường trung bình động] để biết thêm chi tiết. 

```{r moving_averages}

## create a moving average variable (deals with missings)
counts <- counts %>% 
     ## create the ma_4w variable 
     ## slide over each row of the case variable
     mutate(ma_4wk = slider::slide_dbl(case, 
                               ## for each row calculate the name
                               ~ mean(.x, na.rm = TRUE),
                               ## use the four previous weeks
                               .before = 4))

## make a quick visualisation of the difference 
ggplot(counts, aes(x = epiweek)) + 
     geom_line(aes(y = case)) + 
     geom_line(aes(y = ma_4wk), colour = "red")

```


<!-- ======================================================= -->
### Tính chu kỳ {.unnumbered}

Sau đây chúng ta sẽ định nghĩa một hàm để tạo một biểu đồ chu kỳ. Xem chương [Viết hàm] để biết cách tạo một hàm trong R.  

Đầu tiên, hàm được định nghĩa. Các đối số của nó bao gồm một bộ dữ liệu với cột `counts`, `start_week = ` là tuần đầu tiên của bộ dữ liệu, một con số để cho biết có bao nhiêu chu kỳ mỗi năm (ví dụ: 52, 12), và cuối cùng là kiểu đầu ra (xem chi tiết trong đoạn mã bên dưới). 


```{r periodogram}
## Function arguments
#####################
## x is a dataset
## counts is variable with count data or rates within x 
## start_week is the first week in your dataset
## period is how many units in a year 
## output is whether you want return spectral periodogram or the peak weeks
  ## "periodogram" or "weeks"

# Define function
periodogram <- function(x, 
                        counts, 
                        start_week = c(2002, 1), 
                        period = 52, 
                        output = "weeks") {
  

    ## make sure is not a tsibble, filter to project and only keep columns of interest
    prepare_data <- dplyr::as_tibble(x)
    
    # prepare_data <- prepare_data[prepare_data[[strata]] == j, ]
    prepare_data <- dplyr::select(prepare_data, {{counts}})
    
    ## create an intermediate "zoo" time series to be able to use with spec.pgram
    zoo_cases <- zoo::zooreg(prepare_data, 
                             start = start_week, frequency = period)
    
    ## get a spectral periodogram not using fast fourier transform 
    periodo <- spec.pgram(zoo_cases, fast = FALSE, plot = FALSE)
    
    ## return the peak weeks 
    periodo_weeks <- 1 / periodo$freq[order(-periodo$spec)] * period
    
    if (output == "weeks") {
      periodo_weeks
    } else {
      periodo
    }
    
}

## get spectral periodogram for extracting weeks with the highest frequencies 
## (checking of seasonality) 
periodo <- periodogram(counts, 
                       case_int, 
                       start_week = c(2002, 1),
                       output = "periodogram")

## pull spectrum and frequence in to a dataframe for plotting
periodo <- data.frame(periodo$freq, periodo$spec)

## plot a periodogram showing the most frequently occuring periodicity 
ggplot(data = periodo, 
                aes(x = 1/(periodo.freq/52),  y = log(periodo.spec))) + 
  geom_line() + 
  labs(x = "Period (Weeks)", y = "Log(density)")


## get a vector weeks in ascending order 
peak_weeks <- periodogram(counts, 
                          case_int, 
                          start_week = c(2002, 1), 
                          output = "weeks")

```

<span style="color: black;">**_LƯU Ý:_** Có thể sử dụng các tuần ở trên để thêm chúng vào các chu kỳ sin và cosin, tuy nhiên chúng ta sẽ sử dụng một hàm để tạo ra các chu kỳ này (xem phần hồi quy bên dưới) </span>

<!-- ======================================================= -->
### Tách nhỏ chuỗi thời gian {.unnumbered}

Phân tách cổ điển được sử dụng để chia nhỏ một chuỗi thời gian thành một số phần, khi kết hợp lại với nhau sẽ tạo nên xu hướng mà bạn nhìn thấy. Các phần khác nhau này là:  

* Chu kỳ xu hướng (hướng dài hạn của dữ liệu)  
* Theo mùa (lặp lại xu hướng)  
* Sự ngẫu nhiên (những gì còn lại sau khi loại bỏ xu hướng và theo mùa)  


```{r decomposition, warning=F, message=F}

## decompose the counts dataset 
counts %>% 
  # using an additive classical decomposition model
  model(classical_decomposition(case_int, type = "additive")) %>% 
  ## extract the important information from the model
  components() %>% 
  ## generate a plot 
  autoplot()

```

<!-- ======================================================= -->
### Tự tương quan {.unnumbered}

Tự tương quan cho bạn biết về mối quan hệ giữa số lượng của mỗi tuần và các tuần trước đó (được gọi là trễ).

Sử dụng hàm `ACF()`, chúng ta có thể tạo ra một biểu đồ cho chúng ta thấy số lượng đường có mối quan hệ ở các độ trễ khác nhau. Khi độ trễ bằng 0 (x = 0), đường này sẽ luôn là 1 vì nó cho thấy mối quan hệ giữa một quan sát và chính nó (không được hiển thị). Đường đầu tiên hiển thị ở đây (x = 1) cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước nó (độ trễ bằng 1), đường thứ hai cho thấy mối quan hệ giữa mỗi quan sát và quan sát trước quan sát cuối cùng (độ trễ là 2) và cứ như thế cho đến khi độ trễ là 52, cho thấy mối quan hệ giữa mỗi quan sát và quan sát từ 1 năm (52 tuần trước đó).  

Sử dụng hàm `ACF()` (cho tự tương quan một phần) hiển thị cùng một loại quan hệ nhưng được hiệu chỉnh cho tất cả các tuần khác nằm giữa. Nó sẽ ít thông tin hơn để xác định tính chu kỳ.

```{r autocorrelation}

## using the counts dataset
counts %>% 
  ## calculate autocorrelation using a full years worth of lags
  ACF(case_int, lag_max = 52) %>% 
  ## show a plot
  autoplot()

## using the counts data set 
counts %>% 
  ## calculate the partial autocorrelation using a full years worth of lags
  PACF(case_int, lag_max = 52) %>% 
  ## show a plot
  autoplot()

```

Bạn có thể kiểm định giả thuyết không về tính độc lập trong một chuỗi thời gian (vd: không tự tương quan) sử dụng kiểm định Ljung-Box (trong package **stats**). Giá trị p có ý nghĩa cho thấy rằng có sự tự tương quan trong dữ liệu.

```{r ljung_box}

## test for independance 
Box.test(counts$case_int, type = "Ljung-Box")

```


<!-- ======================================================= -->
## Fit mô hình hồi quy {  }

Có thể fit một số lượng lớn các hồi quy khác nhau vào một chuỗi thời gian, tuy nhiên ở đây chúng tôi sẽ trình bày cách để fit một hồi quy nhị thức âm - vì nó thường phù hợp nhất cho dữ liệu về trường hợp bệnh trong các bệnh truyền nhiễm. 

<!-- ======================================================= -->
### Chu kỳ Fourier {.unnumbered}

Chu kỳ Fourier tương đương với các đường cong sin và cosin. Sự khác biệt là chúng được dựa trên việc tìm ra sự kết hợp thích hợp nhất của các đường cong để giải thích dữ liệu của bạn.  

If only fitting một chu kỳ Fourier, điều này sẽ tương đương với việc fitting một đường sin và cosin cho độ trễ xảy ra thường xuyên nhất được thấy trong biểu đồ chu kỳ của bạn (trong trường hợp của chúng ta là 52 tuần). Chúng ta sử dụng hàm `fourier()` từ package **forecast**.  

Trong code dưới đây, chúng ta gán bằng cách sử dụng `$`, vì hàm `fourier()` trả về hai cột (một cho sin và một cho cosin) và vì vậy chúng được thêm vào tập dữ liệu dưới dạng danh sách, được gọi là "fourier" - nhưng danh sách này sau đó có thể được sử dụng như một biến bình thường trong hồi quy. 

```{r fourier}

## add in fourier terms using the epiweek and case_int variabless
counts$fourier <- select(counts, epiweek, case_int) %>% 
  fourier(K = 1)
```

<!-- ======================================================= -->
### Hồi quy nhị thức âm {.unnumbered}

Bạn có thể fit các mô hình hồi quy sử dụng các hàm từ package **stats** hoặc **MASS** trong base R (vd: `lm()`, `glm()` và `glm.nb()`). Tuy nhiên, chúng ta sẽ sử dụng các hàm từ package **trending**, vì nó cho phép tính khoảng tin cậy và khoảng tiên lượng phù hợp (các hàm khác không có sẵn). Cú pháp vẫn như vậy, bạn cụ thể biến đầu ra và theo sau bởi dấu ngã (~), sau đó thêm các biến giải thích vào, phân cách nhau bởi dấu cộng (+). 

Sự khác biệt là đầu tiên chúng ta phải xác định model trước, và sau đó `fit()` nó vào dữ liệu. Điều này rất hữu ích vì nó cho phép so sánh nhiều mô hình khác nhau với cùng một cú pháp.. 

<span style="color: darkgreen;">**_MẸO:_** Nếu bạn muốn sử dụng tỷ suất hơn là số lượng, bạn có thể bao gồm biến dân số dưới dạng thuật ngữ bù logarit, bằng cách thêm `offset(log(population)`. Sau đó, bạn sẽ cần đặt dân số là 1, trước khi sử dụng hàm `predict()` để tạo ra tỷ suất. </span>

<span style="color: darkgreen;">**_MẸO:_** Để fit những mô hình phức tạp hơn chẳng hạn như ARIMA hoặc prophet, hãy tham khảo package [**fable**](https://fable.tidyverts.org/index.html).</span>

```{r nb_reg, warning = FALSE}

## define the model you want to fit (negative binomial) 
model <- glm_nb_model(
  ## set number of cases as outcome of interest
  case_int ~
    ## use epiweek to account for the trend
    epiweek +
    ## use the fourier terms to account for seasonality
    fourier)

## fit your model using the counts dataset
fitted_model <- trending::fit(model, counts)

## calculate confidence intervals and prediction intervals 
observed <- predict(fitted_model, simulate_pi = FALSE)

## plot your regression 
ggplot(data = observed, aes(x = epiweek)) + 
  ## add in a line for the model estimate
  geom_line(aes(y = estimate),
            col = "Red") + 
  ## add in a band for the prediction intervals 
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## add in a line for your observed case counts
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## make a traditional plot (with black axes and white background)
  theme_classic()


```

<!-- ======================================================= -->
### Phần dư {.unnumbered}

Để xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào, chúng ta cần xem xét phần dư. Phần dư là sự khác biệt giữa số lượng được quan sát và số lượng được ước tính từ mô hình. Chúng ta có thể tính toán nó một cách đơn giản bằng cách dùng hàm `case_int - estimate`, nhưng hàm `residuals()` trích xuất nó trực tiếp từ mô hình hồi quy cho chúng ta.

Những gì chúng ta thấy dưới đây là chúng ta không giải thích tất cả các sự dao động mà chúng ta có thể có với mô hình. Có thể chúng ta cần fit nhiều chu kỳ fourier hơn, và gủau quyết biên độ. Tuy nhiên đối với ví dụ này, chúng ta sẽ để nguyên như vậy. Các biểu đồ cho thấy mô hình của chúng ta hoạt động kém hơn ở các đỉnh và đáy (khi số lượng ở mức cao nhất và thấp nhất) và có nhiều khả năng ước tính không đầy đủ các số lượng quan sát được. 

```{r, warning=F, message=F}

## calculate the residuals 
observed <- observed %>% 
  mutate(resid = residuals(fitted_model$fitted_model, type = "response"))

## are the residuals fairly constant over time (if not: outbreaks? change in practice?)
observed %>%
  ggplot(aes(x = epiweek, y = resid)) +
  geom_line() +
  geom_point() + 
  labs(x = "epiweek", y = "Residuals")

## is there autocorelation in the residuals (is there a pattern to the error?)  
observed %>% 
  as_tsibble(index = epiweek) %>% 
  ACF(resid, lag_max = 52) %>% 
  autoplot()

## are residuals normally distributed (are under or over estimating?)  
observed %>%
  ggplot(aes(x = resid)) +
  geom_histogram(binwidth = 100) +
  geom_rug() +
  labs(y = "count") 
  
## compare observed counts to their residuals 
  ## should also be no pattern 
observed %>%
  ggplot(aes(x = estimate, y = resid)) +
  geom_point() +
  labs(x = "Fitted", y = "Residuals")

## formally test autocorrelation of the residuals
## H0 is that residuals are from a white-noise series (i.e. random)
## test for independence 
## if p value significant then non-random
Box.test(observed$resid, type = "Ljung-Box")

```

<!-- ======================================================= -->
## Mối quan hệ của hai chuỗi thời gian {  }

Ở đây chúng ta xem xét việc sử dụng dữ liệu thời tiết (đặc biệt là nhiệt độ) để giải thích số lượng trường hợp campylobacter. 

<!-- ======================================================= -->
### Nối hai bộ dữ liệu {.unnumbered}

Bạn có thể nối các tập dữ liệu của mình sử dụng biến tuần. Để biết thêm về nối dữ liệu, xem chương [Nối dữ liệu].

```{r join}

## left join so that we only have the rows already existing in counts
## drop the date variable from temp_data (otherwise is duplicated)
counts <- left_join(counts, 
                    select(temp_data, -date),
                    by = "epiweek")

```

<!-- ======================================================= -->
### Phân tích mô tả {.unnumbered}

Đầu tiên hãy trực quan hóa dữ liệu của bạn để kiểm tra xem có bất kỳ mối tương quan rõ ràng nào không. Biểu đồ dưới đây cho thấy một mối quan hệ rõ ràng về tính mùa vụ của các biến, và nhiệt độ có thể đạt đỉnh vài tuần trước khi các trường hợp xảy ra. Để biết thêm về xoay trục dữ liệu, xem chương [Xoay trục dữ liệu]. 

```{r basic_plot_bivar}

counts %>% 
  ## keep the variables we are interested 
  select(epiweek, case_int, t2m) %>% 
  ## change your data in to long format
  pivot_longer(
    ## use epiweek as your key
    !epiweek,
    ## move column names to the new "measure" column
    names_to = "measure", 
    ## move cell values to the new "values" column
    values_to = "value") %>% 
  ## create a plot with the dataset above
  ## plot epiweek on the x axis and values (counts/celsius) on the y 
  ggplot(aes(x = epiweek, y = value)) + 
    ## create a separate plot for temperate and case counts 
    ## let them set their own y-axes
    facet_grid(measure ~ ., scales = "free_y") +
    ## plot both as a line
    geom_line()

```

<!-- ======================================================= -->
### Lags và tương quan chéo {.unnumbered}

Để kiểm định xem những tuần nào có tương quan nhiều nhất tới các trường hợp và nhiệt độ, bạn có thể sử dụng hàm tương quan chéo (`CCF()`) từ package **feasts**. Bạn cũng có thể trực quan hóa (hơn là sử dụng `arrange`) sử dụng hàm `autoplot()`. 

```{r cross_correlation, warning=FALSE}

counts %>% 
  ## calculate cross-correlation between interpolated counts and temperature
  CCF(case_int, t2m,
      ## set the maximum lag to be 52 weeks
      lag_max = 52, 
      ## return the correlation coefficient 
      type = "correlation") %>% 
  ## arange in decending order of the correlation coefficient 
  ## show the most associated lags
  arrange(-ccf) %>% 
  ## only show the top ten 
  slice_head(n = 10)

```

Chúng ta thấy rằng độ trễ 4 tuần có mối tương quan cao nhất, vì vậy chúng ta tạo một biến nhiệt độ trễ để đưa vào mô hình hồi quy. 

<span style="color: red;">**_NGUY HIỂM:_** Lưu ý rằng bốn tuần đầu tiên dữ liệu của chúng ta trong biến nhiệt độ trễ bị thiếu (`NA`) - bởi vì không có bốn tuần trước đó để lấy dữ liệu. Để sử dụng bộ dữ liệu này với hàm **trending** `predict()`, chúng ta cần phải sử dụng đối số `simulate_pi = FALSE` bên trong hàm `predict()`. Nếu chúng ta muốn sử dụng tùy chọn mô phỏng, thì chúng ta phải loại bỏ các giá trị missings và lưu thành một bộ dữ liệu mới bằng cách thêm hàm `drop_na(t2m_lag4)` vào đoạn code dưới đây.</span>  
 

```{r lag_tempvar}

counts <- counts %>% 
  ## create a new variable for temperature lagged by four weeks
  mutate(t2m_lag4 = lag(t2m, n = 4))

```


<!-- ======================================================= -->
### Hồi quy nhị thức âm với hai biến số {.unnumbered}

Chúng ta sẽ fit một mô hình hồi quy nhị thức âm như đã thực hiện trước đó. Lần này chúng ta thêm biến nhiệt độ có độ trễ là bốn tuần. 

<span style="color: orange;">**_CẨN TRỌNG:_** Lưu ý cách sử dụng của đối số `simulate_pi = FALSE` bên trong hàm `predict()`. Điều này là bởi hành vi mặc định của **trending** là sử dụng package **ciTools** để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị `NA`, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem `?trending::predict.trending_model_fit` để biết thêm chi tiết. </span>  

```{r nb_reg_bivar, warning = FALSE}

## define the model you want to fit (negative binomial) 
model <- glm_nb_model(
  ## set number of cases as outcome of interest
  case_int ~
    ## use epiweek to account for the trend
    epiweek +
    ## use the fourier terms to account for seasonality
    fourier + 
    ## use the temperature lagged by four weeks 
    t2m_lag4
    )

## fit your model using the counts dataset
fitted_model <- trending::fit(model, counts)

## calculate confidence intervals and prediction intervals 
observed <- predict(fitted_model, simulate_pi = FALSE)

```


Để khảo sát các chu kỳ đơn lẻ, chúng ta có thể lấy mô hình hồi quy nhị thức âm gốc ra khỏi định dạng **trending** bằng cách sử dụng hàm `get_model()` và chuyển nó tới hàm `tidy()` của package **broom** để truy xuất các ước tính được lũy thừa hóa và các khoảng tin cậy.  

Điều này cho chúng ta thấy là nhiệt độ trễ, sau khi kiểm soát xu hướng và tính theo mùa, tương tự như số lượng trường hợp (ước tính ~ 1) và sự liên quan có ý nghĩa. Điều này cho thấy rằng nó có thể là một biến số tốt để sử dụng trong việc dự báo các ca bệnh trong tương lai (các dữ liệu dự báo khí hậu luôn có sẵn). 

```{r results_nb_reg_bivar}

fitted_model %>% 
  ## extract original negative binomial regression
  get_model() %>% 
  ## get a tidy dataframe of results
  tidy(exponentiate = TRUE, 
       conf.int = TRUE)
```

Đánh giá nhanh mô hình cho thấy nó có thể thực hiện tốt hơn công việc ước tính số ca bệnh quan sát được.

```{r plot_nb_reg_bivar, warning=F, message=F}

## plot your regression 
ggplot(data = observed, aes(x = epiweek)) + 
  ## add in a line for the model estimate
  geom_line(aes(y = estimate),
            col = "Red") + 
  ## add in a band for the prediction intervals 
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## add in a line for your observed case counts
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## make a traditional plot (with black axes and white background)
  theme_classic()


```


#### Phần dư {.unnumbered}

Chúng ta một lần nữa lại khảo sát phần dư để xem mô hình của chúng ta phù hợp với dữ liệu quan sát như thế nào. Các kết quả và phiên giải ở đây tương tự như kết quả của hồi quy trước đó, vì vậy sẽ khả thi hơn khi chọn mô hình đơn giản hơn mà không có nhiệt độ. 

```{r}

## calculate the residuals 
observed <- observed %>% 
  mutate(resid = case_int - estimate)

## are the residuals fairly constant over time (if not: outbreaks? change in practice?)
observed %>%
  ggplot(aes(x = epiweek, y = resid)) +
  geom_line() +
  geom_point() + 
  labs(x = "epiweek", y = "Residuals")

## is there autocorelation in the residuals (is there a pattern to the error?)  
observed %>% 
  as_tsibble(index = epiweek) %>% 
  ACF(resid, lag_max = 52) %>% 
  autoplot()

## are residuals normally distributed (are under or over estimating?)  
observed %>%
  ggplot(aes(x = resid)) +
  geom_histogram(binwidth = 100) +
  geom_rug() +
  labs(y = "count") 
  
## compare observed counts to their residuals 
  ## should also be no pattern 
observed %>%
  ggplot(aes(x = estimate, y = resid)) +
  geom_point() +
  labs(x = "Fitted", y = "Residuals")

## formally test autocorrelation of the residuals
## H0 is that residuals are from a white-noise series (i.e. random)
## test for independence 
## if p value significant then non-random
Box.test(observed$resid, type = "Ljung-Box")

```

<!-- ======================================================= -->
## Phát hiện ổ dịch {  }

Chúng tôi sẽ trình bày hai phương pháp (tương tự) để phát hiện các ổ dịch ở đây. Cách đầu tiên được xây dựng dựa vào phần bên trên. Chúng ta sử dụng package **trending** để fit các mô hình hồi quy cho các năm trước đó, sau đó dự báo cho các năm tiếp theo. Nếu số lượng quan sát được cao hơn những gì chúng tôi dự báo, thì khả năng là đã có một đợt bùng phát. Phương pháp thứ hai dựa trên nguyên tắc tương tự nhưng sử dụng package **surveillance**, cung cấp nhiều thuật toán khác nhau để phát hiện các thay đổi bất thường.

<span style="color: orange;">**_CẨN TRỌNG:_** Thông thường, bạn quan tâm đến năm hiện tại (do bạn chỉ biết số ca bệnh đến tuần hiện tại). Vì vậy, trong ví dụ này, chúng tôi đang giả định là tuần 39 của năm 2011.</span>

<!-- ======================================================= -->
### Package **trending** {.unnumbered}

Đối với phương pháp này, chúng ta xác định một mốc (baseline) (thường là khoảng 5 năm dữ liệu). Chúng ta fit một mô hình hồi quy tới dữ liệu baseline, và sau đó sử dụng nó để ước tính cho năm sau. 

<!-- ======================================================= -->
#### Điểm cắt ngày { -}

Sẽ dễ dàng hơn khi xác định ngày của bạn ở một nơi và sau đó sử dụng những ngày này trong suốt phần còn lại trong của bạn.  

Ở đây chúng ta xác định ngày bắt đầu (khi các quan sát của chúng ta bắt đầu) và ngày làm điểm cắt (cut-off date) (kết thúc giai đoạn baseline - và giai đoạn chúng ta muốn dự đoán cho sự bắt đầu). ~Chúng ta cũng xác định có bao nhiêu tuần trong năm mà chúng tôi sẽ dự đoán)~. Chúng ta cũng xác định có bao nhiêu tuần mà chúng ta đang muốn dự báo nằm giữa điểm cắt baseline và ngày kết thúc. 


<span style="color: black;">**_LƯU Ý:_** Trong ví dụ này, chúng tôi giả sử hiện đang ở cuối tháng 9 năm 2011 ("2011 W39").</span>  

```{r cut_off}

## define start date (when observations began)
start_date <- min(counts$epiweek)

## define a cut-off week (end of baseline, start of prediction period)
cut_off <- yearweek("2010-12-31")

## define the last date interested in (i.e. end of prediction)
end_date <- yearweek("2011-12-31")

## find how many weeks in period (year) of interest
num_weeks <- as.numeric(end_date - cut_off)

```


<!-- ======================================================= -->
#### Thêm hàng {.unnumbered}

Để có thể dự báo ở định dạng tidyverse, chúng ta cần có số hàng phù hợp trong tập dữ liệu của mình, tức là một hàng cho mỗi tuần cho tới ngày kết thúc `end_date` đã được xác định bên trên. Đoạn mã bên dưới cho phép bạn thêm các hàng này theo một biến nhóm - ví dụ: nếu chúng ta có nhiều quốc gia trong một tập dữ liệu, chúng ta có thể nhóm theo quốc gia và sau đó thêm các hàng một cách thích hợp cho từng quốc gia. Hàm `group_by_key()` trong package **tsibble** cho phép chúng ta thực hiện điều này và sau đó chuyển dữ liệu đã nhóm tới các hàm **dplyr** như `group_modify()` và `add_row()`. Sau đó, chúng ta cụ thể trình tự các tuần giữa một tuần sau tuần tối đa hiện có trong dữ liệu và tuần kết thúc.

```{r add_rows}

## add in missing weeks till end of year 
counts <- counts %>%
  ## group by the region
  group_by_key() %>%
  ## for each group add rows from the highest epiweek to the end of year
  group_modify(~add_row(.,
                        epiweek = seq(max(.$epiweek) + 1, 
                                      end_date,
                                      by = 1)))

```



<!-- ======================================================= -->
#### Chu kỳ Fourier {.unnumbered}

Chúng ta phải định nghĩa lại chu kỳ Fourier - bởi vì chúng ta chỉ muốn fit chúng tới ngày baseline và sau đó dự báo (ngoại suy) các chu kỳ này cho năm sau. Để làm điều này, chúng ta cần kết hợp hai danh sách đầu ra từ hàm `fourier()` lại với nhau; cái đầu tiên dành cho dữ liệu baseline, và cái thứ hai dự đoán cho năm quan tâm (bằng cách xác định đối số `h`).  

*Lưu ý* để nối dòng chúng ta phải sử dụng hàm `rbind()` (thay vì hàm tidyverse `bind_rows`) bởi vì các cột fourier ở định dạng danh sách (vì vậy không được đặt tên riêng lẻ). 

```{r fourier_terms_pred}


## define fourier terms (sincos) 
counts <- counts %>% 
  mutate(
    ## combine fourier terms for weeks prior to  and after 2010 cut-off date
    ## (nb. 2011 fourier terms are predicted)
    fourier = rbind(
      ## get fourier terms for previous years
      fourier(
        ## only keep the rows before 2011
        filter(counts, 
               epiweek <= cut_off), 
        ## include one set of sin cos terms 
        K = 1
        ), 
      ## predict the fourier terms for 2011 (using baseline data)
      fourier(
        ## only keep the rows before 2011
        filter(counts, 
               epiweek <= cut_off),
        ## include one set of sin cos terms 
        K = 1, 
        ## predict 52 weeks ahead
        h = num_weeks
        )
      )
    )

```

<!-- ======================================================= -->
#### Chia dữ liệu và fit mô hình hồi quy {.unnumbered}

Chúng ta bây giờ cần phải chia dữ liệu của mình thành 2 giai đoạn: giai đoạn baseline và giai đoạn dự báo. Nó có thể thực hiện được với hàm **dplyr** `group_split()` sau khi nhóm bởi `group_by()`, và sẽ tạo ra một danh sách gồm hai data frame, một trước thời điểm cut-off và một cái ở thời điểm sau cut-off.  

Chúng ta sau đó sử dụng hàm `pluck()` từ package **purrr** để kéo tập dữ liệu ra khỏi danh sách (tương đương với việc sử dụng ngoặc vuông, vd: `dat[[1]]`), và sau đó có thể fit mô hình của chúng ta tới dữ liệu nền,và sau đó sử dụng hàm `predict()` cho dữ liệu mà chúng ta quan tâm sau cut-off.  

Xem chương [Lặp, vòng lặp, và danh sách] để biết thêm về **purrr**.  

<span style="color: orange;">**_CẨN TRỌNG:_** Lưu ý cách sử dụng của đối số `simulate_pi = FALSE` bên trong hàm `predict()`. Điều này là bởi hành vi mặc định của **trending** là sử dụng package **ciTools** để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị `NA`, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem `?trending::predict.trending_model_fit` để biết thêm chi tiết. </span>  

```{r forecast_regression, warning = FALSE}
# split data for fitting and prediction
dat <- counts %>% 
  group_by(epiweek <= cut_off) %>%
  group_split()

## define the model you want to fit (negative binomial) 
model <- glm_nb_model(
  ## set number of cases as outcome of interest
  case_int ~
    ## use epiweek to account for the trend
    epiweek +
    ## use the furier terms to account for seasonality
    fourier
)

# define which data to use for fitting and which for predicting
fitting_data <- pluck(dat, 2)
pred_data <- pluck(dat, 1) %>% 
  select(case_int, epiweek, fourier)

# fit model 
fitted_model <- trending::fit(model, fitting_data)

# get confint and estimates for fitted data
observed <- fitted_model %>% 
  predict(simulate_pi = FALSE)

# forecast with data want to predict with 
forecasts <- fitted_model %>% 
  predict(pred_data, simulate_pi = FALSE)

## combine baseline and predicted datasets
observed <- bind_rows(observed, forecasts)

```

Như bên trên, chúng ta có thể trực quan hóa mô hình với **ggplot**. Chúng ta đánh dấu các cảnh báo bằng các chấm màu đỏ cho các trường hợp quan sát được phía trên 95% khoảng dự đoán. Lần này, chúng ta cũng thêm một đường dọc để dán nhãn khi dự báo bắt đầu. 

```{r forecast_plot}

## plot your regression 
ggplot(data = observed, aes(x = epiweek)) + 
  ## add in a line for the model estimate
  geom_line(aes(y = estimate),
            col = "grey") + 
  ## add in a band for the prediction intervals 
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## add in a line for your observed case counts
  geom_line(aes(y = case_int), 
            col = "black") + 
  ## plot in points for the observed counts above expected
  geom_point(
    data = filter(observed, case_int > upper_pi), 
    aes(y = case_int), 
    colour = "red", 
    size = 2) + 
  ## add vertical line and label to show where forecasting started
  geom_vline(
           xintercept = as.Date(cut_off), 
           linetype = "dashed") + 
  annotate(geom = "text", 
           label = "Forecast", 
           x = cut_off, 
           y = max(observed$upper_pi) - 250, 
           angle = 90, 
           vjust = 1
           ) + 
  ## make a traditional plot (with black axes and white background)
  theme_classic()
```



<!-- ======================================================= -->
#### Đánh giá dự báo {.unnumbered}

Ngoài việc kiểm tra các phần dư, cũng quan trọng khi đánh giá xem mô hình của bạn tốt như thế nào trong việc dự đoán các trường hợp trong tương lai. Điều này cung cấp cho bạn ý tưởng về mức độ đáng tin cậy của các ngưỡng cảnh báo của bạn.  

Cách kiểm định truyền thống là xem bạn có thể dự đoán năm gần nhất trước năm hiện tại tốt như thế nào (bởi vì bạn chưa biết số lượng cho "năm hiện tại"). Ví dụ: trong tập dữ liệu của chúng ta, chúng ta sẽ sử dụng dữ liệu từ năm 2002 đến năm 2009 để dự đoán năm 2010 và sau đó xem mức độ chính xác của những dự đoán đó. Sau đó, fit lại mô hình có bao gồm dữ liệu năm 2010 và sử dụng dữ liệu đó để dự đoán cho năm 2011.  

Bạn có thể xem ảnh minh họa bên dưới bởi *Hyndman và cộng sự* trong cuốn ["Các nguyên tắc dự báo và thực hành"](https://otexts.com/fpp3/). 

![](`r "https://otexts.com/fpp3/fpp_files/figure-html/traintest-1.png"`) *hình sử dụng lại với sự cho phép của các tác giả* 

Nhược điểm của cách này là bạn không sử dụng tất cả dữ liệu có sẵn và nó không phải là mô hình cuối cùng mà bạn đang sử dụng để dự đoán.

Một giải pháp thay thế là sử dụng một phương pháp được gọi là xác thực chéo (cross-validation). Trong trường hợp này, bạn cuộn qua tất cả dữ liệu có sẵn để fit nhiều mô hình để dự đoán một năm tới. Bạn sẽ sử dụng nhiều dữ liệu hơn trong các mô hình, như được trình bày dưới đây từ cùng [*cuốn sách của Hyndman và cộng sự*](https://otexts.com/fpp3/). Ví dụ, mô hình đầu tiên sử dụng 2002 để dự đoán năm 2003, mô hình thứ hai sử dụng 2002 và 2003 để dự đoán năm 2004, v.v. 

![](`r "https://otexts.com/fpp2/fpp_files/figure-html/cv1-1.png"`) *hình sử dụng lại với sự cho phép của các tác giả*

Dưới đây chúng ta sử dụng hàm `map()` từ package **purrr** để chạy vòng lặp trên từng tập dữ liệu. Sau đó, chúng ta đặt các ước tính vào một tập dữ liệu và hợp nhất với số lượng trường hợp ban đầu để sử dụng package **yardstick** để tính toán các đo lường về độ chính xác. Chúng ta sẽ tính toán bốn giá trị bao gồm: Root mean squared error (RMSE), Mean absolute error (MAE), Mean absolute scaled error (MASE), Mean absolute percent error (MAPE).

<span style="color: orange;">**_CẨN TRỌNG:_** Lưu ý cách sử dụng của đối số `simulate_pi = FALSE` bên trong hàm `predict()`. Điều này là bởi hành vi mặc định của **trending** là sử dụng package **ciTools** để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị `NA`, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem `?trending::predict.trending_model_fit` để biết thêm chi tiết. </span>  

```{r cross_validation, warning = FALSE}

## Cross validation: predicting week(s) ahead based on sliding window

## expand your data by rolling over in 52 week windows (before + after) 
## to predict 52 week ahead
## (creates longer and longer chains of observations - keeps older data)

## define window want to roll over
roll_window <- 52

## define weeks ahead want to predict 
weeks_ahead <- 52

## create a data set of repeating, increasingly long data
## label each data set with a unique id
## only use cases before year of interest (i.e. 2011)
case_roll <- counts %>% 
  filter(epiweek < cut_off) %>% 
  ## only keep the week and case counts variables
  select(epiweek, case_int) %>% 
    ## drop the last x observations 
    ## depending on how many weeks ahead forecasting 
    ## (otherwise will be an actual forecast to "unknown")
    slice(1:(n() - weeks_ahead)) %>%
    as_tsibble(index = epiweek) %>% 
    ## roll over each week in x after windows to create grouping ID 
    ## depending on what rolling window specify
    stretch_tsibble(.init = roll_window, .step = 1) %>% 
  ## drop the first couple - as have no "before" cases
  filter(.id > roll_window)


## for each of the unique data sets run the code below
forecasts <- purrr::map(unique(case_roll$.id), 
                        function(i) {
  
  ## only keep the current fold being fit 
  mini_data <- filter(case_roll, .id == i) %>% 
    as_tibble()
  
  ## create an empty data set for forecasting on 
  forecast_data <- tibble(
    epiweek = seq(max(mini_data$epiweek) + 1,
                  max(mini_data$epiweek) + weeks_ahead,
                  by = 1),
    case_int = rep.int(NA, weeks_ahead),
    .id = rep.int(i, weeks_ahead)
  )
  
  ## add the forecast data to the original 
  mini_data <- bind_rows(mini_data, forecast_data)
  
  ## define the cut off based on latest non missing count data 
  cv_cut_off <- mini_data %>% 
    ## only keep non-missing rows
    drop_na(case_int) %>% 
    ## get the latest week
    summarise(max(epiweek)) %>% 
    ## extract so is not in a dataframe
    pull()
  
  ## make mini_data back in to a tsibble
  mini_data <- tsibble(mini_data, index = epiweek)
  
  ## define fourier terms (sincos) 
  mini_data <- mini_data %>% 
    mutate(
    ## combine fourier terms for weeks prior to  and after cut-off date
    fourier = rbind(
      ## get fourier terms for previous years
      forecast::fourier(
        ## only keep the rows before cut-off
        filter(mini_data, 
               epiweek <= cv_cut_off), 
        ## include one set of sin cos terms 
        K = 1
        ), 
      ## predict the fourier terms for following year (using baseline data)
      fourier(
        ## only keep the rows before cut-off
        filter(mini_data, 
               epiweek <= cv_cut_off),
        ## include one set of sin cos terms 
        K = 1, 
        ## predict 52 weeks ahead
        h = weeks_ahead
        )
      )
    )
  
  
  # split data for fitting and prediction
  dat <- mini_data %>% 
    group_by(epiweek <= cv_cut_off) %>%
    group_split()

  ## define the model you want to fit (negative binomial) 
  model <- glm_nb_model(
    ## set number of cases as outcome of interest
    case_int ~
      ## use epiweek to account for the trend
      epiweek +
      ## use the furier terms to account for seasonality
      fourier
  )

  # define which data to use for fitting and which for predicting
  fitting_data <- pluck(dat, 2)
  pred_data <- pluck(dat, 1)
  
  # fit model 
  fitted_model <- trending::fit(model, fitting_data)
  
  # forecast with data want to predict with 
  forecasts <- fitted_model %>% 
    predict(pred_data, simulate_pi = FALSE) %>% 
    ## only keep the week and the forecast estimate
    select(epiweek, estimate)
    
  }
  )

## make the list in to a data frame with all the forecasts
forecasts <- bind_rows(forecasts)

## join the forecasts with the observed
forecasts <- left_join(forecasts, 
                       select(counts, epiweek, case_int),
                       by = "epiweek")

## using {yardstick} compute metrics
  ## RMSE: Root mean squared error
  ## MAE:  Mean absolute error	
  ## MASE: Mean absolute scaled error
  ## MAPE: Mean absolute percent error
model_metrics <- bind_rows(
  ## in your forcasted dataset compare the observed to the predicted
  rmse(forecasts, case_int, estimate), 
  mae( forecasts, case_int, estimate),
  mase(forecasts, case_int, estimate),
  mape(forecasts, case_int, estimate),
  ) %>% 
  ## only keep the metric type and its output
  select(Metric  = .metric, 
         Measure = .estimate) %>% 
  ## make in to wide format so can bind rows after
  pivot_wider(names_from = Metric, values_from = Measure)

## return model metrics 
model_metrics

```


<!-- ======================================================= -->
### package **surveillance** {.unnumbered}

Trong phần này chúng ta sẽ sử dụng package **surveillance** để tạo các ngưỡng cảnh báo dựa trên thuật toán phát hiện ổ dịch. Có một số phương pháp khác có sẵn trong package, tuy nhiên chúng ta sẽ tập trung vào hai tùy chọn ở đây. Để biết chi tiết, xem các bài báo sau về [sự ứng dụng](https://cran.r-project.org/web/packages/surveillance/vignettes/monitoringCounts.pdf) và [lý thuyết](https://cran.r-project.org/web/packages/surveillance/vignettes/glrnb.pdf) về các thuật toán được sử dụng. 

Lựa chọn đầu tiên là sử dụng phương pháp Farrington cải tiến. Nó fit một mô hình nhị thức âm tổng quát (bao gồm xu hướng) và down-weights các đợt bùng phát trong quá khứ (giá trị ngoại lai) để tạo một mức ngưỡng. 

Lựa chọn thứ hai là dùng phương pháp glrnb. Nó cũng fit một mô hình nhị thức âm tổng quát nhưng bao gồm cả xu hướng và chu kỳ fourier (vì vậy được ưu ái ở đây). Mô hình hồi quy được sử dụng để tính toán "control mean" (~fitted values) - nó sau đó sử dụng một phép thống kê tính toán likelihood ratio statistic tổng quát hóa để đánh giá nếu có sự thay đổi trung bình cho mỗi tuần. Lưu ý rằng ngưỡng cho mỗi tuần sẽ tính đến các tuần trước, vì vậy nếu có sự thay đổi liên tục, một cảnh báo sẽ được kích hoạt. (Cũng lưu ý rằng sau mỗi lần cảnh báo, thuật toán sẽ được đặt lại)

Để làm việc được với package **surveillance**, trước tiên chúng ta cần xác định đối tượng "chuỗi thời gian giám sát" (sử dụng hàm `sts()`) để fit vào bên trong framework. 

```{r surveillance_obj}

## define surveillance time series object
## nb. you can include a denominator with the population object (see ?sts)
counts_sts <- sts(observed = counts$case_int[!is.na(counts$case_int)],
                  start = c(
                    ## subset to only keep the year from start_date 
                    as.numeric(str_sub(start_date, 1, 4)), 
                    ## subset to only keep the week from start_date
                    as.numeric(str_sub(start_date, 7, 8))), 
                  ## define the type of data (in this case weekly)
                  freq = 52)

## define the week range that you want to include (ie. prediction period)
## nb. the sts object only counts observations without assigning a week or 
## year identifier to them - so we use our data to define the appropriate observations
weekrange <- cut_off - start_date

```

<!-- ======================================================= -->
#### Phương pháp Farrington {.unnumbered}

Sau đó chúng ta xác định từng tham số cho phương pháp Farrington trong một danh sách `list`. Sau đó, chúng ta chạy thuật toán bằng cách sử dụng hàm `farringtonFlexible()` và sau đó chúng ta có thể trích xuất ngưỡng cảnh báo bằng hàm `farringtonmethod@upperbound` để thêm vào tệp dữ liệu của chúng ta. Bạn cũng có thể trích xuất giá trị TRUE/FALSE cho từng tuần nếu nó kích hoạt một cảnh báo (cao hơn ngưỡng) bằng cách sử dụng `farringtonmethod@alarm`. 

```{r farrington}

## define control
ctrl <- list(
  ## define what time period that want threshold for (i.e. 2011)
  range = which(counts_sts@epoch > weekrange),
  b = 9, ## how many years backwards for baseline
  w = 2, ## rolling window size in weeks
  weightsThreshold = 2.58, ## reweighting past outbreaks (improved noufaily method - original suggests 1)
  ## pastWeeksNotIncluded = 3, ## use all weeks available (noufaily suggests drop 26)
  trend = TRUE,
  pThresholdTrend = 1, ## 0.05 normally, however 1 is advised in the improved method (i.e. always keep)
  thresholdMethod = "nbPlugin",
  populationOffset = TRUE
  )

## apply farrington flexible method
farringtonmethod <- farringtonFlexible(counts_sts, ctrl)

## create a new variable in the original dataset called threshold
## containing the upper bound from farrington 
## nb. this is only for the weeks in 2011 (so need to subset rows)
counts[which(counts$epiweek >= cut_off & 
               !is.na(counts$case_int)),
              "threshold"] <- farringtonmethod@upperbound
```

Sau đó, chúng ta có thể trực quan hóa kết quả với ggplot như đã thực hiện ở trên. 

```{r plot_farrington, warning=F, message=F}

ggplot(counts, aes(x = epiweek)) + 
  ## add in observed case counts as a line
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## add in upper bound of aberration algorithm
  geom_line(aes(y = threshold, colour = "Alert threshold"), 
            linetype = "dashed", 
            size = 1.5) +
  ## define colours
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Alert threshold" = "red")) + 
  ## make a traditional plot (with black axes and white background)
  theme_classic() + 
  ## remove title of legend 
  theme(legend.title = element_blank())

```

<!-- ======================================================= -->
#### Phương pháp GLRNB {.unnumbered}

Tương tự với phương pháp GLRNB, chúng ta xác định từng tham số vào một danh sách `list`, sau đó fit thuật toán và trích xuất các giới hạn trên.

<span style="color: orange;">**_CẨN TRỌNG:_** Phương pháp này sử dụng "brute force" (tương tự như bootstrapping) để tính toán các ngưỡng, vì vậy có thể mất nhiều thời gian!</span>

Xem [GLRNB vignette](https://cran.r-project.org/web/packages/surveillance/vignettes/glrnb.pdf) để biết thêm chi tiết. 

```{r glrnb, warning = FALSE, message = FALSE}

## define control options
ctrl <- list(
  ## define what time period that want threshold for (i.e. 2011)
  range = which(counts_sts@epoch > weekrange),
  mu0 = list(S = 1,    ## number of fourier terms (harmonics) to include
  trend = TRUE,   ## whether to include trend or not
  refit = FALSE), ## whether to refit model after each alarm
  ## cARL = threshold for GLR statistic (arbitrary)
     ## 3 ~ middle ground for minimising false positives
     ## 1 fits to the 99%PI of glm.nb - with changes after peaks (threshold lowered for alert)
   c.ARL = 2,
   # theta = log(1.5), ## equates to a 50% increase in cases in an outbreak
   ret = "cases"     ## return threshold upperbound as case counts
  )

## apply the glrnb method
glrnbmethod <- glrnb(counts_sts, control = ctrl, verbose = FALSE)

## create a new variable in the original dataset called threshold
## containing the upper bound from glrnb 
## nb. this is only for the weeks in 2011 (so need to subset rows)
counts[which(counts$epiweek >= cut_off & 
               !is.na(counts$case_int)),
              "threshold_glrnb"] <- glrnbmethod@upperbound

```

Trực quan hóa kết quả đầu ra như bên trên. 

```{r plot_glrnb, message=F, warning=F}

ggplot(counts, aes(x = epiweek)) + 
  ## add in observed case counts as a line
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## add in upper bound of aberration algorithm
  geom_line(aes(y = threshold_glrnb, colour = "Alert threshold"), 
            linetype = "dashed", 
            size = 1.5) +
  ## define colours
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Alert threshold" = "red")) + 
  ## make a traditional plot (with black axes and white background)
  theme_classic() + 
  ## remove title of legend 
  theme(legend.title = element_blank())

```

<!-- ======================================================= -->
## Chuỗi thời gian bị gián đoạn {  }

Chuỗi thời gian bị gián đoạn (còn được gọi là hồi quy phân đoạn hoặc phân tích can thiệp), thường được sử dụng để đánh giá tác động của vắc-xin đối với tỷ lệ mắc mới của bệnh. Nhưng nó có thể được sử dụng để đánh giá tác động của một loạt các can thiệp hoặc sự giới thiệu. Ví dụ như những thay đổi trong quy trình của bệnh viện hoặc sự xuất hiện của chủng bệnh mới vào quần thể. Trong ví dụ này, chúng ta sẽ giả định rằng một chủng mới của Campylobacter đã xuất hiện ở Đức vào cuối năm 2008, và xem liệu điều đó có ảnh hưởng đến số lượng trường hợp. Chúng ta sẽ sử dụng hồi quy nhị thức âm một lần nữa. Sự hồi quy lần này sẽ được chia thành hai phần, một phần trước khi can thiệp (hoặc sự xuất hiện của chủng mới) và một phần sau (trước và sau giai đoạn). Điều này cho phép chúng ta tính toán tỷ số tỷ lệ mới mắc giữa hai khoảng thời gian. Giải thích phương trình có thể làm cho điều này rõ ràng hơn (nếu không thì chỉ cần bỏ qua!). 

Hồi quy nhị thức âm có thể được định nghĩa như sau: 

$$\log(Y_t)= β_0 + β_1 \times t+ β_2 \times δ(t-t_0) + β_3\times(t-t_0 )^+ + log(pop_t) + e_t$$

Trong đó:

$Y_t$ là số trường hợp quan sát được tại thời điểm $t$  

$pop_t$ nếu kích thước quần thể trong 100,000s tại thời điểm $t$ (không sử dụng tại đây)  

$t_0$ là năm cuối cùng của giai đoạn trước (bao gồm cả thời gian chuyển tiếp nếu có)  

$δ(x$ là hàm chỉ báo (nó là 0 nếu x ≤ 0 và 1 nếu x > 0)

$(x)^+$ là toán tử cut off (nó là x nếu x > 0 và ngược lại sẽ bằng 0)  

$e_t$ biểu thị phần dư 

Các chu kỳ bổ sung có xu hướng hoặc theo mùa có thể được thêm vào nếu cần thiết. 

$β_2 \times δ(t-t_0) + β_3\times(t-t_0 )^+$ là một phần của mô hình tuyến tỉnh tổng quát hóa của giai đoạn sau và bằng không ở giai đoạn trước. Điều này có nghĩa là $β_2$ và $β_3$ ước tính các hiệu quả của can thiệp. 

Chúng ta cần tính toán lại chu kỳ Fourier mà không có dự báo ở đây, vì chúng ta sẽ sử dụng tất cả dữ liệu có sẵn (vd: hồi cứu). Ngoài ra, chúng ta cần tính toán các điều khoản bổ sung cần thiết cho hồi quy. thực tế là chúng ta cần tính chu kỳ mở rộng (extra terms) cho đường hồi quy. 

```{r define_terms_interrupted}

## add in fourier terms using the epiweek and case_int variabless
counts$fourier <- select(counts, epiweek, case_int) %>% 
  as_tsibble(index = epiweek) %>% 
  fourier(K = 1)

## define intervention week 
intervention_week <- yearweek("2008-12-31")

## define variables for regression 
counts <- counts %>% 
  mutate(
    ## corresponds to t in the formula
      ## count of weeks (could probably also just use straight epiweeks var)
    # linear = row_number(epiweek), 
    ## corresponds to delta(t-t0) in the formula
      ## pre or post intervention period
    intervention = as.numeric(epiweek >= intervention_week), 
    ## corresponds to (t-t0)^+ in the formula
      ## count of weeks post intervention
      ## (choose the larger number between 0 and whatever comes from calculation)
    time_post = pmax(0, epiweek - intervention_week + 1))

```

Chúng ta sau đó sử dụng các chi kỳ này để fit một mô hình hồi quy nhị thức âm, và tạo một bảng với phần trăm thay đổi. Những gì ví dụ này cho thấy là không có thay đổi đáng kể. 

<span style="color: orange;">**_CẨN TRỌNG:_** Lưu ý cách sử dụng của đối số `simulate_pi = FALSE` bên trong hàm `predict()`. Điều này là bởi hành vi mặc định của **trending** là sử dụng package **ciTools** để ước tính khoảng tiên lượng. Nó sẽ không hoạt động nếu có giá trị `NA`, cũng như tạo ra nhiều khoảng chi tiết hơn. Xem `?trending::predict.trending_model_fit` để biết thêm chi tiết. </span>  

```{r interrupted_regression, warning = FALSE}


## define the model you want to fit (negative binomial) 
model <- glm_nb_model(
  ## set number of cases as outcome of interest
  case_int ~
    ## use epiweek to account for the trend
    epiweek +
    ## use the furier terms to account for seasonality
    fourier + 
    ## add in whether in the pre- or post-period 
    intervention + 
    ## add in the time post intervention 
    time_post
    )

## fit your model using the counts dataset
fitted_model <- trending::fit(model, counts)

## calculate confidence intervals and prediction intervals 
observed <- predict(fitted_model, simulate_pi = FALSE)



## show estimates and percentage change in a table
fitted_model %>% 
  ## extract original negative binomial regression
  get_model() %>% 
  ## get a tidy dataframe of results
  tidy(exponentiate = TRUE, 
       conf.int = TRUE) %>% 
  ## only keep the intervention value 
  filter(term == "intervention") %>% 
  ## change the IRR to percentage change for estimate and CIs 
  mutate(
    ## for each of the columns of interest - create a new column
    across(
      all_of(c("estimate", "conf.low", "conf.high")), 
      ## apply the formula to calculate percentage change
            .f = function(i) 100 * (i - 1), 
      ## add a suffix to new column names with "_perc"
      .names = "{.col}_perc")
    ) %>% 
  ## only keep (and rename) certain columns 
  select("IRR" = estimate, 
         "95%CI low" = conf.low, 
         "95%CI high" = conf.high,
         "Percentage change" = estimate_perc, 
         "95%CI low (perc)" = conf.low_perc, 
         "95%CI high (perc)" = conf.high_perc,
         "p-value" = p.value)
```

Như bên trên, chúng ta có thể trực quan hóa các đầu ra của mô hình hồi quy. 

```{r plot_interrupted}

ggplot(observed, aes(x = epiweek)) + 
  ## add in observed case counts as a line
  geom_line(aes(y = case_int, colour = "Observed")) + 
  ## add in a line for the model estimate
  geom_line(aes(y = estimate, col = "Estimate")) + 
  ## add in a band for the prediction intervals 
  geom_ribbon(aes(ymin = lower_pi, 
                  ymax = upper_pi), 
              alpha = 0.25) + 
  ## add vertical line and label to show where forecasting started
  geom_vline(
           xintercept = as.Date(intervention_week), 
           linetype = "dashed") + 
  annotate(geom = "text", 
           label = "Intervention", 
           x = intervention_week, 
           y = max(observed$upper_pi), 
           angle = 90, 
           vjust = 1
           ) + 
  ## define colours
  scale_colour_manual(values = c("Observed" = "black", 
                                 "Estimate" = "red")) + 
  ## make a traditional plot (with black axes and white background)
  theme_classic()

```


<!-- ======================================================= -->
## Nguồn tham khảo {  }

[forecasting: principles and practice textbook](https://otexts.com/fpp3/)  
[EPIET timeseries analysis case studies](https://github.com/EPIET/TimeSeriesAnalysis)  
[Penn State course](https://online.stat.psu.edu/stat510/lesson/1) 
[Surveillance package manuscript](https://www.jstatsoft.org/article/view/v070i10)

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/time_series.Rmd-->

# Mô hình hóa dịch bệnh {#epidemic-models}

<!-- ======================================================= -->

## Tổng quan

Ngày càng có nhiều công cụ để tạo một mô hình dịch bệnh cho phép chúng ta tiến hành các phân tích khá phức tạp và tiết kiệm nguồn lực. Chương này sẽ cung cấp một cái nhìn tổng quan về cách sử dụng các công cụ để:

-   ước tính hệ số lây nhiễm hiệu quả R<sub>t</sub> và các thống kê liên quan chẳng hạn như thời gian tăng gấp đôi
-   đưa ra các dự báo ngắn hạn về số mắc mới trong tương lai

Chương này *không* tổng quan về các phương pháp luận và phương pháp thống kê cơ bản của các công cụ này, vì vậy vui lòng tham khảo mục Tài liệu tham khảo để đọc các bài báo có đề cập tới. Hãy chắc chắn rằng bạn có kiến thức cơ bản về các phương pháp trước khi sử dụng các công cụ này; điều này sẽ đảm bảo bạn có thể giải thích chính xác các kết quả của chúng.

Dưới đây là một ví dụ về những kết quả đầu ra mà chúng ta sẽ thực hiện trong chương này.

```{r out.width=c('100%', '100%'), fig.show='hold', echo=F, fig.width = 12, fig.height = 9, message=F, warning=F}

## install and load packages
pacman::p_load(tidyverse, EpiNow2, EpiEstim, here, incidence2, epicontacts, rio, projections)

## load linelist
linelist <- import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## ## estimate gamma generation time
## generation_time <- bootstrapped_dist_fit(
##   get_pairwise(epic, "date_infection"),
##   dist = "gamma",
##   max_value = 20,
##   bootstraps = 1
## )

## ## export for caching
## export(
##   generation_time,
##   here("data/cache/epidemic_models/generation_time.rds")
## )

## import cached generation time
generation_time <- import(here("data/cache/epidemic_models/generation_time.rds"))

## ## estimate incubation period
## incubation_period <- bootstrapped_dist_fit(
##   linelist$date_onset - linelist$date_infection,
##   dist = "lognormal",
##   max_value = 100,
##   bootstraps = 1
## )

## ## export for caching
## export(
##   incubation_period,
##   here("data/cache/epidemic_models/incubation_period.rds")
## )

## import cached incubation period
incubation_period <- import(here("data/cache/epidemic_models/incubation_period.rds"))

## get incidence from onset date
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())

## ## run epinow
## epinow_res <- epinow(
##   reported_cases = cases,
##   generation_time = generation_time,
##   delays = delay_opts(incubation_period),
##   target_folder = here("data/cache/epidemic_models"),
##   return_output = TRUE,
##   output = "samples",
##   verbose = TRUE,
##   stan = stan_opts(samples = 750, chains = 4),
##   horizon = 21
## )

## ## export for caching
## export(
##   epinow_res,
##   here("data/cache/epidemic_models/epinow_res.rds")
## )

## import cached epinow results
epinow_res <- import(here("data/cache/epidemic_models/epinow_res.rds"))

## plot summary figure
plot(epinow_res)

```

<!-- ======================================================= -->

## Chuẩn bị

Chúng ta sẽ sử dụng hai phương pháp và package khác nhau để ước tính R<sub>t</sub>, cụ thể là package **EpiNow** và package **EpiEstim**, cũng như package **projections** cho dự báo các trường hợp mới mắc.

Đoạn code này hiển thị tải các package cần thiết cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, để cài đặt package nếu cần thiết *và* gọi package để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem thêm chương [R cơ bản] để biết thêm thông tin về package R.

```{r epidemic_models_packages, }
pacman::p_load(
   rio,          # File import
   here,         # File locator
   tidyverse,    # Data management + ggplot2 graphics
   epicontacts,  # Analysing transmission networks
   EpiNow2,      # Rt estimation
   EpiEstim,     # Rt estimation
   projections,  # Incidence projections
   incidence2,   # Handling incidence data
   epitrix,      # Useful epi functions
   distcrete     # Discrete delay distributions
)
```

Chúng ta sẽ sử dụng bộ dữ liệu các trường hợp linelist đã được làm sạch cho tất cả các phân tích trong chương này. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'> bấm để tải xuống bộ dữ liệu linelist đã được "làm sạch" </a> (dưới dạng tệp .rds). Xem chương [Tải sách và dữ liệu] để tải xuống tất cả các dữ liệu minh họa được sử dụng trong sổ tay này.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# import the cleaned linelist
linelist <- import("linelist_cleaned.rds")
```

<!-- ======================================================= -->

## Ước tính R<sub>t</sub>

### EpiNow2 và EpiEstim {.unnumbered}

Hệ số lây nhiễm R là thước đo khả năng lây truyền của một bệnh và được định nghĩa là số ca thứ phát kỳ vọng trên mỗi trường hợp nhiễm bệnh. Trong một quần thể cảm nhiễm toàn bộ, giá trị này đại diện cho hệ số lây nhiễm cơ bản R<sub>0</sub>. Tuy nhiên, vì số lượng các cá thể cảm nhiễm trong một quần thể thay đổi trong suốt vụ dịch hoặc đại dịch và khi các biện pháp ứng phó khác nhau được thực hiện, chỉ số đo lường khả năng lây truyền thường được sử dụng phổ biến nhất là hệ số lây nhiễm hiệu quả R<sub>t</sub>; nó được định nghĩa là số trường hợp thứ cấp kỳ vọng trên mỗi trường hợp bị nhiễm tại một thời điểm *t* nhất định.

Package **EpiNow2** cung cấp một framework phức tạp nhất cho việc ước tính R<sub>t</sub>. Package này có hai điểm mạnh chính so với package thường dùng khác là **EpiEstim** như sau:

-   Nó giải thích cho thời gian trì hoãn (delay) trong báo cáo và do đó có thể ước tính R<sub>t</sub> ngay cả khi dữ liệu không đầy đủ.
-   Nó ước tính R<sub>t</sub> dựa vào *ngày nhiễm bệnh* hơn là ngày khởi phát được báo cáo, có nghĩa là ảnh hưởng của một can thiệp sẽ được thể hiện ngay lập tức bởi sự thay đổi của R<sub>t</sub>, thay vì có một sự trì hoãn.

Tuy nhiên, nó cũng có hai nhược điểm chính:

-   Nó yêu cầu kiến thức về phân phối thời gian phát sinh một thế hệ (generation time: tức là phân phối khoảng thời gian giữa ca nhiễm trùng sơ cấp và các ca thứ cấp), phân bố thời gian ủ bệnh (incubation period: tức là phân bố khoảng thời gian giữa nhiễm trùng và khởi phát triệu chứng) và bất kỳ phân phối khoảng thời gian nào khác có liên quan đến dữ liệu của bạn (ví dụ: nếu bạn có ngày báo cáo, bạn cần thông tin phân phối độ trễ từ khi bắt đầu có triệu chứng đến khi được báo cáo). Trong khi điều này sẽ cho phép ước tính R<sub>t</sub> chính xác hơn thì package **EpiEstim** chỉ yêu cầu phân bố của khoảng thời gian liên tiếp (serial interval: khoảng thời gian từ lúc bệnh nhân ban đầu khởi phát triệu chứng đến lúc bệnh nhân thứ phát có triệu chứng khởi phát), mà đó có thể là phân phối duy nhất có sẵn cho bạn.\
-   Package **EpiNow2** chậm hơn đáng kể so với package **EpiEstim** theo một hệ số khoảng 100-1000 (tin đồn)! Ví dụ: ước tính R<sub>t</sub> đối với đợt bùng phát được lấy ví dụ trong phần này mất khoảng bốn giờ (được chạy lặp lại một số lượng lớn lần để đảm bảo độ chính xác và tất nhiên có thể giảm nếu cần thiết, tuy nhiên nói chung là thuật toán chậm). Điều này có thể không khả thi nếu bạn thường xuyên phải cập nhật ước tính R<sub>t</sub>.

Do đó, package bạn chọn sử dụng sẽ phụ thuộc vào dữ liệu, thời gian và tài nguyên tính toán có sẵn cho bạn.

###Package EpiNow2 {.unnumbered}

#### Ước tính phân phối thời gian trì hoãn {.unnumbered}

Phân phối độ trễ yêu cầu chạy package **EpiNow2** tùy thuộc vào dữ liệu bạn có. Về cơ bản, bạn cần có khả năng mô tả độ trễ từ ngày nhiễm bệnh đến ngày diễn ra sự kiện bạn muốn sử dụng để ước tính R<sub>t</sub>. Nếu bạn đang sử dụng ngày bắt đầu, thì nó sẽ chỉ đơn giản là phân bố thời kỳ ủ bệnh. Nếu bạn đang sử dụng ngày báo cáo, bạn yêu cầu thời gian trì hoãn từ khi lây nhiễm đến khi báo cáo. Bởi vì phân phối này khó có thể được biết trực tiếp, package **EpiNow2** cho phép bạn xâu chuỗi nhiều phân phối trì hoãn với nhau; trong trường hợp này, đó là thời gian trì hoãn từ khi nhiễm trùng đến khi khởi phát triệu chứng (ví dụ: thời kỳ ủ bệnh, thường có khả năng biết) và từ khi bắt đầu có triệu chứng đến khi báo cáo ca bệnh (mà bạn có thể thường xuyên ước tính từ dữ liệu).

Vì chúng ta có ngày bắt đầu cho tất cả các trường hợp trong ví dụ của bộ dữ liệu linelist, chúng ta sẽ chỉ cần phân phối thời gian ủ bệnh để liên kết dữ liệu của chúng ta (ví dụ: ngày bắt đầu có triệu chứng) đến ngày nhiễm bệnh. Chúng ta có thể ước tính phân phối này từ dữ liệu hoặc sử dụng các giá trị từ y văn.

Tài liệu về ước tính thời gian ủ bệnh của Ebola (trích dẫn từ [bài báo này](https://www.nejm.org/doi/full/10.1056/nejmoa1411100)) với giá trị trung bình là 9.1, độ lệch chuẩn là 7.3 và giá trị lớn nhất là 30 sẽ được chỉ định như sau:

```{r epidemic_models_incubation_literature, eval=F}
incubation_period_lit <- list(
  mean = log(9.1),
  mean_sd = log(0.1),
  sd = log(7.3),
  sd_sd = log(0.1),
  max = 30
)
```

Lưu ý rằng package **EpiNow2** yêu cầu các phân phối thời gian trì hoãn này phải được cung cấp trên thang đo **log** bằng cách dùng lệnh gọi `log` xung quanh mỗi giá trị (ngoại trừ tham số `max`, hơi rắc rối, cung cấp theo thang đo tự nhiên). `mean_sd` và `sd_sd` xác định độ lệch chuẩn của ước tính giá trị trung bình và độ lệch chuẩn. Vì chúng không được biết trong trường hợp này, chúng tôi chọn giá trị khá tùy ý là 0.1.

Trong phân tích này, thay vào đó, chúng ta ước tính phân phối thời gian ủ bệnh từ chính bộ dữ liệu linelist bằng cách sử dụng hàm `bootstrapped_dist_fit`, để fit một phân phối lognormal cho thời gian trì hoãn giữa nhiễm trùng và khởi phát quan sát được trong linelist.

```{r epidemic_models_incubation_estimate, eval=F}
## estimate incubation period
incubation_period <- bootstrapped_dist_fit(
  linelist$date_onset - linelist$date_infection,
  dist = "lognormal",
  max_value = 100,
  bootstraps = 1
)
```

Phân phối khác mà chúng ta cần là thời gian phát sinh một thế hệ. Vì chúng ta có dữ liệu về thời gian nhiễm bệnh **và** đường lây truyền, chúng ta có thể ước tính phân phối này từ linelist bằng cách tính toán đỗ trễ giữa các lần lây nhiễm của các cặp người lây nhiễm-người bị lây nhiễm. Để làm điều này, chúng ta sử dụng hàm `get_pairwise` từ package **epicontacts**, cho phép chúng ta tính toán sự khác biệt từng cặp trường hợp lây nhiễm của linelist. Đầu tiên, chúng ta tạo một đối tượng epicontacts (xem chương [Chuỗi lây nhiễm] để biết thêm chi tiết):

```{r epidemic_models_epicontacts, eval=F}
## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về thời gian nhiễm bệnh giữa các cặp lây nhiễm (được tính toán bằng cách sử dụng hàm `get_pairwise`)

```{r epidemic_models_generation_estimate, eval=F}
## estimate gamma generation time
generation_time <- bootstrapped_dist_fit(
  get_pairwise(epic, "date_infection"),
  dist = "gamma",
  max_value = 20,
  bootstraps = 1
)
```

#### Chạy **EpiNow2** {.unnumbered}

Bây giờ chúng ta chỉ cần tính toán số mới mắc hàng ngày từ linelist mà có thể thực hiện dễ dàng với các hàm `group_by()` và `n()` từ package **dplyr**. Lưu ý rằng **EpiNow2** yêu cầu tên cột phải là `date` và `confirm`.

```{r epidemic_models_cases, eval=F}
## get incidence from onset dates
cases <- linelist %>%
  group_by(date = date_onset) %>%
  summarise(confirm = n())
```

Sau đó, chúng ta có thể ước tính R<sub>t</sub> bằng cách sử dụng hàm `epinow`. Một vài lưu ý về các dữ liệu đầu vào:
 
-   Chúng ta có thể cung cấp một số lượng bất kỳ các 'chuỗi' phân phối thời gian trì hoãn tới đối số `delays`; chúng ta chỉ cần chèn chúng cùng với đối tượng `incubation_period` bên trong hàm `delay_opts`.
-   `return_output` đảm bảo đầu ra được trả về trong R chứ không chỉ được lưu vào một tệp.
-   `verbose` nếu chúng ta muốn đọc tiến trình.
-   `horizon` để yêu cầu hiển thị số ngày chúng ta muốn tính số mới mắc trong tương lai
-   Chúng ta chuyển các tùy chọn bổ sung cho đối số `stan` để chỉ định cách chúng ta muốn chạy suy luận. Tăng số lượng mẫu `samples` và chuỗi `chain` sẽ cung cấp cho bạn một ước tính chính xác hơn với những phẩm chất tốt hơn cho sự không chắc chắn, tuy nhiên sẽ mất nhiều thời gian hơn để chạy.

```{r epidemic_models_run_epinow, eval=F}
## run epinow
epinow_res <- epinow(
  reported_cases = cases,
  generation_time = generation_time,
  delays = delay_opts(incubation_period),
  return_output = TRUE,
  verbose = TRUE,
  horizon = 21,
  stan = stan_opts(samples = 750, chains = 4)
)
```

#### Phân tích kết quả đầu ra {.unnumbered}

Khi code đã chạy xong, chúng ta có thể vẽ biểu đồ tóm tắt rất dễ dàng như sau. Cuộn hình ảnh để xem toàn bộ.

```{r out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F }
## plot summary figure
plot(epinow_res)
```

Chúng ta cũng có thể xem xét các thống kê tóm tắt khác nhau:

```{r epidemic_models_epinow_summary,}
## summary table
epinow_res$summary
```

Để có các phân tích sâu hơn và vẽ biểu đồ tùy chỉnh, bạn có thể truy cập vào phần ước tính hàng ngày tổng hợp thông qua `$estimates$summarised`. Chúng ta sẽ chuyển nó từ định dạng mặc định `data.table` thành định dạng `tibble` để dễ dàng sử dụng với package **dplyr**.

```{r epidemic_models_to_tibble, eval=F}
## extract summary and convert to tibble
estimates <- as_tibble(epinow_res$estimates$summarised)
estimates
```

```{r epidemic_models_tibble_show,  echo = F}
## show outputs
estimates <- as_tibble(epinow_res$estimates$summarised)
DT::datatable(
  estimates,
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap'
)
```

Để ví dụ, chúng ta hãy vẽ một biểu đồ về thời gian nhân đôi và R<sub>t</sub>. Chúng ta sẽ chỉ xem xét vài tháng đầu tiên của đợt bùng phát khi R<sub>t</sub> chỉ cao hơn một, để tránh vẽ biểu đồ số lần nhân đôi quá cao.

Chúng ta sử dụng công thức `log(2)/growth_rate` để tính thời gian nhân đôi từ tốc độ tăng trưởng ước tính.

```{r epidemic_models_plot_epinow_cusotom, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## make wide df for median plotting
df_wide <- estimates %>%
  filter(
    variable %in% c("growth_rate", "R"),
    date < as.Date("2014-09-01")
  ) %>%
  ## convert growth rates to doubling times
  mutate(
    across(
      c(median, lower_90:upper_90),
      ~ case_when(
        variable == "growth_rate" ~ log(2)/.x,
        TRUE ~ .x
      )
    ),
    ## rename variable to reflect transformation
    variable = replace(variable, variable == "growth_rate", "doubling_time")
  )

## make long df for quantile plotting
df_long <- df_wide %>%
  ## here we match matching quantiles (e.g. lower_90 to upper_90)
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## make plot
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  ## use label_parsed to allow subscript label
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(R = "R[t]", doubling_time = "Doubling~time"), label_parsed),
    strip.position = 'left'
  ) +
  ## manually define quantile transparency
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credibel\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )

```

<!-- ======================================================= -->

### EpiEstim {.unnumbered}

Để chạy **EpiEstim**, chúng ta cần cung cấp dữ liệu về số trường hợp mới mắc hàng ngày và cụ thể khoảng thời gian nối tiếp (tức là phân bố thời gian trì hoãn khởi phát triệu chứng giữa các trường hợp sơ cấp và thứ cấp).

Dữ liệu về con số mới mắc có thể được cung cấp cho **EpiEstim** dưới dạng một vectơ, một bảng số liệu, hoặc một đối tượng `incidence` nguyên bản từ package **incidence**. Bạn thậm chí có thể phân biệt giữa ca nhiễm bệnh từ nơi khác đến và tại địa phương; xem tài liệu hướng dẫn bằng cách gõ `?estimate_R` để biết thêm chi tiết.

Chúng ta sẽ tạo dữ liệu đầu vào bằng cách sử dụng package **incidence2**. Xem chương [Đường cong dịch bệnh] để xem thêm các ví dụ về package **incidence2**. Do có một số cập nhật của package **incidence2** khiến nó không hoàn toàn phù hợp với đầu vào kỳ vọng của hàm `estimateR()`, bạn cần thực hiện một số bước bổ sung cần thiết. Đối tượng incidence bao gồm một tibble với thông tin về ngày tháng và số lượng trường hợp tương ứng. Chúng ta sử dụng hàm `complete()` từ package **tidyr** để đảm bảo tất cả các ngày đều được bao gồm (kể cả những ngày không có trường hợp), và sau đó dùng hàm `rename()` để đổi tên các cột để căn chỉnh sao cho phù hợp với hàm `estimate_R()` ở bước sau.

```{r epidemic_models_epiestim_incidence,}
## get incidence from onset date
cases <- incidence2::incidence(linelist, date_index = date_onset) %>% # get case counts by day
  tidyr::complete(date_index = seq.Date(                              # ensure all dates are represented
    from = min(date_index, na.rm = T),
    to = max(date_index, na.rm=T),
    by = "day"),
    fill = list(count = 0)) %>%                                       # convert NA counts to 0
  rename(I = count,                                                   # rename to names expected by estimateR
         dates = date_index)
```

Package này cung cấp một số tùy chọn để cụ thể khoảng thời gian nối tiếp, chi tiết được cung cấp trong tài liệu hướng dẫn bằng cách gõ `?estimate_R`. Chúng tôi sẽ đề cập đến hai trong số chúng ở đây.

#### Sử dụng ước tính khoảng thời gian nối tiếp từ y văn {.unnumbered}

Sử dụng tùy chọn `method = "parametric_si"`, chúng ta có thể chỉ định thủ công trung bình và độ lệch chuẩn của khoảng thời gian nối tiếp của đối tượng `config` được tạo bằng hàm `make_config`. Chúng ta sử dụng giá trị trung bình và độ lệch chuẩn tương ứng là 12.0 và 5.2, được xác định trong [bài báo này](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0):

```{r epidemic_models_epiestim_config,}
## make config
config_lit <- make_config(
  mean_si = 12.0,
  std_si = 5.2
)
```

Sau đó, chúng ta có thể ước tính R<sub>t</sub> bằng hàm `estimate_R`:

```{r epidemic_models_epiestim_lit,  warning = FALSE}
epiestim_res_lit <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_lit
)
```

và vẽ tóm tắt các kết quả đầu ra:

```{r epidemic_models_epiestim_lit_plot,  warning = FALSE}
plot(epiestim_res_lit)
```

#### Sử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu {.unnumbered}

Vì chúng ta có dữ liệu về ngày khởi phát triệu chứng *và* các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục **EpiNow2**, chúng ta sẽ sử dụng hàm `get_pairwise` từ package **epicontacts**, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương [Chuỗi lây nhiễm] để biết thêm chi tiết):

```{r epidemic_models_epicontacts_epiestim, eval=F}
## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm `get_pairwise`). Chúng ta sử dụng hàm `fit_disc_gamma` từ package **epitrix** cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc *(discretised)*.

```{r epidemic_models_incubation_estimate_epiestim,  warning = FALSE}
## estimate gamma serial interval
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))
```

Sau đó, chúng ta chuyển thông tin này đến đối tượng `config`, và chạy **EpiEstim** một lần nữa và vẽ biểu đồ kết quả:

```{r epidemic_models_epiestim_emp,  warning = FALSE}
## make config
config_emp <- make_config(
  mean_si = serial_interval$mu,
  std_si = serial_interval$sd
)

## run epiestim
epiestim_res_emp <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_emp
)

## plot outputs
plot(epiestim_res_emp)
```

#### Cụ thể thời gian bắt đầu ước tính {.unnumbered}

Các tùy chọn mặc định này sẽ cung cấp một ước tính theo tuần và có thể hoạt động như một cảnh báo rằng bạn đang ước tính R<sub>t</sub> quá sớm trong đợt bùng phát để có một ước tính chính xác. Bạn có thể thay đổi điều này bằng cách đặt ngày bắt đầu ước tính muộn hơn như dưới đây. Thật không may, **EpiEstim** chỉ cung cấp một cách rất khó hiểu để cụ thể thời gian ước tính này, trong đó bạn phải cung cấp một vectơ **số nguyên** đề cập đến ngày bắt đầu và ngày kết thúc cho mỗi cửa sổ thời gian.

```{r epidemic_models_epiestim_config_late,}

## define a vector of dates starting on June 1st
start_dates <- seq.Date(
  as.Date("2014-06-01"),
  max(cases$dates) - 7,
  by = 1
) %>%
  ## subtract the starting date to convert to numeric
  `-`(min(cases$dates)) %>%
  ## convert to integer
  as.integer()

## add six days for a one week sliding window
end_dates <- start_dates + 6
  
## make config
config_partial <- make_config(
  mean_si = 12.0,
  std_si = 5.2,
  t_start = start_dates,
  t_end = end_dates
)
```

Bây giờ chúng ta chạy lại **EpiEstim** và có thể thấy rằng các ước tính chỉ bắt đầu từ tháng 6:

```{r epidemic_models_epiestim_config_late_run,}

## run epiestim
epiestim_res_partial <- estimate_R(
  incid = cases,
  method = "parametric_si",
  config = config_partial
)

## plot outputs
plot(epiestim_res_partial)

```

#### Phân tích kết quả đầu ra {.unnumbered}

Các đầu ra chính có thể được truy cập thông qua `$R`. Ví dụ: chúng ta sẽ tạo một biểu đồ của R<sub>t</sub> và một thước đo "khả năng truyền bệnh" được đưa ra bởi sản phẩm của R<sub>t</sub> và số trường hợp được báo cáo vào ngày đó; điều này thể hiện số trường hợp dự kiến trong thế hệ lây nhiễm tiếp theo.

```{r epidemic_models_epiestim_plot_full, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## make wide dataframe for median
df_wide <- epiestim_res_lit$R %>%
  rename_all(clean_labels) %>%
  rename(
    lower_95_r = quantile_0_025_r,
    lower_90_r = quantile_0_05_r,
    lower_50_r = quantile_0_25_r,
    upper_50_r = quantile_0_75_r,
    upper_90_r = quantile_0_95_r,
    upper_95_r = quantile_0_975_r,
    ) %>%
  mutate(
    ## extract the median date from t_start and t_end
    dates = epiestim_res_emp$dates[round(map2_dbl(t_start, t_end, median))],
    var = "R[t]"
  ) %>%
  ## merge in daily incidence data
  left_join(cases, "dates") %>%
  ## calculate risk across all r estimates
  mutate(
    across(
      lower_95_r:upper_95_r,
      ~ .x*I,
      .names = "{str_replace(.col, '_r', '_risk')}"
    )
  ) %>%
  ## seperate r estimates and risk estimates
  pivot_longer(
    contains("median"),
    names_to = c(".value", "variable"),
    names_pattern = "(.+)_(.+)"
  ) %>%
  ## assign factor levels
  mutate(variable = factor(variable, c("risk", "r")))

## make long dataframe from quantiles
df_long <- df_wide %>%
  select(-variable, -median) %>%
  ## seperate r/risk estimates and quantile levels
  pivot_longer(
    contains(c("lower", "upper")),
    names_to = c(".value", "quantile", "variable"),
    names_pattern = "(.+)_(.+)_(.+)"
  ) %>%
  mutate(variable = factor(variable, c("risk", "r")))

## make plot
ggplot() +
  geom_ribbon(
    data = df_long,
    aes(x = dates, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = dates, y = median),
    alpha = 0.2
  ) +
  ## use label_parsed to allow subscript label
  facet_wrap(
    ~ variable,
    ncol = 1,
    scales = "free_y",
    labeller = as_labeller(c(r = "R[t]", risk = "Transmission~potential"), label_parsed),
    strip.position = 'left'
  ) +
  ## manually define quantile transparency
  scale_alpha_manual(
    values = c(`50` = 0.7, `90` = 0.4, `95` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = NULL,
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    strip.background = element_blank(),
    strip.placement = 'outside'
  )
  
```

<!-- ======================================================= -->

## Dự đoán số trường hợp mắc mới

### EpiNow2 {.unnumbered}

Bên cạnh ước tính R<sub>t</sub>, package **EpiNow2** cũng hỗ trợ dự báo R<sub>t</sub> và dự báo các số trường hợp bằng cách tích hợp với package **EpiSoon**. Tất cả những gì bạn cần làm là chỉ định đối số `horizon` trong hàm `epinow` của bạn, cho biết số ngày bạn muốn dự báo trong tương lai; xem phần **EpiNow2** trong mục "Ước tính R<sub>t</sub>" để biết chi tiết về cách thiết lập và chạy **EpiNow2**. Trong phần này, chúng ta sẽ chỉ vẽ các kết quả đầu ra từ phân tích đó, được lưu trữ trong đối tượng `epinow_res`.

```{r epidemic_models_episoon, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## define minimum date for plot
min_date <- as.Date("2015-03-01")

## extract summarised estimates
estimates <-  as_tibble(epinow_res$estimates$summarised)

## extract raw data on case incidence
observations <- as_tibble(epinow_res$estimates$observations) %>%
  filter(date > min_date)

## extract forecasted estimates of case numbers
df_wide <- estimates %>%
  filter(
    variable == "reported_cases",
    type == "forecast",
    date > min_date
  )

## convert to even longer format for quantile plotting
df_long <- df_wide %>%
  ## here we match matching quantiles (e.g. lower_90 to upper_90)
  pivot_longer(
    lower_90:upper_90,
    names_to = c(".value", "quantile"),
    names_pattern = "(.+)_(.+)"
  )

## make plot
ggplot() +
  geom_histogram(
    data = observations,
    aes(x = date, y = confirm),
    stat = 'identity',
    binwidth = 1
  ) +
  geom_ribbon(
    data = df_long,
    aes(x = date, ymin = lower, ymax = upper, alpha = quantile),
    color = NA
  ) +
  geom_line(
    data = df_wide,
    aes(x = date, y = median)
  ) +
  geom_vline(xintercept = min(df_long$date), linetype = 2) +
  ## manually define quantile transparency
  scale_alpha_manual(
    values = c(`20` = 0.7, `50` = 0.4, `90` = 0.2),
    labels = function(x) paste0(x, "%")
  ) +
  labs(
    x = NULL,
    y = "Daily reported cases",
    alpha = "Credible\ninterval"
  ) +
  scale_x_date(
    date_breaks = "1 month",
    date_labels = "%b %d\n%Y"
  ) +
  theme_minimal(base_size = 14)

```

### Dự đoán {.unnumbered}

Package **projections** do RECON phát triển giúp bạn dễ dàng đưa ra dự báo số trường hợp mắc mới trong ngắn hạn, chỉ yêu cầu kiến thức về hệ số lây nhiễm hiệu quả R<sub>t</sub> và khoảng thời gian nối tiếp. Ở đây chúng tôi sẽ trình bày cách sử dụng ước tính khoảng thời gian nối tiếp từ y văn và từ ước tính của riêng chúng ta từ dữ liệu linelist.

#### Sử dụng ước tính khoảng thời gian nối tiếp từ y văn {.unnumbered}

**projections** yêu cầu một phân phối rời rạc của khoảng thời gian nối tiếp của class `distcrete` từ package **distcrete**. Chúng ta sẽ sử dụng phân phối gamma với giá trị trung bình là 12.0 và và độ lệch chuẩn là 5.2 được lấy từ [bài báo này](https://bmcmedicine.biomedcentral.com/articles/10.1186/s12916-014-0196-0). Để chuyển đổi các giá trị này thành các tham số shape và scale cần thiết cho phân phối gamma, chúng ta sẽ sử dụng hàm `gamma_mucv2shapescale` từ package **epitrix**.

```{r epidemic_models_projections_distcrete,}

## get shape and scale parameters from the mean mu and the coefficient of
## variation (e.g. the ratio of the standard deviation to the mean)
shapescale <- epitrix::gamma_mucv2shapescale(mu = 12.0, cv = 5.2/12)

## make distcrete object
serial_interval_lit <- distcrete::distcrete(
  name = "gamma",
  interval = 1,
  shape = shapescale$shape,
  scale = shapescale$scale
)

```

Sau đây là một cách kiểm tra nhanh để đảm bảo rằng khoảng thời gian nối tiếp chính xác. Chúng ta truy cập mật độ của phân phối gamma mà chúng ta vừa xác định thông qua `$d`, tương đương với cách gọi `dgamma`:

```{r epidemic_models_projections_distcrete_plot,}

## check to make sure the serial interval looks correct
qplot(
  x = 0:50, y = serial_interval_lit$d(0:50), geom = "area",
  xlab = "Serial interval", ylab = "Density"
)

```

#### Sử dụng ước tính khoảng thời gian nối tiếp từ dữ liệu {.unnumbered}

Vì chúng ta có dữ liệu về ngày khởi phát triệu chứng *và* các liên kết lây truyền, chúng ta cũng có thể ước tính khoảng thời gian nối tiếp từ bộ số liệu linelist bằng cách tính toán độ trễ giữa ngày khởi phát của các cặp người truyền bệnh-người nhiễm bệnh. Như chúng ta đã làm trong mục **EpiNow2**, chúng ta sẽ sử dụng hàm `get_pairwise` từ package **epicontacts**, cho phép chúng ta tính toán theo từng cặp sự khác biệt giữa các cặp lây truyền trong bộ số liệu linelist. Chúng ta trước hết tạo một đối tượng epicontacts (xem chương [Chuỗi lây nhiễm] để biết thêm chi tiết):

```{r epidemic_models_epicontacts_projections, eval=F}
## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id
  ) %>%
  drop_na()

## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)
```

Sau đó, chúng ta fit một phân phối gamma cho sự khác biệt về ngày khởi phát giữa các cặp lây truyền (được tính toán bằng hàm `get_pairwise`). Chúng ta sử dụng hàm `fit_disc_gamma` từ package **epitrix** cho quy trình kết hợp này, vì chúng ta yêu cầu một phân phối rời rạc *(discretised)*.

```{r epidemic_models_incubation_estimate_projections,  warning = FALSE}
## estimate gamma serial interval
serial_interval <- fit_disc_gamma(get_pairwise(epic, "date_onset"))

## inspect estimate
serial_interval[c("mu", "sd")]
```

#### Dự đoán số trường hợp mắc mới {.unnumbered}

Để dự đoán số mắc mới trong tương lai, chúng ta vẫn cần cung cấp lịch sử số mới mắc dưới dạng một đối tượng `incidence`, cũng như một mẫu các giá trị R<sub>t</sub> khả dĩ. Chúng ta sẽ tạo các giá trị này bằng cách sử dụng ước tính R<sub>t</sub> được sinh ra bởi **EpiEstim** trong phần trước (trong mục "Ước tính R<sub>t</sub>") và được lưu trữ trong đối tượng `epiestim_res_emp`. Trong đoạn code dưới đây, chúng ta trích xuất các ước tính trung bình và độ lệch chuẩn của R<sub>t</sub> cho khoảng thời gian cửa sổ cuối cùng của đợt bùng phát (sử dụng hàm `tail` để truy cập giá trị cuối cùng trong một vectơ) và mô phỏng 1000 giá trị từ phân phối gamma bằng cách sử dụng hàm `rgamma`. Bạn cũng có thể cung cấp vectơ của các giá trị R<sub>t</sub> của riêng mình mà bạn muốn sử dụng để dự báo.

```{r epidemic_models_projection_setup,  warning = FALSE}

## create incidence object from dates of onset
inc <- incidence::incidence(linelist$date_onset)

## extract plausible r values from most recent estimate
mean_r <- tail(epiestim_res_emp$R$`Mean(R)`, 1)
sd_r <- tail(epiestim_res_emp$R$`Std(R)`, 1)
shapescale <- gamma_mucv2shapescale(mu = mean_r, cv = sd_r/mean_r)
plausible_r <- rgamma(1000, shape = shapescale$shape, scale = shapescale$scale)

## check distribution
qplot(x = plausible_r, geom = "histogram", xlab = expression(R[t]), ylab = "Counts")

```

Sau đó, chúng ta sử dụng hàm `project()` để đưa ra dự báo thực tế. Chúng ta cụ thể số ngày chúng ta muốn dự báo qua đối số `n_days` và chỉ định số lượng mô phỏng bằng cách sử dụng đối số `n_sim`.

```{r epidemic_models_make_projection,}

## make projection
proj <- project(
  x = inc,
  R = plausible_r,
  si = serial_interval$distribution,
  n_days = 21,
  n_sim = 1000
)

```

Sau đó, chúng ta có thể vẽ biểu đồ số trường hợp mắc mới và số dự báo bằng cách sử dụng các hàm `plot()` và `add_projections()`. Chúng ta có thể dễ dàng lấy tập con của đối tượng `incidence` để chỉ hiển thị các trường hợp gần đây nhất bằng cách sử dụng toán tử dấu ngoặc vuông.

```{r epidemic_models_plot_projection, out.width=c('100%', '100%'), fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}

## plot incidence and projections
plot(inc[inc$dates > as.Date("2015-03-01")]) %>%
  add_projections(proj)

```

Bạn cũng có thể dễ dàng trích xuất các ước tính thô của số trường hợp hàng ngày bằng cách chuyển đổi đầu ra thành một dataframe.

```{r epidemic_models_projection_df, eval=F, warning = FALSE}
## convert to data frame for raw data
proj_df <- as.data.frame(proj)
proj_df
```

```{r epidemic_models_projection_dt,  echo = F}

## convert to data frame for raw data
proj_df <- as.data.frame(proj)

## data table output
DT::datatable(
  proj_df[1:11],
  rownames = FALSE,
  filter = "top",
  options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap'
)

```

<!-- ======================================================= -->

## Tài liệu tham khảo

-   [Bài báo này](https://www.sciencedirect.com/science/article/pii/S1755436519300350) mô tả phương pháp được thực hiện trong **EpiEstim**.
-   [Bài báo này](https://wellcomeopenresearch.org/articles/5-112/v1) mô tả phương pháp được thực hiện trong **EpiNow2**.
-   [Bài báo này](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1008409) mô tả các cân nhắc phương pháp luận và thực tế khác nhau để ước tính R<sub>t</sub>.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/epidemic_models.Rmd-->

# Truy vết tiếp xúc {#contact-tracing}

Chương này trình bày phân tích mô tả về dữ liệu truy vết tiếp xúc, bổ sung một số cân nhắc chính và cách tiếp cận độc đáo đối với kiểu dữ liệu này.

Chương này đề cập nhiều đến năng lực quản lý dữ liệu và trực quan hóa mà đã được đề cập đến trong các chương khác (ví dụ: làm sạch dữ liệu, xoay trục dữ liệu, data table, phân tích chuỗi thời gian), nhưng chúng tôi sẽ nêu bật các ví dụ cụ thể về truy vết tiếp xúc, năng lực hữu ích cho việc đưa ra quyết định hành động. Ví dụ, nó bao gồm việc trực quan hóa dữ liệu truy vết tiếp xúc theo thời gian hoặc trên các khu vực địa lý, hay tạo bảng Chỉ Số Đánh Giá Hiệu Quả Công Việc (Key Performance Indicator - KPI) rõ ràng hỗ trợ cho người giám sát truy vết tiếp xúc.

Với mục đích minh họa, chúng tôi sẽ sử dụng dữ liệu truy vết tiếp xúc mẫu từ nền tảng [Go.Data](https://www.who.int/tools/godata). Các nguyên tắc được đề cập ở đây sẽ áp dụng cho cả dữ liệu truy vết tiếp xúc từ những nền tảng khác - bạn có thể chỉ cần trải qua các bước xử lý trước dữ liệu khác nhau tùy thuộc vào cấu trúc dữ liệu của bạn.

Bạn có thể đọc thêm về dự án Go.Data trên [Trang tài liệu Github](https://worldhealthorganization.github.io/godata/) và [Cộng đồng thực hành](https://community-godata.who.int/).

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị những package cần cho các phân tích. Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ **pacman**, hàm sẽ cài đặt package nếu cần *và* gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để có thêm thông tin về các R package.

```{r, message = F}
pacman::p_load(
  rio,          # importing data  
  here,         # relative file pathways  
  janitor,      # data cleaning and tables
  lubridate,    # working with dates
  epikit,       # age_categories() function
  apyramid,     # age pyramids
  tidyverse,    # data manipulation and visualization
  RColorBrewer, # color palettes
  formattable,  # fancy tables
  kableExtra    # table formatting
)
```

### Nhập dữ liệu {.unnumbered}

Chúng ta sẽ nhập bộ dữ liệu mẫu về những người tiếp xúc và thông tin "theo dõi" của họ. Những dữ liệu này đã được truy xuất và không được lồng ghép với Go.Data API, đồng thời được lưu trữ dưới dạng tệp ".rds".

Bạn có thể tải xuống tất cả dữ liệu mẫu cho sổ tay này từ chương [Tải sách và dữ liệu].

Nếu bạn muốn tải xuống dữ liệu truy vết tiếp xúc mẫu cụ thể cho chương này, hãy sử dụng ba liên kết tải xuống dưới đây:

[Bấm để tải xuống dữ liệu điều tra ca mắc (file .rds)](https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/cases_clean.rds?raw=true'%20class='download-button)

[Bấm để tải xuống dữ liệu khai báo tiếp xúc (file .rds)](https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/contacts_clean.rds?raw=true'%20class='download-button)

[Bấm để tải xuống dữ liệu theo dõi tiếp xúc (file .rds)](https://github.com/WorldHealthOrganization/godata/blob/master/analytics/r-reporting/data/followups_clean.rds?raw=true'%20class='download-button)

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "godata_api_github.png"))
```

Ở dạng gốc các các tệp có thể tải xuống được, dữ liệu thể hiện dữ liệu gốc được cung cấp bởi Go.Data API (tìm hiểu thêm về [APIs ở đây](#import_api)). Đối với mục đích ví dụ ở đây, chúng ta sẽ làm sạch dữ liệu để giúp bạn đọc chương này dễ dàng hơn. Nếu bạn đang sử dụng một phiên bản Go.Data, bạn có thể xem hướng dẫn đầy đủ về cách truy xuất dữ liệu của mình [tại đây](https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting).

Dưới đây, các bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương về [Nhập xuất dữ liệu] để biết những cách nhập dữ liệu khác nhau. Chúng tôi sử dụng hàm `here()` để xác định đường dẫn tệp - bạn nên cung cấp đường dẫn tệp cụ thể cho máy tính của mình. Sau đó, chúng tôi sử dụng hàm `select()` để chỉ chọn một số cột nhất định của dữ liệu, nhằm đơn giản hóa cho mục đích diễn giải.

#### Dữ liệu ca mắc {.unnumbered}

Dữ liệu này là một bảng các ca mắc và thông tin về họ.

```{r}
cases <- import(here("data", "godata", "cases_clean.rds")) %>% 
  select(case_id, firstName, lastName, gender, age, age_class,
         occupation, classification, was_contact, hospitalization_typeid)
```

Dưới đây là `nrow(cases)` các trường hợp :

```{r, message=FALSE, echo=F}
DT::datatable(cases, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Dữ liệu tiếp xúc {.unnumbered}

Những dữ liệu này là một bảng gồm tất cả những người tiếp xúc và thông tin về họ. Một lần nữa, hãy cung cấp đường dẫn tệp của riêng bạn. Sau khi nhập, chúng tôi thực hiện một số bước làm sạch dữ liệu sơ bộ bao gồm:

-   Thiết lập age_class là biến kiểu factor và đảo ngược thứ tự giá trị của biến sao cho những người trẻ hơn nằm ở trên đầu\
-   Chỉ chọn một số cột nhất định, và đặt lại tên cho một trong số chúng\
-   Giả định gán các hàng missing ở cột admin_2\_name thành "Djembe", để cải thiện sự rõ ràng ở một số ví dụ trực quan hóa.

```{r}
contacts <- import(here("data", "godata", "contacts_clean.rds")) %>% 
  mutate(age_class = forcats::fct_rev(age_class)) %>% 
  select(contact_id, contact_status, firstName, lastName, gender, age,
         age_class, occupation, date_of_reporting, date_of_data_entry,
         date_of_last_exposure = date_of_last_contact,
         date_of_followup_start, date_of_followup_end, risk_level, was_case, admin_2_name) %>% 
  mutate(admin_2_name = replace_na(admin_2_name, "Djembe"))
```

Đây là `nrow(contacts)` các hàng của bộ dữ liệu `contacts`:

```{r, message=FALSE, echo=F}
DT::datatable(contacts, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Dữ liệu theo dõi {.unnumbered}

Những dữ liệu này là bản ghi của các tương tác được "theo dõi" với những người tiếp xúc. Mỗi người tiếp xúc được cho là có một cuộc gặp gỡ mỗi ngày với ca mắc trong vòng 14 ngày sau khi phơi nhiễm.

Chúng ta nhập dữ liệu và thực hiện một số bước làm sạch. Chúng ta chọn một số cột nhất định và cũng chuyển đổi tất cả các giá trị thành chữ thường ở một cột định dạng ký tự.

```{r}
followups <- rio::import(here::here("data", "godata", "followups_clean.rds")) %>% 
  select(contact_id, followup_status, followup_number,
         date_of_followup, admin_2_name, admin_1_name) %>% 
  mutate(followup_status = str_to_lower(followup_status))
```

Đây là 50 hàng đầu tiên của `nrow(followups)` - hàng của bộ dữ liệu `followups` (mỗi hàng là một người tiếp xúc được theo dõi, với trạng thái kết quả trong cột `followup_status`):

```{r, message=FALSE, echo=F}
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Dữ liệu mối quan hệ {.unnumbered}

Ở đây chúng ta nhập dữ liệu cho thấy mối quan hệ giữa các ca mắc và người tiếp xúc. Chúng ta chọn một số cột nhất định để hiển thị.

```{r}
relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_visualid, source_gender, source_age, date_of_last_contact,
         date_of_data_entry, target_visualid, target_gender,
         target_age, exposure_type)
```

Dưới đây là 50 hàng đầu tiên của bộ dữ liệu `relationships`, bộ dữ liệu này ghi lại tất cả mối quan hệ giữa các ca mắc và những người tiếp xúc.

```{r, message=FALSE, echo=F}
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## Phân tích mô tả

Bạn có thể sử dụng các kỹ thuật được đề cập đến trong những chương khác của sổ tay này để tiến hành các phân tích mô tả về những ca mắc, người tiếp xúc và mối quan hệ của họ. Dưới đây là một số ví dụ.

### Nhân khẩu học {.unnumbered}

Như được trình bày trong chương [Tháp dân số và thang đo Likert], bạn có thể trực quan hóa phân bố theo độ tuổi và giới tính (ở đây chúng tôi sử dụng package **apyramid**).

#### Tuổi và Giới tính của người tiếp xúc {.unnumbered}

Kim tự tháp dưới đây so sánh sự phân bố độ tuổi của những người tiếp xúc theo giới tính. Lưu ý rằng những người tiếp xúc bị missing tuổi được đưa vào thanh riêng của họ ở trên cùng. Bạn có thể thay đổi hiển thị mặc định này, nhưng sau đó hãy xem xét liệt kê số bị missing trong chú thích.

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = contacts,                                   # use contacts dataset
  age_group = "age_class",                           # categorical age column
  split_by = "gender") +                             # gender for halfs of pyramid
  labs(
    fill = "Gender",                                 # title of legend
    title = "Age/Sex Pyramid of COVID-19 contacts")+ # title of the plot
  theme_minimal()                                    # simple background
```

Với cấu trúc dữ liệu Go.Data, bộ dữ liệu `relationships` bao gồm độ tuổi của cả các ca mắc và những người tiếp xúc, vì vậy bạn có thể sử dụng bộ dữ liệu đó và tạo tháp tuổi cho thấy sự khác biệt giữa hai nhóm người này. Data frame `relationships` sẽ được biến đổi để chuyển các cột tuổi ở dạng số số thành các nhóm định danh (xem chương [Làm sạch số liệu và các hàm quan trọng]). Chúng ta cũng sẽ xoay trục dataframe sang định dạng dọc nhằm vẽ biểu đồ dễ dàng hơn với **ggplot2** (xem chương [Xoay trục dữ liệu]).

```{r}
relation_age <- relationships %>% 
  select(source_age, target_age) %>% 
  transmute(                              # transmute is like mutate() but removes all other columns not mentioned
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5)),
    ) %>% 
  pivot_longer(cols = contains("class"), names_to = "category", values_to = "age_class")  # pivot longer


relation_age
```

Bây giờ chúng ta có thể vẽ biểu đồ bộ dữ liệu đã chuyển đổi này với hàm `age_pyramid()` như trước đây, nhưng thay thế `gender` bởi `category` (người tiếp xúc, hoặc ca mắc).

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = relation_age,                               # use modified relationship dataset
  age_group = "age_class",                           # categorical age column
  split_by = "category") +                           # by cases and contacts
  scale_fill_manual(
    values = c("orange", "purple"),                  # to specify colors AND labels
    labels = c("Case", "Contact"))+
  labs(
    fill = "Legend",                                           # title of legend
    title = "Age/Sex Pyramid of COVID-19 contacts and cases")+ # title of the plot
  theme_minimal()                                              # simple background
```

Chúng ta cũng có thể xem xét các đặc điểm khác như cơ cấu nghề nghiệp (ví dụ: ở dạng biểu đồ tròn).

```{r, warning=F, message=F}
# Clean dataset and get counts by occupation
occ_plot_data <- cases %>% 
  mutate(occupation = forcats::fct_explicit_na(occupation),  # make NA missing values a category
         occupation = forcats::fct_infreq(occupation)) %>%   # order factor levels in order of frequency
  count(occupation)                                          # get counts by occupation
  
# Make pie chart
ggplot(data = occ_plot_data, mapping = aes(x = "", y = n, fill = occupation))+
  geom_bar(width = 1, stat = "identity") +
  coord_polar("y", start = 0) +
  labs(
    fill = "Occupation",
    title = "Known occupations of COVID-19 cases")+
  theme_minimal() +                    
  theme(axis.line = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank())
```

### Số người tiếp xúc trên mỗi ca mắc {.unnumbered}

Số người tiếp xúc trên mỗi ca mắc có thể là một thước đo quan trọng để đánh giá chất lượng của việc điều tra số người tiếp xúc và mức độ tuân thủ của người dân với việc ứng phó sức khỏe cộng đồng.

Tùy thuộc vào cấu trúc dữ liệu của bạn, điều này có thể được đánh giá thông qua bộ dữ liệu chứa thông tin tất cả các ca mắc và những người tiếp xúc. Trong bộ dữ liệu Go.Data, liên kết giữa các ca mắc ("nguồn") và những người tiếp xúc ("mục tiêu") được lưu trữ trong bộ dữ liệu `relationships`.

Trong bộ dữ liệu này, mỗi hàng là một người tiếp xúc và trong đó có liệt kê ca mắc nguồn. Không có người tiếp xúc nào có mối quan hệ với nhiều ca mắc, nhưng nếu điều này tồn tại, bạn có thể cần tính toán những người đó trước khi vẽ biểu đồ (và khám phá chúng nữa!).

Chúng ta bắt đầu bằng cách đếm số hàng (người tiếp xúc) trên mỗi ca mắc nguồn. Kết quả này được lưu dưới dạng một data frame.

```{r}
contacts_per_case <- relationships %>% 
  count(source_visualid)

contacts_per_case
```

Chúng ta sử dụng hàm `geom_histogram()` để vẽ các dữ liệu này dưới dạng biểu đồ histogram.

```{r, warning=F, message=F}
ggplot(data = contacts_per_case)+        # begin with count data frame created above
  geom_histogram(mapping = aes(x = n))+  # print histogram of number of contacts per case
  scale_y_continuous(expand = c(0,0))+   # remove excess space below 0 on y-axis
  theme_light()+                         # simplify background
  labs(
    title = "Number of contacts per case",
    y = "Cases",
    x = "Contacts per case"
  )
  

```

## Theo dõi người tiếp xúc

Dữ liệu truy vết tiếp xúc thường chứa dữ liệu "theo dõi", dữ liệu này ghi lại kết quả kiểm tra triệu chứng hàng ngày của những người trong diện cách ly. Phân tích dữ liệu này có thể xác định chiến lược ứng phó, xác định những người tiếp xúc có nguy cơ mất theo dõi hoặc có nguy cơ phát triển bệnh.

### Làm sạch dữ liệu {.unnumbered}

Những dữ liệu này có thể tồn tại ở nhiều định dạng khác nhau. Chúng có thể tồn tại dưới dạng trang tính Excel định dạng "ngang" với một hàng cho mỗi người tiếp xúc và một cột cho mỗi "ngày" theo dõi. Xem chương [Xoay trục dữ liệu] để hiểu về mô tả dữ liệu "dọc" và "ngang", và cả cách xoay trục dữ liệu sang định dạng ngang hoặc dọc.

Trong ví dụ Go.Data của chúng tôi, những dữ liệu này được lưu trữ trong data frame `followups`, data frame này có định dạng "dọc" với một hàng cho mỗi tương tác theo dõi. 50 hàng đầu tiên như sau:

```{r, message=FALSE, echo=FALSE}
# display the first 50 rows of contact linelist data as a table
DT::datatable(head(followups, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

[***CẨN TRỌNG:*** Cẩn thận với các bản trùng lặp khi xử lý dữ liệu theo dõi; vì có thể có một vài lần theo dõi sai sót trong cùng một ngày cho một người tiếp xúc nhất định. Nó dường như có vẻ là một lỗi nhưng lại phản ánh đúng thực tế - ví dụ: người theo dõi trường hợp tiếp xúc có thể gửi biểu mẫu theo dõi từ sớm trong ngày dù họ chưa liên hệ được với người tiếp xúc và gửi biểu mẫu thứ hai khi họ đã liên hệ được sau đó. Việc này sẽ phụ thuộc vào quy trình thực hiện hoạt động đối với cách bạn muốn xử lý các bản trùng lặp - chỉ cần đảm bảo ghi lại cách tiếp cận của bạn một cách rõ ràng.]{style="color: orange;"}

Hãy *xem* chúng ta có bao nhiêu trường hợp hàng "trùng lặp":

```{r}
followups %>% 
  count(contact_id, date_of_followup) %>%   # get unique contact_days
  filter(n > 1)                             # view records where count is more than 1  
```

Trong dữ liệu ví dụ của chúng ta, các bản ghi duy nhất áp dụng điều này là những bản ghi missing ID! Chúng ta có thể loại bỏ chúng. Tuy nhiên, với mục đích diễn giải, chúng ta sẽ trình bày các bước nhằm loại bỏ trùng lặp để mỗi người tiếp xúc chỉ có một lần theo dõi truy vết mỗi ngày. Xem chương [Loại bỏ trùng lặp] để biết thêm chi tiết. Chúng ta sẽ giả định rằng bản ghi cuộc gọi truy vết mới nhất là bản ghi chính xác. Chúng ta cũng tận dụng cơ hội để làm sạch cột `followup_number` ("ngày" theo dõi sẽ nằm trong khoảng 1 - 14).

```{r, warning=F, message=F}
followups_clean <- followups %>%
  
  # De-duplicate
  group_by(contact_id, date_of_followup) %>%        # group rows per contact-day
  arrange(contact_id, desc(date_of_followup)) %>%   # arrange rows, per contact-day, by date of follow-up (most recent at top)
  slice_head() %>%                                  # keep only the first row per unique contact id  
  ungroup() %>% 
  
  # Other cleaning
  mutate(followup_number = replace(followup_number, followup_number > 14, NA)) %>% # clean erroneous data
  drop_na(contact_id)                               # remove rows with missing contact_id
```

Đối với mỗi cuộc gọi truy vết tiếp theo, chúng ta có một trạng thái theo dõi (chẳng hạn như cuộc gọi truy vết có xảy ra hay không và nếu có, người tiếp xúc có triệu chứng hay không). Để xem tất cả các giá trị, chúng ta có thể chạy nhanh lệnh `tabyl()` (từ **janitor**) hoặc `table()` (từ **base** R) (xem chương [Bảng mô tả]) bằng `followup_status` để xem tần suất của từng kết quả.

Trong bộ dữ liệu này, "seen_not_ok" có nghĩa là "được thấy có triệu chứng" và "seen_ok" có nghĩa là "được thấy không có triệu chứng".

```{r}
followups_clean %>% 
  tabyl(followup_status)
```

### Vẽ biểu đồ theo thời gian {.unnumbered}

Vì dữ liệu ngày là liên tục, chúng ta sẽ sử dụng biểu đồ histogram để vẽ chúng với biến `date_of_followup` được gán cho trục x. Chúng ta có thể vẽ được biểu đồ histogram "xếp chồng" bằng cách chỉ định đối số `fill =` trong `aes()`, đối số mà chúng ta gán cho cột `followup_status`. Do đó, bạn có thể thiết lập chú thích bằng cách sử dụng đối số `fill =` của `labs()`.

Chúng ta có thể thấy rằng những người tiếp xúc được xác định theo từng đợt (có lẽ là tương ứng với các đợt dịch) và việc hoàn thành theo dõi dường như không cải thiện trong suốt đợt dịch.

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_histogram(mapping = aes(x = date_of_followup, fill = followup_status)) +
  scale_fill_discrete(drop = FALSE)+   # show all factor levels (followup_status) in the legend, even those not used
  theme_classic() +
  labs(
    x = "",
    y = "Number of contacts",
    title = "Daily Contact Followup Status",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups$date_of_followup, na.rm=T)}"))   # dynamic subtitle
  
```

[***CẨN TRỌNG:*** Nếu bạn đang chuẩn bị nhiều biểu đồ (ví dụ: cho nhiều khu vực pháp lý), bạn sẽ muốn các chú thích xuất hiện giống hệt nhau ngay cả với các mức độ hoàn thiện dữ liệu hoặc thành phần dữ liệu khác nhau. Có thể có những biểu đồ mà không phải tất cả các trạng thái theo dõi đều có trong dữ liệu, nhưng bạn vẫn muốn các danh mục đó xuất hiện trong chú thích. Trong ggplots (như trên), bạn có thể chỉ định đối số `drop = FALSE` của hàm `scale_fill_discrete()`. Trong bảng, hãy sử dụng `tabyl()` để hiển thị số lượng cho tất cả các thực bậc của factor hoặc nếu sử dụng `count()` từ **dplyr**, hãy thêm đối số `.drop = FALSE` để bao gồm số lượng của tất cả các thứ bậc factors.]{style="color: orange;"}

### Theo dõi cá nhân hàng ngày {.unnumbered}

Nếu sự bùng phát dịch của bạn đủ nhỏ, bạn có thể muốn xem xét từng người tiếp xúc và xem trạng thái của họ trong suốt quá trình theo dõi. May mắn rằng, bộ dữ liệu `followups` này đã chứa sẵn một cột với "số" ngày theo dõi (1-14). Nếu cột này không tồn tại trong dữ liệu của bạn, bạn có thể tạo ra nó bằng cách tính toán sự khác biệt giữa ngày truy vết và ngày dự định bắt đầu theo dõi người tiếp xúc.

Một cơ chế trực quan hóa thuận tiện (nếu số lượng ca mắc không quá lớn) có thể là một biểu đồ nhiệt, được tạo bằng `geom_tile()`. Xem thêm chi tiết trong chương [Biểu đồ nhiệt].

```{r, warning=F, message=F}
ggplot(data = followups_clean)+
  geom_tile(mapping = aes(x = followup_number, y = contact_id, fill = followup_status),
            color = "grey")+       # grey gridlines
  scale_fill_manual( values = c("yellow", "grey", "orange", "darkred", "darkgreen"))+
  theme_minimal()+
  scale_x_continuous(breaks = seq(from = 1, to = 14, by = 1))
```

### Phân tích theo nhóm {.unnumbered}

Có lẽ những dữ liệu theo dõi này đang được kiểm tra hàng ngày hoặc hàng tuần để đưa ra quyết định hành động. Bạn có thể muốn những phân tách có ý nghĩa hơn theo khu vực địa lý hoặc theo nhóm truy vết tiếp xúc. Chúng ta có thể làm điều này bằng cách điều chỉnh các cột được cung cấp tới hàm `group_by()`.

```{r, warning=F, message=F}

plot_by_region <- followups_clean %>%                                        # begin with follow-up dataset
  count(admin_1_name, admin_2_name, followup_status) %>%   # get counts by unique region-status (creates column 'n' with counts)
  
  # begin ggplot()
  ggplot(                                         # begin ggplot
    mapping = aes(x = reorder(admin_2_name, n),     # reorder admin factor levels by the numeric values in column 'n'
                  y = n,                            # heights of bar from column 'n'
                  fill = followup_status,           # color stacked bars by their status
                  label = n))+                      # to pass to geom_label()              
  geom_col()+                                     # stacked bars, mapping inherited from above 
  geom_text(                                      # add text, mapping inherited from above
    size = 3,                                         
    position = position_stack(vjust = 0.5), 
    color = "white",           
    check_overlap = TRUE,
    fontface = "bold")+
  coord_flip()+
  labs(
    x = "",
    y = "Number of contacts",
    title = "Contact Followup Status, by Region",
    fill = "Followup Status",
    subtitle = str_glue("Data as of {max(followups_clean$date_of_followup, na.rm=T)}")) +
  theme_classic()+                                                                      # Simplify background
  facet_wrap(~admin_1_name, strip.position = "right", scales = "free_y", ncol = 1)      # introduce facets 

plot_by_region
```

<!-- Nếu điều này được phân tách bằng người truy vết tiếp xúc, có lẽ chúng tôi muốn thêm một đường ngưỡng để hiển thị tổng # những người tiếp xúc mà thông thường một người hoặc một khu vực/nhóm có thể xử lý và cách mà khối lượng công việc hiện tại được so sánh. Chúng tôi chỉ làm điều này bằng cách sử dụng hàm `geom_hline()`. -->

<!-- ```{r, warning=F, message=F} -->

<!-- plot_by_region +  -->

<!--      geom_hline(aes(yintercept=25), color="#C70039", linetype = "dashed") # fictitious threshold at 25 contacts -->

<!-- ``` -->

## Bảng KPI

Có một số Chỉ Số Đánh Giá Hiệu Quả Công Việc (KPI) khác nhau có thể được tính toán và theo dõi ở các mức độ phân tách khác nhau và trong những khoảng thời gian khác nhau để theo dõi hiệu suất thực hiện truy vết tiếp xúc. Khi bạn đã tính toán xong và có định dạng bảng cơ bản; khá dễ dàng để hoán đổi các KPI khác nhau.

Có nhiều nguồn KPI truy vết tiếp xúc, chẳng hạn như nguồn này từ [ResolveToSaveLives.org](https://contacttracingplaybook.resolvetosavelives.org/checklists/metrics). Phần lớn công việc sẽ là xem xét cấu trúc dữ liệu và suy nghĩ về tất cả các tiêu chí bao gồm/loại trừ. Chúng tôi đưa ra một vài ví dụ dưới đây; sử dụng cấu trúc siêu dữ liệu Go.Data:

+------------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Danh mục                                             | Chỉ số                                                                                                         | Tử số Go.Data                                                                                                                       | Mẫu số Go.Data   |
+======================================================+================================================================================================================+=====================================================================================================================================+==================+
| Chỉ Số Quy Trình - Tốc Độ Truy Vết Tiếp Xúc          | \% các trường hợp được phỏng vấn và cách ly trong vòng 24 giờ kể từ khi báo cáo ca mắc                         | ĐẾM `case_id` MÀ (`date_of_reporting` - `date_of_data_entry`) \< 1 ngày VÀ (`isolation_startdate` - `date_of_data_entry`) \< 1 ngày | ĐẾM `case_id`    |
+------------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Chỉ Số Quy Trình - Tốc Độ Truy Vết Tiếp Xúc          | \% những người tiếp xúc được thông báo và cách ly trong vòng 24 giờ kể từ khi được tìm thấy                    | ĐẾM `contact_id` MÀ `followup_status` == "SEEN_NOT_OK" HOẶC "SEEN_OK" VÀ `date_of_followup` - `date_of_reporting` \< 1 ngày         | ĐẾM `contact_id` |
+------------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Chỉ Số Quy Trình - Tính Hoàn chỉnh của Việc Kiểm Tra | \% các ca mắc có triệu chứng mới được kiểm tra và phỏng vấn trong vòng 3 ngày kể từ khi bắt đầu có triệu chứng | ĐẾM `case_id` MÀ (`date_of_reporting` - `date_of_onset`) \< =3 ngày                                                                 | ĐẾM `case_id`    |
+------------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------+------------------+
| Chỉ Số Kết quả - Tổng Kết                            | \% các ca mắc mới trong danh sách liên hệ hiện có                                                              | ĐẾM `case_id` MÀ `was_contact` == "TRUE"                                                                                            | ĐẾM `case_id`    |
+------------------------------------------------------+----------------------------------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------+------------------+

Sau đây chúng tôi sẽ giới thiệu một bài tập mẫu về cách tạo bảng đẹp mắt để hiển thị thông tin theo dõi người tiếp xúc trên các khu vực hành chính. Cho tới bước cuối cùng, chúng tôi sẽ tạo bảng phù hợp để trình bày với package **formattable** (nhưng bạn có thể sử dụng các package khác như **flextable** - xem chương [Trình bày bảng]).

Cách bạn tạo một bảng như thế nào sẽ phụ thuộc vào cấu trúc của dữ liệu truy vết tiếp xúc của bạn. Sử dụng chương [Bảng mô tả] để tìm hiểu cách tóm tắt dữ liệu bằng các hàm **dplyr**.

Chúng tôi sẽ tạo một bảng động và thay đổi khi dữ liệu thay đổi. Để làm cho kết quả thú vị, chúng tôi sẽ thiết lập `report_date` nhằm cho phép chúng tôi mô phỏng việc chạy bảng vào một ngày nhất định (chúng tôi chọn ngày 10 tháng 6 năm 2020). Dữ liệu được lọc cho ngày đó.

```{r, warning=F, message=F}
# Set "Report date" to simulate running the report with data "as of" this date
report_date <- as.Date("2020-06-10")

# Create follow-up data to reflect the report date.
table_data <- followups_clean %>% 
  filter(date_of_followup <= report_date)
```

Bây giờ, dựa trên cấu trúc dữ liệu, chúng ta sẽ làm như sau:

1)  Bắt đầu với dữ liệu `followups` và tóm tắt nó để chứa cho mỗi liên hệ duy nhất:

-   Ngày của bản ghi gần nhất (bất kể tình trạng của truy vết)\
-   Ngày truy vết gần nhất mà người tiếp xúc được "seen"\
-   Trạng thái truy vết ở lần truy vết "seen" cuối cùng (ví dụ: có triệu chứng, không có triệu chứng)\

2)  Nối dữ liệu này với dữ liệu người tiếp xúc, dữ liệu mà chứa các thông tin khác như trạng thái tổng thể của người tiếp xúc, ngày tiếp xúc cuối với một ca mắc, v.v. Ngoài ra, chúng ta sẽ tính toán các số liệu được quan tâm cho mỗi người tiếp xúc, chẳng hạn như số ngày kể từ lần phơi nhiễm cuối\
3)  Chúng ta nhóm dữ liệu người tiếp xúc nâng cao theo vùng địa lý (`admin_2_name`) và tính toán tóm tắt thống kê cho mỗi khu vực\
4)  Cuối cùng, chúng ta định dạng bảng thích hợp để trình bày

Đầu tiên, chúng ta tóm tắt dữ liệu theo dõi để có được thông tin quan tâm:

```{r, warning=F, message=F}
followup_info <- table_data %>% 
  group_by(contact_id) %>% 
  summarise(
    date_last_record   = max(date_of_followup, na.rm=T),
    date_last_seen     = max(date_of_followup[followup_status %in% c("seen_ok", "seen_not_ok")], na.rm=T),
    status_last_record = followup_status[which(date_of_followup == date_last_record)]) %>% 
  ungroup()
```

Đây là cách những dữ liệu này được nhìn thấy:

```{r, echo=F}
DT::datatable(followup_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Bây giờ chúng ta sẽ thêm thông tin này vào bộ dữ liệu `contacts` và tính toán một số cột bổ sung.

```{r}
contacts_info <- followup_info %>% 
  right_join(contacts, by = "contact_id") %>% 
  mutate(
    database_date       = max(date_last_record, na.rm=T),
    days_since_seen     = database_date - date_last_seen,
    days_since_exposure = database_date - date_of_last_exposure
    )
```

Đây là cách những dữ liệu này được nhìn thấy. Lưu ý cột `contacts` nằm ở bên phải và cột mới được tính toán nằm ở ngoài cùng bên phải.

```{r, echo=F}
DT::datatable(contacts_info, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Tiếp theo, chúng ta tổng hợp dữ liệu người tiếp xúc theo khu vực, để có một data frame ngắn gọn của các cột thống kê đã tóm tắt.

```{r}
contacts_table <- contacts_info %>% 
  
  group_by(`Admin 2` = admin_2_name) %>%
  
  summarise(
    `Registered contacts` = n(),
    `Active contacts`     = sum(contact_status == "UNDER_FOLLOW_UP", na.rm=T),
    `In first week`       = sum(days_since_exposure < 8, na.rm=T),
    `In second week`      = sum(days_since_exposure >= 8 & days_since_exposure < 15, na.rm=T),
    `Became case`         = sum(contact_status == "BECAME_CASE", na.rm=T),
    `Lost to follow up`   = sum(days_since_seen >= 3, na.rm=T),
    `Never seen`          = sum(is.na(date_last_seen)),
    `Followed up - signs` = sum(status_last_record == "Seen_not_ok" & date_last_record == database_date, na.rm=T),
    `Followed up - no signs` = sum(status_last_record == "Seen_ok" & date_last_record == database_date, na.rm=T),
    `Not Followed up`     = sum(
      (status_last_record == "NOT_ATTEMPTED" | status_last_record == "NOT_PERFORMED") &
        date_last_record == database_date, na.rm=T)) %>% 
    
  arrange(desc(`Registered contacts`))

```

```{r, echo=F}
DT::datatable(contacts_table, rownames = FALSE, options = list(pageLength = 12, scrollX=T), class = 'white-space: nowrap' )
```

Và bây giờ chúng ta áp dụng kiểu bảng từ các package **formattable** và **knitr**, bao gồm một chú thích cuối trang hiển thị "kể từ" ngày.

```{r}
contacts_table %>%
  mutate(
    `Admin 2` = formatter("span", style = ~ formattable::style(
      color = ifelse(`Admin 2` == NA, "red", "grey"),
      font.weight = "bold",font.style = "italic"))(`Admin 2`),
    `Followed up - signs`= color_tile("white", "orange")(`Followed up - signs`),
    `Followed up - no signs`= color_tile("white", "#A0E2BD")(`Followed up - no signs`),
    `Became case`= color_tile("white", "grey")(`Became case`),
    `Lost to follow up`= color_tile("white", "grey")(`Lost to follow up`), 
    `Never seen`= color_tile("white", "red")(`Never seen`),
    `Active contacts` = color_tile("white", "#81A4CE")(`Active contacts`)
  ) %>%
  kable("html", escape = F, align =c("l","c","c","c","c","c","c","c","c","c","c")) %>%
  kable_styling("hover", full_width = FALSE) %>%
  add_header_above(c(" " = 3, 
                     "Of contacts currently under follow up" = 5,
                     "Status of last visit" = 3)) %>% 
  kableExtra::footnote(general = str_glue("Data are current to {format(report_date, '%b %d %Y')}"))

```

## Ma trận lây truyền

Như đã thảo luận trong chương [Biểu đồ nhiệt], bạn có thể tạo ma trận "ai đã lây nhiễm cho ai" bằng cách sử dụng hàm `geom_tile()`.

Khi những ca tiếp xúc mới được tạo, Go.Data lưu trữ thông tin về mối quan hệ này tại điểm cuối API `relationships`; chúng ta có thể thấy 50 hàng đầu tiên của bộ dữ liệu này bên dưới. Điều này có nghĩa là chúng ta có thể tạo một biểu đồ nhiệt với một vài bước với mỗi tiếp điểm được nối với ca mắc nguồn của nó.

```{r, warning=F, message=F, echo=F}
# display the first 50 rows of relationships data as a table
DT::datatable(head(relationships, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Như đã thực hiện ở trên đối với tháp tuổi so sánh các ca mắc và những người tiếp xúc, chúng ta có thể chọn một vài biến số chúng ta cần và tạo các cột nhóm tuổi được phân loại cho cả dữ liệu nguồn (ca mắc) và mục tiêu (người tiếp xúc).

```{r}
heatmap_ages <- relationships %>% 
  select(source_age, target_age) %>% 
  mutate(                              # transmute is like mutate() but removes all other columns
    source_age_class = epikit::age_categories(source_age, breakers = seq(0, 80, 5)),
    target_age_class = epikit::age_categories(target_age, breakers = seq(0, 80, 5))) 
```

Như đã mô tả bên trên, chúng ta tạo bảng chéo;

```{r, warning=F, message=FALSE}

cross_tab <- table(
  source_cases = heatmap_ages$source_age_class,
  target_cases = heatmap_ages$target_age_class)

cross_tab
```

chuyển đổi thành định dạng dọc với những tỷ lệ;

```{r, warning=FALSE, message=FALSE}

long_prop <- data.frame(prop.table(cross_tab))

```

và tạo biểu đồ nhiệt cho độ tuổi.

```{r, warning=F, message=F}

ggplot(data = long_prop)+       # use long data, with proportions as Freq
  geom_tile(                    # visualize it in tiles
    aes(
      x = target_cases,         # x-axis is case age
      y = source_cases,     # y-axis is infector age
      fill = Freq))+            # color of the tile is the Freq column in the data
  scale_fill_gradient(          # adjust the fill color of the tiles
    low = "blue",
    high = "orange")+
  theme(axis.text.x = element_text(angle = 90))+
  labs(                         # labels
    x = "Target case age",
    y = "Source case age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # legend title
  )

```

## Tài nguyên học liệu

<https://github.com/WorldHealthOrganization/godata/tree/master/analytics/r-reporting>

<https://worldhealthorganization.github.io/godata/>

<https://community-godata.who.int/>
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/contact_tracing.Rmd-->

# Phân tích khảo sát {#survey-analysis}

<!-- ======================================================= -->

## Tổng quan

Chương này trình bày việc sử dụng một số packages để phân tích khảo sát.

Hầu hết các packages R dùng để phân tích khảo sát đều dựa trên [**survey** package](https://cran.r-project.org/web/packages/survey/index.html) cho phân tích có trọng số. Chúng tôi sẽ sử dụng **survey** cũng như [**srvyr**](https://cran.r-project.org/web/packages/srvyr/index.html) (cho phép **survey** mã hóa theo kiểu tidyverse) và [**gtsummary**](https://cran.r-project.org/web/packages/gtsummary/index.html) (cho phép **survey** tạo các bảng sẵn sàng cho xuất bản). Trong khi package **survey** ban đầu không cho phép mã hóa theo kiểu tidyverse, nhưng nó có điểm cộng là cho phép khảo sát được trọng số hóa mô hình tuyến tính tổng quát (sẽ được thêm vào chương này sau). Chúng tôi cũng sẽ minh họa bằng cách sử dụng một hàm từ package [**sitrep**](https://github.com/R4EPI/sitrep) để tạo mẫu trọng số (*lưu ý* package này hiện chưa có trên CRAN, nhưng có thể được cài đặt từ github).

Hầu hết chương này dựa trên công việc đã hoàn thành của [dự án "R4Epis"](https://r4epis.netlify.app/); để biết code chi tiết và mẫu R-markdown xem [trang github của "R4Epis"](https://github.com/R4EPI/sitrep). Một số package **survey** dựa trên các phiên bản đầu tiên của [các nghiên cứuu trường hợp EPIET](https://github.com/EPIET/RapidAssessmentSurveys).

Hiện tại, chương này không đề cập đến các phép tính cỡ mẫu hoặc lấy mẫu. Để tính cỡ mẫu đơn giản, hãy xem [OpenEpi](https://www.openepi.com/Menu/OE_Menu.htm). Chương [GIS cơ bản] trong sổ tay này sẽ có một phần về lấy mẫu ngẫu nhiên theo không gian và chương này cũng sẽ đề cập một phần về khung lấy mẫu cũng như tính toán cỡ mẫu.

1.  Dữ liệu khảo sát
2.  Thời gian quan sát
3.  Áp dụng trọng số
4.  Đối tượng thiết kế nghiên cứu
5.  Phân tích mô tả
6.  Tỷ lệ được áp dụng trọng số
7.  Tỷ suất được áp dụng trọng số

<!-- ======================================================= -->

## Chuẩn bị

### Packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R. Ở đây chúng tôi cũng minh họa việc sử dụng hàm `p_load_gh()` từ **pacman** để cài đặt một package tải từ github mà chưa được công bố trên CRAN.

```{r}

## load packages from CRAN
pacman::p_load(rio,          # File import
               here,         # File locator
               tidyverse,    # data management + ggplot2 graphics
               tsibble,      # handle time series datasets
               survey,       # for survey functions
               srvyr,        # dplyr wrapper for survey package
               gtsummary,    # wrapper for survey package to produce tables
               apyramid,     # a package dedicated to creating age pyramids
               patchwork,    # for combining ggplots
               ggforce       # for alluvial/sankey plots
               ) 

## load packages from github
pacman::p_load_gh(
     "R4EPI/sitrep"          # for observation time / weighting functions
)

```

### Nạp dữ liệu {.unnumbered}

Bộ dữ liệu ví dụ được sử dụng trong phần này:

-   dữ liệu điều tra tỷ lệ tử vong mô phỏng.
-   số lượng dân cư mô phỏng cho khu vực khảo sát.
-   từ điển dữ liệu cho dữ liệu khảo sát tử vong mô phỏng.

Bộ này dựa trên khảo sát đã được phê duyệt trước của hội đồng đạo đức MSF OCA. Các tập dữ liệu mô phỏng được tạo như một phần của [Dự án "R4Epis"](https://r4epis.netlify.app/). Tất cả đều dựa trên dữ liệu được thu thập bằng [KoboToolbox](https://www.kobotoolbox.org/), đây là một phần mềm thu thập dữ liệu dựa trên [Open Data Kit](https://opendatakit.org/).

Kobo cho phép bạn xuất cả dữ liệu đã thu thập, cũng như từ điển dữ liệu cho tập dữ liệu đó. Chúng tôi thực sự khuyên bạn nên làm điều này vì nó đơn giản hóa việc làm sạch dữ liệu và hữu ích cho việc tra cứu các biến/câu hỏi.

[***MẸO:*** Từ điển dữ liệu Kobo có tên biến trong cột "name" của sheet "survey" (khảo sát). Các giá trị có thể có cho mỗi biến được chỉ định trong sheet "choices" (lựa chọn). Trong tab lựa chọn, "name" có giá trị rút gọn và các cột "label::english" và "label::french" chứa các nhãn mô tả đầy đủ. Sử dụng hàm `msf_dict_survey()` của package **epidict** để nhập tệp excel từ điển Kobo sẽ định dạng lại tệp này cho bạn để bạn có thể dễ dàng sử dụng để code lại.]{style="color: darkgreen;"}

[***THẬN TRỌNG:*** Bộ dữ liệu ví dụ không giống nhau dưới dạng xuất (như trong Kobo, bạn xuất từng cấp bảng câu hỏi khác nhau) - xem phần dữ liệu khảo sát bên dưới để hợp nhất các cấp độ khác nhau.]{style="color: orange;"}

Bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương về [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau.

```{r echo = FALSE}
# import the survey into R
survey_data <- rio::import(here::here("data", "surveys", "survey_data.xlsx"))

# import the dictionary into R
survey_dict <- rio::import(here::here("data", "surveys", "survey_dict.xlsx")) 

# import the population in to R 
population <- rio::import(here::here("data", "surveys", "population.xlsx"))
```

```{r eval = FALSE}
# import the survey data
survey_data <- rio::import("survey_data.xlsx")

# import the dictionary into R
survey_dict <- rio::import("survey_dict.xlsx") 
```

10 hàng đầu tiên của khảo sát được hiển thị bên dưới.

```{r, message = FALSE, echo = FALSE}
# display the survey data as a table
DT::datatable(head(survey_data, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Chúng ta cũng muốn nhập dữ liệu về quần thể lấy mẫu để có thể tạo ra các trọng số thích hợp. Dữ liệu này có thể ở các định dạng khác nhau, tuy nhiên chúng tôi khuyên bạn nên định dạng như hình bên dưới (dữ liệu này có thể chỉ cần nhập vào excel).

```{r read_data_pop_show, eval = FALSE}
# import the population data
population <- rio::import("population.xlsx")
```

10 hàng đầu tiên của khảo sát được hiển thị bên dưới.

```{r message=FALSE, echo=F}
# display the survey data as a table
DT::datatable(head(population, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Đối với khảo sát theo cụm, bạn có thể muốn thêm trọng số khảo sát ở cấp cụm. Bạn có thể đọc dữ liệu này như trên. Ngoài ra, nếu số lượng ít, chúng có thể được nhập như dưới đây dưới dạng một tibble. Trong mọi trường hợp, bạn sẽ cần có một cột với mã định danh cụm khớp với dữ liệu khảo sát của bạn và một cột khác với số lượng hộ gia đình ở từng cụm.

```{r cluster_counts}

## define the number of households in each cluster
cluster_counts <- tibble(cluster = c("village_1", "village_2", "village_3", "village_4", 
                                     "village_5", "village_6", "village_7", "village_8",
                                     "village_9", "village_10"), 
                         households = c(700, 400, 600, 500, 300, 
                                        800, 700, 400, 500, 500))

```

### Làm sạch dữ liệu {.unnumbered}

Dưới đây đảm bảo rằng cột ngày ở định dạng thích hợp. Có một số cách khác để thực hiện việc này (xem chương [Làm việc với ngày tháng] để biết chi tiết), tuy nhiên sử dụng từ điển để xác định ngày sẽ nhanh chóng và dễ dàng.

Chúng tôi cũng tạo một biến nhóm tuổi bằng cách sử dụng hàm `age_categories()` từ **epikit** - xem phần [Làm sạch dữ liệu](#cleaning) của sổ tay để biết chi tiết. Ngoài ra, chúng tôi tạo một biến ký tự xác định các cụm khác nhau nằm trong khu vực nào.

Cuối cùng, chúng tôi mã hóa lại tất cả các biến yes/no thành các biến TRUE/FALSE - nếu không, các biến này không thể được sử dụng bởi các hàm tính tỷ lệ trong package **survey**.

```{r cleaning}

## select the date variable names from the dictionary 
DATEVARS <- survey_dict %>% 
  filter(type == "date") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select date vars
  
## change to dates 
survey_data <- survey_data %>%
  mutate(across(all_of(DATEVARS), as.Date))


## add those with only age in months to the year variable (divide by twelve)
survey_data <- survey_data %>% 
  mutate(age_years = if_else(is.na(age_years), 
                             age_months / 12, 
                             age_years))

## define age group variable
survey_data <- survey_data %>% 
     mutate(age_group = age_categories(age_years, 
                                    breakers = c(0, 3, 15, 30, 45)
                                    ))


## create a character variable based off groups of a different variable 
survey_data <- survey_data %>% 
  mutate(health_district = case_when(
    cluster_number %in% c(1:5) ~ "district_a", 
    TRUE ~ "district_b"
  ))


## select the yes/no variable names from the dictionary 
YNVARS <- survey_dict %>% 
  filter(type == "yn") %>% 
  filter(name %in% names(survey_data)) %>% 
  ## filter to match the column names of your data
  pull(name) # select yn vars
  
## change to dates 
survey_data <- survey_data %>%
  mutate(across(all_of(YNVARS), 
                str_detect, 
                pattern = "yes"))

```

<!-- ======================================================= -->

## Dữ liệu khảo sát

Có rất nhiều thiết kế lấy mẫu khác nhau có thể được sử dụng cho các khảo sát. Ở đây chúng tôi sẽ trình bày code cho: - Phân tầng - Cụm - Cụm phân tầng  

Như đã mô tả ở trên (tùy thuộc vào cách bạn thiết kế bảng câu hỏi của mình), dữ liệu cho mỗi cấp độ sẽ được xuất dưới dạng bộ dữ liệu riêng biệt từ Kobo. Trong ví dụ của chúng tôi, có một cấp cho các hộ gia đình và một cấp cho các cá nhân trong các hộ gia đình đó.  

Hai cấp độ này được liên kết bởi một mã định danh duy nhất. Đối với bộ dữ liệu Kobo, biến này là "\_index" ở cấp hộ gia đình, khớp với "\_parent_index" ở cấp cá nhân. Thao tác này sẽ tạo các hàng mới cho hộ gia đình với mỗi cá nhân phù hợp, hãy xem chương [Nối dữ liệu](#joining-matching) để biết chi tiết.  

```{r merge_data_levels, eval = FALSE}

## join the individual and household data to form a complete data set
survey_data <- left_join(survey_data_hh, 
                         survey_data_indiv,
                         by = c("_index" = "_parent_index"))


## create a unique identifier by combining indeces of the two levels 
survey_data <- survey_data %>% 
     mutate(uid = str_glue("{index}_{index_y}"))

```

<!-- ======================================================= -->

## Thời gian quan sát

Đối với các cuộc khảo sát về tỷ lệ tử vong, chúng ta muốn biết mỗi cá nhân đã có mặt tại địa điểm trong bao lâu để có thể tính toán tỷ lệ tử vong thích hợp trong khoảng thời gian nghiên cứu. Điều này không áp dụng đối với tất cả các cuộc điều tra, nhưng đặc biệt rất quan trọng đối với các cuộc điều tra tử vong vì chúng thường được khảo sát ở các quần thể di động hoặc di cư.  

Để làm điều này, trước tiên chúng ta xác định khoảng thời gian quan tâm, còn được gọi là khoảng thời gian hồi cứu (tức là thời gian mà những người tham gia được yêu cầu báo cáo khi trả lời câu hỏi). Sau đó, chúng ta có thể sử dụng khoảng thời gian này để đặt các ngày không thích hợp thành giá trị missing, vd: các trường hợp tử vong được báo cáo ngoài khoảng thời gian quan tâm.  

```{r recall_period}

## set the start/end of recall period
## can be changed to date variables from dataset 
## (e.g. arrival date & date questionnaire)
survey_data <- survey_data %>% 
  mutate(recall_start = as.Date("2018-01-01"), 
         recall_end   = as.Date("2018-05-01")
  )


# set inappropriate dates to NA based on rules 
## e.g. arrivals before start, departures departures after end
survey_data <- survey_data %>%
      mutate(
           arrived_date = if_else(arrived_date < recall_start, 
                                 as.Date(NA),
                                  arrived_date),
           birthday_date = if_else(birthday_date < recall_start,
                                  as.Date(NA),
                                  birthday_date),
           left_date = if_else(left_date > recall_end,
                              as.Date(NA),
                               left_date),
           death_date = if_else(death_date > recall_end,
                               as.Date(NA),
                               death_date)
           )

```

Sau đó, chúng ta có thể sử dụng các biến ngày của mình để xác định ngày bắt đầu và ngày kết thúc cho từng cá nhân. Chúng ta có thể sử dụng hàm `find_start_date()` từ **sitrep** để xác định ngày bắt đầu và sau đó sử dụng hàm đó để tính toán sự khác biệt giữa các ngày (người-thời gian).  

Ngày bắt đầu: Sự kiện phù hợp tới sớm nhất trong khoảng thời gian hồi cứu của bạn. Hoặc là ngày bắt đầu thời gian hồi cứu của bạn (mà bạn xác định trước) hoặc ngày sau khi bắt đầu hồi cứu nếu có (ví dụ: đi đến hoặc sinh ra)  

Ngày kết thúc: Sự kiện dừng lại thích hợp sớm nhất trong thời gian hồi cứu của bạn. Hoặc là ngày kết thúc thời gian hồi cứu hoặc ngày trước khi kết thúc hồi cứu nếu có (ví dụ: rời đi, tử vong)  

```{r observation_time}

## create new variables for start and end dates/causes
survey_data <- survey_data %>% 
     ## choose earliest date entered in survey
     ## from births, household arrivals, and camp arrivals 
     find_start_date("birthday_date",
                  "arrived_date",
                  period_start = "recall_start",
                  period_end   = "recall_end",
                  datecol      = "startdate",
                  datereason   = "startcause" 
                 ) %>%
     ## choose earliest date entered in survey
     ## from camp departures, death and end of the study
     find_end_date("left_date",
                "death_date",
                period_start = "recall_start",
                period_end   = "recall_end",
                datecol      = "enddate",
                datereason   = "endcause" 
               )


## label those that were present at the start/end (except births/deaths)
survey_data <- survey_data %>% 
     mutate(
       ## fill in start date to be the beginning of recall period (for those empty) 
       startdate = if_else(is.na(startdate), recall_start, startdate), 
       ## set the start cause to present at start if equal to recall period 
       ## unless it is equal to the birth date 
       startcause = if_else(startdate == recall_start & startcause != "birthday_date",
                              "Present at start", startcause), 
       ## fill in end date to be end of recall period (for those empty) 
       enddate = if_else(is.na(enddate), recall_end, enddate), 
       ## set the end cause to present at end if equall to recall end 
       ## unless it is equal to the death date
       endcause = if_else(enddate == recall_end & endcause != "death_date", 
                            "Present at end", endcause))


## Define observation time in days
survey_data <- survey_data %>% 
  mutate(obstime = as.numeric(enddate - startdate))

```

<!-- ======================================================= -->

## Áp dụng trọng số

Điều quan trọng là bạn phải loại bỏ các đối tượng có lỗi trước khi thêm trọng số khảo sát. Ví dụ: nếu bạn có các quan sát với thời gian theo dõi âm, bạn sẽ cần kiểm tra các đối tượng đó (bạn có thể thực hiện việc này với hàm `assert_positive_timespan()` từ **sitrep**. Một điều khác là nếu bạn muốn bỏ các hàng trống (ví dụ: với `drop_na(uid)`) hoặc xóa các bản ghi trùng lặp (xem chương [Loại bỏ trùng lặp] trong sổ tay này để biết thêm chi tiết). Những đối tượng không có sự đồng ý tham gia nghiên cứu cũng cần phải bị xóa.  

Trong ví dụ này, chúng ta lọc các trường hợp muốn loại bỏ và lưu trữ chúng trong một dataframe riêng - theo cách này, chúng ta có thể mô tả những trường hợp đã bị loại khỏi khảo sát. Sau đó, chúng ta sử dụng hàm `anti_join()` từ **dplyr** để xóa những trường hợp bị loại bỏ này khỏi dữ liệu khảo sát của chúng ta.

[***NGUY HIỂM:*** Bạn không thể có giá trị missing trong biến trọng số của mình hoặc bất kỳ biến nào có liên quan đến thiết kế khảo sát của bạn (ví dụ: tuổi, giới tính, biến phân tầng hoặc cụm).]{style="color: red;"}  

```{r remove_unused_data}

## store the cases that you drop so you can describe them (e.g. non-consenting 
## or wrong village/cluster)
dropped <- survey_data %>% 
  filter(!consent | is.na(startdate) | is.na(enddate) | village_name == "other")

## use the dropped cases to remove the unused rows from the survey data set  
survey_data <- anti_join(survey_data, dropped, by = names(dropped))

```

Như đã đề cập ở trên, chúng tôi trình bày cách thêm trọng số cho ba thiết kế nghiên cứu khác nhau (phân tầng, phân cụm và cụm phân tầng). Chúng yêu cầu thông tin về dân số gốc và/hoặc các cụm được khảo sát. Chúng tôi sẽ sử dụng code cụm phân tầng cho ví dụ này, nhưng hãy sử dụng code nào thích hợp nhất cho thiết kế nghiên cứu của bạn.  

```{r survey_weights}

# stratified ------------------------------------------------------------------
# create a variable called "surv_weight_strata"
# contains weights for each individual - by age group, sex and health district
survey_data <- add_weights_strata(x = survey_data,
                                         p = population,
                                         surv_weight = "surv_weight_strata",
                                         surv_weight_ID = "surv_weight_ID_strata",
                                         age_group, sex, health_district)

## cluster ---------------------------------------------------------------------

# get the number of people of individuals interviewed per household
# adds a variable with counts of the household (parent) index variable
survey_data <- survey_data %>%
  add_count(index, name = "interviewed")


## create cluster weights
survey_data <- add_weights_cluster(x = survey_data,
                                          cl = cluster_counts,
                                          eligible = member_number,
                                          interviewed = interviewed,
                                          cluster_x = village_name,
                                          cluster_cl = cluster,
                                          household_x = index,
                                          household_cl = households,
                                          surv_weight = "surv_weight_cluster",
                                          surv_weight_ID = "surv_weight_ID_cluster",
                                          ignore_cluster = FALSE,
                                          ignore_household = FALSE)


# stratified and cluster ------------------------------------------------------
# create a survey weight for cluster and strata
survey_data <- survey_data %>%
  mutate(surv_weight_cluster_strata = surv_weight_strata * surv_weight_cluster)

```

<!-- ======================================================= -->

## Đối tượng theo thiết kế nghiên cứu

Tạo đối tượng khảo sát theo thiết kế nghiên cứu của bạn. Sử dụng theo cách tương tự như dataframe để tính toán trọng số cho tỷ lệ, v.v. Đảm bảo rằng tất cả các biến cần thiết đã được tạo trước bước này.  

Có bốn tùy chọn, hãy đánh dấu thành bình luận những tùy chọn bạn không sử dụng: - Ngẫu nhiên đơn - Phân tầng - Cụm - Cụm phân tầng  

Đối với mẫu này - chúng ta sẽ giả vờ rằng chúng ta nhóm cụm các cuộc khảo sát theo hai tầng riêng biệt (khu vực A và B). Vì vậy, để có được ước tính tổng thể, chúng ta cần có trọng số kết hợp của cụm và tầng.  

Như đã đề cập trước đây, có hai packages có sẵn để thực hiện việc này. Package cổ điển là **survey** và một package gọn hơn được gọi là **srvyr** giúp tạo các đối tượng và hàm theo phong cách tidyverse. Chúng tôi sẽ trình bày cả hai, nhưng lưu ý rằng hầu hết code trong chương này sẽ sử dụng các đối tượng dựa trên **srvyr**. Một ngoại lệ là package **gtsummary** chỉ chấp nhận các đối tượng từ package **survey**.  

### Package **Survey** 

Package **survey** sử dụng hiệu quả code **base** *R* nên không thể sử dụng các pipes (`%>%`) hoặc các cú pháp **dplyr** khác. Với package **survey**, chúng tôi sử dụng hàm `svydesign()` để xác định đối tượng khảo sát với các cụm, trọng số và tầng thích hợp.  

[***LƯU Ý:*** chúng ta cần sử dụng dấu ngã (`~`) trước các biến, điều này là do package sử dụng cú pháp **base** *R* để gán các biến dựa trên công thức.]{style="color: black;"}  

```{r survey_design}

# simple random ---------------------------------------------------------------
base_survey_design_simple <- svydesign(ids = ~1, # 1 for no cluster ids
                   weights = NULL,               # No weight added
                   strata = NULL,                # sampling was simple (no strata)
                   data = survey_data            # have to specify the dataset
                  )

## stratified ------------------------------------------------------------------
base_survey_design_strata <- svydesign(ids = ~1,  # 1 for no cluster ids
                   weights = ~surv_weight_strata, # weight variable created above
                   strata = ~health_district,     # sampling was stratified by district
                   data = survey_data             # have to specify the dataset
                  )

# cluster ---------------------------------------------------------------------
base_survey_design_cluster <- svydesign(ids = ~village_name, # cluster ids
                   weights = ~surv_weight_cluster, # weight variable created above
                   strata = NULL,                 # sampling was simple (no strata)
                   data = survey_data              # have to specify the dataset
                  )

# stratified cluster ----------------------------------------------------------
base_survey_design <- svydesign(ids = ~village_name,      # cluster ids
                   weights = ~surv_weight_cluster_strata, # weight variable created above
                   strata = ~health_district,             # sampling was stratified by district
                   data = survey_data                     # have to specify the dataset
                  )
```

### Package **Srvyr** 

Với package **srvyr**, chúng ta có thể sử dụng hàm `as_survey_design()`, nó có tất cả các đối số tương tự như trên nhưng cho phép dùng các pipes (`%>%`), và vì vậy chúng ta không cần sử dụng dấu ngã (`~`).  
 
```{r survey_design_srvyr}
## simple random ---------------------------------------------------------------
survey_design_simple <- survey_data %>% 
  as_survey_design(ids = 1, # 1 for no cluster ids 
                   weights = NULL, # No weight added
                   strata = NULL # sampling was simple (no strata)
                  )
## stratified ------------------------------------------------------------------
survey_design_strata <- survey_data %>%
  as_survey_design(ids = 1, # 1 for no cluster ids
                   weights = surv_weight_strata, # weight variable created above
                   strata = health_district # sampling was stratified by district
                  )
## cluster ---------------------------------------------------------------------
survey_design_cluster <- survey_data %>%
  as_survey_design(ids = village_name, # cluster ids
                   weights = surv_weight_cluster, # weight variable created above
                   strata = NULL # sampling was simple (no strata)
                  )

## stratified cluster ----------------------------------------------------------
survey_design <- survey_data %>%
  as_survey_design(ids = village_name, # cluster ids
                   weights = surv_weight_cluster_strata, # weight variable created above
                   strata = health_district # sampling was stratified by district
                  )
```

<!-- ======================================================= -->

## Phân tích mô tả  

Phân tích mô tả và trực quan hóa cơ bản được đề cập nhiều trong các chương khác của cuốn sổ tay, vì vậy chúng tôi sẽ không đi sâu vào nó ở đây. Để biết chi tiết, hãy xem các chương về [Bảng mô tả], [Các kiểm định thống kê cơ bản], [Trình bày bảng], [ggplot cơ bản] và [Báo cáo với R Markdown].  

Trong phần này, chúng ta sẽ tập trung vào cách điều tra sai số trong mẫu của bạn và trực quan hóa chúng. Chúng ta cũng sẽ xem xét việc trực quan hóa dòng dân cư trong bối cảnh khảo sát bằng cách sử dụng sơ đồ luồng alluvial/sankey.  

Nhìn chung, bạn nên xem xét đưa vào các phân tích mô tả sau:  

-   Số cụm, hộ gia đình và cá nhân cuối cùng được đưa vào
-   Số lượng cá nhân bị loại trừ và lý do loại trừ
-   Trung vị (biên độ) số hộ gia đình trên một cụm và số cá thể trên một hộ gia đình  

### Sai số chọn mẫu  

So sánh tỷ lệ trong từng nhóm tuổi giữa mẫu của bạn và quần thể gốc. Điều này rất quan trọng để có thể làm nổi bật sai số chọn mẫu tiềm ẩn. Tương tự, bạn có thể lặp lại điều này khi xem xét sự phân bố theo giới tính.

Lưu ý rằng các giá trị p từ phép kiểm định hai nhóm chỉ mang tính chất chỉ dẫn và phần thảo luận mang tính mô tả (hoặc trực quan với tháp tuổi bên dưới) về các phân bố trong mẫu nghiên cứu của bạn so với quần thể gốc là quan trọng. Đó là bởi vì việc tăng cỡ mẫu sẽ hay dẫn đến những khác biệt có thể không liên quan sau khi áp dụng trọng số vào dữ liệu của bạn.  

```{r descriptive_sampling_bias, warning = FALSE}

## counts and props of the study population
ag <- survey_data %>% 
  group_by(age_group) %>% 
  drop_na(age_group) %>% 
  tally() %>% 
  mutate(proportion = n / sum(n), 
         n_total = sum(n))

## counts and props of the source population
propcount <- population %>% 
  group_by(age_group) %>%
    tally(population) %>%
    mutate(proportion = n / sum(n))

## bind together the columns of two tables, group by age, and perform a 
## binomial test to see if n/total is significantly different from population
## proportion.
  ## suffix here adds to text to the end of columns in each of the two datasets
left_join(ag, propcount, by = "age_group", suffix = c("", "_pop")) %>%
  group_by(age_group) %>%
  ## broom::tidy(binom.test()) makes a data frame out of the binomial test and
  ## will add the variables p.value, parameter, conf.low, conf.high, method, and
  ## alternative. We will only use p.value here. You can include other
  ## columns if you want to report confidence intervals
  mutate(binom = list(broom::tidy(binom.test(n, n_total, proportion_pop)))) %>%
  unnest(cols = c(binom)) %>% # important for expanding the binom.test data frame
  mutate(proportion_pop = proportion_pop * 100) %>%
  ## Adjusting the p-values to correct for false positives 
  ## (because testing multiple age groups). This will only make 
  ## a difference if you have many age categories
  mutate(p.value = p.adjust(p.value, method = "holm")) %>%
                      
  ## Only show p-values over 0.001 (those under report as <0.001)
  mutate(p.value = ifelse(p.value < 0.001, 
                          "<0.001", 
                          as.character(round(p.value, 3)))) %>% 
  
  ## rename the columns appropriately
  select(
    "Age group" = age_group,
    "Study population (n)" = n,
    "Study population (%)" = proportion,
    "Source population (n)" = n_pop,
    "Source population (%)" = proportion_pop,
    "P-value" = p.value
  )
```

### Tháp dân số  

Tháp dân số (hoặc tháp tuổi-giới) là một cách dễ dàng để trực quan hóa sự phân bố trong quần thể khảo sát của bạn. Cũng nên xem xét việc tạo [Bảng mô tả] về độ tuổi và giới tính theo tầng khảo sát. Chúng ta sẽ minh họa bằng package **apyramid** vì nó cho phép các tỷ lệ được áp dụng trọng số sử dụng đối tượng theo thiết kế nghiên cứu mà chúng ta đã tạo ở trên. Các tùy chọn khác để tạo [Tháp dân số](#age-pyramid) được đề cập nhiều hơn trong chương đó của sổ tay. Chúng ta cũng sẽ sử dụng một hàm gọn hơn từ **sitrep** được gọi là `plot_age_pyramid()` để lưu một vài dòng code để tạo ra một biểu đồ theo tỷ lệ.  

Giống như với phép kiểm định sự khác biệt giữa hai nhóm chuẩn được thảo luận ở trên trong phần sai số chọn mẫu, ở đây chúng ta quan tâm đến việc trực quan hóa liệu quần thể mẫu của chúng ta có khác biệt đáng kể so với quần thể gốc hay không, và liệu trọng số có sửa chữa được sự khác biệt này hay không. Để làm điều này, chúng ta sẽ sử dụng package **patchwork** để hiển thị các biểu đồ tạo bởi **ggplot** song song với nhau; chi tiết xem phần kết hợp các đồ thị trong chương [Các tips với ggplot] của sổ tay này. Chúng ta sẽ trực quan hóa quần thể gốc, quần thể khảo sát không trọng số và quần thể khảo sát có trọng số. Bạn cũng có thể xem xét trực quan theo từng tầng của khảo sát - bằng cách sử dụng đối số `stack_by  = "health_district"` trong ví dụ của chúng tôi ở đây (xem `?plot_age_pyramid` để biết chi tiết).  

[***Lưu ý:*** Trục x và y được lật ngược trong tháp]{style="color: black;"}

```{r weighted_age_pyramid, warning = FALSE, message = FALSE, fig.show = "hold", fig.width = 15}

## define x-axis limits and labels ---------------------------------------------
## (update these numbers to be the values for your graph)
max_prop <- 35      # choose the highest proportion you want to show 
step <- 5           # choose the space you want beween labels 

## this part defines vector using the above numbers with axis breaks
breaks <- c(
    seq(max_prop/100 * -1, 0 - step/100, step/100), 
    0, 
    seq(0 + step / 100, max_prop/100, step/100)
    )

## this part defines vector using the above numbers with axis limits
limits <- c(max_prop/100 * -1, max_prop/100)

## this part defines vector using the above numbers with axis labels
labels <-  c(
      seq(max_prop, step, -step), 
      0, 
      seq(step, max_prop, step)
    )


## create plots individually  --------------------------------------------------

## plot the source population 
## nb: this needs to be collapsed for the overall population (i.e. removing health districts)
source_population <- population %>%
  ## ensure that age and sex are factors
  mutate(age_group = factor(age_group, 
                            levels = c("0-2", 
                                       "3-14", 
                                       "15-29",
                                       "30-44", 
                                       "45+")), 
         sex = factor(sex)) %>% 
  group_by(age_group, sex) %>% 
  ## add the counts for each health district together 
  summarise(population = sum(population)) %>% 
  ## remove the grouping so can calculate overall proportion
  ungroup() %>% 
  mutate(proportion = population / sum(population)) %>% 
  ## plot pyramid 
  age_pyramid(
            age_group = age_group, 
            split_by = sex, 
            count = proportion, 
            proportional = TRUE) +
  ## only show the y axis label (otherwise repeated in all three plots)
  labs(title = "Source population", 
       y = "", 
       x = "Age group (years)") + 
  ## make the x axis the same for all plots 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)
  
  
## plot the unweighted sample population 
sample_population <- plot_age_pyramid(survey_data, 
                 age_group = "age_group", 
                 split_by = "sex",
                 proportion = TRUE) + 
  ## only show the x axis label (otherwise repeated in all three plots)
  labs(title = "Unweighted sample population", 
       y = "Proportion (%)", 
       x = "") + 
  ## make the x axis the same for all plots 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)


## plot the weighted sample population 
weighted_population <- survey_design %>% 
  ## make sure the variables are factors
  mutate(age_group = factor(age_group), 
         sex = factor(sex)) %>%
  plot_age_pyramid(
    age_group = "age_group",
    split_by = "sex", 
    proportion = TRUE) +
  ## only show the x axis label (otherwise repeated in all three plots)
  labs(title = "Weighted sample population", 
       y = "", 
       x = "")  + 
  ## make the x axis the same for all plots 
  scale_y_continuous(breaks = breaks, 
    limits = limits, 
    labels = labels)

## combine all three plots  ----------------------------------------------------
## combine three plots next to eachother using + 
source_population + sample_population + weighted_population + 
  ## only show one legend and define theme 
  ## note the use of & for combining theme with plot_layout()
  plot_layout(guides = "collect") & 
  theme(legend.position = "bottom",                    # move legend to bottom
        legend.title = element_blank(),                # remove title
        text = element_text(size = 18),                # change text size
        axis.text.x = element_text(angle = 45, hjust = 1, vjust = 1) # turn x-axis text
       )
```

### Sơ đồ alluvial/sankey

Trực quan điểm bắt đầu và kết quả của từng cá nhân có thể rất hữu ích để có được cái nhìn tổng quan. Có một ứng dụng khá rõ ràng cho quần thể di động, tuy nhiên có rất nhiều ứng dụng khác như nhóm thuần tập hoặc bất kỳ tình huống nào khác trong đó có sự chuyển đổi ở các trạng thái của các cá nhân. Các sơ đồ này có một số tên khác nhau bao gồm các tập hợp alluvial, sankey và parallel - chi tiết có trong chương sổ tay về [Sơ đồ và biểu đồ].  

```{r visualise_population_flow}

## summarize data
flow_table <- survey_data %>%
  count(startcause, endcause, sex) %>%  # get counts 
  gather_set_data(x = c("startcause", "endcause")) %>%     # change format for plotting
  mutate(x = fct_relevel(x, c("startcause", "endcause")),  # set startcause as first level
         x = fct_recode(x, 
                        "Start \n cause" = "startcause",   # add line break (\n) after start
                        "End \n cause"   = "endcause")
        )


## plot your dataset 
  ## on the x axis is the start and end causes
  ## gather_set_data generates an ID for each possible combination
  ## splitting by y gives the possible start/end combos
  ## value as n gives it as counts (could also be changed to proportion)
ggplot(flow_table, aes(x, id = id, split = y, value = n)) +
  ## colour lines by sex 
  geom_parallel_sets(aes(fill = sex), alpha = 0.5, axis.width = 0.2) +
  ## fill in the label boxes grey
  geom_parallel_sets_axes(axis.width = 0.15, fill = "grey80", color = "grey80") +
  ## change text colour and angle (needs to be adjusted)
  geom_parallel_sets_labels(color = "black", angle = 0, size = 5) +
  ## adjusted y and x axes (probably needs more vertical space)
  scale_x_discrete(name = NULL, expand = c(0, 0.2)) + 
  ## remove axis labels
  theme(
    title = element_text(size = 26),
    text = element_text(size = 26),
    axis.line = element_blank(),
    axis.ticks = element_blank(),
    axis.text.y = element_blank(),
    panel.background = element_blank(),
    legend.position = "bottom",                    # move legend to bottom
    legend.title = element_blank(),                # remove title
  )

```

<!-- ======================================================= -->

## Tỷ lệ được áp dụng trọng số

Phần này sẽ trình bày chi tiết cách tạo bảng cho số lượng và tỷ lệ được áp dụng trọng số, với khoảng tin cậy và hệ số thiết kế liên quan. Có bốn tùy chọn khác nhau sử dụng các hàm từ các packages sau: **survey**, **srvyr**, **sitrep** và **gtsummary**. Để tạo ra một bảng dịch tễ học tiêu chuẩn với code tối giản, chúng tôi khuyên bạn nên dùng hàm **sitrep** - là một hàm có code gọn hơn của **srvyr**; Tuy nhiên, lưu ý rằng hàm này chưa có trên CRAN và có thể thay đổi trong tương lai. Mặt khác, code của **survey** có thể là code ổn định nhất trong thời gian dài, trong khi **srvyr** sẽ phù hợp nhất đối với các luồng công việc sử dụng tidyverse. Mặc dù các hàm **gtsummary** có rất nhiều tiềm năng, nhưng chúng vẫn đang được thử nghiệm và chưa hoàn thiện tại thời điểm viết chương này.  

### Package **survey**

Chúng ta có thể sử dụng hàm `svyciprop()` từ **survey** để lấy tỷ lệ có trọng số và khoảng tin cậy 95% đi kèm. Một hệ số thiết kế thích hợp có thể được trích xuất bằng cách sử dụng hàm `svymean()` chứ không phải hàm `svyprop()`. Cần lưu ý rằng `svyprop()` dường như chỉ chấp nhận các biến có giá trị từ 0 đến 1 (hoặc TRUE/FALSE), vì vậy các biến phân loại sẽ không hoạt động.  

[***LƯU Ý:*** Các hàm từ **survey** cũng chấp nhận các đối tượng thiết kế từ **srvyr**, nhưng ở đây chúng tôi đã sử dụng đối tượng thiết kế từ package **survey** với mục đích tạo sự nhất quán]{style="color: black;"}  

```{r survey_props}

## produce weighted counts 
svytable(~died, base_survey_design)

## produce weighted proportions
svyciprop(~died, base_survey_design, na.rm = T)

## get the design effect 
svymean(~died, base_survey_design, na.rm = T, deff = T) %>% 
  deff()

```

Chúng ta có thể kết hợp các hàm từ **survey** được hiển thị ở trên với một hàm mà chúng ta tự định nghĩa như bên dưới, được gọi là `svy_prop`; và sau đó chúng ta có thể sử dụng hàm đó cùng với hàm `map()` từ package **purrr** để lặp qua một số biến và tạo một bảng. Xem chương [Lặp, vòng lặp, và danh sách] để biết chi tiết về **purrr**.  

```{r survey_prop_fun}
# Define function to calculate weighted counts, proportions, CI and design effect
# x is the variable in quotation marks 
# design is your survey design object

svy_prop <- function(design, x) {
  
  ## put the variable of interest in a formula 
  form <- as.formula(paste0( "~" , x))
  ## only keep the TRUE column of counts from svytable
  weighted_counts <- svytable(form, design)[[2]]
  ## calculate proportions (multiply by 100 to get percentages)
  weighted_props <- svyciprop(form, design, na.rm = TRUE) * 100
  ## extract the confidence intervals and multiply to get percentages
  weighted_confint <- confint(weighted_props) * 100
  ## use svymean to calculate design effect and only keep the TRUE column
  design_eff <- deff(svymean(form, design, na.rm = TRUE, deff = TRUE))[[TRUE]]
  
  ## combine in to one data frame
  full_table <- cbind(
    "Variable"        = x,
    "Count"           = weighted_counts,
    "Proportion"      = weighted_props,
    weighted_confint, 
    "Design effect"   = design_eff
    )
  
  ## return table as a dataframe
  full_table <- data.frame(full_table, 
             ## remove the variable names from rows (is a separate column now)
             row.names = NULL)
  
  ## change numerics back to numeric
  full_table[ , 2:6] <- as.numeric(full_table[, 2:6])
  
  ## return dataframe
  full_table
}

## iterate over several variables to create a table 
purrr::map(
  ## define variables of interest
  c("left", "died", "arrived"), 
  ## state function using and arguments for that function (design)
  svy_prop, design = base_survey_design) %>% 
  ## collapse list in to a single data frame
  bind_rows() %>% 
  ## round 
  mutate(across(where(is.numeric), round, digits = 1))

```

### Package **srvyr** 

Với **srvyr** chúng ta có thể sử dụng cú pháp của package **dplyr** để tạo một bảng. Lưu ý rằng hàm `survey_mean()` được sử dụng, đối số tỷ lệ được chỉ định và hàm tương tự cũng được sử dụng để tính toán hệ số thiết kế. Điều này là do **srvyr** bao gồm cả hai hàm `svyciprop()` và `svymean()` của package **survey** được sử dụng trong phần trên.  

[***LƯU Ý:*** Có vẻ như không thể lấy tỷ lệ từ các biến phân loại bằng **srvyr**, nếu bạn cần điều này, hãy xem phần bên dưới sử dụng **sitrep**]{style="color: black;"}  

```{r srvyr_prop}

## use the srvyr design object
survey_design %>% 
  summarise(
    ## produce the weighted counts 
    counts = survey_total(died), 
    ## produce weighted proportions and confidence intervals 
    ## multiply by 100 to get a percentage 
    props = survey_mean(died, 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## produce the design effect 
    deff = survey_mean(died, deff = TRUE)) %>% 
  ## only keep the rows of interest
  ## (drop standard errors and repeat proportion calculation)
  select(counts, props, props_low, props_upp, deff_deff)

```

Ở đây, chúng ta cũng có thể viết một hàm để sau đó lặp qua nhiều biến bằng cách sử dụng package **purrr**. Xem chương [Lặp, vòng lặp, và danh sách] trong sổ tay này để biết chi tiết về **purrr**.  

```{r srvyr_prop_fun}

# Define function to calculate weighted counts, proportions, CI and design effect
# design is your survey design object
# x is the variable in quotation marks 


srvyr_prop <- function(design, x) {
  
  summarise(
    ## using the survey design object
    design, 
    ## produce the weighted counts 
    counts = survey_total(.data[[x]]), 
    ## produce weighted proportions and confidence intervals 
    ## multiply by 100 to get a percentage 
    props = survey_mean(.data[[x]], 
                        proportion = TRUE, 
                        vartype = "ci") * 100, 
    ## produce the design effect 
    deff = survey_mean(.data[[x]], deff = TRUE)) %>% 
  ## add in the variable name
  mutate(variable = x) %>% 
  ## only keep the rows of interest
  ## (drop standard errors and repeat proportion calculation)
  select(variable, counts, props, props_low, props_upp, deff_deff)
  
}
  

## iterate over several variables to create a table 
purrr::map(
  ## define variables of interest
  c("left", "died", "arrived"), 
  ## state function using and arguments for that function (design)
  ~srvyr_prop(.x, design = survey_design)) %>% 
  ## collapse list in to a single data frame
  bind_rows()
  

```

### Package **sitrep** 

Hàm `tab_survey()` từ **sitrep** là một hàm gọn hơn cho **srvyr**, cho phép bạn tạo các bảng có trọng số với code tối giản. Nó cũng cho phép bạn tính toán tỷ lệ có trọng số cho các biến phân loại.  

```{r sitrep_props}

## using the survey design object
survey_design %>% 
  ## pass the names of variables of interest unquoted
  tab_survey(arrived, left, died, education_level,
             deff = TRUE,   # calculate the design effect
             pretty = TRUE  # merge the proportion and 95%CI
             )

```

### Package **gtsummary** 

Với **gtsummary**, dường như vẫn chưa có hàm sẵn có để thêm khoảng tin cậy hoặc hệ số thiết kế. Ở đây chúng tôi trình bày cách định nghĩa một hàm để thêm khoảng tin cậy và sau đó thêm khoảng tin cậy vào bảng được tạo bằng **gtsummary** với hàm `tbl_svysummary()`.  

```{r gtsummary_table}


confidence_intervals <- function(data, variable, by, ...) {
  
  ## extract the confidence intervals and multiply to get percentages
  props <- svyciprop(as.formula(paste0( "~" , variable)),
              data, na.rm = TRUE)
  
  ## extract the confidence intervals 
  as.numeric(confint(props) * 100) %>% ## make numeric and multiply for percentage
    round(., digits = 1) %>%           ## round to one digit
    c(.) %>%                           ## extract the numbers from matrix
    paste0(., collapse = "-")          ## combine to single character
}

## using the survey package design object
tbl_svysummary(base_survey_design, 
               include = c(arrived, left, died),   ## define variables want to include
               statistic = list(everything() ~ c("{n} ({p}%)"))) %>% ## define stats of interest
  add_n() %>%  ## add the weighted total 
  add_stat(fns = everything() ~ confidence_intervals) %>% ## add CIs
  ## modify the column headers
  modify_header(
    list(
      n ~ "**Weighted total (N)**",
      stat_0 ~ "**Weighted Count**",
      add_stat_1 ~ "**95%CI**"
    )
    )

```

<!-- ======================================================= -->

## Tỷ suất được áp dụng trọng số

Tương tự đối với các tỷ lệ được áp dụng trọng số (chẳng hạn như tỷ lệ tử vong), bạn có thể sử dụng package **survey** hoặc **srvyr**. Tương tự, bạn có thể viết các hàm (tương tự như ở trên) để lặp qua một số biến. Bạn cũng có thể tạo một hàm cho **gtsummary** như trên nhưng hiện tại nó không có chức năng sẵn có.  

### Package **survey**

```{r survey_ratio}

ratio <- svyratio(~died, 
         denominator = ~obstime, 
         design = base_survey_design)

ci <- confint(ratio)

cbind(
  ratio$ratio * 10000, 
  ci * 10000
)

```

### Package **srvyr** 

```{r srvyr_ratio}

survey_design %>% 
  ## survey ratio used to account for observation time 
  summarise(
    mortality = survey_ratio(
      as.numeric(died) * 10000, 
      obstime, 
      vartype = "ci")
    )

```

<!-- ======================================================= -->

## Tài nguyên học liệu

[UCLA stats page](https://stats.idre.ucla.edu/r/seminars/survey-data-analysis-with-r/)

[Analyze survey data free](http://asdfree.com/)

[srvyr packge](http://gdfe.co/srvyr/)

[gtsummary package](http://www.danieldsjoberg.com/gtsummary/reference/index.html)

[EPIET survey case studies](https://github.com/EPIET/RapidAssessmentSurveys)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/survey_analysis.Rmd-->


<!-- ======================================================= -->
<!-- ======================================================= -->
<!-- ======================================================= -->
# Phân tích sống còn {#survival-analysis}  


```{r out.width = c('75%'), fig.align='center', fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "survival_analysis.png"))
```

<!-- ======================================================= -->
## Tổng quan {}


*Phân tích sống còn* tập trung mô tả cho một cá thể hay một nhóm cá thể nhất định. Một điểm xác định của một sự kiện được gọi là **_failure_** (như là xuất hiện bệnh, chữa khỏi bệnh, tử vong, tái phát sau khi đáp ứng với điều trị...) mà xảy ra sau một khoảng thời gian được gọi là **_failure time (thời gian dẫn đến sự kiện)_** (hoặc **_follow-up time (thời gian theo dõi)_** trong nghiên cứu thuần tập/nghiên cứu dựa vào dân số) trong suốt thời gian các cá thể được quan sát. Để xác định thời gian dẫn đến sự kiện, chúng ta cần xác định thời điểm bắt đầu (có thể là ngày nhận vào, ngày chẩn đoán...). 

Mục tiêu suy luận đối với phân tích sống còn là khoảng thời gian giữa thời điểm bắt đầu và thời điểm sự kiện xảy ra. 
Trong nghiên cứu y học hiện nay, phân tích sống còn được sử dụng rộng rãi trong các nghiên cứu lâm sàng để đánh giá hiệu quả của một phương phương điều trị hoặc để đánh giá tình trạng sống còn của một số các biện pháp điều trị ung thư. 


Nó thường được diễn đạt qua **_survival probability (xác suất sống sót)_** là xác suất mà sự hiện đang quan tâm không xảy ra trong khoảng thời gian t.


**_Censoring_**: Censoring xảy ra khi sự kiện đang quan tâm không xảy ra trong một số cá thể ở cuối quá trình theo dõi, và vì thế, thời gian thật dẫn đến sự kiện của những cá thể này là không biết. Trong chương này, chúng tôi tập trung chủ yếu vào sự kiện không xảy ra về phía bên phải. Để biết thêm chi tiết về các loại censoring và phân tích sống còn nói chung, xem thêm các tài liệu tham khảo. 


```{r echo=F, eval=F, out.width = "80%", out.height="80%", fig.align = "center"}
 
#Add a figure from the following chunks for the last version of the page
#do not forget to save the output figure in "images"
# knitr::include_graphics(here::here("images", "survanalysis.png"))

```  

<!-- ======================================================= -->
## Chuẩn bị {  }

### Gọi packages {.unnumbered}  

**Survival** là gói lệnh được sử dụng rộng rãi nhất để phân tích sống còn bằng R. Đầu tiên, chúng ta cài đặt và sau đó tải gói lệnh này cũng như các gói lệnh khác sẽ được sử dụng trong phần này:

Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, giúp cài đặt package nếu cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package đã được cài đặt bằng hàm `library()` trong **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.  

```{r, echo=F, message=FALSE, warning=FALSE}

# install/load the different packages needed for this page
pacman::p_load(
  survival,      # survival analysis 
  survminer,     # survival analysis
  rio,           # importing data  
  here,          # relative file pathways  
  janitor,       # tabulations
  SemiCompRisks, # dataset examples and advanced tools for working with Semi-Competing Risks data
  tidyverse,     # data manipulation and visualization
  Epi,           # stat analyses in Epi
  survival,      # survival analysis
  survminer      # survival analysis: advanced KM curves
)


```


Chương này sẽ tìm hiểu phân tích sống còn bằng cách dùng bộ số liệu linelist đã được sử dụng trong hầu hết các chương trước và thay đổi một vài điểm để tạo ra bộ số liệu phù hợp cho phân tích sống còn.


### Nhập bộ số liệu {.unnumbered}  

Chúng ta nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Để tiện làm theo, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải số liệu linelist “đã được làm sạch”</a> (dưới dạng tệp .rds). Nhập số liệu này bằng hàm `import()` từ package **rio** (hàm này chấp nhận nhiều loại tập tin như .xlsx, .rds, .csv – xem chi tiết trong chương [Nhập xuất số liệu].  

```{r echo=F}
# import linelist
linelist_case_data <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r eval=F}
# import linelist
linelist_case_data <- rio::import("linelist_cleaned.rds")
```

### Quản lý và chuyển đổi số liệu {.unnumbered}

Nói ngắn gọn, số liệu cho phân tích sống còn có ba đặc điểm sau:

1) biến phụ thuộc hay đáp ứng là khoảng thời gian từ thời điểm bắt đầu đến thời điểm một sự kiện (được xác định rõ) xảy ra,
2) quan sát censored là các quan sát mà sự kiện quan tâm không xảy ra tại thời điểm phân tích số liệu, và 
3) các biến dự đoán hay giải thích có ảnh hưởng đến thời gian dẫn đến sự kiện mà chúng ta muốn đánh giá hoặc kiểm soát. 

Do đó, chúng ta sẽ tạo các biến số khác nhau tuân theo cấu trúc dữ liệu đó và tiến hành phân tích sống còn.

Chúng ta định nghĩa:

- một bộ số liệu mới `linelist_surv` cho phân tích này  
- sự kiện quan tâm là “tử vong” (vì thế xác suất sống sót sẽ là xác suất sống trong một khoảng thời gian nhất định sau thời đểm bắt đầu),
- thời gian theo dõi (`futime`) là *số ngày* giữa thời điểm khởi phát bệnh và thời điểm có kết cục,
- bệnh nhân censored là những người đã hồi phục hoặc những người không biết kết cục, ví dụ như sự kiện “tử vong” không được quan sát (`event=0`).

<span style="color: orange;">**_THẬN TRỌNG:_** Trong một nghiên cứu thuần tập thực tế, thông tin về thời điểm bắt đầu và thời điểm kết thúc theo dõi của các cá thể là được biết, do đó chúng ta sẽ loại bỏ các quan sát không có ngày bắt đầu và ngày có kết cục. Ngoài ra, các trường hợp có ngày khởi phát bệnh trễ hơn ngày có kết cục cũng bị loại bỏ vì các trường hợp này được xem là sai.</span>

<span style="color: darkgreen;">**_MẸO:_** Khi lọc đến các giá trị lớn hơn (>) hoặc nhỏ hơn (<) một ngày có thể loại bỏ các hàng có giá trị missing, nên khi áp dụng lọc sai ngày cũng sẽ loại bỏ các hàng có ngày bị thiếu.</span>

Sau đó, chúng ta sử dụng hàm `case_when()` để tạo ra một cột `age_cat_small` mà chỉ có 3 giá trị của nhóm tuổi.

```{r }
#create a new data called linelist_surv from the linelist_case_data

linelist_surv <-  linelist_case_data %>% 
     
  dplyr::filter(
       # remove observations with wrong or missing dates of onset or date of outcome
       date_outcome > date_onset) %>% 
  
  dplyr::mutate(
       # create the event var which is 1 if the patient died and 0 if he was right censored
       event = ifelse(is.na(outcome) | outcome == "Recover", 0, 1), 
    
       # create the var on the follow-up time in days
       futime = as.double(date_outcome - date_onset), 
    
       # create a new age category variable with only 3 strata levels
       age_cat_small = dplyr::case_when( 
            age_years < 5  ~ "0-4",
            age_years >= 5 & age_years < 20 ~ "5-19",
            age_years >= 20   ~ "20+"),
       
       # previous step created age_cat_small var as character.
       # now convert it to factor and specify the levels.
       # Note that the NA values remain NA's and are not put in a level "unknown" for example,
       # since in the next analyses they have to be removed.
       age_cat_small = fct_relevel(age_cat_small, "0-4", "5-19", "20+")
       )
```


<span style="color: darkgreen;">**_MẸO:_** Chúng ta có thể kiểm tra lại các cột mới đã được tạo ra bằng cách thực hiện tóm tắt đối với biến số `futime` avà bảng chéo giữa biến số `event` và biến kết cục `outcome`. Bên cạnh việc kiểm tra này, đây là một thói quen tốt để biết được thời gian theo dõi trung vị khi giải thích kết quả của phân tích sống còn.</span>

```{r }

summary(linelist_surv$futime)

# cross tabulate the new event var and the outcome var from which it was created
# to make sure the code did what it was intended to
linelist_surv %>% 
  tabyl(outcome, event)
```

Bây giờ, chúng ta tạo bảng chéo giữa biến nhóm tuổi mới `age_cat_small` và biến nhóm tuổi cũ `age_cat` để đảm bảo tính chính xác của việc chuyển đổi số liệu  

```{r}
linelist_surv %>% 
  tabyl(age_cat_small, age_cat)
```

Bây giờ, chúng ta xem lại 10 quan sát đầu tiên của bộ số liệu `linelist_surv` bằng cách xem xét các biến cụ thể (bao gồm cả các biến mới được tạo ra).  


```{r}
linelist_surv %>% 
  select(case_id, age_cat_small, date_onset, date_outcome, outcome, event, futime) %>% 
  head(10)
```

Chúng ta cũng có thể tạo bảng chéo giữa cột biến `age_cat_small` và `gender` để biết thêm chi tiết về sự phân bố của biến số mới này theo giới tính. Chúng ta sử dụng hàm `tabyl()` và hàm *adorn* từ package **janitor** như được mô tả trong chương [Bảng mô tả]. 

<!-- For this we use the `stat.table()` function of the **Epi** package. -->

```{r}

linelist_surv %>% 
  tabyl(gender, age_cat_small, show_na = F) %>% 
  adorn_totals(c("row", "col")) %>% 
  adorn_percentages() %>% 
  adorn_pct_formatting() %>% 
  adorn_ns(position = "front")

```

<!-- Epi::stat.table(  -->
<!--   #give variables for the cross tabulation -->
<!--   list( -->
<!--     gender,  -->
<!--     age_cat_small -->
<!--     ), -->

<!--   #precise the function you want to call (mean,count..) -->
<!--   list(  -->
<!--     count(), -->
<!--     percent(age_cat_small) -->
<!--     ),  -->

<!--   #add margins -->
<!--   margins=T,  -->

<!--   #data used -->
<!--   data = linelist_surv  -->
<!--   ) -->

<!-- ``` -->


<!-- ======================================================= -->
## Cơ bản về phân tích sống còn {}


### Tạo ra đối tượng kiểu surv {.unnumbered}

Đầu tiên, chúng ta dùng hàm `Surv()` từ package **survival** để tạo ra một ‘đối tượng surv’ từ cột follow-up time và event.  

Kết quả của bước này tạo ra một đối tượng *Surv* bao gồm thông tin thời gian và có hay không sự kiện quan tâm (tử vong) được nhận thấy. Đối tượng này sẽ được sử dụng sau này ở phía bên phải trong công thức của những mô hình tiếp theo (xem [tài liệu](https://cran.r-project.org/web/packages/survival/vignettes/survival.pdf)).  


```{r survobj }
# Use Suv() syntax for right-censored data
survobj <- Surv(time = linelist_surv$futime,
                event = linelist_surv$event)
```

<!-- ```{r} -->
<!-- survobj <- with(linelist_surv, -->

<!--                 survival::Surv(futime, event) -->

<!--                 ) -->
<!-- ``` -->


Để xem lại số liệu, đây là 10 hàng đầu tiên của bộ số liệu `linelist_surv` data, chỉ hiển thị các cột quan trọng.  

```{r}
linelist_surv %>% 
  select(case_id, date_onset, date_outcome, futime, outcome, event) %>% 
  head(10)
```

Và đây là 10 thành phần đầu tiên của đối tượng `survobj`. Về bản chất, nó xuất ra đưới dạng một véc tơ của biến số thời gian theo dõi, dấu “+” là đại điện cho một quan sát censored ở phía bên phải. Xem cách các con số sắp xếp bên trên và bên dưới.  

```{r}
#print the 50 first elements of the vector to see how it presents
head(survobj, 10)
```


### Thực hiện các phân tích ban đầu {.unnumbered}

Sau đó, chúng ta bắt đầu phân tích bằng cách sử dụng hàm `survfit()` để tạo ra một *đối tượng survfit*, phù hợp với các tính toán mặc định cho các ước tính **_Kaplan Meier_** (KM) của đường cong sống sót chung (cận biên), mà thực tế là một hàm bước với các bước nhảy tại thời điểm sự kiện được quan sát. Đối tượng *survfit object* cuối cùng chứa đựng một hoặc nhiều đường cong sống sót và được tạo ra bằng cách sử dụng đối tượng *Surv* làm biến đáp ứng trong công thức của mô hình.  

<span style="color: black;">**_LƯU Ý:_** Ước tính Kaplan-Meier là một ước tính khả dĩ tối đa phi tham số của hàm sống còn (xem mục Tài nguyên học liệu để biết thêm thông tin).</span>

Tóm tắt của *đối tượng survfit* này sẽ cho một bảng được gọi là *life table (bảng sống còn)*. Đối với mỗi bước thời gian theo dõi (`time`) là nơi một sự kiện xảy ra (theo thứ tự tăng dần):  

* số người có nguy cơ dẫn đến sự kiện (người chưa có sự kiện cũng như sự kiện chưa xảy ra: `n.risk`)  
* những người có sự kiện  (`n.event`)  
* và từ những dữ kiện trên tính xác suất không đưa đến sự kiện (xác suất không tử vong, hoặc sống sót sau khoảng thời gian cụ thể đó)  
* cuối cùng, sai số chuẩn và khoảng tin cậy cho xác suất đó được tính toán và trình bày  

Chúng ta thực hiện các ước tính KM bằng cách sử dụng công thức với đối tượng Surv trước đó “survobj” làm biến đáp ứng. “~ 1” diễn đạt rẳng chúng ta đang thực hiện mô hình sống còn tổng quát.  

```{r fit}
# fit the KM estimates using a formula where the Surv object "survobj" is the response variable.
# "~ 1" signifies that we run the model for the overall survival  
linelistsurv_fit <-  survival::survfit(survobj ~ 1)

#print its summary for more details
summary(linelistsurv_fit)

```


Khi sử dụng hàm `summary()`, chúng ta có thể thêm tùy chọn `times` và cụ thể các thời điểm nhất định mà chúng ta muốn xem các thông tin sống còn 

```{r print_spec_times}

#print its summary at specific times
summary(linelistsurv_fit, times = c(5,10,20,30,60))

```


Chúng ta cũng có thể sử dụng hàm `print()`. Đối số `print.rmean = TRUE` được sử dụng để có được giá trị trung bình của thời gian sống sót và sai số chuẩn (se).

<span style="color: black;">**_LƯU Ý:_** Thời gian sống sót trung bình giới hạn là một đo lường sống còn cụ thể ngày càng được sử dụng trong phân tích sống còn của bệnh ung thư và thường được định nghĩa là khu vực dưới đường cong, khi chúng ta quan sát bệnh nhân cho đến thời gian giới hạn T (xem phần Tài nguyên học liệu để biết thêm chi tiết).


```{r, mean_survtime}
# print linelistsurv_fit object with mean survival time and its se. 
print(linelistsurv_fit, print.rmean = TRUE)

```


<span style="color: darkgreen;">**_MẸO:_** Chúng ta có thể tạo ra *đối tượng surv* trực tiếp trong hàm `survfit()` và tiết kiệm một dòng lệnh. Thực hiện điều này như sau: `linelistsurv_quick <-  survfit(Surv(futime, event) ~ 1, data=linelist_surv)`.</span>


### Mối nguy tích lũy {.unnumbered}  

Bên cạnh hàm `summary()`, chúng ta có thể sử dụng hàm `str()`, hàm này cho biết chi tiết hơn vể cấu trúc của các đối tượng trong hàm `survfit()`. Cấu trúc này là một danh sách của 16 thành phần.  

Một thành phần quan trọng trong số những thành phần này là: `cumhaz`,  một véc tơ kiểu số. Thành phần này có thể được vẽ để hiển thị **_mối nguy tích lũy_**, với **_mối nguy_** là **_tỷ suất xảy ra sự kiện tức thời_** (xem tài liệu tham khảo).

```{r fit_struct}

str(linelistsurv_fit)

```

<!-- ======================================================= -->
### Vẽ đường cong Kaplan-Meir  {.unnumbered}

Sau khi ước tính KM đã được fit, chúng ta có thể hình dung xác suất sống sót qua một thời gian nhất định bằng cách dùng hàm `plot()` để vẽ “đường cong Kaplan-Meier”. Nói cách khác, đường cong bên dưới là một minh họa đường cong sống sót quy ước của toàn bộ nhóm bệnh nhân.

Chúng ta có thể nhanh chóng xác minh thời gian theo dõi tối thiểu và tối đa trên đường cong.  

Một cách dễ dàng để giải thích là phát biểu rằng, tại thời điểm 0, tất cả người tham gia đều sống và xác suất sống sót khi đó là 100%.Xác suất ngày giảm dần theo thời gian khi có bệnh nhân tử vong. Tỷ lệ người tham gia sống sót sau 60 ngày là khoảng 40%.

```{r }

plot(linelistsurv_fit, 
     xlab = "Days of follow-up",    # x-axis label
     ylab="Survival Probability",   # y-axis label
     main= "Overall survival curve" # figure title
     )

```

Khoảng tin cậy của các ước tính KM cũng được vẽ mặc định trên biểu đồ và có thể bị loại bỏ bằng cách thêm tùy chọn `conf.int = FALSE` vào trong lệnh `plot()`.

Vì sự kiện quan tâm là “tử vong”, việc vẽ một đường cong mô tả phần bù tỷ lệ sống sót sẽ đưa đến việc vẽ tỷ lệ tử vong tích lũy. Điều này có thể được thực hiện với hàm `lines()`, bổ sung thông tin trên biểu đồ hiện có.  


```{r}

# original plot
plot(
  linelistsurv_fit,
  xlab = "Days of follow-up",       
  ylab = "Survival Probability",       
  mark.time = TRUE,              # mark events on the curve: a "+" is printed at every event
  conf.int = FALSE,              # do not plot the confidence interval
  main = "Overall survival curve and cumulative mortality"
  )

# draw an additional curve to the previous plot
lines(
  linelistsurv_fit,
  lty = 3,             # use different line type for clarity
  fun = "event",       # draw the cumulative events instead of the survival 
  mark.time = FALSE,
  conf.int = FALSE
  )

# add a legend to the plot
legend(
  "topright",                               # position of legend
  legend = c("Survival", "Cum. Mortality"), # legend text 
  lty = c(1, 3),                            # line types to use in the legend
  cex = .85,                                # parametes that defines size of legend text
  bty = "n"                                 # no box type to be drawn for the legend
  )

```

<!-- ======================================================= -->
## So sánh các đường cong sống sót 

Để so sánh các đường cong sống sót của những nhóm người tham gia hoặc bệnh nhân khác nhau, đầu tiên chúng ta có thể cần xem xét các đường cong tương ứng của các nhóm và sau đó thực hiện các kiểm định để lượng giá sự khác biệt giữa các nhóm độc lập. So sánh này có thể liên quan đến các nhóm dựa vào giới tính, tuổi tác, điều trị, bệnh đi kèm,...

### Kiểm định Log rank {.unnumbered}

Kiểm định log rank là một kiểm định phổ biến để so sánh toàn bộ quá trình sống sót giữa hai hay nhiều nhóm *độc lập* và có thể xem xét các đường cong sống sót có tương đồng (chồng chéo) hay không (giả thuyết vô hiệu là không có sự khác biệt về sự sống sót giữa các nhóm). Hàm `survdiff()` trong **survival package** cho phép thực hiện kiểm định log-rank khi chúng ta cụ thể `rho = 0` (mặc định). Kết quả kiểm định cho ra một thống kê chi bình phương cùng với giá trị p vì log-rank phân phối gần giống như thống kê của kiểm định chi bình phương.

Đầu tiên, chúng ta thử so sánh các đường cong sống sót theo giới tính. Đối với điều này, chúng ta thử hình dung nó (kiểm tra xem hai đường cong sống sót có chồng lên nhau không). Một *đối tượng survfit* mới sẽ được tạo ra với một công thức hơi khác một chút. Sau đó, *đối tượng survdiff* sẽ được tạo ra.

Bằng cách cung cấp ` ~ gender` ở phía bên phải của công thức, chúng ta không còn vẽ biểu đồ đường cong sống sót chung mà thay vào đó là theo giới tính.  


```{r comp_surv, warning=FALSE}

# create the new survfit object based on gender
linelistsurv_fit_sex <-  survfit(Surv(futime, event) ~ gender, data = linelist_surv)
```

Bây giờ, chúng ta có thể vẽ các đường cong sống sót theo giới tính. Hãy xem *thứ tự* giá trị biến của giới tính trước khi xác định màu sắc và chú giải.  

```{r}
# set colors
col_sex <- c("lightgreen", "darkgreen")

# create plot
plot(
  linelistsurv_fit_sex,
  col = col_sex,
  xlab = "Days of follow-up",
  ylab = "Survival Probability")

# add legend
legend(
  "topright",
  legend = c("Female","Male"),
  col = col_sex,
  lty = 1,
  cex = .9,
  bty = "n")
```

Và bây giờ, chúng ta có thể tính toán kiểm định sự khác biệt giữa các đường cong bằng cách sử dụng hàm `survdiff()`

```{r}
#compute the test of the difference between the survival curves
survival::survdiff(
  Surv(futime, event) ~ gender, 
  data = linelist_surv
  )

```

Chúng ta thấy rằng đường cong sống sót cho nữ và đường cong cho nam chồng lên nhau và kiểm định log-rank không đưa ra bằng chứng về sự khác biệt sống sót giữa nam và nữ.

Một số package trong R cho phép minh họa các đường cong sống sót cho các nhóm và kiểm định sự khác biệt cùng một lúc. Sử dụng hàm `ggsurvplot()` từ package **survminer**, chúng ta cũng có thể bao gồm các bảng nguy cơ với các đường cong này cũng như giá trị p từ kiểm định log-rank. 

<span style="color: orange;">**_THẬN TRỌNG:_**  Các hàm từ package **survminer** đòi hỏi chúng ta cụ thể đối tượng sống sót *và* cụ thể bộ số liệu để so sánh đối tượng sống sót. Hãy nhớ làm điều này để tránh thông báo lỗi do không cụ thể. </span>

```{r, warning=F, message=F}

survminer::ggsurvplot(
    linelistsurv_fit_sex, 
    data = linelist_surv,          # again specify the data used to fit linelistsurv_fit_sex 
    conf.int = FALSE,              # do not show confidence interval of KM estimates
    surv.scale = "percent",        # present probabilities in the y axis in %
    break.time.by = 10,            # present the time axis with an increment of 10 days
    xlab = "Follow-up days",
    ylab = "Survival Probability",
    pval = T,                      # print p-value of Log-rank test 
    pval.coord = c(40,.91),        # print p-value at these plot coordinates
    risk.table = T,                # print the risk table at bottom 
    legend.title = "Gender",       # legend characteristics
    legend.labs = c("Female","Male"),
    font.legend = 10, 
    palette = "Dark2",             # specify color palette 
    surv.median.line = "hv",       # draw horizontal and vertical lines to the median survivals
    ggtheme = theme_light()        # simplify plot background
)

```


Chúng ta có thể cũng muốn kiểm định sự khác biệt về sống còn theo nguồn lây (nguồn ô nhiễm).  

Trong trường hợp này, kiểm định log-rank cho thấy có đủ bằng chứng về sự khác biệt trong xác suất sống sót với `alpha= 0.005`. Xác suất sống sót cho những bệnh nhân bị nhiễm tại các đám tang cao hơn xác suất sống sót ở những nơi khác mà gợi ý về lợi ích sống sót.

```{r}

linelistsurv_fit_source <-  survfit(
  Surv(futime, event) ~ source,
  data = linelist_surv
  )

# plot
ggsurvplot( 
  linelistsurv_fit_source,
  data = linelist_surv,
  size = 1, linetype = "strata",   # line types
  conf.int = T,
  surv.scale = "percent",  
  break.time.by = 10, 
  xlab = "Follow-up days",
  ylab= "Survival Probability",
  pval = T,
  pval.coord = c(40,.91),
  risk.table = T,
  legend.title = "Source of \ninfection",
  legend.labs = c("Funeral", "Other"),
  font.legend = 10,
  palette = c("#E7B800","#3E606F"),
  surv.median.line = "hv", 
  ggtheme = theme_light()
)

```

<!-- ======================================================= -->
## Phân tích bằng hồi quy Cox {}

Hồi quy mối nguy theo tỷ lệ Cox (sau này sẽ gọi ngắn gọn là hồi quy Cox) là một trong những kỹ thuật hồi quy phổ biến nhất cho phân tích sống còn. Các mô hình khác cũng có thể được sử dụng, vì để sử dụng thích hợp mô hình Cox, *các giả định quan trọng* cần phải được xác minh: xem tài liệu tham khảo. 

Trong một mô hình hồi quy Cox, đo lường ảnh hưởng là **_hazard rate (tỷ suất mối nguy)_** (HR), là nguy cơ xảy ra sự kiện (hay là nguy cơ tử vong trong ví dụ này), của người tham gia sống sót đến một thời điểm cụ thể. Thông thường, chúng ta quan tâm đến việc so sánh giữa các nhóm *độc lập* gvề nguy cơ của nó, và sử dụng tỷ số nguy cơ mà tương tự như tỷ số chênh khi thực hiện hồi quy logistic đa biến. Hàm `cox.ph()` từ package **survival** được sử dụng để fit mô hình. Hàm `cox.zph()` từ package **survival** có thể được sử dụng để kiểm tra tính phù hợp của giả định nguy cơ theo tỷ lệ với mô hình hồi quy Cox. 

<span style="color: black;">**_LƯU Ý:_** Xác suất phải nằm trong khoảng từ 0 đến 1. Tuy nhiên, nguy cơ đại điện cho số sự kiện dự đoán trên một đơn vị thời gian. 

* Nếu tỷ số nguy cơ cho một yếu tố dự đoán gần bằng 1, thì yếu tố dự đoán đó không ảnh hưởng đến sự sống sót,
* Nếu HR nhỏ hơn 1, thì yếu tố dự đoán là yếu tố bảo vệ (tức là yếu tố liên quan đến cải thiện khả năng sống sót),
* Và nếu HR lớn hơn 1, thì yếu tố dự đoán kết hợp với tăng nguy cơ (hay là giảm khả năng sống sót).</span> 

### Fitting một mô hình Cox {.unnumbered}

Đầu tiên, chúng ta có thể fit một mô hình để đánh giá ảnh hưởng của tuổi và giới lên sự sống sót. Chỉ cần xuất mô hình, chúng ta có những thông tin sau:

  + các ước lượng hệ số hồi quy `coef` để xác định mối liên hệ giữa các biến dự đoán và biến kết cục,
  + lũy thừa của các ước số (`exp(coef)`) để tính *tỷ số nguy cơ*,
  + các sai số chuẩn `se(coef)`,
  + chỉ số z-score: bao nhiêu sai số chuẩn là hệ số ước tính khác biệt từ giá trị 0,
  + và p-value: xác suất mà ước số có thể là 0.
  
Áp dụng hàm `summary()` cho các đối tượng của mô hình Cox cho biết thêm thông tin như là khoảng tin cậy của HR và các chỉ số kiểm định khác.

Kết quả của hiệp biến đầu tiên `gender` được trình bày ở hàng đầu tiên. `genderm` (nam) được in ra có ngụ ý rằng vị trí tầng đầu tiên ("f"), tức là nhóm nữ, là nhóm tham chiếu cho biến số giới tính. Vì thế, giải thích các thông số kiểm định là của nam so với nữ. Giá trị p chỉ ra rằng không có đủ bằng chứng về ảnh hưởng của giới tính lên mối nguy hay là không có đủ bằng chứng về mối liên quan giữa giới và tử vong (do tất cả các nguyên nhân).

Cũng thiếu bằng chứng như vậy đối với biến số nhóm tuổi.

```{r coxmodel_agesex}

#fitting the cox model
linelistsurv_cox_sexage <-  survival::coxph(
              Surv(futime, event) ~ gender + age_cat_small, 
              data = linelist_surv
              )


#printing the model fitted
linelistsurv_cox_sexage


#summary of the model
summary(linelistsurv_cox_sexage)

```


Thật rất thú vị để thực hiện mô hình và xem kết quả, nhưng quan sát đầu tiên để xác minh xem có thỏa các giả định về nguy cơ theo tỷ lệ hay không mà có thể giúp tiết kiệm thời gian.

```{r test_assumption}

test_ph_sexage <- survival::cox.zph(linelistsurv_cox_sexage)
test_ph_sexage

```


<span style="color: black;">**_LƯU Ý:_** đối số thứ hai được gọi là *method* có thể được định rõ khi tính toán mô hình Cox để xác định cách ràng buộc được vận dụng. Phương pháp *mặc định* là "efron", và các tùy chọn khác là "breslow" và "exact".</span>

Trong một mô hình khác, chúng tôi thêm nhiều yếu tố nguy cơ hơn như nguồn lây và số ngày giữa ngày khởi phát và ngày nhập viện. Điều trước tiên vào lúc này là xác minh các giả định nguy cơ theo tỷ lệ trước khi thực hiện các bước tiếp theo.

Trong mô hình này, chúng ta bao gồm một biến dự báo liên tục (`days_onset_hosp`). Trong trường hợp này, chúng ta giải thích các ước tính của thông số như là sự gia tăng theo lôgarít kỳ vọng của nguy cơ tương đối cho mỗi mức tăng của một đơn vị trong biến dự đoán, bằng cách giữ các yếu tố dự đoán khác cố định. Đầu tiên chúng ta xác minh giả định nguy cơ theo tỷ lệ.  

```{r coxmodel_fit_ph,  message=FALSE}

#fit the model
linelistsurv_cox <-  coxph(
                        Surv(futime, event) ~ gender + age_years+ source + days_onset_hosp,
                        data = linelist_surv
                        )


#test the proportional hazard model
linelistsurv_ph_test <- cox.zph(linelistsurv_cox)
linelistsurv_ph_test
```

Việc xác minh bằng đồ thị của giả định này có thể được thực hiện bằng hàm `ggcoxzph()` của package **survminer**. 

```{r}
survminer::ggcoxzph(linelistsurv_ph_test)

```


Kết quả mô hình chỉ ra rằng có mối liên quan nghịch giữa khoảng thời gian từ khởi phát bệnh đến nhân viện và tử vong do tất cả các nguyên nhân. Nguy cơ dự đoán là bằng 0.9 lần ở một người nhập viện trễ hơn một ngày so với người khác, khi giữ biến giới tính cố định. Hay giải thích một cách dễ hiểu hơn, tăng một đơn vị thời gian từ lúc khởi phát đến nhập viện thì có liên quan đến giảm 10.7% (`coef *100`) nguy cơ tử vong.

Kết quả cũng cho thấy một mối liên quan thuận giữa nguồn lây và tử vong. Điều này có nghĩa là nguy cơ tử vong của bệnh nhân có nguồn lây bằng 1.21 lần so với bệnh nhân có nguồn lây là đám tang.


```{r coxmodel_summary,  message=FALSE}

#print the summary of the model
summary(linelistsurv_cox)

```


Chúng ta có thể xác minh mối quan hệ này bằng một bảng: 


```{r}
linelist_case_data %>% 
  tabyl(days_onset_hosp, outcome) %>% 
  adorn_percentages() %>%  
  adorn_pct_formatting()

```


Chúng ta cần phải xem xét và điều tra tại sao sự kết hợp này tồn tại trong số liệu. Một giải thích có thể chấp nhận được là bệnh nhân nhập viện trễ hơn vì có bệnh lúc đầu ít nghiêm trọng hơn. Một giải thích khác có lẽ dễ chấp nhận hơn là vì chúng ta sử dụng một bộ số liệu mô phỏng, mẫu này không phản ánh đúng thực tế!  


<!-- ======================================================= -->

### Biểu đồ Forest plot {.unnumbered}

Chúng ta có thể vẽ kết quả của mô hình Cox bằng cách sử dụng hàm `ggforest()` trong package **survminer** để vẽ biểu đồ Forest plot.

```{r forestp}

ggforest(linelistsurv_cox, data = linelist_surv)

```

<!-- ======================================================= -->
## Các hiệp biến phụ thuộc vào thời gian trong mô hình sống còn {}

Một số nội dung dưới đây được adapt từ tài liệu [Giới thiệu về phân tích sống còn với R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html) với sự cho phép của [TS. Emily Zabor](https://www.emilyzabor.com/) 

Trong phần trước, chúng ta đã đề cập đến việc sử dụng hồi quy Cox để kiểm tra mối liên quan giữa hiệp biến và biến kết cục sống còn. Nhưng những phân tích này dựa trên hiệp biến được đo lường ở thời điểm ban đầu, tức là trước thời gian theo dõi sự kiện bắt đầu.

Điều gì sẽ xảy ra nếu chúng ta quan tâm đến một hiệp biến được đo **sau khi** thời gian theo dõi bắt đầu? Hoặc điều gì sẽ xảy ra nếu chúng ta có một hiệp biến có thể thay đổi theo thời gian

Ví dụ: có thể chúng ta đang làm việc với các số liệu lâm sàng mà chúng lặp lại đo lường các giá trị xét nghiệm mà có thể thay đổi theo thời gian. Đây là một ví dụ về **hiệp biến phụ thuộc vào thời gian**.  Để nhấn mạnh vào vấn đề này, chúng ta cần một thiết lập đặc biệt, nhưng may là mô hình Cox rất linh động và loại số liệu này cũng có thể được mô hình hóa bằng các công cụ từ package **survival**. 

### Thiết lập hiệp biến phụ thuộc vào thời gian {.unnumbered} 

Phân tích các hiệp biến phụ thuộc vào thời gian trong R đòi hỏi thiết lập một bộ dữ liệu đặc biệt. Nếu quan tâm, hãy xem chi tiết hơn về vấn đề này được viết bởi tác giả của package **survival** [Sử Dụng Hiệp Biến Phụ Thuộc Vào Thời Gian và Hệ Số Phụ Thuộc Vào Thời Gian trong Mô Hình Cox](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf).

Đối với vấn đề này, chúng ta sử dụng một bộ số liệu mới từ package `SemiCompRisks` có tên là `BMT`, bộ số liệu này bao gồm 137 bệnh nhân cấy ghép tủy xương. Các biến chúng ta sẽ tập trung vào là:  

* `T1`  - thời gian (tính bằng ngày) đến khi tử vong hoặc đến lần theo dõi cuối cùng  
* `delta1` - chỉ số tử vong; 1-Tử vong, 0-Còn sống  
* `TA` -  thời gian (tính theo ngày) đến khi phát bệnh GVHD cấp tính (bệnh tế bào ghép tấn công vật chủ)  
* `deltaA` -  chỉ số của bệnh GVHD cấp tính;  
  * 1 - Đã tiến triển bệnh GVHD cấp tính  
  * 0 - Không tiến triển bệnh GVHD cấp tính

Chúng ta sẽ gọi bộ số liệu này từ package **survival** bằng cách sử dụng lệnh `data()` từ **base** R, giúp tải số liệu được chứa ở trong một package đã được cài đặt. Một data frame có tên `BMT` sẽ hiện thị trong môi trường R.  

```{r}
data(BMT, package = "SemiCompRisks")
```

#### Thêm mã nhận dạng bệnh nhân {.unnumbered}  

Không có cột ID trong bộ số liệu `BMT`, cột này cần thiết để tạo ra bộ số liệu mà chúng ta muốn. Vì vậy, chúng ta sử dụng hàm `rowid_to_column()` từ package **tibble** thuộc hệ sinh thái **tidyverse** để tạo một biến id mới gọi là `my_id` (thêm cột ở vị trí đầu tiên của bộ số liệu với việc đánh số hàng tuần tự theo số nhận dạng bắt đầu từ số 1). Chúng ta đặt tên bộ số liệu này là `bmt`.  

```{r}
bmt <- rowid_to_column(BMT, "my_id")
```

Bộ số liệu mới bây giờ trông sẽ như thế này:  

```{r message=FALSE, echo=F}
DT::datatable(bmt, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Mở rộng hàng của các bệnh nhân {.unnumbered}  

Tiếp theo, chúng ta sử dụng hàm `tmerge()` với các hàm hỗ trợ `event()` và `tdc()` để tái cấu trúc bộ số liệu. Mục tiêu của chúng ta là tái cấu trúc bộ số liệu để tạo một hàng riêng biệt cho từng bệnh nhân trong mỗi khoảng thời gian mà họ có giá trị `deltaA` khác nhau. Trong bộ số liệu này, mỗi bệnh nhân có thể có nhiều nhất là hai hàng tùy thuộc vào việc họ có phát bệnh GVHD hay không trong giai đoạn thu thập số liệu. Chúng ta sẽ gọi chỉ số mới cho việc phát bệnh GVHD là `agvhd`.

- `tmerge()`  tạo một bộ số liệu dài với nhiều khoảng thời gian cho các giá trị hiệp biến khác nhau cho từng bệnh nhân
- `event()` tạo chỉ số cho sự kiện mới để đi cùng với khoảng thời gian mới được tạo ra
- `tdc()` tạo cột hiệp biến phụ thuộc vào thời gian `agvhd` để đi cùng với các khoảng thời gian mới được tạo ra

```{r}
td_dat <- 
  tmerge(
    data1 = bmt %>% select(my_id, T1, delta1), 
    data2 = bmt %>% select(my_id, T1, delta1, TA, deltaA), 
    id = my_id, 
    death = event(T1, delta1),
    agvhd = tdc(TA)
    )
```

Để xem điều này thực hiện thế nào, hãy xem số liệu của 5 bệnh nhân đầu tiên.

Các biến quan tâm trong bộ số liệu gốc trông như sau:

```{r}
bmt %>% 
  select(my_id, T1, delta1, TA, deltaA) %>% 
  filter(my_id %in% seq(1, 5))
```

Bộ số liệu mới cho cùng các bệnh nhân này trông như sau:

```{r}
td_dat %>% 
  filter(my_id %in% seq(1, 5))
```

Bây giờ, một số bệnh nhân có hai hàng trong bộ số liệu tương ứng với khoảng thời gian mà họ có giá trị khác của biến mới `agvhd`. Ví dụ như Bệnh nhân số 1 hiện có hai hàng có giá trị của biến `agvhd` bằng 0 từ thời điểm 0 đến 67 và giá trị bằng 1 từ thời điểm 67 đến 2081. 

### Hồi quy Cox với hiệp biến phụ thuộc vào thời gian {.unnumbered} 

Bây giờ, chúng ta đã định hình lại số liệu và thêm biến mới `aghvd` phụ thuộc vào thời gian, hãy fit mô hình cox đơn biến. Chúng ta có thể sử dụng cùng hàm `coxph()` như trước, chỉ cần thay đổi trong hàm `Surv()` để chỉ rõ thời gian bắt đầu và thời gian kết thúc cho mỗi khoảng thời gian bằng cách sử dụng các đối số cho `time1 = ` và `time2 = `. 


```{r}
bmt_td_model = coxph(
  Surv(time = tstart, time2 = tstop, event = death) ~ agvhd, 
  data = td_dat
  )

summary(bmt_td_model)
```

Một lần nữa, chúng ta trực quan hóa kết quả mô hình Cox bằng cách sử dụng hàm `ggforest()` từ **survminer package**.:

```{r}

ggforest(bmt_td_model, data = td_dat)

```

Như bạn thấy từ biểu đồ forest plot, khoảng tin cậy và giá trị p cho thấy rằng không có mối liên hệ chặt chẽ giữa tử vong và bệnh GVHD cấp tính trong mô hình hồi quy đơn giản này. 

<!-- ======================================================= -->
## Tài nguyên học liệu {  }

[Survival Analysis Part I: Basic concepts and first analyses](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2394262/)

[Survival Analysis in R](https://www.emilyzabor.com/tutorials/survival_analysis_in_r_tutorial.html)

[Survival analysis in infectious disease research: Describing events in time](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2954271/)

[Chapter on advanced survival models Princeton](https://data.princeton.edu/wws509/notes/c7.pdf)

[Using Time Dependent Covariates and Time Dependent Coefficients in the Cox Model](https://cran.r-project.org/web/packages/survival/vignettes/timedep.pdf)

[Survival analysis cheatsheet R](https://publicifsv.sund.ku.dk/~ts/survival/survival-cheat.pdf)

[Survminer cheatsheet](https://paulvanderlaken.files.wordpress.com/2017/08/survminer_cheatsheet.pdf)

[Paper on different survival measures for cancer registry data with Rcode provided as supplementary materials](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6322561/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/survival_analysis.Rmd-->

# GIS cơ bản {#gis}

```{r, out.width=c('100%', '100%'), echo=F}
knitr::include_graphics(here::here("images", "gis_head_image.png"))
```

<!-- ======================================================= -->

## Tổng quan

Các khía cạnh không gian trong dữ liệu của bạn có thể cung cấp nhiều thông tin chi tiết về tình hình đợt bùng phát dịch và để trả lời các câu hỏi như:

-   Các điểm nóng về dịch bệnh hiện nay ở đâu?
-   Các điểm nóng đã thay đổi như thế nào theo thời gian?
-   Việc tiếp cận các cơ sở y tế như thế nào? Có cần thêm sự tăng cường nào không?

Trọng tâm hiện tại trong chương GIS này nhằm giải quyết nhu cầu của các nhà dịch tễ học ứng dụng trong ứng phó với các đợt bùng phát dịch. Chúng ta sẽ khám phá các phương pháp trực quan hóa dữ liệu không gian cơ bản bằng cách sử dụng package **tmap** và **ggplot2**. Chúng ta cũng sẽ đi qua một số phương pháp quản lý và truy vấn dữ liệu không gian cơ bản với package **sf**. Cuối cùng, chúng ta sẽ đề cập ngắn gọn đến các khái niệm về *thống kê không gian (spatial statistics)* như mối quan hệ không gian, tự tương quan không gian và hồi quy không gian bằng cách sử dụng package **spdep**.

## Các thuật ngữ chính

Dưới đây chúng tôi giới thiệu một số thuật ngữ chính. Để được giới thiệu kỹ lưỡng về GIS và phân tích không gian, chúng tôi khuyên bạn nên xem lại một trong các hướng dẫn hoặc khóa học dài hơn được liệt kê trong phần Tài nguyên học liệu.

**Hệ thống thông tin địa lý (Geographic Information System - GIS)** - GIS là một framework hoặc môi trường để thu thập, quản lý, phân tích và trực quan hóa dữ liệu không gian.

### Phần mềm GIS {.unnumbered}

Một số phần mềm GIS phổ biến cho phép tương tác bằng các thao tác chuột để phát triển bản đồ và phân tích không gian. Những công cụ này đi kèm với những lợi thế như không cần phải học code và dễ dàng lựa chọn và đặt các biểu tượng và tính năng trên bản đồ theo cách thủ công. Dưới đây là hai phần mềm phổ biến:

**ArcGIS** - Một phần mềm GIS thương mại do công ty ESRI phát triển, rất phổ biến nhưng khá đắt

**QGIS** - Một phần mềm GIS mã nguồn mở nhưng làm được hầu hết mọi thứ mà ArcGIS có thể làm được. Bạn có thể [tải QGIS tại đây](https://qgis.org/en/site/forusers/download.html)

Sử dụng R để thao tác GIS thoạt đầu có vẻ đáng sợ hơn bởi vì thay bằng các "thao tác chuột", nó có “giao diện dòng lệnh” (bạn phải viết code để có được kết quả mong muốn). Tuy nhiên, đây là một lợi thế lớn nếu bạn cần tạo bản đồ lặp đi lặp lại hoặc tạo các phân tích có thể tái lập được.

### Dữ liệu không gian {.unnumbered}

Hai dạng dữ liệu không gian chính được sử dụng trong GIS là dữ liệu vectơ và raster:

**Vector Data** - Định dạng phổ biến nhất của dữ liệu không gian được sử dụng trong GIS, dữ liệu vectơ bao gồm các đặc điểm hình học của vertices and paths. Dữ liệu không gian dạng vectơ có thể được chia thành ba loại nhỏ được sử dụng rộng rãi:

-   *Điểm (Points)* - Một điểm bao gồm một cặp tọa độ (x, y) đại diện cho một vị trí cụ thể trong một hệ tọa độ. Điểm là dạng dữ liệu không gian cơ bản nhất và có thể được sử dụng để biểu thị một trường hợp (vd: nhà bệnh nhân) hoặc một vị trí (vd: bệnh viện) trên bản đồ.

-   *Đường (Lines)* - Một đường bao gồm hai điểm kết nối với nhau. Đường có độ dài và có thể được sử dụng để biểu thị những thứ như con đường hoặc sông.

-   *Đa giác (Polygons)* - A polygon is composed of at least three line segments connected by points. Polygon features have a length (i.e. the perimeter of the area) as well as an area measurement. Polygons may be used to note an area (i.e. a village) or a structure (i.e. the actual area of a hospital).

**Raster Data** - Một đa giác bao gồm ít nhất ba đoạn thẳng được nối với nhau bằng các điểm. Các đối tượng đa giác có chiều dài (vd: chu vi của khu vực) cũng như số đo diện tích. Đa giác có thể được sử dụng để biểu diễn một khu vực (vd: một ngôi làng) hoặc một cấu trúc (vd: diện tích thực tế của một bệnh viện).

### Trực quan hóa dữ liệu không gian {.unnumbered}

Để thể hiện trực quan dữ liệu không gian trên bản đồ, phần mềm GIS yêu cầu bạn cung cấp đầy đủ thông tin về vị trí của các đối tượng địa lý khác nhau, trong mối quan hệ của chúng với nhau. Nếu bạn đang sử dụng dữ liệu vectơ, điều này sẽ đúng cho hầu hết các trường hợp sử dụng, thông tin này thường sẽ được lưu trữ trong một shapefile:

**Shapefiles** - Shapefile là một định dạng dữ liệu phổ biến để lưu trữ dữ liệu không gian "vectơ" bao gồm hoặc đường, điểm hoặc đa giác. Một shapefile thực chất là một tập hợp của ít nhất ba tệp - .shp, .shx và .dbf. Tất cả các tệp thành phần phụ này phải nằm trong cùng một thư mục để chúng có thể đọc được. Các tệp liên quan này có thể được nén vào một thư mục ZIP để gửi qua email hoặc tải xuống từ một trang web.

Shapefile sẽ chứa thông tin về bản thân các đối tượng địa lý cũng như vị trí định vị chúng trên bề mặt Trái đất. Điều này rất quan trọng bởi vì trong khi Trái đất là một quả địa cầu, các bản đồ thường là hai chiều; các lựa chọn về cách "làm phẳng" dữ liệu không gian có thể có tác động lớn đến giao diện và cách giải thích các kết quả..

**Hệ trục tọa độ tham chiếu (Coordinate Reference Systems - CRS)** - CRS là một hệ thống dựa trên tọa độ được sử dụng để xác định vị trí các đối tượng địa lý trên bề mặt Trái đất. Nó có một số thành phần chính:

-   *Hệ tọa độ* - Có nhiều hệ tọa độ khác nhau, vì vậy hãy đảm bảo rằng bạn biết hệ tọa độ của mình là từ hệ nào. Các kinh độ/vĩ độ là phổ biến nhẩt, nhưng bạn cũng có thể gặp hệ tọa độ [UTM](https://www.maptools.com/tutorials/utm/quick_guide).

-   *Đơn vị* - Các đơn vị dành cho hệ tọa độ của bạn (ví dụ: độ thập phân, mét)

-   *Dữ liệu* - Một phiên bản được mô hình hóa cụ thể của Trái đất. Chúng đã được sửa đổi trong nhiều năm, vì vậy hãy đảm bảo rằng các lớp bản đồ của bạn đang sử dụng cùng một dữ liệu..

-   *Phép chiếu* - Tham chiếu đến phương trình toán học được sử dụng để chiếu trái đất hình tròn lên một bề mặt phẳng (bản đồ).

Hãy nhớ rằng bạn có thể tóm tắt dữ liệu không gian mà không cần sử dụng các công cụ lập bản đồ được hiển thị bên dưới. Đôi khi một bảng đơn giản phân chia theo địa lý (ví dụ: huyện, quốc gia, v.v.) là tất cả những gì cần thiết!

## Bắt đầu với GIS

Có một số thứ quan trọng bạn sẽ cần phải có và suy nghĩ tới khi tạo bản đồ. Bao gồm:

-   Một **tập dữ liệu** -- tập dữ liệu này có thể ở định dạng dữ liệu không gian (chẳng hạn như shapefiles, như đã lưu ý ở trên) hoặc nó có thể không ở định dạng không gian (chẳng hạn như csv).

-   Nếu tập dữ liệu của bạn không ở định dạng không gian, bạn cũng sẽ cần một **tập dữ liệu tham chiếu**. Dữ liệu tham chiếu bao gồm biểu diễn không gian của dữ liệu và **các thuộc tính** liên quan, sẽ bao gồm tài liệu chứa thông tin vị trí và địa chỉ của các đối tượng địa lý cụ thể.

    -   Nếu bạn đang làm việc với các ranh giới địa lý được xác định trước (ví dụ: khu vực hành chính), các shapefiles tham chiếu thường có sẵn miễn phí để tải xuống từ cơ quan chính phủ hoặc tổ chức chia sẻ dữ liệu. Khi nghi ngờ, bạn có thể tìm kiếm trên Google cụm từ "[tên vùng] shapefile"

    -   Nếu bạn có thông tin địa chỉ, nhưng không có vĩ độ và kinh độ, bạn có thể cần sử dụng một **công cụ mã hóa địa lý** để lấy dữ liệu không gian tham chiếu cho bản ghi của mình.

-   Ý tưởng về **cách bạn muốn trình bày** thông tin trong bộ dữ liệu của mình cho đối tượng mục tiêu. Có nhiều loại bản đồ khác nhau, và điều quan trọng là phải suy nghĩ xem loại bản đồ nào phù hợp nhất với nhu cầu của bạn.

### Các loại bản đồ để trực quan hóa dữ liệu {.unnumbered}

**Bản đồ Choropleth** - một loại bản đồ trong đó màu sắc, sự đổ bóng, hoặc các họa tiết được sử dụng để thể hiện các vùng địa lý liên quan đến giá trị của một thuộc tính. Ví dụ: giá trị lớn hơn có thể được biểu thị bằng màu tối hơn giá trị nhỏ hơn. Loại bản đồ này đặc biệt hữu ích khi trực quan hóa một biến số và xem cách nó thay đổi trên các vùng hoặc khu vực địa chính trị xác định.

```{r, out.width = '50%', fig.align = "center", fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "gis_choropleth.png"))
```

**Bản đồ nhiệt mật độ trường hợp** - một loại bản đồ trong đó màu sắc được sử dụng để thể hiện cường độ của một giá trị, tuy nhiên, nó không sử dụng các vùng hoặc ranh giới địa chính trị xác định để nhóm dữ liệu. Loại bản đồ này thường được sử dụng để hiển thị 'điểm nóng' hoặc các khu vực có mật độ hoặc tập trung điểm cao.

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_heatmap.png"))
```

**Bản đồ mật độ điểm** - một loại bản đồ sử dụng các điểm để biểu thị các giá trị thuộc tính trong dữ liệu của bạn. Loại bản đồ này được sử dụng tốt nhất để trực quan hóa phân tán dữ liệu của bạn và scan một cách trực quan các cụm.

```{r, fig.align = "center", echo=F}
# dot density img here
```

**Bản đồ ký hiệu tỷ lệ (bản đồ ký hiệu chia độ)** - một loại bản đồ tương tự như bản đồ choropleth, nhưng thay vì sử dụng màu sắc để biểu thị giá trị của một thuộc tính, nó sử dụng một ký hiệu (thường là một vòng tròn) liên quan đến giá trị. Ví dụ, một giá trị lớn hơn có thể được biểu thị bằng một ký hiệu lớn hơn một giá trị nhỏ hơn. Loại bản đồ này được sử dụng tốt nhất khi bạn muốn trực quan hóa kích thước hoặc số lượng dữ liệu của mình trên các vùng địa lý.

```{r, fig.align = "center", echo=F}
# proportional symbols img here
```

Bạn cũng có thể kết hợp một số loại trực quan hóa khác nhau để hiển thị các trường hợp địa lý phức tạp. Ví dụ, các trường hợp (điểm) trong bản đồ dưới đây được tô màu theo cơ sở y tế gần nhất của họ (xem phần chú thích). Các vòng tròn lớn hiển thị *cơ sở y tế gần nhất trong khu vực* ở một bán kính xác định, và các điểm màu đỏ tươi là những cơ sở y tế không nằm trong bất kỳ bán kính nào:

```{r, fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "gis_hf_catchment.png"))
```

Lưu ý: Trọng tâm chính trong chương GIS này được dựa trên tình huống đáp ứng các vụ dịch tại thực địa. Do đó, nội dung của chương sẽ bao gồm các thao tác, hình ảnh hóa và phân tích dữ liệu không gian cơ bản.

<!-- ======================================================= -->

## Chuẩn bị

### Gọi package {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.

```{r}
pacman::p_load(
  rio,           # to import data
  here,          # to locate files
  tidyverse,     # to clean, handle, and plot the data (includes ggplot2 package)
  sf,            # to manage spatial data using a Simple Feature format
  tmap,          # to produce simple maps, works for both interactive and static maps
  janitor,       # to clean column names
  OpenStreetMap, # to add OSM basemap in ggplot map
  spdep          # spatial statistics
  ) 
                  
```

Bạn có thể xem tổng quan về tất cả các package trong R xử lý dữ liệu không gian tại [CRAN "Spatial Task View"](https://cran.r-project.org/web/views/Spatial.html).

### Dữ liệu trường hợp mẫu {.unnumbered}

Với mục đích minh họa, chúng ta sẽ làm việc với một mẫu ngẫu nhiên gồm 1000 trường hợp từ bộ dữ liệu một vụ dịch Ebola mô phỏng có tên `linelist` (về mặt tính toán, việc làm việc với ít trường hợp hơn sẽ dễ hiển thị hơn trong sổ tay này). Để tiện the dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch"</a> (dưới dạng tệp .rds).

Vì chúng ta đang lấy một mẫu ngẫu nhiên của các trường hợp, nên kết quả của bạn có thể hơi khác so với những gì được minh họa ở đây khi bạn tự chạy code của mình.

Nhập dữ liệu vào bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r, echo=F}
# import clean case linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))  
```

```{r, eval=F}
# import clean case linelist
linelist <- import("linelist_cleaned.rds")  
```

Tiếp theo, chúng ta chọn một mẫu ngẫu nhiên gồm 1000 hàng bằng hàm `sample()` từ **base** R.

```{r}
# generate 1000 random row numbers, from the number of rows in linelist
sample_rows <- sample(nrow(linelist), 1000)

# subset linelist to keep only the sample rows, and all columns
linelist <- linelist[sample_rows,]
```

Bây giờ chúng ta muốn chuyển đổi bộ dữ liệu `linelist` đang là một dataframe, thành một đối tượng "sf" (spatial features - các đặc tính không gian). Do bộ dữ liệu linelist có hai cột "lon" và "lat" đại diện cho kinh độ và vĩ độ của nơi cư trú của từng trường hợp, nên việc chuyển đổi này khá dễ dàng.

Chúng ta sử dụng package **sf** (spatial features - các đặc tính không gian) và hàm `st_as_sf()` của nó để tạo đối tượng mới có tên `linelist_sf`. Đối tượng mới này về cơ bản giống với linelist, nhưng các cột `lon` và `lat` đã được chỉ định là cột tọa độ, và một hệ thống tham chiếu tọa độ (CRS) đã được gán khi các điểm được hiển thị. 4326 xác định tọa độ của chúng ta dựa trên [Hệ thống trắc địa thế giới 1984 (WGS84)](https://gisgeography.com/wgs84-world-geodetic-system/) - là tiêu chuẩn cho tọa độ GPS.

```{r}
# Create sf object
linelist_sf <- linelist %>%
     sf::st_as_sf(coords = c("lon", "lat"), crs = 4326)
```

Dưới đây là cách bộ dữ liệu `linelist` gốc được hiển thị. Trong phần minh họa này, chúng ta sẽ chỉ sử dụng cột `date_onset` và `geometry` (được xây dựng từ các trường kinh độ và vĩ độ ở trên và là cột cuối cùng trong khung dữ liệu).

```{r}
DT::datatable(head(linelist_sf, 10), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Shapefiles phân cấp hành chính {.unnumbered}

**Sierra Leone: shapefiles phân cấp hành chính**

Trước đó, chúng tôi đã tải xuống tất cả các phân cấp hành chính của Sierra Leone từ [website của Humanitarian Data Exchange (HDX) ](https://data.humdata.org/dataset/sierra-leone-all-ad-min-level-boundaries). Ngoài ra, bạn có thể tải xuống các dữ liệu này và tất cả các dữ liệu mẫu khác cho sổ tay này qua gói R của chúng tôi, như được giải thích trong trang [Tải sách và dữ liệu].

Bây giờ chúng ta sẽ thực hiện những bước sau để lưu shapefile hành chính cấp 3 vào R:

1)  Nhập shapefile\
2)  Làm sạch tên cột\
3)  Lọc các hàng để chỉ giữ lại các khu vực quan tâm

Để nhập một shapefile, chúng ta sử dụng hàm `read_sf()` từ package **sf**. Nó được cung cấp đường dẫn tệp thông qua hàm `here()`. - trong trường hợp này tệp nằm bên trong Dự án R của bạn tại thư mục "data", rồi tới "gis", và thư mục con "shp", với tệp có tên "sle_adm3.shp" (xem chương [Nhập xuất dữ liệu] và [Dự án R] để biết thêm chi tiết). Bạn sẽ cần cung cấp đường dẫn tệp của riêng mình.

```{r, echo=F}
sle_adm3_raw <- sf::read_sf(here("data", "gis", "shp", "sle_adm3.shp"))
```

Tiếp theo, chúng ta sử dụng hàm `clean_names()` từ package **janitor** để chuẩn hóa tên các cột của shapefile. Chúng ta cũng sử dụng hàm `filter()` để chỉ giữ lại các hàng có tên admin2 là "Western Area Urban" hoặc "Western Area Rural".

```{r}
# ADM3 level clean
sle_adm3 <- sle_adm3_raw %>% 
  janitor::clean_names() %>% # standardize column names
  filter(admin2name %in% c("Western Area Urban", "Western Area Rural")) # filter to keep certain areas
```

Dưới đây, bạn có thể thấy shapefile trông như thế nào sau khi nhập và làm sạch. *Cuộn sang phải* to see how there are columns hành chính cấp 0 (quốc gia), hành chính cấp 1, hành chính cấp 2, và cuối cùng là hành chính cấp 3. Mỗi cấp độ có một tên và một mã định danh duy nhất "pcode". Pcode mở rộng với mỗi sự tăng lên của cấp hành chính, vd. SL (Sierra Leone) -\> SL04 (Western) -\> SL0410 (Western Area Rural) -\> SL040101 (Koya Rural).

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(sle_adm3, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Dữ liệu dân số {.unnumbered}

**Sierra Leone: Dân số theo ADM3**

Những dữ liệu này có thể tải xuống từ HDX (link [tại đây](https://data.humdata.org/dataset/sierra-leone-population)) hoặc thông qua R package **epirhandbook** như đã được giải thích [trong chương này][Tải sách và dữ liệu]. Chúng ta cũng sử dụng hàm `import()` để nạp tệp .csv. Chúng tôi cũng chuyển file được nhập tới hàm `clean_names()` để chuẩn hóa cú pháp tên cột.

```{r}
# Population by ADM3
sle_adm3_pop <- import(here("data", "gis", "population", "sle_admpop_adm3_2020.csv")) %>%
  janitor::clean_names()
```

Bộ dữ liệu dân số trông sẽ như bên dưới. Cuộn sang bên phải để xem các cột: dân số nam (`male` population), dân số nữ (`female` populaton), tổng dân số (`total` population), và dân số theo từng nhóm tuổi.

```{r message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(sle_adm3_pop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Các cơ sở y tế {.unnumbered}

**Sierra Leone: Dữ liệu cơ sở y tế từ OpenStreetMap**

Một lần nữa, bạn có thể tải xuống thông tin vị trí của các cơ sở y tế từ HDX [tại đây](https://data.humdata.org/dataset/hotosm_sierra_leone_health_facilities) hoặc thông qua hướng dẫn trong chương [Tải sách và dữ liệu].

Chúng ta nhập shapefile tọa độ điểm các cơ sở với hàm `read_sf()`, làm sạch lại tên cột, sau đó lọc để chỉ giữ lại các điểm được gắn thẻ là "hospital", "clinic", hoặc "doctors".

```{r}
# OSM health facility shapefile
sle_hf <- sf::read_sf(here("data", "gis", "shp", "sle_hf.shp")) %>% 
  janitor::clean_names() %>%
  filter(amenity %in% c("hospital", "clinic", "doctors"))
```

Dưới đây là dataframe kết quả - *Cuộn phải* để xem tên cơ sở và tọa độ `geometry`.

```{r message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(sle_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Vẽ đồ thị tọa độ

Cách dễ nhất để vẽ đồ thị tọa độ X-Y (kinh độ / vĩ độ, điểm), trong trường hợp này, là vẽ chúng dưới dạng điểm trực tiếp từ đối tượng `linelist_sf` mà chúng ta đã tạo trong phần chuẩn bị.

Package **tmap** cung cấp khả năng lập bản đồ đơn giản ở cả dạng tĩnh ("plot" mode) và tương tác ("view" mode) chỉ với một vài dòng code. Cú pháp của **tmap** tương tự như cú pháp của **ggplot2**, chẳng hạn như các lệnh được thêm vào nhau bằng dấu `+`. Đọc thêm chi tiết trong [hướng dẫn này](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html).

1)  Thiết lập **tmap** mode. Trong trường hợp này chúng ta sẽ sử dụng "plot" mode để tạo ra các biểu đồ tĩnh.

```{r, warning = F, message=F}
tmap_mode("plot") # choose either "view" or "plot"
```

Dưới đây, các điểm được vẽ độc lập. Hàm `tm_shape()` được cung cấp bởi đối tượng `linelist_sf`. Chúng ta sau đó thêm các điểm thông qua hàm `tm_dots()`, và cụ thể kích thước và màu sắc. `linelist_sf` là một đối tượng sf đã được chúng ta chỉ định hai cột chứa tọa độ vĩ độ/kinh độ và hệ quy chiếu tọa độ (CRS):

```{r, warning = F, message=F}
# Just the cases (points)
tm_shape(linelist_sf) + tm_dots(size=0.08, col='blue')
```

Khi đứng một mình, các điểm không cho biết nhiều thông tin. Vì vậy, chúng ta nên lập bản đồ địa giới hành chính:

Một lần nữa chúng ta sử dụng hàm `tm_shape()` (xem [tài liệu này](https://www.rdocumentation.org/packages/tmap/versions/3.3/topics/tm_shape)) nhưng thay vì cung cấp shapefile tọa độ điểm các trường hợp, chúng ta cung cấp shapefile địa giới hành chính (đa giác).

Với đối số `bbox =` (bbox là viết tắt của "bounding box"), chúng ta có thể chỉ định các ranh giới tọa độ. Đầu tiên, chúng ta hiển thị bản đồ mà không có  `bbox`, và sau đó thêm nó vào.

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Just the administrative boundaries (polygons)
tm_shape(sle_adm3) +               # admin boundaries shapefile
  tm_polygons(col = "#F7F7F7")+    # show polygons in light grey
  tm_borders(col = "#000000",      # show borders with color and line weight
             lwd = 2) +
  tm_text("admin3name")            # column text to display for each polygon


# Same as above, but with zoom from bounding box
tm_shape(sle_adm3,
         bbox = c(-13.3, 8.43,    # corner
                  -13.2, 8.5)) +  # corner
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")

```

Và bây giờ hiển thị các điểm và đa giác cùng nhau:

```{r, warning=F, message=FALSE}
# All together
tm_shape(sle_adm3, bbox = c(-13.3, 8.43, -13.2, 8.5)) +     #
  tm_polygons(col = "#F7F7F7") +
  tm_borders(col = "#000000", lwd = 2) +
  tm_text("admin3name")+
tm_shape(linelist_sf) +
  tm_dots(size=0.08, col='blue', alpha = 0.5) +
  tm_layout(title = "Distribution of Ebola cases")   # give title to map

```

Để đọc một bài so sánh hay về các tùy chọn vẽ bản đồ trong R, hãy xem [bài đăng blog này](https://rstudio-pubs-static.s3.amazonaws.com/324400_69a673183ba449e9af4011b1eeb456b9.html).

<!-- ======================================================= -->

## Phép nối theo không gian

Bạn có thể đã quen với việc *nối* dữ liệu từ một tập dữ liệu này sang một tập dữ liệu khác. Một số phương pháp được thảo luận trong chương [Nối dữ liệu] của cuốn sổ tay này. Một phép nối theo không gian phục vụ một mục đích tương tự nhưng tận dụng các mối quan hệ không gian. Thay vì dựa vào các giá trị chung trong các cột để khớp chính xác các quan sát, bạn có thể sử dụng các mối quan hệ không gian của chúng, chẳng hạn như một đối tượng địa lý *nằm trong* đối tượng khác, hoặc *hàng xóm gần nhất* với đối tượng khác, hoặc ở trong *vùng đệm* của một bán kính nhất định từ đối tượng khác, v.v.

Package **sf** cung cấp nhiều phương thức khác nhau để nối theo không gian. Xem thêm tài liệu về phương pháp st_join và các kiểu nối theo không gian trong [tài liệu tham khảo này](https://r-spatial.github.io/sf/reference/geos_binary_pred.html).

### Điểm trong đa giác {.unnumbered}

**Gán đơn vị hành chính cho các trường hợp theo không gian**

Sau đây là một câu hỏi hóc búa thú vị: linelist không chứa bất kỳ thông tin nào về các đơn vị hành chính của các trường hợp. Mặc dù lý tưởng nhất là thu thập thông tin như vậy trong giai đoạn thu thập dữ liệu ban đầu, chúng ta cũng có thể gán các đơn vị hành chính cho các trường hợp riêng lẻ dựa trên mối quan hệ không gian của chúng (tức là điểm giao với một đa giác)..

Dưới đây, chúng ta sẽ giao các vị trí (điểm) theo không gian với địa giới hành chính cấp 3 (đa giác):

1)  Bắt đầu với linelist (các điểm)\
2)  Nối theo không gian tới các địa giới, thiết lập kiểu nối là "st_intersects"\
3)  Sử dụng hàm `select()` để chỉ giữ lại một số cột địa giới hành chính mới

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # join the administrative boundary file to the linelist, based on spatial intersection
  sf::st_join(sle_adm3, join = st_intersects)
```

Tất cả các cột từ `sle_adms` đã được thêm vào linelist! Mỗi trường hợp bây giờ có các cột thể hiện chi tiết cấp hành chính mà nó nằm trong đó. Trong ví dụ này, chúng ta chỉ muốn giữ lại hai trong số các cột mới (địa giới hành chính cấp 3), vì vậy chúng dùng hàm `select()` để chọn tên các cột cũ và chỉ hai cột bổ sung quan tâm:

```{r, warning=F, message=F}
linelist_adm <- linelist_sf %>%
  
  # join the administrative boundary file to the linelist, based on spatial intersection
  sf::st_join(sle_adm3, join = st_intersects) %>% 
  
  # Keep the old column names and two new admin ones of interest
  select(names(linelist_sf), admin3name, admin3pcod)
```

Dưới đây, chỉ với mục đích hiển thị, bạn có thể thấy mười trường hợp đầu tiên và địa giới hành chính cấp 3 của chúng đã được gắn với nhau, dựa trên vị trí giao nhau trong không gian giữa các điểm với đa giác.

```{r, warning=F, message=F}
# Now you will see the ADM3 names attached to each case
linelist_adm %>% select(case_id, admin3name, admin3pcod)
```

Bây giờ chúng ta có thể mô tả các trường hợp theo đơn vị hành chính - điều mà chúng ta đã không thể làm trước khi nối theo không gian!

```{r, warning=F, message=F}
# Make new dataframe containing counts of cases by administrative unit
case_adm3 <- linelist_adm %>%          # begin with linelist with new admin cols
  as_tibble() %>%                      # convert to tibble for better display
  group_by(admin3pcod, admin3name) %>% # group by admin unit, both by name and pcode 
  summarise(cases = n()) %>%           # summarize and count rows
  arrange(desc(cases))                     # arrange in descending order

case_adm3
```

Chúng ta cũng có thể tạo một biểu đồ cột về số lượng trường hợp theo đơn vị hành chính.

Trong ví dụ này, chúng ta bắt đầu hàm `ggplot()` với bộ dữ liệu `linelist_adm`, trong đó chúng ta có thể áp dụng các hàm làm việc với factor như `fct_infreq()` để sắp xếp các cột theo tần suất (xem chương [Factors] để biết thêm các mẹo).

```{r, warning=F, message=F}
ggplot(
    data = linelist_adm,                       # begin with linelist containing admin unit info
    mapping = aes(
      x = fct_rev(fct_infreq(admin3name))))+ # x-axis is admin units, ordered by frequency (reversed)
  geom_bar()+                                # create bars, height is number of rows
  coord_flip()+                              # flip X and Y axes for easier reading of adm units
  theme_classic()+                           # simplify background
  labs(                                      # titles and labels
    x = "Admin level 3",
    y = "Number of cases",
    title = "Number of cases, by adminstative unit",
    caption = "As determined by a spatial join, from 1000 randomly sampled cases from linelist"
  )
```

<!-- ======================================================= -->

### Hàng xóm gần nhất {.unnumbered}

**Tìm cơ sở y tế gần nhất / khu vực cung cấp dịch vụ y tế**

Có thể sẽ hữu ích nếu biết các cơ sở y tế nằm ở đâu trong mối liên quan đến các điểm nóng về dịch bệnh.

Chúng ta có thể sử dụng phương pháp nối *st_nearest_feature* trong hàm `st_join()` (**sf** package) để trực quan hóa cơ sở y tế gần nhất với các trường hợp bệnh nhân.

1)  Chúng ta bắt đầu với shapefile linelist có tên `linelist_sf`\
2)  Chúng ta nối theo không gian với đối tượng `sle_hf`, chứa thông tin về vị trí của các cơ sở y tế và phòng khám (các điểm)

```{r, warning=F, message=F}
# Closest health facility to each case
linelist_sf_hf <- linelist_sf %>%                  # begin with linelist shapefile  
  st_join(sle_hf, join = st_nearest_feature) %>%   # data from nearest clinic joined to case data 
  select(case_id, osm_id, name, amenity) %>%       # keep columns of interest, including id, name, type, and geometry of healthcare facility
  rename("nearest_clinic" = "name")                # re-name for clarity
```

Chúng ta có thể thấy bên dưới (50 hàng đầu tiên) rằng mỗi trường hợp hiện đã có dữ liệu về phòng khám/bệnh viện gần nhất

```{r message=FALSE, echo=F}
DT::datatable(head(linelist_sf_hf, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Chúng ta có thể thấy rằng "Den Clinic" là cơ sở y tế gần nhất với khoảng \~30% các trường hợp.

```{r}
# Count cases by health facility
hf_catchment <- linelist_sf_hf %>%   # begin with linelist including nearest clinic data
  as.data.frame() %>%                # convert from shapefile to dataframe
  count(nearest_clinic,              # count rows by "name" (of clinic)
        name = "case_n") %>%         # assign new counts column as "case_n"
  arrange(desc(case_n))              # arrange in descending order

hf_catchment                         # print to console
```

Để trực quan hóa kết quả, chúng ta có thể sử dụng **tmap** - lúc này interactive mode sẽ xem dễ dàng hơn

```{r, warning=F, message=F}
tmap_mode("view")   # set tmap mode to interactive  

# plot the cases and clinic points 
tm_shape(linelist_sf_hf) +            # plot cases
  tm_dots(size=0.08,                  # cases colored by nearest clinic
          col='nearest_clinic') +    
tm_shape(sle_hf) +                    # plot clinic facilities in large black dots
  tm_dots(size=0.3, col='black', alpha = 0.4) +      
  tm_text("name") +                   # overlay with name of facility
tm_view(set.view = c(-13.2284, 8.4699, 13), # adjust zoom (center coords, zoom)
        set.zoom.limits = c(13,14))+
tm_layout(title = "Cases, colored by nearest clinic")
```

### Vùng đệm {.unnumbered}

Chúng ta cũng có thể tìm hiểu xem có bao nhiêu trường hợp nằm trong khoảng cách đi bộ 2,5 km (\~30 phút) từ cơ sở y tế gần nhất.

*Chú ý: Để tính toán khoảng cách chính xác hơn, tốt hơn nên chiếu lại đối tượng sf của bạn lên hệ thống chiếu bản đồ địa phương tương ứng chẳng hạn như UTM (Trái đất được chiếu lên bề mặt phẳng). Trong ví dụ này, để đơn giản hơn, chúng ta sẽ dựa vào Hệ tọa độ địa lý của Hệ thống trắc địa thế giới (WGS84) (Trái đất được biểu diễn trong một bề mặt hình cầu/tròn, do đó các đơn vị được tính bằng độ thập phân). Chúng ta sẽ sử dụng quy đổi chung là: 1 độ thập phân = \~111km.*

Xem thêm thông tin về phép chiếu bản đồ và hệ tọa độ tại bài viết này [esri article](https://www.esri.com/arcgis-blog/products/arcgis-pro/mapping/gcs_vs_pcs/). [Blog này](http://www.geo.hunter.cuny.edu/~jochen/gtech201/lectures/lec6concepts/map%20coordinate%20systems/how%20to%20choose%20a%20projection.htm) nói về các loại phép chiếu bản đồ khác nhau và cách người ta có thể chọn phép chiếu phù hợp tùy thuộc vào khu vực quan tâm và bối cảnh của bản đồ/phân tích của bạn.

**Đầu tiên**, tạo một vùng đệm hình tròn với bán kính \~2.5km xung quanh mỗi cơ sở y tế. Điều này được thực hiện với hàm `st_buffer()` trong package **tmap**. Bởi vì đơn vị của bản đồ là kinh/vĩ độ thập phân, đó là cách "0.02" được diễn giải. Nếu hệ tọa độ bản đồ của bạn tính bằng mét, thì số đó phải được cung cấp bằng mét.

```{r, warning=F, message=F}
sle_hf_2k <- sle_hf %>%
  st_buffer(dist=0.02)       # decimal degrees translating to approximately 2.5km 
```

Sau đây chúng ta vẽ biểu đồ của chính các vùng đệm, với:

```{r, warning=F, message=F}
tmap_mode("plot")
# Create circular buffers
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2)+
tm_shape(sle_hf) +                    # plot clinic facilities in large red dots
  tm_dots(size=0.3, col='black')      
```

**Thứ hai**, *chúng ta giao các vùng đệm này với các trường hợp (điểm) bằng cách sử dụng hàm `st_join()` và kiểu nối là st_intersects*. Tức là, dữ liệu từ vùng đệm được nối với các điểm mà chúng giao với nhau.

```{r, warning=F, message=F}
# Intersect the cases with the buffers
linelist_sf_hf_2k <- linelist_sf_hf %>%
  st_join(sle_hf_2k, join = st_intersects, left = TRUE) %>%
  filter(osm_id.x==osm_id.y | is.na(osm_id.y)) %>%
  select(case_id, osm_id.x, nearest_clinic, amenity.x, osm_id.y)
```

Bây giờ chúng ta có thể đếm kết quả: có `nrow(linelist_sf_hf_2k[is.na(linelist_sf_hf_2k$osm_id.y),])` trường hợp trong số 1000 trường hợp không giao nhau với bất kỳ vùng đệm nào (giá trị đó bị thiếu), và do đó họ sống ở nơi cách nhiều hơn 30 phút đi bộ tới cơ sở y tế gần nhất.

```{r}
# Cases which did not get intersected with any of the health facility buffers
linelist_sf_hf_2k %>% 
  filter(is.na(osm_id.y)) %>%
  nrow()
```

Chúng ta có thể trực quan hóa kết quả sao cho các trường hợp không giao nhau với bất kỳ vùng đệm nào sẽ xuất hiện với màu đỏ.

```{r, out.width = '100%', warning=F, message=F}
tmap_mode("view")

# First display the cases in points
tm_shape(linelist_sf_hf) +
  tm_dots(size=0.08, col='nearest_clinic') +

# plot clinic facilities in large black dots
tm_shape(sle_hf) +                    
  tm_dots(size=0.3, col='black')+   

# Then overlay the health facility buffers in polylines
tm_shape(sle_hf_2k) +
  tm_borders(col = "black", lwd = 2) +

# Highlight cases that are not part of any health facility buffers
# in red dots  
tm_shape(linelist_sf_hf_2k %>%  filter(is.na(osm_id.y))) +
  tm_dots(size=0.1, col='red') +
tm_view(set.view = c(-13.2284,8.4699, 13), set.zoom.limits = c(13,14))+

# add title  
tm_layout(title = "Cases by clinic catchment area")

```

### Các hàm nối theo không gian khác {.unnumbered}

Các giá trị tùy chọn cho đối số `join` bao gồm (lấy từ [tài liệu này](https://r-spatial.github.io/sf/reference/st_join.html))

-   st_contains_properly\
-   st_contains\
-   st_covered_by\
-   st_covers\
-   st_crosses\
-   st_disjoint\
-   st_equals_exact\
-   st_equals\
-   st_is_within_distance\
-   st_nearest_feature\
-   st_overlaps\
-   st_touches\
-   st_within

## Bản đồ Choropleth

Bản đồ Choropleth có thể hữu ích để trực quan hóa dữ liệu của bạn theo khu vực được xác định trước, thường là đơn vị hành chính hoặc khu vực y tế. Ví dụ, trong ứng phó với ổ dịch, điều này có thể giúp xác định mục tiêu phân bổ nguồn lực cho các khu vực cụ thể có tỷ lệ mắc bệnh cao.

Bây giờ chúng ta đã gán tên đơn vị hành chính cho tất cả các trường hợp (xem phần về phép nối không gian, ở trên), chúng ta có thể bắt đầu lập bản đồ số lượng trường hợp theo khu vực (bản đồ choropleth).

Vì chúng ta cũng có dữ liệu dân số theo cấp hành chính cấp 3 (ADM3), chúng ta có thể thêm thông tin này vào bảng *case_adm3* đã được tạo trước đó.

Chúng ta bắt đầu với dataframe `case_adm3` được tạo trong bước trước đó, là bảng tóm tắt của từng đơn vị hành chính và số lượng các trường hợp của nó.

1)  Dữ liệu dân số `sle_adm3_pop` được nối sử dụng hàm `left_join()` từ **dplyr** trên cơ sở các giá trị chung trên cột `admin3pcod` trong bộ dữ liệu `case_adm3`, và cột `adm_pcode` trong bộ dữ liệu `sle_adm3_pop`. Xem chương [Nối dữ liệu]).\
2)  `select()` được áp dụng trên dataframe mới, để chỉ giữ những cột cần thiệt - `total` nghĩa là tổng dân số\
3)  Các trường hợp trên 10,000 dân được tính toán bằng cách tạo cột mới với hàm `mutate()`

```{r}
# Add population data and calculate cases per 10K population
case_adm3 <- case_adm3 %>% 
     left_join(sle_adm3_pop,                             # add columns from pop dataset
               by = c("admin3pcod" = "adm3_pcode")) %>%  # join based on common values across these two columns
     select(names(case_adm3), total) %>%                 # keep only important columns, including total population
     mutate(case_10kpop = round(cases/total * 10000, 3)) # make new column with case rate per 10000, rounded to 3 decimals

case_adm3                                                # print to console for viewing
```

Nối bảng này với đa giác shapfile ADM3 để vẽ bản đồ

```{r, warning=F, message=F}
case_adm3_sf <- case_adm3 %>%                 # begin with cases & rate by admin unit
  left_join(sle_adm3, by="admin3pcod") %>%    # join to shapefile data by common column
  select(objectid, admin3pcod,                # keep only certain columns of interest
         admin3name = admin3name.x,           # clean name of one column
         admin2name, admin1name,
         cases, total, case_10kpop,
         geometry) %>%                        # keep geometry so polygons can be plotted
  st_as_sf()                                  # convert to shapefile

```

Vẽ bản đồ kết quả

```{r, message=F, warning=F}
# tmap mode
tmap_mode("plot")               # view static map

# plot polygons
tm_shape(case_adm3_sf) + 
        tm_polygons("cases") +  # color by number of cases column
        tm_text("admin3name")   # name display
```

Chúng ta cũng có thể lập bản đồ tỷ suất mới mắc

```{r, warning=F, message=F}
# Cases per 10K population
tmap_mode("plot")             # static viewing mode

# plot
tm_shape(case_adm3_sf) +                # plot polygons
  tm_polygons("case_10kpop",            # color by column containing case rate
              breaks=c(0, 10, 50, 100), # define break points for colors
              palette = "Purples"       # use a purple color palette
              ) +
  tm_text("admin3name")                 # display text

```

## Vẽ bản đồ với ggplot2

Nếu bạn đã quen với việc sử dụng **ggplot2**, bạn có thể sử dụng package này để vẽ bản đồ tĩnh cho dữ liệu của bạn. Hàm `geom_sf()` sẽ vẽ các đối tượng khác nhau dựa trên các đối tượng địa lý (điểm, đường thẳng hoặc đa giác) có trong dữ liệu của bạn. Ví dụ: bạn có thể sử dụng hàm `geom_sf()` trong `ggplot()` bằng cách sử dụng dữ liệu `sf` với dạng hình học đa giác để tạo bản đồ choropleth.

Để minh họa cách thức hoạt động của nó, Chúng ta có thể bắt đầu với shapefile đa giác ADM3 mà chúng ta đã sử dụng lúc trước. Xin nhớ lại rằng đây là các khu vực hành chính cấp 3 ở Sierra Leone:

```{r}
sle_adm3
```

Chúng ta có thể sử dụng hàm `left_join()` từ **dplyr** để thêm dữ liệu mà chúng ta muốn vẽ tới đối tượng shapefile. Trong trường hợp này, chúng ta sẽ sử dụng bộ dữ liệu `case_adm3` mà chúng ta đã tạo trước đó để tóm tắt số lượng trường hợp theo khu vực hành chính; tuy nhiên, chúng ta có thể sử dụng phương pháp tương tự này để vẽ bất kỳ dữ liệu nào được lưu trữ trong data frame.

```{r}
sle_adm3_dat <- sle_adm3 %>% 
  inner_join(case_adm3, by = "admin3pcod") # inner join = retain only if in both data objects

select(sle_adm3_dat, admin3name.x, cases) # print selected variables to console
```

Để tạo biểu đồ cột về số lượng trường hợp theo khu vực, sử dụng **ggplot2**, sau đó chúng ta có thể gọi `geom_col()` như sau:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +
  geom_col(aes(x=fct_reorder(admin3name.x, cases, .desc=T),   # reorder x axis by descending 'cases'
               y=cases)) +                                  # y axis is number of cases by region
  theme_bw() +
  labs(                                                     # set figure text
    title="Number of cases, by administrative unit",
    x="Admin level 3",
    y="Number of cases"
  ) + 
  guides(x=guide_axis(angle=45))                            # angle x-axis labels 45 degrees to fit better

```

Nếu chúng ta muốn sử dụng **ggplot2** để tạo bản đồ choropleth về số lượng trường hợp, chúng ta có thể sử dụng cú pháp tương tự để gọi hàm `geom_sf()`:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) + 
  geom_sf(aes(fill=cases))    # set fill to vary by case count variable

```

Sau đó, chúng ta có thể tùy chỉnh hình thức bản đồ bằng cách sử dụng ngữ pháp nhất quán trên **ggplot2**, ví dụ:

```{r, fig.align = "center"}
ggplot(data=sle_adm3_dat) +                           
  geom_sf(aes(fill=cases)) +						
  scale_fill_continuous(high="#54278f", low="#f2f0f7") +    # change color gradient
  theme_bw() +
  labs(title = "Number of cases, by administrative unit",   # set figure text
       subtitle = "Admin level 3"
  )
```

Đối với người dùng R cảm thấy thoải mái khi làm việc với **ggplot2**, `geom_sf()` cung cấp một cách làm đơn giản và trực tiếp, phù hợp với việc trực quan hóa bản đồ cơ bản. Để tìm hiểu thêm, hãy đọc [hướng dẫn geom_sf() này](https://ggplot2.tidyverse.org/reference/ggsf.html) hoặc [sách về ggplot2](https://ggplot2-book.org/maps.html).

<!-- ======================================================= -->

## Bản đồ cơ sở

### OpenStreetMap {.unnumbered}

Dưới đây, chúng tôi mô tả cách lấy được bản đồ cơ sở cho bản đồ **ggplot2** bằng cách sử dụng các tính năng của OpenStreetMap. Các phương pháp thay thế bao gồm sử dụng **ggmap**, yêu cầu bạn đăng ký miễn phí với Google ([chi tiết](https://www.earthdatascience.org/courses/earth-analytics/lidar-raster-data-r/ggmap-basemap/)).

[**OpenStreetMap**](https://en.wikipedia.org/wiki/OpenStreetMap) là một dự án hợp tác nhằm tạo ra một bản đồ thế giới có thể chỉnh sửa miễn phí. Dữ liệu vị trí địa lý nền tảng ví dụ: vị trí của các thành phố, đường xá, đặc điểm tự nhiên, sân bay, trường học, bệnh viện, đường xá, v.v.) được coi là đầu ra chính của dự án.

Đầu tiên, chúng ta gọi package **OpenStreetMap** để lấy bản đồ cơ sở.

Sau đó chúng ta tạo đối tượng `map`, được xác định bằng cách sử dụng hàm `openmap()` từ package **OpenStreetMap** ([tài liệu](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/openmap)). Chúng ta cung cấp những thông tin sau:

-   `upperLeft` và `lowerRight` Hai cặp tọa độ xác định giới hạn của ô bản đồ cơ sở

    -   Trong trường hợp này, chúng tôi đã đưa giá trị tối đa và tối thiểu từ các hàng trong linelist, vì vậy bản đồ sẽ tương tác động với dữ liệu\

-   `zoom =` (nếu null nó sẽ được xác định tự động)\

-   `type =` loại bản đồ cơ sở nào - chúng tôi đã liệt kê một số khả năng ở đây và code hiện đang sử dụng cái đầu tiên (`[1]`) "osm"\

-   `mergeTiles =` chúng tôi đã chọn TRUE để tất cả các lớp nền được hợp nhất thành một

```{r, message=FALSE, warning=FALSE}
# load package
pacman::p_load(OpenStreetMap)

# Fit basemap by range of lat/long coordinates. Choose tile type
map <- openmap(
  upperLeft = c(max(linelist$lat, na.rm=T), max(linelist$lon, na.rm=T)),   # limits of basemap tile
  lowerRight = c(min(linelist$lat, na.rm=T), min(linelist$lon, na.rm=T)),
  zoom = NULL,
  type = c("osm", "stamen-toner", "stamen-terrain", "stamen-watercolor", "esri","esri-topo")[1])
```

Nếu chúng ta vẽ bản đồ cơ sở này ngay bây giờ, sử dụng hàm `autoplot.OpenStreetMap()` từ package **OpenStreetMap**, bạn sẽ thấy rằng các đơn vị trên các trục không phải là kinh/vĩ độ. Nó đang sử dụng một hệ tọa độ khác. Để hiển thị chính xác nơi cứ trú các trường hợp (được lưu trữ theo vĩ độ/kinh độ), điều này phải được thay đổi.

```{r, warning=F, message=F}
autoplot.OpenStreetMap(map)
```

Vì vậy, chúng ta muốn chuyển đổi bản đồ thành vĩ độ/kinh độ với hàm `openproj()` từ package **OpenStreetMap**. Chúng ta cung cấp bản đồ cơ sở `map` và cũng cung cấp Hệ thống tham chiếu tọa độ (CRS) mà chúng ta muốn. Chúng ta thực hiện điều này bằng cách cung cấp chuỗi ký tự “proj.4” cho phép chiếu WGS 1984, nhưng bạn cũng có thể cung cấp CRS theo những cách khác. (xem [trang này](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/understand-epsg-wkt-and-other-crs-definition-file-types/) để hiểu rõ hơn chuỗi proj.4 là gì)

```{r, warning=F, message=F}
# Projection WGS84
map_latlon <- openproj(map, projection = "+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs")
```

Bây giờ khi chúng ta tạo biểu đồ, chúng ta thấy rằng dọc theo các trục là tọa độ vĩ độ và kinh độ. Hệ tọa độ đã được chuyển đổi. Bây giờ các trường hợp của chúng ta sẽ được biểu diễn chính xác nếu được phủ lên!

```{r, warning=F, message=F}
# Plot map. Must use "autoplot" in order to work with ggplot
autoplot.OpenStreetMap(map_latlon)
```

Xem các hướng dẫn [tại đây](http://data-analytics.net/cep/Schedule_files/geospatial.html) và [tại đây](https://www.rdocumentation.org/packages/OpenStreetMap/versions/0.3.4/topics/autoplot.OpenStreetMap) để biết thêm chi tiết.

## Bản đồ nhiệt mật độ đường viền 

Dưới đây, chúng tôi mô tả cách đạt được bản đồ nhiệt mật độ đường viền của các trường hợp, trên một bản đồ cơ sở, bắt đầu với một danh sách dòng (một dòng cho mỗi trường hợp).

1)  Tạo ô bản đồ cơ sở từ OpenStreetMap, như được mô tả ở trên\
2)  Vẽ biểu đồ các trường hợp từ `linelist` bằng cách sử dụng cột vĩ độ và kinh độ\
3)  Chuyển đổi các điểm thành bản đồ nhiệt mật độ với hàm `stat_density_2d()` trong **ggplot2**,

Khi chúng ta có một bản đồ cơ sở với tọa độ vĩ độ/kinh độ, chúng ta có thể vẽ các trường hợp của mình lên trên bằng cách sử dụng tọa độ vĩ độ/kinh độ của nơi cư trú của chúng.

Xây dựng dựa trên hàm `autoplot.OpenStreetMap()` để tạo bản đồ cơ sở, các hàm **ggplot2** sẽ dễ dàng thêm vào trên cùng, như được hiển thị với hàm `geom_point()` bên dưới:

```{r, warning=F, message=F}
# Plot map. Must be autoplotted to work with ggplot
autoplot.OpenStreetMap(map_latlon)+                 # begin with the basemap
  geom_point(                                       # add xy points from linelist lon and lat columns 
    data = linelist,                                
    aes(x = lon, y = lat),
    size = 1, 
    alpha = 0.5,
    show.legend = FALSE) +                          # drop legend entirely
  labs(x = "Longitude",                             # titles & labels
       y = "Latitude",
       title = "Cumulative cases")

```

Bản đồ trên có thể khó giải thích, đặc biệt là với các điểm trùng lặp. Vì vậy, thay vào đó bạn có thể vẽ một bản đồ mật độ 2d bằng cách sử dụng hàm `stat_density_2d()` trong **ggplot2**. Bạn vẫn đang sử dụng tọa độ vĩ độ/kinh độ của linelist, nhưng ước tính mật độ lõi 2D được thực hiện và kết quả được hiển thị với các đường đồng mức - giống như bản đồ địa hình. Đọc bản đầy đủ [tài liệu tại đây](https://ggplot2.tidyverse.org/reference/geom_density_2d.html).

```{r, warning=F, message=F}
# begin with the basemap
autoplot.OpenStreetMap(map_latlon)+
  
  # add the density plot
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # specify color scale
  scale_fill_gradient(low = "black", high = "red")+
  
  # labels 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases")

```

<!-- ======================================================= -->

### Bản đồ nhiệt chuỗi thời gian {.unnumbered}

Bản đồ nhiệt mật độ ở trên cho thấy *các trường hợp tích lũy*. Chúng ta có thể khảo sát các vụ dịch theo thời gian và không gian bằng cách faceting bản đồ nhiệt dựa trên *tháng khởi phát triệu chứng*, như được rút ra từ linelist.

Chúng ta bắt đầu với `linelist`, tạo một cột mới với Năm và Tháng khởi phát. Hàm `format()` trong **base** R thay đổi cách hiển thị ngày. Trong trường hợp này, chúng ta muốn "YYYY-MM"..

```{r, warning=F, message=F}
# Extract month of onset
linelist <- linelist %>% 
  mutate(date_onset_ym = format(date_onset, "%Y-%m"))

# Examine the values 
table(linelist$date_onset_ym, useNA = "always")
```

Bây giờ, chúng ta chỉ cần đơn giản facet thông qua **ggplot2** vào bản đồ nhiệt mật độ. `facet_wrap()` được áp dụng, sử dụng cột mới làm hàng. Chúng ta thiết lập số lượng cột được facet là 4 cho rõ ràng.

```{r, warning=F, message=F}
# packages
pacman::p_load(OpenStreetMap, tidyverse)

# begin with the basemap
autoplot.OpenStreetMap(map_latlon)+
  
  # add the density plot
  ggplot2::stat_density_2d(
        data = linelist,
        aes(
          x = lon,
          y = lat,
          fill = ..level..,
          alpha = ..level..),
        bins = 10,
        geom = "polygon",
        contour_var = "count",
        show.legend = F) +                          
  
  # specify color scale
  scale_fill_gradient(low = "black", high = "red")+
  
  # labels 
  labs(x = "Longitude",
       y = "Latitude",
       title = "Distribution of cumulative cases over time")+
  
  # facet the plot by month-year of onset
  facet_wrap(~ date_onset_ym, ncol = 4)               

```

<!-- SPATIAL STATISTICS SECTION IS UNDER DEVELOPMENT -->

## Thống kê không gian

Hầu hết các cuộc thảo luận của chúng ta cho đến nay đều tập trung vào việc trực quan hóa dữ liệu không gian. Trong một số trường hợp, bạn cũng có thể quan tâm đến việc sử dụng *thống kê không gian* để định lượng mối quan hệ không gian của các thuộc tính trong dữ liệu của mình. Phần này sẽ cung cấp một cái nhìn tổng quan ngắn gọn về một số khái niệm chính trong thống kê không gian và đề xuất một số tài liệu sẽ hữu ích để khám phá nếu bạn muốn thực hiện các phân tích không gian toàn diện hơn.

### Mối quan hệ không gian {.unnumbered}

Trước khi có thể tính toán bất kỳ số liệu thống kê không gian nào, chúng ta cần xác định mối quan hệ giữa các đối tượng địa lý trong dữ liệu của mình. Có nhiều cách để khái niệm hóa các mối quan hệ không gian, nhưng một mô hình đơn giản và thường được áp dụng để sử dụng là mô hình *adjancy - liền kề* - cụ thể là chúng ta mong đợi mối quan hệ địa lý giữa các khu vực có chung biên giới hoặc “láng giềng” với nhau..

Chúng ta có thể định lượng các mối quan hệ liền kề giữa các vùng địa giới hành chính trong dữ liệu `sle_adm3` mà chúng ta đang sử dụng với package **spdep**. Chúng ta sẽ cụ thể sự tiếp giáp *queen*, có nghĩa là các khu vực sẽ là hàng xóm của nhau nếu chúng có chung ít nhất một điểm dọc theo biên giới của chúng. Phương pháp thay thế có thể là sự tiếp giáp *rook*, đòi hỏi các khu vực phải chia sẻ một cạnh - trong trường hợp của chúng ta, với các đa giác không đều, sự phân biệt là không đáng kể, nhưng trong một số trường hợp, sự lựa chọn giữa queen và rook có thể có ảnh hưởng.

```{r}
sle_nb <- spdep::poly2nb(sle_adm3_dat, queen=T) # create neighbors 
sle_adjmat <- spdep::nb2mat(sle_nb)    # create matrix summarizing neighbor relationships
sle_listw <- spdep::nb2listw(sle_nb)   # create listw (list of weights) object -- we will need this later

sle_nb
round(sle_adjmat, digits = 2)
```

Ma trận được in ở trên hiển thị mối quan hệ giữa 9 vùng trong dữ liệu `sle_adm3` của chúng ta. Điểm 0 cho biết hai vùng không phải là láng giềng, trong khi bất kỳ giá trị nào khác 0 cho biết mối quan hệ láng giềng. Các giá trị trong ma trận được chia tỷ lệ để mỗi vùng có tổng trọng số hàng là 1.

Một cách tốt hơn để trực quan hóa những mối quan hệ láng giềng này là vẽ biểu đồ chúng:

```{r, fig.align='center', results='hide'}
plot(sle_adm3_dat$geometry) +                                           # plot region boundaries
  spdep::plot.nb(sle_nb,as(sle_adm3_dat, 'Spatial'), col='grey', add=T) # add neighbor relationships
```

Chúng ta đã sử dụng phương pháp tiếp cận adjacency để xác định các đa giác hàng xóm; những người hàng xóm mà chúng ta đã xác định đôi khi cũng được gọi là **những người hàng xóm dựa trên sự tiếp giáp**. Nhưng đây chỉ là một cách để lựa chọn các khu vực dự kiến có mối quan hệ địa lý. Các cách tiếp cận thay thế phổ biến nhất để xác định các mối quan hệ địa lý tạo ra **những người hàng xóm dựa trên khoảng cách**; ngắn gọn thì chúng là:

-   **K-nearest neighbors** - Dựa trên khoảng cách giữa các tâm (trung tâm có trọng số địa lý của mỗi vùng đa giác), hãy chọn *n* vùng gần nhất làm vùng lân cận. Ngưỡng khoảng cách tối đa cũng có thể được chỉ định. Trong **spdep**, bạn có thể sử dụng hàm `knearneigh()` (xem [tài liệu](https://r-spatial.github.io/spdep/reference/knearneigh.html)).

-   **Distance threshold neighbors** - Chọn tất cả hàng xóm trong một ngưỡng khoảng cách. Trong **spdep**, các mối quan hệ láng giềng này có thể được xác định bằng cách sử dụng hàm `dnearneigh()` (xem [tài liệu](https://www.rdocumentation.org/packages/spdep/versions/1.1-7/topics/dnearneigh)).

### Tự tương quan không gian {.unnumbered}

Định luật địa lý đầu tiên được trích dẫn của Tobler tuyên bố rằng “mọi thứ đều liên quan đến mọi thứ khác, nhưng những thứ ở gần có liên quan hơn những thứ ở xa”. Trong dịch tễ học, điều này thường có nghĩa là nguy cơ về một kết quả sức khỏe cụ thể ở một vùng nhất định tương tự với các vùng lân cận hơn là những vùng xa. Khái niệm này đã được chính thức hóa dưới dạng **tự tương quan không gian** - thuộc tính thống kê mà các đối tượng địa lý có giá trị tương tự được nhóm lại với nhau trong không gian. Các phép đo thống kê về tự tương quan không gian có thể được sử dụng để *định lượng mức độ phân cụm không gian* trong dữ liệu của bạn, *xác định vị trí xảy ra phân cụm*, và *xác định các xu hướng chung về tự tương quan không gian* giữa các biến khác nhau trong dữ liệu của bạn. Phần này giới thiệu tổng quan về một số thước đo phổ biến của tự tương quan không gian và cách tính chúng trong R.

**Moran's I** - Đây là thống kê tóm tắt mang tính toàn cục (global) về mối tương quan giữa giá trị của một biến trong một vùng và giá trị của cùng một biến ở các vùng lân cận. Thống kê Moran's I thường dao động từ -1 tới 1. Giá trị 0 cho thấy không có tương quan không gian, trong khi các giá trị gần 1 hoặc -1 cho thấy tự tương quan không gian (các giá trị tương tự gần nhau) hoặc phân tán không gian (các giá trị không tương tự ở gần nhau) mạnh hơn.

Ví dụ: chúng ta sẽ tính toán thống kê Moran's I để định lượng tự tương quan theo không gian trong các trường hợp Ebola mà chúng ta đã mapping trước đó (hãy nhớ rằng đây là một tập con các trường hợp từ một vụ dịch mô phỏng trong dataframe `linelist`). Package **spdep** có hàm `moran.test` có thể giúp chúng ta thực hiện phép tính toán này:

```{r}
moran_i <-spdep::moran.test(sle_adm3_dat$cases,    # numeric vector with variable of interest
                            listw=sle_listw)       # listw object summarizing neighbor relationships

moran_i                                            # print results of Moran's I test
```

Đầu ra từ hàm `moran.test()` cho chúng ta thấy kết quả thống kê Moran I statistic từ hàm `round(moran_i$estimate[1],2)`. Điều này cho thấy sự hiện diện của tự tương quan không gian trong dữ liệu của chúng ta - cụ thể là những khu vực có số ca mắc Ebola tương tự nhau thì có khả năng ở gần nhau. Giá trị p cung cấp bởi kiểm định `moran.test()` được tạo ra bằng cách so sánh với kỳ vọng trong giả thuyết không là không có tự tương quan không gian, và có thể được sử dụng nếu bạn cần báo cáo kết quả của một kiểm định giả thuyết chính thức.

**Local Moran's I** - Chúng ta có thể phân tách thống kê Moran's I (toàn cục - global) được tính toán ở trên để xác định tự tương quan *cục bộ (local)*; nghĩa là, để xác định các cụm cụ thể trong dữ liệu của chúng ta. Thống kê này, đôi khi còn được gọi là **Local Indicator of Spatial Association (LISA)**, tóm tắt mức độ tự tương quan không gian xung quanh mỗi vùng riêng lẻ. Nó có thể hữu ích để tìm các điểm "nóng - hot" và "lạnh - cold" trên bản đồ.

Để hiển thị một ví dụ, chúng ta có thể tính toán và lập bản đồ Local Moran's I cho các trường hợp Ebola ở trên với hàm `local_moran()` từ package **spdep**:

```{r, fig.align='center'}
# calculate local Moran's I
local_moran <- spdep::localmoran(                  
  sle_adm3_dat$cases,                              # variable of interest
  listw=sle_listw                                  # listw object with neighbor weights
)

# join results to sf data
sle_adm3_dat<- cbind(sle_adm3_dat, local_moran)    

# plot map
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=Ii)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Local Moran's I") +
  labs(title="Local Moran's I statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

**Getis-Ord Gi\*** - Đây là một thống kê khác thường được sử dụng để phân tích điểm nóng - hotspot analysis; mức độ phổ biến của thống kê này liên quan đến ứng dụng của nó trong công cụ Phân tích điểm nóng của ArcGIS. Nó dựa trên giả định rằng thông thường, sự khác biệt về giá trị của một biến giữa các vùng lân cận phải tuân theo phân phối chuẩn. Nó sử dụng cách tiếp cận z-score để xác định các vùng có giá trị cao hơn đáng kể (điểm nóng) hoặc thấp hơn đáng kể (điểm lạnh) của một biến cụ thể, so với các vùng lân cận của chúng..

Chúng ta có thể tính toán và lập bản đồ chỉ số Gi\* sử dụng hàm `localG()` từ package **spdep**:

```{r}
# Perform local G analysis
getis_ord <- spdep::localG(
  sle_adm3_dat$cases,
  sle_listw
)

# join results to sf data
sle_adm3_dat$getis_ord <- getis_ord

# plot map
ggplot(data=sle_adm3_dat) +
  geom_sf(aes(fill=getis_ord)) +
  theme_bw() +
  scale_fill_gradient2(low="#2c7bb6", mid="#ffffbf", high="#d7191c",
                       name="Gi*") +
  labs(title="Getis-Ord Gi* statistic for Ebola cases",
       subtitle="Admin level 3 regions, Sierra Leone")

```

Như bạn có thể thấy, bản đồ được tạo ra bởi Getis-Ord Gi\* trông hơi khác so với bản đồ của Local Moran's I được tạo ra trước đó. Điều này phản ánh rằng phương pháp được sử dụng để tính toán hai số liệu thống kê này hơi khác nhau; bạn nên sử dụng cái nào tùy thuộc vào trường hợp sử dụng cụ thể của bạn và câu hỏi nghiên cứu quan tâm.

**Lee's L test** - Đây là một kiểm định thống kê về mối tương quan không gian giữa hai biến. Nó cho phép bạn kiểm định xem xu hướng không gian của một biến *x* có tương tự với xu hướng không gian của một biến *y* khác hay không, với giả định là chúng có mối tương quan không gian với nhau

Để đưa ra một ví dụ, hãy kiểm định liệu rằng xu hướng không gian các trường hợp Ebola từ một vụ dịch mô phỏng có tương quan với xu hướng không gian của dân số hay không. Để bắt đầu, chúng ta cần có một biến `population` trong bộ dữ liệu `sle_adm3` của mình. Chúng ta có thể sử dụng biến `total` từ bộ dữ liệu `sle_adm3_pop` mà chúng ta đã tải trước đó.

```{r}
sle_adm3_dat <- sle_adm3_dat %>% 
  rename(population = total)                          # rename 'total' to 'population'
```

Chúng ta có thể trực quan hóa nhanh xu hướng không gian của hai biến cạnh nhau, để xem liệu chúng có tương tự nhau hay không:
```{r, fig.align='center', warning=F, message=F}
tmap_mode("plot")

cases_map <- tm_shape(sle_adm3_dat) + tm_polygons("cases") + tm_layout(main.title="Cases")
pop_map <- tm_shape(sle_adm3_dat) + tm_polygons("population") + tm_layout(main.title="Population")

tmap_arrange(cases_map, pop_map, ncol=2)   # arrange into 2x1 facets
```

Một cách trực quan, các xu hướng có vẻ không giống nhau. Chúng ta có thể sử dụng hàm `lee.test()` trong package **spdep** để kiểm định liệu xu hướng tự tương quan không gian giữa hai biến số có liên quan có ý nghĩa thống kê với nhau hay không. Thống kê L sẽ gần tới 0 nếu không có mối tương quan giữa các xu hướng, gần bằng 1 nếu có mối tương quan dương mạnh (tức là các xu hướng tương tự nhau) và gần bằng -1 nếu có mối tương quan âm mạnh (tức là các xu hướng là ngược nhau).

```{r, warning=F, message=F}
lee_test <- spdep::lee.test(
  x=sle_adm3_dat$cases,          # variable 1 to compare
  y=sle_adm3_dat$population,     # variable 2 to compare
  listw=sle_listw                # listw object with neighbor weights
)

lee_test
```

Kết quả từ thống kê Lee's L cho hai biến là `round(lee_test$estimate[1],2)`, chỉ ra rằng chúng có mối tương quan âm yếu. Điều này khẳng định đánh giá trực quan của chúng ta rằng xu hướng các trường hợp bệnh và dân số không liên quan đến nhau cũng như cung cấp bằng chứng rằng xu hướng không gian của các trường hợp không hoàn toàn là kết quả của mật độ dân số ở các khu vực có nguy cơ cao.

Thống kê Lee L có thể hữu ích để đưa ra các suy luận về mối quan hệ phân bố theo không gian giữa các biến; tuy nhiên, để mô tả bản chất của mối quan hệ giữa hai biến một cách chi tiết hơn, hoặc điều chỉnh cho nhiễu, sẽ cần đến các kỹ thuật *hồi quy không gian*. Chúng sẽ được mô tả ngắn gọn trong phần sau.

### Hồi quy không gian {.unnumbered}

Bạn có thể muốn đưa ra các suy luận thống kê về mối quan hệ giữa các biến trong dữ liệu không gian của mình. Trong những trường hợp này, sẽ hữu ích khi xem xét các kỹ thuật *hồi quy không gian* - nghĩa là, các cách tiếp cận hồi quy xem xét rõ ràng tổ chức không gian của các đơn vị trong dữ liệu của bạn. Một số lý do mà bạn có thể cần xem xét các mô hình hồi quy không gian, thay vì các mô hình hồi quy tiêu chuẩn như GLM, bao gồm:

-   Các mô hình hồi quy tiêu chuẩn giả định rằng các phần dư là độc lập với nhau. Khi có hiện tượng *tự tương quan không gian* mạnh, các phần dư của mô hình hồi quy chuẩn cũng có khả năng tự tương quan không gian, do đó vi phạm giả định này. Điều này có thể dẫn đến các vấn đề trong việc giải thích kết quả mô hình, trong trường hợp đó, một mô hình không gian sẽ được ưu tiên hơn.

-   Các mô hình hồi quy cũng thường giả định rằng tác động của một biến *x* là không đổi đối với tất cả các quan sát. Trong trường hợp *không đồng nhất về không gian - spatial heterogenity*, các tác động mà chúng ta muốn ước tính có thể thay đổi theo không gian và chúng ta có thể quan tâm đến việc định lượng những khác biệt đó. Trong trường hợp này, các mô hình hồi quy không gian mang lại sự linh hoạt hơn cho việc ước lượng và giải thích các tác động.

Các chi tiết về phương pháp tiếp cận hồi quy không gian nằm ngoài phạm vi của sổ tay này. Thay vào đó, phần này sẽ cung cấp tổng quan về các mô hình hồi quy không gian phổ biến nhất và cách sử dụng của chúng, đồng thời giới thiệu cho bạn tài liệu tham khảo có thể sử dụng nếu bạn muốn khám phá thêm lĩnh vực này.

**Các mô hình sai số không gian - Spatial error models** - Các mô hình này giả định rằng sai số trên các đơn vị không gian có tương quan với nhau, trong trường hợp đó, dữ liệu sẽ vi phạm các giả định của mô hình OLS tiêu chuẩn. Các mô hình này đôi khi còn được biết đến với tên **Các mô hình tự hồi quy đồng thời - simultaneous autoregressive (SAR) models**. Mô hình được fit bằng cách sử dụng hàm `errorsarlm()` trong package **spatialreg** (các hàm hồi quy không gian là một phần của package **spdep**).

**Các mô hình độ trễ không gian - Spatial lag models** - Các mô hình này giả định rằng biến phụ thuộc của một vùng *i* không chỉ bị ảnh hưởng bởi giá trị của các biến độc lập trong *i*, mà còn bởi giá trị của các biến đó ở các vùng lân cận *i*. Tương tự như các mô hình sai số không gian, các mô hình độ trễ không gian cũng thường được biết đến với tên gọi **Các mô hình tự hồi quy đồng thời**. Mô hình được fit bằng cách sử dụng hàm `lagsarlm()` trong package **spatialreg**.

Package **spdep** chứa một số kiểm định hữu ích để quyết định lựa chọn giữa các mô hình OLS chuẩn, độ trễ không gian và sai số không gian. Các kiểm định này được gọi là *chẩn đoán Lagrange Multiplier*, có thể được sử dụng để xác định loại phụ thuộc không gian trong dữ liệu của bạn và chọn mô hình nào phù hợp nhất. Hàm `lm.LMtests()` có thể được sử dụng để tính toán tất cả các kiểm định Lagrange Multiplier. Anselin (1988) cũng cung cấp một sơ đồ khối hữu ích để quyết định sử dụng mô hình hồi quy không gian nào dựa trên kết quả của các kiểm định Lagrange Multiplier:

```{r, fig.align='center', echo=F}
knitr::include_graphics(here::here("images", "gis_lmflowchart.jpg"))
```

**Các mô hình Bayesian phân tầng - Bayesian hierarchical models** - Phương pháp tiếp cận Bayes thường được sử dụng cho một số ứng dụng trong phân tích không gian, phổ biến nhất là [lập bản đồ dịch bệnh](https://pubmed.ncbi.nlm.nih.gov/15690999/). Chúng được ưu tiên sử dụng trong các trường hợp dữ liệu trường hợp được phân phối thưa thớt (ví dụ trong trường hợp các outcome là hiếm gặp) hoặc “nhiễu” về mặt thống kê, vì chúng có thể được sử dụng để tạo ra các ước tính “mượt mà” về nguy cơ bệnh tật bằng cách tính đến quy trình không gian tiềm ẩn cơ bản. Điều này có thể giúp cải thiện chất lượng của các ước tính. Chúng cũng cho phép người điều tra cụ thể trước (thông qua việc lựa chọn prior) các xu hướng tương quan không gian phức tạp có thể tồn tại trong dữ liệu, mà có thể giải thích cho các sự biến động phụ thuộc hoặc không phụ thuộc không gian trong cả biến độc lập và phụ thuộc. Trong R, các mô hình Bayesian phân tầng có thể sử dụng thông qua package **CARbayes** (xem [hưỡng dẫn](https://cran.r-project.org/web/packages/CARBayes/vignettes/CARBayes.pdf)) hoặc R-INLA (xem [trang web](https://www.r-inla.org/home) và [sách giáo khoa](https://becarioprecario.bitbucket.io/inla-gitbook/)). R cũng có thể được sử dụng để gọi phần mềm bên ngoài thực hiện ước lượng Bayes, chẳng hạn như JAGS hoặc WinBUGS.

<!-- ======================================================= -->

## Tài nguyên học liệu

-   R Các tính năng cơ bản và package sf [vignette](https://cran.r-project.org/web/packages/sf/vignettes/sf1.html)

-   R tmap package [vignette](https://cran.r-project.org/web/packages/tmap/vignettes/tmap-getstarted.html)

-   ggmap: [Trực quan hóa không gian với ggplot2](https://journal.r-project.org/archive/2013-1/kahle-wickham.pdf)

-   [Giới thiệu về cách tạo bản đồ với R, tổng quan về các package khác nhau](https://bookdown.org/nicohahn/making_maps_with_r5/docs/introduction.html)

-   Dữ liệu không gian trong R [(khóa học EarthLab)](https://www.earthdatascience.org/courses/earth-analytics/spatial-data-r/)

-   Phân tích dữ liệu không gian ứng dụng trong R [sách giáo khoa](https://link.springer.com/book/10.1007/978-1-4614-7618-4)

-   **SpatialEpiApp** - một [ứng dụng Shiny có thể tải xuống dưới dạng một package trong R](https://github.com/Paula-Moraga/SpatialEpiApp), cho phép bạn cung cấp dữ liệu của riêng mình và tiến hành lập bản đồ, phân tích cụm và thống kê không gian.

-   Giới thiệu về kinh tế lượng không gian với R [hội thảo](http://www.econ.uiuc.edu/~lab/workshop/Spatial_in_R.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/gis.Rmd-->

# (PART) Trực quan hóa dữ liệu {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_data_viz.Rmd-->


# Trình bày bảng {#tables-presentation}  


```{r echo=FALSE, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}

linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) 

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make HTML tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

table <- linelist %>% 
  # filter
  ########
  #filter(!is.na(outcome) & hospital != "Missing") %>%  # Remove cases with missing outcome or hospital
  
  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)

  # formatting
  ############
  flextable() %>% 
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  #bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


Chương này sẽ trình bày cách chuyển đổi một bảng tóm tắt dữ liệu thành các bảng sẵn sàng cho mục đích trình bày với package **flextable**. Các bảng này có thể được chèn vào slide powerpoint, trang HTML, tài liệu PDF hoặc Word, v.v.  

Hãy hiểu rằng *trước khi* sử dụng **flextable**, bạn phải tạo bảng tóm tắt dữ liệu dưới dạng một data frame. Sử dụng các phương pháp trong các chương [Bảng mô tả] và [Xoay trục dữ liệu] như tạo bảng đơn, tạo bảng chéo, xoay trục, và tính toán các thống kê mô tả. Kết quả là một data frame sau đó có thể được chuyển đến **flextable** để định dạng hiển thị.  


Có nhiều các R packages khác có thể được sử dụng để tạo bảng cho mục đích trình bày - trong chương này chúng tôi nhấm mạnh vào package **flextable**. Một ví dụ sử dụng **knitr** package và hàm của nó `kable()` có thể được tìm thấy trong chương [Truy vết tiếp xúc]. Tương tự như vậy, package **DT** cũng được nhấn mạnh trong chương [Dashboards với Shiny]. Các package khác như **GT** và **huxtable** được đề cập trong chương [Package đề xuất].  



<!-- ======================================================= -->
## Chuẩn bị {  }

### Gọi packages {.unnumbered} 

Hãy cài đặt và gọi package **flextable**. Trong sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt package nếu cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi package bằng lệnh `library()` từ **base** R. Xem thêm chương [R cơ bản] để biết thêm các thông tin về các package trong R.  

```{r}
pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make HTML tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

```

### Nhập dữ liệu {.unnumbered}  

Để bắt đầu, chúng ta nhập bộ dữ liệu linelist đã được làm sạch về các ca bệnh Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/epirhandbook/Epi_R_handbook/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã làm sạch"</a> (as .rds file). Nhập dữ liệu bằng hàm `import()` từ package **rio** (chấp nhận nhiều loại tập tin như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết). 


```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu linelist được hiển thị như dưới đây.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Chuẩn bị bảng {.unnumbered}  

*Trước khi* bắt đầu sử dụng **flextable** bạn cần phải *tạo* bảng của bạn dưới một data frame. Xem chương [Bảng mô tả] và [Xoay trục dữ liệu] để biết cách tạo một data frame sử dụng các packages như **janitor** và **dplyr**. Đầu tiên, bạn phải sắp xếp nội dung theo hàng và cột như cách bạn muốn nội dung hiển thị. Sau đó, data frame sẽ được chuyển đến **flextable** để hiển thị nó với màu sắc, tiêu đề, phông chữ, v.v. 
  
Dưới đây là một ví dụ trong chương [Bảng mô tả] về cách biến đổi các trường hợp bệnh trong `linelist` thành một data frame để tóm tắt các outcomes của bệnh nhân và giá trị CT theo bệnh viện, với hàng Tổng ở cuối bảng. Đầu ra được lưu dưới dạng `table`.  

```{r message=FALSE, warning=FALSE}
table <- linelist %>% 
  
  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known)                                    # Arrange rows from lowest to highest (Total row at bottom)

table  # print

```




<!-- ======================================================= -->
## Cơ bản về flextable {  }

### Tạo một flextable {.unnumbered}  

Để tạo và quản lý các đối tượng của **flextable**, đầu tiên chúng ta đẩy data frame vào hàm `flextable()`, sau đó lưu kết quả là `my_table`.  

```{r}

my_table <- flextable(table) 
my_table

```

Sau khi thực hiện việc này, chúng ta có thể pipe dần đối tượng `my_table` thông qua các hàm định dạng **flextable** khác.  

Trong trang này để rõ ràng, chúng tôi sẽ lưu bảng ở các bước trung gian vào đối tượng `my_table`, thêm các hàm **flextable** theo từng bước. Nếu bạn muốn xem *tất cả* code từ đầu đến cuối được viết trong một đoạn, hãy xem mục [Kết hợp tất cả các code](#tbl_pres_all) phía dưới đây.  

Cú pháp chung của mỗi dòng code **flextable** như sau:

* `function(table, i = X, j = X, part = "X")`, where:
  * 'function' có thể là một trong số rất nhiều hàm khác nhau, ví dụ như `width()` để xác định độ rộng cột, `bg()` để thiết lập màu nền, `align()` để điều chỉnh văn bản căn giữa / phải / trái, v.v. 
  * `table = ` tên của data frame, có thể bỏ qua nếu như data frame được piping vào trong hàm.
  * `part = ` đề cập đến phần nào của bảng mà hàm đang được áp dụng. Ví dụ. "tiêu đề", "nội dung" hoặc "tất cả". 
  * `i = ` chỉ định *hàng* mà hàm sẽ được áp dụng, trong đó 'X' là số thứ tự hàng. Nếu nhiều hàng được chọn, ví dụ: từ hàng đầu tiên đến hàng thứ ba, ta có thể viết: `i = c (1: 3)`. Lưu ý nếu chọn 'body', hàng đầu tiên bắt đầu từ bên dưới phần tiêu đề.
  * `j = ` chỉ định *cột* mà hàm sẽ được áp dụng, trong đó 'X' là số thứ tự cột hoặc tên cột. Nếu nhiều cột được chọn, ví dụ: từ hàng thứ năm đến hàng thứ sáu, ta có thể viết: `j = c(5,6)`. 
  
Bạn có thể tìm thấy danh sách đầy đủ các hàm định dạng trong package **flextable** [tại đây](https://davidgohel.github.io/flextable/reference/index.html) hoặc xem tài liệu hướng dẫn bằng cách gõ `?flextable`.  


### Độ rộng cột {.unnumbered}

Chúng ta có thể sử dụng hàm `autofit()` để điều chỉnh bảng sao cho mỗi ô chỉ có một hàng văn bản. Hàm `qflextable()` là một cách viết tắt thuận tiện cho `flextable()` và `autofit()`.  

```{r}

my_table %>% autofit()

```

Tuy nhiên, điều này có thể không phải lúc nào cũng phù hợp, đặc biệt nếu có các giá trị rất dài trong các ô, nghĩa là bảng có thể không vừa trong độ rộng của trang.

Thay vào đó, chúng ta có thể điều chỉnh độ rộng cột bằng hàm `width()`. Điều này có thể tốn một chút thời gian để tìm giá trị chiều rộng phù hợp cho các cột. Trong ví dụ dưới đây, chúng ta chỉ định các độ rộng khác nhau cho cột 1, cột 2 và cột 4 đến 8. 

```{r}

my_table <- my_table %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1)

my_table
  
```

### Tiêu đề cột {.unnumbered}

Một bảng có nhiều tiêu đề cột sẽ giúp giải thích nội dung bảng một cách dễ dàng hơn.

Đối với bảng này, chúng ta cần thêm một lớp tiêu đề thứ hai để các cột bao gồm các nhóm con giống nhau có thể được nhóm lại với nhau. Chúng ta thực hiện điều này bằng hàm `add_header_row()` với `top = TRUE`. Chúng ta cung cấp tên mới của mỗi cột bằng `values = `, bỏ trống `""` đối với các cột chúng ta dự định sẽ ghép lại với nhau sau này.  

Chúng ta cũng đổi tên các tên tiêu đề phụ ở hàng thứ hai bằng lệnh `set_header_labels()`.  

Cuối cùng, chúng ta sử dụng hàm `merge_at ()` để hợp nhất các tiêu đề cột trong hàng tiêu đề trên cùng.  

```{r}
my_table <- my_table %>% 
  
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    
  set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header")     # Horizontally merge columns 6 to 8 in new header row

my_table  # print

```

### Đường viền và nền {.unnumbered}  

Bạn có thể điều chỉnh đường viền, đường bên trong, v.v. bằng các hàm khác nhau trong **flextable**. Để dễ dàng, thông thường đầu tiên bạn cần loại bỏ hết các đường viền trong bảng bằng hàm `border_remove()`.  

Sau đó, bạn có thể áp dụng các theme đường viền mặc định bằng cách đưa bảng tới hàm `theme_box()`, `theme_booktabs()`, hoặc `theme_alafoli()`.  

Bạn có thể thêm các đường dọc và ngang bằng nhiều hàm khác nhau. `hline()` và `vline()` sẽ thêm các dòng vào một hàng hoặc cột cụ thể. Bên trong hàm, bạn cần chỉ định phần mà bảng sẽ áp dụng qua đối số `part = ` với các tùy chọn "all", "body", hoặc "header". Đối với các đường dọc, ghi rõ cột được áp dụng với `j = `, đối với các đường ngang, ghi rõ hàng được áp dụng với `i = `. Các hàm khác như `vline_right()`, `vline_left()`, `hline_top()`, và `hline_bottom()` chỉ thêm các đường viền ở bên ngoài.  

Bên trong tất cả các hàm này, kiểu đường phải được định nghĩa thông qua đối số `border = ` và phải là đầu ra của một lệnh riêng biệt bằng cách sử dụng hàm `fp_border()` từ package **officer**. Hàm này giúp bạn xác định độ rộng và màu sắc của đường. Bạn có thể định nghĩa các thông tin này phía trên trước khi thực hiện các lệnh liên quan tới bảng, như được trình bày dưới đây:  

```{r}
# define style for border line
border_style = officer::fp_border(color="black", width=1)

# add border lines to table
my_table <- my_table %>% 

  # Remove all existing borders
  border_remove() %>%  
  
  # add horizontal lines via a pre-determined theme setting
  theme_booktabs() %>% 
  
  # add vertical lines to separate Recovered and Died sections
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style)       # at column 5

my_table
```

### Phông chữ và căn chỉnh {.unnumbered}

Chúng ta căn giữa tất cả các cột ngoại trừ cột ngoài cùng bên trái với tên các bệnh viện, bằng cách sử dụng hàm `align()` từ **flextable**.

```{r}
my_table <- my_table %>% 
   flextable::align(align = "center", j = c(2:8), part = "all") 
my_table
```

Ngoài ra, chúng ta có thể tăng kích thước phông chữ tiêu đề và sau đó thay đổi thành in đậm. Chúng ta cũng có thể thay đổi hàng "Total" thành in đậm.  

```{r}

my_table <-  my_table %>%  
  fontsize(i = 1, size = 12, part = "header") %>%   # adjust font size of header
  bold(i = 1, bold = TRUE, part = "header") %>%     # adjust bold face of header
  bold(i = 7, bold = TRUE, part = "body")           # adjust bold face of total row (row 7 of body)

my_table

```


Chúng ta cũng có thể thiết lập để các cột tỷ lệ chỉ hiển thị một chữ số thập phân bằng cách sử dụng hàm `colformat_num()`. Lưu ý rằng điều này cũng có thể được thực hiện ở giai đoạn quản lý dữ liệu với hàm `round()`. 

```{r}
my_table <- colformat_num(my_table, j = c(4,7), digits = 1)
my_table
```

### Hợp nhất ô {.unnumbered}  

Cũng giống như khi chúng ta hợp nhất các ô theo chiều ngang trong hàng tiêu đề, chúng ta cũng có thể hợp nhất các ô theo chiều dọc bằng cách sử dụng `merge_at()` và chỉ rõ các hàng (`i`) và cột (`j`). Ở đây chúng ta hợp nhất ô "Hospital" và "Total cases with known outcome" theo chiều dọc để cung cấp thêm không gian cho chúng.   

```{r}
my_table <- my_table %>% 
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header")

my_table
```

### Màu nền {.unnumbered}

Để phân biệt nội dung của bảng với các tiêu đề, chúng ta có thể muốn thêm định dạng bổ sung, ví dụ như thay đổi màu nền. Trong ví dụ này, chúng ta sẽ thay đổi nội dung bảng thành màu xám.

```{r}
my_table <- my_table %>% 
    bg(part = "body", bg = "gray95")  

my_table 
```


<!-- ======================================================= -->
## Định dạng có điều kiện {  }

Chúng ta có thể highlight tất cả các giá trị trong một cột đáp ứng một quy tắc nhất định, ví dụ các ô có hơn 55% trường hợp tử vong. Đơn giản chỉ cần đặt điều kiện so sánh vào trong đối số `i = ` hoặc `j = `, phía sau dấu `~`. Bạn cần tham chiếu tới thứ tự cột cần highlight trong trong data frame, không phải tiêu đề cột.  

```{r}

my_table %>% 
  bg(j = 7, i = ~ Pct_Death >= 55, part = "body", bg = "red") 

```



Hoặc, chúng ta có thể highlight toàn bộ hàng đáp ứng một tiêu chí nhất định, chẳng hạn như tên một bệnh viện. Để làm điều này đơn giản chỉ cần không định danh thông số ở đối số (`j`), để các tiêu chí được áp dụng cho tất cả các cột.


```{r}

my_table %>% 
  bg(., i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") 

```

## Kết hợp tất cả các code {#tbl_pres_all}  


Dưới đây, chúng tôi ghép tất cả code từ các phần trên lại với nhau. 

```{r}  

border_style = officer::fp_border(color="black", width=1)

pacman::p_load(
  rio,            # import/export
  here,           # file pathways
  flextable,      # make HTML tables 
  officer,        # helper functions for tables
  tidyverse)      # data management, summary, and visualization

table <- linelist %>% 

  # Get summary values per hospital-outcome group
  ###############################################
  group_by(hospital, outcome) %>%                      # Group data
  summarise(                                           # Create new summary columns of indicators of interest
    N = n(),                                            # Number of rows per hospital-outcome group     
    ct_value = median(ct_blood, na.rm=T)) %>%           # median CT value per group
  
  # add totals
  ############
  bind_rows(                                           # Bind the previous table with this mini-table of totals
    linelist %>% 
      filter(!is.na(outcome) & hospital != "Missing") %>%
      group_by(outcome) %>%                            # Grouped only by outcome, not by hospital    
      summarise(
        N = n(),                                       # Number of rows for whole dataset     
        ct_value = median(ct_blood, na.rm=T))) %>%     # Median CT for whole dataset
  
  # Pivot wider and format
  ########################
  mutate(hospital = replace_na(hospital, "Total")) %>% 
  pivot_wider(                                         # Pivot from long to wide
    values_from = c(ct_value, N),                       # new values are from ct and count columns
    names_from = outcome) %>%                           # new column names are from outcomes
  mutate(                                              # Add new columns
    N_Known = N_Death + N_Recover,                               # number with known outcome
    Pct_Death = scales::percent(N_Death / N_Known, 0.1),         # percent cases who died (to 1 decimal)
    Pct_Recover = scales::percent(N_Recover / N_Known, 0.1)) %>% # percent who recovered (to 1 decimal)
  select(                                              # Re-order columns
    hospital, N_Known,                                   # Intro columns
    N_Recover, Pct_Recover, ct_value_Recover,            # Recovered columns
    N_Death, Pct_Death, ct_value_Death)  %>%             # Death columns
  arrange(N_Known) %>%                                 # Arrange rows from lowest to highest (Total row at bottom)

  # formatting
  ############
  flextable() %>%              # table is piped in from above
  add_header_row(
    top = TRUE,                # New header goes on top of existing header row
    values = c("Hospital",     # Header values for each column below
               "Total cases with known outcome", 
               "Recovered",    # This will be the top-level header for this and two next columns
               "",
               "",
               "Died",         # This will be the top-level header for this and two next columns
               "",             # Leave blank, as it will be merged with "Died"
               "")) %>% 
    set_header_labels(         # Rename the columns in original header row
      hospital = "", 
      N_Known = "",                  
      N_Recover = "Total",
      Pct_Recover = "% of cases",
      ct_value_Recover = "Median CT values",
      N_Death = "Total",
      Pct_Death = "% of cases",
      ct_value_Death = "Median CT values")  %>% 
  merge_at(i = 1, j = 3:5, part = "header") %>% # Horizontally merge columns 3 to 5 in new header row
  merge_at(i = 1, j = 6:8, part = "header") %>%  
  border_remove() %>%  
  theme_booktabs() %>% 
  vline(part = "all", j = 2, border = border_style) %>%   # at column 2 
  vline(part = "all", j = 5, border = border_style) %>%   # at column 5
  merge_at(i = 1:2, j = 1, part = "header") %>% 
  merge_at(i = 1:2, j = 2, part = "header") %>% 
  width(j=1, width = 2.7) %>% 
  width(j=2, width = 1.5) %>% 
  width(j=c(4,5,7,8), width = 1) %>% 
  flextable::align(., align = "center", j = c(2:8), part = "all") %>% 
  bg(., part = "body", bg = "gray95")  %>% 
  bg(., j=c(1:8), i= ~ hospital == "Military Hospital", part = "body", bg = "#91c293") %>% 
  colformat_num(., j = c(4,7), digits = 1) %>%
  bold(i = 1, bold = TRUE, part = "header") %>% 
  bold(i = 7, bold = TRUE, part = "body")

table
```


<!-- ======================================================= -->
## Lưu bảng của bạn {  }

Có nhiều cách khác nhau mà bảng có thể được tích hợp vào kết quả đầu ra của bạn. 

### Lưu bảng đơn {.unnumbered}

Bạn có thể xuất các bảng ra file Word, PowerPoint hoặc HTML hoặc dưới tệp tin ảnh (PNG). Để thực hiện điều này, hãy sử dụng một trong các hàm sau:

* `save_as_docx()`  
* `save_as_pptx()`  
* `save_as_image()`  
* `save_as_html()`  

Ví dụ dưới đây, chúng ta sẽ lưu bảng dưới dạng tài liệu word. Lưu ý cú pháp của đối số đầu tiên - bạn chỉ có thể cung cấp tên của đối tượng flextable, ví dụ: `my_table`, hoặc bạn có thể gán một "tên" cho bảng (ví dụ đặt tên là "my table"). Nếu đặt tên thì tên này sẽ xuất hiện dưới dạng tiêu đề của bảng trong Word. Code để lưu bảng dưới dạng ảnh PNG cũng được minh họa như dưới đây.  

```{r message=FALSE, warning=FALSE, eval=F}
# Edit the 'my table' as needed for the title of table.  
save_as_docx("my table" = my_table, path = "file.docx")

save_as_image(my_table, path = "file.png")
```

Lưu ý là bạn cần cài đặt package `webshot` hoặc `webshot2` để lưu bảng từ flextable dưới dạng ảnh. Hình ảnh xuất ra sẽ có nền trong suốt.

Nếu bạn muốn xem thử kết quả đầu ra của bảng **flextable** , sử dụng lệnh `print()` và chỉ định định dạng muốn xem trước với `preview = `. Tài liệu sẽ được "mở lên" trên máy tính của bạn bằng phần mềm đã chỉ định, nhưng sẽ không được lưu. Điều này có thể hữu ích để kiểm tra xem bảng có vừa với một trang/slide hay không hoặc bạn có thể nhanh chóng copy kết quả sang một tài liệu khác. Bạn có thể sử dụng phương pháp này với đối số preview đặt là “pptx” hoặc “docx”.  

```{r, eval=F}
print(my_table, preview = "docx") # Word document example
print(my_table, preview = "pptx") # Powerpoint example
```

### In bảng trong R markdown {.unnumbered}  

Bảng này có thể được tích hợp vào R markdown, một dạng báo cáo tự động của bạn, nếu đối tượng bảng được gọi trong phần code chunk của R markdown. Điều này có nghĩa là bảng có thể được cập nhật như một phần của báo cáo trong đó dữ liệu có thể thay đổi, do đó, các con số có thể được làm mới.

Xem thêm chi tiết trong chương [Báo cáo với R Markdown] của cuốn sổ tay này. 

<!-- ======================================================= -->
## Nguồn {  }

Sách đầy đủ về **flextable** có thể xem ở đây: https://ardata-fr.github.io/flextable-book/
Trang Github xem ở [đây](https://davidgohel.github.io/flextable/)  
Có thể tìm thấy sách hướng dẫn về tất cả các hàm **flextable** ở [đây](https://davidgohel.github.io/flextable/reference/index.html)

Thư viên các ví dụ về mẫu bảng **flextable** cùng code có thể truy cập tại [đây](https://ardata-fr.github.io/flextable-gallery/gallery/)  
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/tables_presentation.Rmd-->

# ggplot cơ bản {#ggplot-basics}

```{r, out.width=c('100%', '100%'), fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "ggplot_basics_top.png"))
```

**ggplot2** là một package dùng để trực quan hóa dữ liệu phổ biến nhất trong R. Các hàm `ggplot()` là nền tảng của package này, và toàn bộ cách tiếp cận này thường được gọi là *"ggplot"* với các số liệu kết quả đôi khi được gọi trìu mến là "ggplots". Chữ "gg" bắt nguồn từ chữ "**g**rammar of **g**raphics" (ngữ pháp đồ thị) dùng để xây dựng các biểu đồ. **ggplot2** được hưởng lợi từ nhiều package R bổ sung giúp nâng cao hơn nữa chức năng của nó.

Cú pháp của nó khác biệt đáng kể so với vẽ biểu đồ bằng **base** `R`, cũng như có một đường cong học tập gắn với nó. Sử dụng **ggplot2** thông thường yêu cầu người sử dụng phải định dạng lại dữ liệu của họ để tương thích với **tidyverse**, giúp cho việc sử dụng các packages này cùng nhau một cách có hiệu quả.

Trong chương này, chúng tôi sẽ trình bày các nguyên tắc cơ bản về vẽ biểu đồ bằng **ggplot2**. Xem chương [Các tips với ggplot] để biết các gợi ý và các kỹ thuật nâng cao giúp cho biểu đồ của bạn thực sự trông đẹp mắt.

Có một số hướng dẫn **ggplot2** mở rộng được liên kết trong phần tài nguyên học liệu. Bạn cũng có thể tải xuống [trực quan hóa dữ liệu với ggplot cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) từ trang web của RStudio. Nếu bạn muốn có cảm hứng cho các cách trực quan hóa dữ liệu của mình một cách sáng tạo, chúng tôi khuyên bạn nên ghé thăm các trang web như [R graph gallery](https://www.r-graph-gallery.com/) và [Data-to-viz](https://www.data-to-viz.com/caveats.html).

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.

```{r}
pacman::p_load(
  tidyverse,      # includes ggplot2 and other data management tools
  rio,            # import/export
  here,           # file locator
  stringr         # working with characters   
)
```

### Nhập dữ liệu {.unnumbered}

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới. Chúng ta sẽ tập trung và hai biến liên tục là `age`, `wt_kg` (cân nặng được tính bằng kilogram), `ct_blood` (giá trị CT), và`days_onset_hosp` (sự khác biệt giữa ngày khởi phát và nhập viện).

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Làm sạch chung {.unnumbered}

Khi chuẩn bị dữ liệu để vẽ biểu đồ, tốt nhất là làm cho dữ liệu tuân thủ [tiêu chuẩn dữ liệu "gọn gàng"](https://r4ds.had.co.nz/tidy-data.html) nhất có thể. Để đạt được điều này, bạn có thể tham khảo chương [Làm sạch số liệu và các hàm quan trọng] trong cuốn sổ tay này.

Một số cách đơn giản mà chúng ta có thể chuẩn bị dữ liệu của mình để tốt hơn cho việc vẽ biểu đồ, có thể bao gồm việc làm cho nội dung của dữ liệu hiển thị tốt hơn - điều này không nhất thiết phải tương đương với việc bạn chuẩn bị dữ liệu tốt hơn để thao tác với dữ liệu. Ví dụ:

-   Thay thế giá trị `NA` trong cột kiểu ký tự thành "Unknown"\
-   Cân nhắc chuyển đổi cột thành dạng *factor* để các giá trị của chúng được quy định một có thứ tự\
-   Làm sạch một số cột để các giá trị "thân thiện với dữ liệu" của chúng với dấu gạch dưới, v.v. được thay đổi thành văn bản bình thường hoặc chữ hoa tiêu đề (xem chương [Ký tự và chuỗi])

Sau đây là một số ví dụ:

```{r, }
# make display version of columns with more friendly names
linelist <- linelist %>%
  mutate(
    gender_disp = case_when(gender == "m" ~ "Male",        # m to Male 
                            gender == "f" ~ "Female",      # f to Female,
                            is.na(gender) ~ "Unknown"),    # NA to Unknown
    
    outcome_disp = replace_na(outcome, "Unknown")          # replace NA outcome with "unknown"
  )
```

### Xoay trục dài hơn {.unnumbered}

Về cấu trúc dữ liệu, đối với **ggplot2** chúng ta thường muốn xoay trục dữ liệu sang định dạng *dài hơn*. Xem thêm ở chương [Xoay trục dữ liệu].

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "pivoting", "pivot_longer_new.png"))
```

Ví dụ, chúng ta muốn vẽ biểu đồ dữ liệu đang ở định dạng "ngang", chẳng hạn từng trường hợp trong bộ dữ liệu `linelist` và các triệu chứng của chúng. Dưới đây chúng ta sẽ tạo một bộ dữ liệu nhỏ từ linelist gọi là `symptoms_data` chỉ chứa `case_id` và các cột triệu chứng.

```{r}
symptoms_data <- linelist %>% 
  select(c(case_id, fever, chills, cough, aches, vomit))
```

Đây là 50 dòng đầu tiên của bộ dữ liệu mới được tạo ra - hãy xem cách chúng được định dạng lại với mỗi triệu chứng là một cột:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(symptoms_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Nếu chúng ta muốn lập biểu đồ số trường hợp có các triệu chứng cụ thể, chúng ta bị giới hạn bởi thực tế là mỗi triệu chứng là một cột khác nhau. Tuy nhiên, chúng ta có thể *xoay* các cột triệu chứng sang một định dạng dài hơn như sau:

```{r, }
symptoms_data_long <- symptoms_data %>%    # begin with "mini" linelist called symptoms_data
  
  pivot_longer(
    cols = -case_id,                       # pivot all columns except case_id (all the symptoms columns)
    names_to = "symptom_name",             # assign name for new column that holds the symptoms
    values_to = "symptom_is_present") %>%  # assign name for new column that holds the values (yes/no)
  
  mutate(symptom_is_present = replace_na(symptom_is_present, "unknown")) # convert NA to "unknown"

```

Dưới đây là danh sách 50 dòng đầu tiên. Lưu ý rằng với mỗi trường hợp sẽ có 5 dòng - mỗi dòng tương ứng với một triệu chứng có thể xảy ra. Các cột mới có tên `symptom_name` và `symptom_is_present` là kết quả của việc xoay trục dữ liệu. Lưu ý rằng định dạng này có thể không hữu ích cho các hoạt động khác, nhưng rất hữu ích cho việc vẽ biểu đồ.

```{r, message=FALSE, echo=F}
DT::datatable(head(symptoms_data_long, 50), rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

<!-- ======================================================= -->

## Các khái niệm cơ bản của ggplot

**"Ngữ pháp đồ thị" - ggplot2**

Vẽ đồ thị với **ggplot2** dựa trên việc "thêm" các lớp đồ thị và các phần tử thiết kế chồng lên nhau, với mỗi lệnh được thêm vào các lệnh trước bằng một dấu cộng (`+`). Kết quả là một đối tượng biểu đồ nhiều lớp có thể được lưu, sửa đổi, in, xuất ra, v.v.

Các đối tượng ggplot có thể rất phức tạp, nhưng thứ tự cơ bản của các lớp thường sẽ giống như sau:

1.  Bắt đầu với lớp nền bằng lệnh `ggplot()` - lệnh này "mở" ggplot và cho phép các hàm tiếp theo được thêm vào với dấu `+`. Thông thường, tập dữ liệu cũng được chỉ định trong lệnh này\
2.  Thêm các lớp "geom" - các hàm này trực quan hóa dữ liệu dưới dạng *geometries - hình học* (*shapes - hình dạng*), ví dụ: biểu đồ cột, biểu đồ đường, biểu đồ phân tán, histogram (hoặc là sự kết hợp giữa chúng!). Tất cả các hàm này đều bắt đầu với tiền tố `geom_`.\
3.  Thêm các yếu tố thiết kế vào đồ thị, chẳng hạn như nhãn trục, tiêu đề, phông chữ, kích thước, phối màu, chú giải hoặc xoay trục

Một ví dụ đơn giản về bộ khung code như dưới đây. Chúng tôi sẽ giải thích từng cấu phần trong các phần bên dưới.

```{r, eval=F}
# plot data from my_data columns as red points
ggplot(data = my_data)+                   # use the dataset "my_data"
  geom_point(                             # add a layer of points (dots)
    mapping = aes(x = col1, y = col2),    # "map" data column to axes
    color = "red")+                       # other specification for the geom
  labs()+                                 # here you add titles, axes labels, etc.
  theme()                                 # here you adjust color, font, size etc of non-data plot elements (axes, title, etc.) 
```

## `ggplot()`

Lệnh mở đầu của bất kỳ biểu đồ ggplot2 nào cũng là `ggplot()`. Lệnh này chỉ đơn giản là tạo ra một khung trống để thêm các lớp. Nó "mở ra" con đường cho các lớp tiếp theo được thêm vào với dấu `+`.

Thông thường, lệnh `ggplot()` bao gồm đối số `data =` cho biểu đồ. Việc này giúp thiết lập bộ dữ liệu mặc định được sử dụng cho các lớp tiếp theo của biểu đồ.

Lệnh này sẽ kết thúc bằng một dấu `+` sau dấu ngoặc đơn đóng cuối cùng của hàm. Điều này giúp lệnh "mở" trở lại. ggplot sẽ chỉ thực thi/xuất hiện khi lệnh đầy đủ bao gồm một lớp cuối cùng mà *không có* dấu `+` ở cuối.

```{r, eval=F}
# This will create plot that is a blank canvas
ggplot(data = linelist)
```

## Geoms

Một khung trống chắc chắn là không đủ - chúng ta cần tạo thêm các hình học (dạng) từ dữ liệu (vd: biểu đồ cột, histograms, biểu đồ phân tán, box plots).

Điều này được thực hiện bằng cách thêm các lớp "geoms" vào lệnh `ggplot()` ban đầu. Có rất nhiều hàm **ggplot2** có thể tạo ra các "geoms". Mỗi hàm này bắt đầu bằng "geom\_", vì vậy chúng tôi sẽ gọi chúng một cách chung chung là `geom_XXXX()`. Có hơn 40 loại geoms trong **ggplot2** và rất nhiều cái khác được tạo ra bởi cộng đồng. Xem chúng tại [thư viện ggplot2](https://exts.ggplot2.tidyverse.org/gallery/). Một số geom phổ biến được liệt kê dưới đây:

-   Histograms - `geom_histogram()`\
-   Biểu đồ cột - `geom_bar()` hoặc `geom_col()` (xem [mục "Biểu đồ cột"](#ggplot_basics_bars))\
-   Box plots - `geom_boxplot()`\
-   Điểm (vd: biểu đồ phân tán) - `geom_point()`\
-   Biểu đồ đường - `geom_line()` hoặc `geom_path()`\
-   Đường xu hướng - `geom_smooth()`

Trong một biểu đồ, bạn có thể hiển thị một hoặc nhiều geoms. Chúng sẽ được thêm vào các lệnh **ggplot2** trước đó bằng dấu `+`, và chúng được vẽ theo thứ tự sao cho các geoms sau được vẽ lên phía trên của geoms trước đó.

## Chọn dữ liệu cho biểu đồ {#ggplot_basics_mapping}

Hầu hết các hàm geom phải được cho biết *cái gì được sử dụng* để vẽ biểu đồ - vì vậy bạn phải cung cấp cách *map (gán) các biến số trong dữ liệu của bạn* tới các thành phần của biểu đồ như là các trục, màu đối tượng, kích thước đối tượng, v.v. Đối với hầu hết các geoms, các thành phần *thiết yếu* phải được gán tới các cột trong dữ liệu là trục x, và (nếu cần) là trục y.

Việc "mapping" được thực hiện bằng đối số `mapping =` của hàm. Giá trị bạn cung cấp tới `mapping` phải được gói trong hàm `aes()`, vì vậy bạn sẽ viết một cái gì đó kiểu như `mapping = aes(x = col1, y = col2)`, như được trình bày bên dưới.

Dưới đây, trong lệnh `ggplot()`, dữ liệu được thiết lập là các trường hợp trong bộ `linelist`. Trong đối số `mapping = aes()`, cột `age` được gán cho trục x, và cột `wt_kg` được gán cho trục y.

Sau dấu `+`, các lệnh vẽ biểu đồ được tiếp tục. Một đối tượng được tạo bằng hàm "geom" thông qua `geom_point()`. Geom này *kế thừa* các thông số được gán từ lệnh `ggplot()` bên trên - nó biết các trục được gán và tiếp tục trực quan hóa mối quan hệ giữa chúng dưới dạng *các điểm* trên khung vẽ.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+
  geom_point()
```

Một ví dụ khác, lệnh sau sử dụng bộ số liệu tương tự, chỉ có một sự khác biệt nhỏ về cách mapping và hàm geom. Hàm `geom_histogram()` chỉ yêu cầu gán cột cho trục x, bởi vì trục số lượng y được tạo ra một cách tự động.

```{r, warning=F, message=F}
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()
```

### Thẩm mỹ đồ thị {.unnumbered}

Trong ggplot, thuật ngữ "thẩm mỹ đồ thị" có một ý nghĩa đặc biệt. Nó đề cập đến một thuộc tính trực quan của *dữ liệu được vẽ*. Lưu ý rằng "thẩm mỹ" ở đây đề cập đến *dữ liệu đưuợc vẽ bằng các geoms/shapes* - không phải các thành phần hiển thị xung quanh như là tiêu đề, nhãn của trục, màu nền, mà bạn có thể liên kết với từ "thẩm mỹ" trong tiếng Anh thông dụng. Trong ggplot, những chi tiết đó được gọi là "chủ đề" và được điều chỉnh trong lệnh `theme()`(xem [phần này](#ggplot_basics_themes)).

Do đó, *thẩm mỹ* của đối tượng biểu đồ có thể là màu sắc, kích thước, độ trong suốt, vị trí, v.v. của *dữ liệu được vẽ*. Không phải tất cả các geoms sẽ có các tùy chọn thẩm mỹ giống nhau, nhưng một số tùy chọn được áp dụng với phần lớn các geoms. Dưới đây là một số ví dụ:

-   `shape =` Hiển thị một điểm với hàm `geom_point()` dưới dạng dấu chấm, ngôi sao, hình tam giác hoặc hình vuông...\
-   `fill =` Màu sắc bên trong (vd: của cột hoặc boxplot)\
-   `color =` Đường bên ngoài của cột, boxplot, v.v., hoặc màu của điểm nếu sử dụng hàm `geom_point()`\
-   `size =` Kích thước (vd: độ dày của đường, kích thước của điểm)\
-   `alpha =` Độ trong suốt (1 = bình thường, 0 = vô hình)\
-   `binwidth =` Độ rộng các bins trong biểu đồ histogram\
-   `width =` Độ rộng của các cột trong "biểu đồ cột"\
-   `linetype =` Kiểu của đường (vd: liền, nét đứt, chấm chấm)

Thẩm mỹ của đối tượng biểu đồ có thể được gán giá trị theo hai cách:

1)  Gán một giá trị tĩnh (vd: `color = "blue"`) để áp dụng cho tất cả các quan sát được vẽ biểu đồ\
2)  Gán cho một cột của dữ liệu (vd: `color = hospital`) để hiển thị từng quan sát phụ thuộc vào giá trị của nó trong cột đó

<!-- *These non-axis aesthetics can be assigned static values (e.g. `size = 1`) or can be mapped to a column (e.g. `size = age`).* If you want the aesthetic to be assigned a static value, the assignment is placed *outside* the `mapping = aes()`. If you want the aesthetic to be scaled/depend on the value in each row of data, the assignment is made *inside* the `mapping = aes()`.   -->

### Gán một giá trị tĩnh {.unnumbered}

Nếu bạn muốn yếu tố thẩm mỹ cho đối tượng biểu đồ là tĩnh, nghĩa là - giống nhau đối với mọi quan sát trong dữ liệu, bạn viết phép gán của nó bên trong geom nhưng *ở bên ngoài* của bất cứ đối số `mapping = aes()` nào. Các phép gán này có thể trông như này `size = 1` hoặc `color = "blue"`. Sau đây là hai ví dụ:

-   Trong ví dụ đầu tiên, đối số `mapping = aes()` ở bên trong hàm `ggplot()` và các trục được gán tới cột age và weight trong bộ dữ liệu. Các yếu tố thẩm mỹ như là `color =`, `size =`, và `alpha =` (độ trong suốt) được gán các giá trị tĩnh. Để rõ ràng, điều này được thực hiện trong hàm `geom_point()`, vì bạn có thể thêm các geom khác sau đó mà sẽ nhận các giá trị khác nhau cho các yếu tố thẩm mỹ của biểu đồ.\
-   Trong ví dụ thứ hai, biểu đồ histogram chỉ yêu cầu trục x được gán với một cột. Các thông số của biểu đồ histogram như `binwidth =`, `color =`, `fill =` (màu sắc bên trong), và `alpha =` một lần nữa được đặt trong geom thành các giá trị tĩnh.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# scatterplot
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  # set data and axes mapping
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)         # set static point aesthetics

# histogram
ggplot(data = linelist, mapping = aes(x = age))+       # set data and axes
  geom_histogram(              # display histogram
    binwidth = 7,                # width of bins
    color = "red",               # bin line color
    fill = "blue",               # bin interior color
    alpha = 0.1)                 # bin transparency
```

### Vẽ theo tỷ lệ giá trị của cột {.unnumbered}

Một cách khác đó là vẽ theo tỷ lệ giá trị của cột các đối tượng thẩm mỹ của biểu đồ. Theo cách tiếp cận này, việc hiển thị các đối tượng thẩm mỹ sẽ phụ thuộc vào giá trị của quan sát trong cột dữ liệu đó. Nếu các giá trị cột là liên tục, thang đo hiển thị (chú giải) cho thẩm mỹ đó sẽ là liên tục. Nếu các giá trị cột là rời rạc, chú giải sẽ hiển thị từng giá trị và dữ liệu được vẽ biểu đồ sẽ xuất hiện dưới dạng "được nhóm" (đọc thêm ở mục [Nhóm](#ggplotgroups) trong chương này).

Để đạt được điều này, bạn gán yếu tố thẩm mỹ của biểu đồ với một *tên cột* (không trong dấu ngoặc kép). Điều này phải được thực hiện *bên trong một hàm `mapping = aes()`* (lưu ý: có một số vị trí trong code mà bạn có thể thực hiện các phép gán, như được thảo luận [bên dưới](##ggplot_basics_map_loc)).

Hai ví dụ như sau.

-   Ở ví dụ đầu tiên, yếu tố thẩm mỹ `color =` (của mỗi điểm) được gán cho cột `age` - và thang đo liên tục được xuất hiện dưới dạng chú thích! Hiện tại bạn chỉ cần quan tâm tới sự xuất hiện của thanh này - chúng ta sẽ học cách chỉnh sửa nó trong các phần sau.\
-   Trong ví dụ thứ hai, hai yếu tố thẩm mỹ được gán cho hai cột tương ứng (`color =` và `size =`), trong khi `shape =` và `alpha =` được gán cho các giá trị tĩnh bên ngoài đối số `mapping = aes()`.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# scatterplot
ggplot(data = linelist,   # set data
       mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age)
       )+     # map color to age
  geom_point()         # display data as points 

# scatterplot
ggplot(data = linelist,   # set data
       mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age,       # map color to age
         size = age))+      # map size to age
  geom_point(             # display data as points
    shape = "diamond",      # points display as diamonds
    alpha = 0.3)            # point transparency at 30%


```

Lưu ý: Các phép gán trục luôn được gán cho các cột trong dữ liệu (không phải cho các giá trị tĩnh) và điều này luôn được thực hiện với `mapping = aes()`.

Điều quan trọng là phải theo dõi các lớp của biểu đồ và các đối tượng thẩm mỹ khi vẽ các biểu đồ phức tạp - ví dụ biểu đồ được cấu thành từ nhiều geoms. ITrong ví dụ dưới đây, `size =` được gán hai lần - một lần cho `geom_point()` và một lần cho `geom_smooth()` - cả hai lần đều là giá trị tĩnh.

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(           # map aesthetics to columns
         x = age,
         y = wt_kg,
         color = age_years)
       ) + 
  geom_point(                   # add points for each row of data
    size = 1,
    alpha = 0.5) +  
  geom_smooth(                  # add a trend line 
    method = "lm",              # with linear method
    size = 2)                   # size (width of line) of 2
```

### Thực hiện phép gán ở đâu {#ggplot_basics_map_loc .unnumbered}

Việc gán các yếu tố thẩm mỹ bên trong đối số `mapping = aes()` có thể được viết ở một số chỗ trong các lệnh vẽ biểu đồ và thậm chí có thể được viết nhiều lần. Nó có thể được viết trong lệnh `ggplot()` trên cùng, và/hoặc cho từng geom riêng lẻ bên dưới. Các kiểu viết bao gồm:

-   Các phép gán được thực hiện ở lệnh `ggplot()` trên cùng sẽ được mặc định kế thừa ở bất kỳ các geom bên dưới, giống như cách mà `x =` và `y =` được kế thừa
-   Các phép gán được thực hiện trong một geom chỉ áp dụng cho geom đó

Tương tự, `data =` được chỉ định cho lệnh `ggplot()` ở trên đầu sẽ áp dụng mặc định cho tất cả các geom bên dưới, nhưng bạn vẫn có thể chỉ định data riêng cho từng geom (nhưng sẽ khó hơn).

Do đó, mỗi lệnh sau sẽ tạo ra cùng một biểu đồ giống nhau:

```{r, eval=F, warning=F, message=F}
# These commands will produce the exact same plot
ggplot(data = linelist, mapping = aes(x = age))+
  geom_histogram()

ggplot(data = linelist)+
  geom_histogram(mapping = aes(x = age))

ggplot()+
  geom_histogram(data = linelist, mapping = aes(x = age))
```

### Nhóm {#ggplotgroups .unnumbered}

Bạn có thể dễ dàng nhóm dữ liệu và "vẽ biểu đồ theo nhóm". Trên thực tế, bạn đã làm điều này rồi!

Gán cột "phân nhóm" với yếu tố thẩm mỹ biều đồ phù hợp, bên trong đối số `mapping = aes()`. Ở bên trên, chúng ta đã minh họa nó bằng cách sử dụng các giá trị liên tục khi gán điểm `size =` tới cột `age`. Tuy nhiên, cách này cũng hoạt động theo cùng một cơ chế đối với các cột rời rạc/phân loại.

Ví dụ, nếu bạn muốn các điểm được hiển thị theo giới, bạn sẽ đặt `mapping = aes(color = gender)`. Một chú giải tự động hiện lên. Phép gán này có thể được thực hiện bên trong `mapping = aes()` ở lệnh `ggplot()` đầu tiên (và được thừa kế bởi các geom), hoặc nó thể được đặt trong một `mapping = aes()` riêng biệt bên trong geom. Cả hai cách tiếp cận được trình bày dưới đây:

```{r, warning=F, message=F}
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg, color = gender))+
  geom_point(alpha = 0.5)
```

```{r, eval=F}
# This alternative code produces the same plot
ggplot(data = linelist,
       mapping = aes(x = age, y = wt_kg))+
  geom_point(
    mapping = aes(color = gender),
    alpha = 0.5)

```

Lưu ý rằng tùy thuộc vào loại geom bạn sử dụng, bạn sẽ cần sử dụng các đối số khác nhau để nhóm dữ liệu. Đối với `geom_point()`, bạn sẽ thường sử dụng nhất các tham số như `color =`, `shape =` hoặc `size =`. Trong khi đó đối với `geom_bar()`, bạn thường sử dụng nhất tham số `fill =`. Điều này chỉ phụ thuộc vào loại geom và yếu tố trang trí nào bạn muốn thể hiện sự phân nhóm.

Cách cơ bản nhất để nhóm dữ liệu là chỉ sử dụng đối số `group =` bên trong `mapping = aes()`. Tuy nhiên, cách này tự nó sẽ không làm thay đổi màu sắc, hình dạng hoặc tạo ra chú thích. Tuy nhiên dữ liệu được nhóm lại, do đó hiển thị thống kê có thể bị ảnh hưởng.

Để thay đổi thứ tự của các nhóm trong biểu đồ, xem chương [Các tips với ggplot] hoặc chương [Factors]. Ngoài ra cũng có rất nhiều ví dụ về các biểu đồ được nhóm trong các phần bên dưới đối với dữ liệu dạng liên tục và danh mục.

## Facets / Chia nhỏ biểu đồ {#ggplot_basics_facet}

Facets, hay "chia nhỏ biểu đồ", được sử dụng để chia một biểu đồ thành nhiều phần nhỏ, với mỗi phần ("facet") đại diện cho một nhóm của dữ liệu. Các biểu đồ giống nhau được tạo nhiều lần, mỗi cái sử dụng một phân nhóm của cùng một bộ dữ liệu.

Faceting là một chức năng đi kèm với **ggplot2**, vì vậy các chú giải và trục của các biểu đồ nhỏ được căn chỉnh tự động. Có các package khác được thảo luận trong chương [Các tips với ggplot] được sử dụng để kết hợp các biểu đồ hoàn toàn khác nhau (**cowplot** và **patchwork**) thành một biểu đồ.

Faceting được thực hiện bằng các hàm **ggplot2** sau đây:

1.  `facet_wrap()` Để hiện thị các biểu đồ khác nhau cho từng thứ bậc của một biến số *đơn lẻ*. Một ví dụ như thể hiện các đường cong dịch bệnh khác nhau cho từng bệnh viện trong khu vực. Các facets được sắp xếp theo thứ tự bảng chữ cái, trừ khi biến có kiểu factor với các thứ bậc đã được xác định.\

-   Bạn có thể sử dụng một số tùy chọn nhất định để xác định bố cục của các facets, vd: `nrow = 1` hoặc `ncol = 1` để kiểm soát số hàng hoặc cột mà chúng được sắp xếp.

2.  `facet_grid()` Áp dụng khi bạn muốn đưa một biến thứ hai vào sắp xếp các biểu đồ con. Ở đây mỗi ô thể hiện sự giao nhau của các giá trị giữa *hai cột*. Ví dụ, các đường cong dịch bệnh cho từng sự kết hợp của bệnh viện-nhóm tuổi với các bệnh viện dọc theo phía đỉnh (các cột) và các nhóm tuổi dọc theo hai bên (các hàng).\

-   `nrow` và `ncol` không được áp dụng, bởi vì các phân nhóm được trình bày dưới dạng lưới

Mỗi hàm này chấp nhận một cú pháp công thức để chỉ định cột được faceting. Cả hai đều chấp nhận tối đa hai cột, mỗi cột ở một bên dấu ngã `~`.

-   Đối với `facet_wrap()`, bạn sẽ thường chỉ viết một cột trước dấu ngã `~` chẳng hạn như `facet_wrap(~hospital)`. Tuy nhiên, bạn vẫn có thể viết hai cột, ví dụ `facet_wrap(outcome ~ hospital)` - mỗi kết hợp duy nhất sẽ hiển thị trong một ô riêng biệt, nhưng chúng sẽ không được sắp xếp trong một lưới. Các tiêu đề sẽ hiển thị các thuật ngữ kết hợp và chúng sẽ không phải là logic cụ thể cho các cột so với các hàng. Nếu bạn đang chỉ cung cấp một biến số để faceting, dấu chấm `.` được sử dụng như để giữ chỗ cho phía bên kia của công thức - hãy xem các ví dụ về code.

-   Đối với `facet_grid()` bạn cũng có thể chỉ định một hoặc hai cột tới công thức (grid `rows ~ columns`). Nếu bạn chỉ muốn chỉ định một cột, hãy đặt một dấu chấm `.` ở một phía của dấu ngã chẳng hạn như `facet_grid(. ~ hospital)` hoặc `facet_grid(hospital ~ .)`.

Facets có thể chứa một lượng lớn thông tin - vì vậy bạn nên đảm bảo những biến số được lựa chọn để facets không có quá nhiều thứ bậc. Dưới đây là một số ví dụ nhanh với tập dữ liệu sốt rét (xem chương [Tải sách và dữ liệu]) bao gồm số lượng trường hợp sốt rét hàng ngày của các cơ sở theo nhóm tuổi..

Sau đây chúng ta nhập số liệu vào và thực hiện một số biến đổi để đơn giản hóa:

```{r, , warning=F, message=F}
# These data are daily counts of malaria cases, by facility-day
malaria_data <- import(here("data", "malaria_facility_count_data.rds")) %>%  # import
  select(-submitted_date, -Province, -newid)                                 # remove unneeded columns

```

50 hàng đầu tiên của dữ liệu sốt rét được trình bày như bên dưới. Lưu ý rằng có một cột tên là `malaria_tot`, ngoài ra còn có các cột khác chứa thông tin về số lượng trường hợp theo nhóm tuổi (chúng sẽ được sử dụng trong ví dụ thứ hai với `facet_grid()`).

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### `facet_wrap()` {.unnumbered}

Tại thời điểm này, hãy chỉ tập trung vào các cột `malaria_tot` và `District`, tạm thời bỏ qua cột số lượng ca bệnh theo tuổi. Chúng ta sẽ vẽ các đường cong dịch bệnh với hàm `geom_col()`, giúp tạo ra một cột cho từng ngày với độ cao được xác định từ giá trị của cột `malaria_tot` (dữ liệu đã là số lượng hàng ngày, vì vậy chúng tôi sử dụng hàm `geom_col()` - xem mục ["Biểu đồ cột" bên dưới](#ggplot_basics_bars)).

Khi chúng ta thêm lệnh `facet_wrap()`, hãy thêm dấu ngã kèm với cột dùng để facet bên trong lệnh (trong trường hợp này là `District`). Bạn có thể đặt một cột khác ở bên trái của dấu ngã, - điều này sẽ tạo ra một facet cho từng sự kết hợp - nhưng chúng tôi khuyên bạn nên làm điều đó bằng hàm `facet_grid()`. Trong ví dụ này, chỉ một facet được tạo ra cho giá trị duy nhất của cột `District`.

```{r, warning=F, message=F}
# A plot with facets by district
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # plot the count data as columns
  theme_minimal()+                              # simplify the background panels
  labs(                                         # add plot labels, title, etc.
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district") +
  facet_wrap(~District)                       # the facets are created
```

### `facet_grid()` {.unnumbered}

Chúng ta có thể sử dụng cách tiếp cận `facet_grid()` đối với hai biến. Giả sử chúng ta muốn thêm `District` and age vào biểu đồ của mình. Trước hết, chúng ta cần thực hiện một số biến đổi dữ liệu trên các cột tuổi để đưa những dữ liệu này sang định dạng "dài" được ggplot ưu tiên. Tất cả các nhóm tuổi đều có các cột riêng - chúng ta cần chúng nhập vào một cột duy nhất có tên `age_group` và một cột khasc có tên `num_cases`. Xem chương [Xoay trục dữ liệu] để hiểu thêm về quy trình này.

```{r, message=F, warning=F}
malaria_age <- malaria_data %>%
  select(-malaria_tot) %>% 
  pivot_longer(
    cols = c(starts_with("malaria_rdt_")),  # choose columns to pivot longer
    names_to = "age_group",      # column names become age group
    values_to = "num_cases"      # values to a single column (num_cases)
  ) %>%
  mutate(
    age_group = str_replace(age_group, "malaria_rdt_", ""),
    age_group = forcats::fct_relevel(age_group, "5-14", after = 1))
```

50 hàng đầu tiên của dữ liệu trông giống như sau:

```{r, message=FALSE, echo=F}
DT::datatable(head(malaria_age, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Khi bạn chuyển hai biến số tới `facet_grid()`, cách đơn giản nhất là sử dụng ký hiệu công thức (vd: `x ~ y`), trong đó x là hàng và y là cột. Dưới đây là biểu đồ, sử dụng `facet_grid()` để hiển thị các biểu đồ cho mỗi kết hợp của các cột `age_group` và `District`.

```{r, message=F, warning=F}
ggplot(malaria_age, aes(x = data_date, y = num_cases)) +
  geom_col(fill = "darkred", width = 1) +
  theme_minimal()+
  labs(
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district and age group"
  ) +
  facet_grid(District ~ age_group)
```

### Giới hạn trục tự do hoặc cố định {.unnumbered}

Theo mặc định, các tỷ lệ trục được hiển thị khi faceting là giống nhau (cố định) trên tất cả các facets. Điều này rất hữu ích cho việc so sánh chéo, nhưng không phải lúc nào cũng thích hợp.

Khi sử dụng `facet_wrap()` hoặc `facet_grid()`, chúng ta có thể thêm `scales = "free_y"` để "free" hoặc giải phóng trục y của các biểu đồ nhỏ chia tỷ lệ thích hợp với tập con dữ liệu của chúng. Điều này đặc biệt hữu ích nếu số lượng thực tế là nhỏ đối với một trong các danh mục phụ và khó có thể nhìn thấy xu hướng. Thay vì "free_y", chúng ta cũng có thể viết "free_x" để làm tương tự đối với trục x (vd: biến ngày thág) hoặc "free" đối với cả hai trục. Lưu ý rằng trong `facet_grid`, tỷ lệ y sẽ giống nhau đối với các facets trong cùng một hàng và tỷ lệ x sẽ giống nhau đối với các facets trong cùng một cột.

Khi chỉ sử dụng `facet_grid`, chúng ta có thể thêm `space = "free_y"` hoặc `space = "free_x"` để chiều cao hoặc chiều rộng thực tế của facet được tính theo giá trị của biều đồ bên trong. Điều này chỉ hoạt động nếu `scales = "free"` (y hoặc x) đã được áp dụng.

```{r, message=FALSE, warning=FALSE}

# Free y-axis
ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1, fill = "darkred") +       # plot the count data as columns
  theme_minimal()+                              # simplify the background panels
  labs(                                         # add plot labels, title, etc.
    x = "Date of report",
    y = "Malaria cases",
    title = "Malaria cases by district - 'free' x and y axes") +
  facet_wrap(~District, scales = "free")        # the facets are created
```

<!-- ```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')} -->

<!-- # A) Facet hospitalsation date by hospital, free y axis -->

<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->

<!--        aes(x = date_hospitalisation ))+ -->

<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->

<!--   labs(title = "A) Histogram with free y axis scales")+ -->

<!--   facet_grid(hospital~., # Facet with hospital as the row  -->

<!--              scales = "free_y") # Free the y scale of each facet -->

<!-- # B) Facet hospitalisation date by hospital, free y axis and vertical spacing -->

<!-- ggplot(data = linelist %>% filter(hospital != "Missing"), # filter removes unknown hospital -->

<!--        aes(x = date_hospitalisation ))+ -->

<!--   geom_histogram(binwidth=7) + # Bindwidth = 7 days -->

<!--   labs(title = "B) Histogram with free y axis scales and spacing")+ -->

<!--   facet_grid(hospital~., # Facet with hospital as the row  -->

<!--              scales = "free_y", # Free the y scale of each facet -->

<!--              space = "free_y") # Free the vertical spacing of each facet to optimise space -->

<!-- ``` -->

### Trật tự thức bậc của Factor trong facets {.unnumbered}

Xem [bài viết](https://juliasilge.com/blog/reorder-within/) này về cách làm thế nào để sắp xếp lại thức bậc của biến factor *bên trong* facets.

## Lưu trữ biểu đồ

### Lưu biểu đồ {.unnumbered}

Mặc định khi bạn chạy lệnh `ggplot()`, biểu đồ sẽ được in ở cửa số Plots của RStudio. Tuy nhiên, bạn cũng có thể lưu biểu đồ dưới dạng một đối tượng bằng cách sử dụng toán tử gán `<-` và đặt tên cho nó. Biểu đồ sẽ không được in ra trừ khi bạn gọi tên của đối tượng. Bạn cũng có thể in nó bằng cách đưa tên biểu đồ vào hàm `print()`, nhưng điều này chỉ cần thiết trong một số trường hợp nhất định chẳng hạn như khi biểu đồ được tạo bên trong một *vòng lặp for* để in nhiều biểu đồ cùng một lúc (xem chương [Lặp, vòng lặp, và danh sách]).

```{r, warning=F, message=F}
# define plot
age_by_wt <- ggplot(data = linelist, mapping = aes(x = age_years, y = wt_kg, color = age_years))+
  geom_point(alpha = 0.1)

# print
age_by_wt    
```

### Chỉnh sửa biều đồ đã lưu {.unnumbered}

Một điểm hay của **ggplot2** là bạn có thể gán tên cho một biểu đồ (như bên trên), và sau đó thêm các lớp mới bắt đầu bằng tên của nó. Bạn không cần phải lặp lại tất cả các lệnh đã tạo ra biểu đồ ban đầu!

Ví dụ: để sửa đổi biểu đồ `age_by_wt` đã được định nghĩa ở bên trên, thêm một trục dọc tại tuổi bằng 50, chúng ta chỉ cần thêm dấu `+` và bắt đầu thêm các lớp bổ sung vào biểu đồ.

```{r, warning=F, message=F}
age_by_wt+
  geom_vline(xintercept = 50)
```

### Xuất biểu đồ {.unnumbered}

Việc xuất biểu đồ được thực hiện dễ dàng với hàm `ggsave()` của package **ggplot2**. Nó có thể hoạt động theo hai cách:

-   Chỉ định tên của đối tượng biểu đồ, sau đó là đường dẫn tệp và tên có phần mở rộng

    -   Ví dụ: `ggsave(my_plot, here("plots", "my_plot.png"))`\

-   Chạy lệnh chỉ với một đường dẫn tệp, để lưu biểu đồ gần nhất được in ra

    -   Ví dụ: `ggsave(here("plots", "my_plot.png"))`

Bạn có thể xuất dưới dạng tệp png, pdf, jpeg, tiff, bmp, svg, hoặc một số định dạng khác, bằng cách chỉ định phần mở rộng tệp trong đường dẫn tệp.

Bạn cũng có thể chỉ định các đối số `width =`, `height =`, và `units =` ("in", "cm", hoặc "mm"). Bạn cũng có thể chỉ định `dpi =` để điều chỉnh độ phân giâỉ của biểu đồ (vd: dpi = 300). Xem hướng dẫn chi tiết về hàm bằng cách gõ `?ggsave` hoặc đọc [tài liệu online này](https://ggplot2.tidyverse.org/reference/ggsave.html).

Hãy nhớ rằng bạn có thể sử dụng cú pháp `here()` để cung cấp đường dẫn tệp mong muốn. Xem chương [Nhập xuất dữ liệu] để biết thêm thông tin.

## Nhãn

Chắc chắn là bạn sẽ muốn thêm hoặc điều chỉnh nhãn của biểu đồ. Việc này được thực hiện dễ dàng nhất với hàm `labs()` bằng cách thêm dấu `+` như cách bạn thêm các geoms.

Bên trong hàm `labs()`, bạn có thể cung cấp các chuỗi ký tự cho các đối số sau:

-   `x =` và `y =` Tiêu đề trục x và trục y (nhãn)\
-   `title =` Tiêu đề chính của biểu đồ\
-   `subtitle =` Tiêu đề phụ của biểu đồ, nhỏ hơn và đặt bên dưới tiêu đề chính\
-   `caption =` Caption của biểu đồ, mặc định ở góc phải dưới

Dưới đây là biểu đồ chúng ta đã tạo lúc trước, nhưng có thêm các nhãn:

```{r, warning=F, message=F}
age_by_wt <- ggplot(
  data = linelist,   # set data
  mapping = aes(     # map aesthetics to column values
         x = age,           # map x-axis to age            
         y = wt_kg,         # map y-axis to weight
         color = age))+     # map color to age
  geom_point()+           # display data as points
  labs(
    title = "Age and weight distribution",
    subtitle = "Fictional Ebola outbreak, 2014",
    x = "Age in years",
    y = "Weight in kilos",
    color = "Age",
    caption = stringr::str_glue("Data as of {max(linelist$date_hospitalisation, na.rm=T)}"))

age_by_wt
```

Hãy để ý chúng ta đã sử dụng hàm `str_glue()` từ package **stringr** để tạo một code R động bên trong văn bản khi gán giá trị cho caption. Caption sẽ hiển thị "Dữ liệu kể từ: " phản ánh ngày nhập viện gần nhất trong bộ dữ liệu linelist. Đọc thêm ở chương [Ký tự và chuỗi].

Một chú ý khi bạn muốn thêm tiêu đề cho *chú giải*: Đó là không có đối số "legend title", vì bạn có thể có nhiều thang đo trong chú giải của mình. Bên trong lệnh `labs()`, bạn có thể viết đối số cho yếu tố thẩm mỹ được sử dụng để tạo chú giải, và cung cấp tiêu đề cho nó theo cách này. Trong ví dụ bên trên, chúng ta đã gán `color = age` để tạo chú giải. Do đó, chúng ta cũng cung cấp đối số `color =` ttrong hàm `labs()` và gán tiêu đề chú giải mong muốn ("Age" với chữ A được viết hoa). Nếu bạn tạo chú thích bằng đối số `aes(fill = COLUMN)`, thì trong lệnh `labs()` bạn nên viết `fill =` để điều chỉnh tiêu đề cho chú thích. Xem thêm mục thang đo màu sắc trong chương [Các tips với ggplot] để biết thêm chi tiết về cách chỉnh sửa chú giải và cách tiếp cận thay thế bằng cách sử dụng các hàm `scales_()`.

## Chủ đề {#ggplot_basics_themes}

Một trong những phần hay nhất của **ggplot2** là mức độ kiểm soát của bạn đối với biểu đồ - bạn có thể định nghĩa bất kỳ điều gì! Như đã đề cập ở trên, thiết kế của biểu đồ *không* liên quan tới dạng biểu đồ mà được điều chỉnh bên trong hàm `theme()`. Ví dụ, màu nền của biểu đồ, sự xuất hiện/biến mất của đường lưới, cũng như phông chữ/cỡ chữ/màu sắc/căn lề của văn bản (tiêu đề chính, tiêu đề phụ, captions, chữ trên các trục...). Những điều chỉnh này có thể được thực hiện theo hai cách:

-   Thêm một [*chủ đề hoàn chỉnh*](https://ggplot2.tidyverse.org/reference/ggtheme.html) bằng hàm `theme_()` để điều chỉnh toàn bộ các thành phần biểu đồ - các chủ đề hoàn chỉnh này bao gồm `theme_classic()`, `theme_minimal()`, `theme_dark()`, `theme_light()` `theme_grey()`, `theme_bw()`
-   Điều chỉnh từng khía cạnh đơn lẻ của biểu đồ với hàm `theme()`

### Chủ đề hoàn chỉnh {.unnumbered}

Vì chúng khá đơn giản, chúng tôi sẽ trình bày các hàm chủ đề hoàn chỉnh bên dưới và sẽ không mô tả thêm ở đây. Lưu ý rằng bất kỳ điều chỉnh nhỏ nào bằng hàm `theme()` nên được thực hiện *sau khi* áp dụng một chủ đề hoàn chỉnh.

Viết chúng với dấu ngoặc đơn trống.

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme classic")+
  theme_classic()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme bw")+
  theme_bw()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme minimal")+
  theme_minimal()

ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+  
  geom_point(color = "darkgreen", size = 0.5, alpha = 0.2)+
  labs(title = "Theme gray")+
  theme_gray()
  


```

### Tùy chỉnh chủ đề {.unnumbered}

Hàm `theme()` có thể nhận một số lượng lớn các đối số, mỗi đối số sẽ chỉnh sửa một khía cạnh rất cụ thể của biểu đồ. Chúng tôi sẽ không trình bày tất cả các đối số, nhưng sẽ tập trung mô tả công thức chung cho chúng và chỉ cho bạn cách tìm tên đối số mà bạn cần. Cú pháp cơ bản là:

1.  Bên trong hàm `theme()`, hãy viết tên đối số cho phần tử biểu đồ mà bạn muốn chỉnh sửa, chẳng hạn như `plot.title =`\
2.  Cung cấp một hàm `element_()` tới đối số\

-   Thường sử dụng nhất là `element_text()`, một số khác bao gồm `element_rect()` chọn màu nền cho canvas, hoặc `element_blank()` để xóa các phần tử biểu đồ\

4.  Bên trong hàm `element_()`, xác định giá trị đối số cần gán để điều chỉnh theo ý bạn mong muốn

Vì trình bày bên trên vẫn khá trừu tượng, nên đây là một số ví dụ.

Lưu ý là biểu đồ dưới đây trông không thật sự đẹp, nhưng nó giúp bạn thấy nhiều cách khác nhau để bạn có thể điều chỉnh biểu đồ của mình.

-   Chúng ta bắt đầu với biểu đồ có tên `age_by_wt` đã được tạo ra bên trên và thêm hàm `theme_classic()`\
-   Để điều chỉnh đẹp hơn, chúng ta thêm hàm `theme()` và bao gồm một đối số cho từng phần tử biểu đồ muốn điều chỉnh

Sẽ rất tốt nếu bạn sắp xếp các đối số theo một trật tự logic. Hãy xem ví dụ sau:

-   `legend.position =` là đặc biệt nhất vì nó chỉ chấp nhận các giá trị đơn giản như "bottom", "top", "left", và "right". các đối số liên quan đến văn bản yêu cầu bạn đặt các chi tiết *bên trong* hàm `element_text()`.\
-   Cỡ chư tiêu đề với `element_text(size = 30)`\
-   Căn lề caption với `element_text(hjust = 0)` (từ trái qua phải)\
-   Tiêu đề phụ được in nghiêng với `element_text(face = "italic")`

```{r, , warning=F, message=F}
age_by_wt + 
  theme_classic()+                                 # pre-defined theme adjustments
  theme(
    legend.position = "bottom",                    # move legend to bottom
    
    plot.title = element_text(size = 30),          # size of title to 30
    plot.caption = element_text(hjust = 0),        # left-align caption
    plot.subtitle = element_text(face = "italic"), # italicize subtitle
    
    axis.text.x = element_text(color = "red", size = 15, angle = 90), # adjusts only x-axis text
    axis.text.y = element_text(size = 15),         # adjusts only y-axis text
    
    axis.title = element_text(size = 20)           # adjusts both axes titles
    )     
```

Sau đây là một số đối số phổ biến của hàm `theme()`. Bạn sẽ nhận ra một số xu hướng chung, chẳng hạn như thêm `.x` hoặc `.y` để chỉ áp dụng thay đổi cho một trục.

+-------------------------------------+------------------------------------------------------------------------------+
| `Đối số theme()`                    | Những gì nó điều chỉnh                                                       |
+=====================================+==============================================================================+
| `plot.title = element_text()`       | Tiêu đề chính                                                                |
+-------------------------------------+------------------------------------------------------------------------------+
| `plot.subtitle = element_text()`    | Tiêu đề phụ                                                                  |
+-------------------------------------+------------------------------------------------------------------------------+
| `plot.caption = element_text()`     | Liên quan tới caption (kiểu font, màu sắc, kích cỡ, góc độ, vjust, hjust...) |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.title = element_text()`       | Tiêu đề trục (cả trục x và y) (kích cỡ, góc độ, màu sắc...)                  |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.title.x = element_text()`     | Chỉ tiêu đề trục x (sử dụng `.y` để chỉ áp dụng với trục y)                  |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.text = element_text()`        | Văn bản trên trục (cả trục x và y)                                           |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.text.x = element_text()`      | Chỉ văn bản trục x (sử dụng `.y` để chỉ áp dụng với trục y)                  |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.ticks = element_blank()`      | Loại bỏ ticks của trục                                                       |
+-------------------------------------+------------------------------------------------------------------------------+
| `axis.line = element_line()`        | Đường trục (màu sắc, kích thước, kiểu đường: nét đứt, nét liền mảnh, v.v.)   |
+-------------------------------------+------------------------------------------------------------------------------+
| `strip.text = element_text()`       | Văn bản trong Facet strip (màu sắc, kích thước, góc độ...)                   |
+-------------------------------------+------------------------------------------------------------------------------+
| `strip.background = element_rect()` | facet strip (tô màu, màu sắc, kích thước...)                                 |
+-------------------------------------+------------------------------------------------------------------------------+

Nhưng còn rất nhiều các đối số khác! Làm thế nào tôi có thể nhớ tất cả chúng? Đừng lo lắng - bạn không thể nhớ hết chúng được đâu. May mắn thay, có một vài công cụ có thể thể giúp bạn:

Tài liệu hướng dẫn của **tidyverse** phần [tùy chỉnh chủ đề](https://ggplot2.tidyverse.org/reference/theme.html), có chứa một danh sách đầy đủ các đối số.

[***MẸO:*** Chạy lệnh `theme_get()` từ **ggplot2** để in tất cả hơn 90 đối số của hàm `theme()` ra console.]{style="color: darkgreen;"}

[***MẸO:*** Nếu bạn muốn xóa một phần tử của biểu đồ, bạn cũng có thể làm điều đó bằng hàm `theme()`. Chỉ cần đặt `element_blank()` tới đối số để nó biến mất hoàn toàn. Đối với chú thích, thiết lập `legend.position = "none".`]{style="color: darkgreen;"}

## Màu sắc

Xem mục [thang đo cho màu sắc trong chương Các tips với ggplot](#ggplot_tips_colors).

## Piping tới **ggplot2**

Khi sử dụng pipes để làm sạch và chuyển đổi dữ liệu của bạn, bạn có thể dễ dàng chuyển dữ liệu đã chuyển đổi tới `ggplot()`.

Các pipes sẽ chuyển dữ liệu từ hàm-tới-hàm và sẽ chuyển tới dấu `+` một khi hàm `ggplot()` được gọi. Lưu ý rằng trong trường hợp này, không cần chỉ định đối số `data =`, bởi vì nó đã được tự động xác định khi bạn piping dữ liệu.

Dưới đây là cách mà nó hoạt động:

```{r, warning=F, message=F}
linelist %>%                                                     # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )
```

## Vẽ biểu đồ dữ liệu liên tục

Xuyên xuốt chương này, bạn đã gặp rất nhiều ví dụ về cách vẽ biểu đồ dữ liệu liên tục. Ở đây chúng tôi tổng hợp ngắn gọn chúng và trình bày một vài biến thể.\
Các ví dụ bao gồm:

-   Vẽ biểu đồ cho một biến liên tục:

    -   **Histogram**, một biểu đồ thường dùng để trình bày sự phân bố của một biến số liên tục.
    -   **Box plot** (còn được gọi là box và whisker), để hiện thị khoảng phân vị 25%, 50%, và 75%, phần cuối của phân phối, và các giá trị ngoại lai (outliers) ([những hạn chế quan trọng](https://www.data-to-viz.com/caveat/boxplot.html)).\
    -   **Jitter plot**, để hiển thị tất cả các giá trị dưới dạng các điểm 'lộn xộn' để chúng có thể (hầu hết) được nhìn thấy, ngay cả khi hai điểm có cùng giá trị.\
    -   **Violin plot**, hiển thị sự phân bố của một biến liên tục dựa trên chiều rộng đối xứng của đàn 'violin'.
    -   **Sina plot**, là sự kết hợp của jitter và violin plots, trong đó các điểm riêng lẻ được hiển thị nhưng ở hình dạng đối xứng của sự phân bố (thông qua package **ggforce**).\

-   **Biểu đồ phân tán (Scatter plot)** cho hai biến liên tục.\

-   **Biểu đồ nhiệt** dành cho ba biến liên tục (xem chương [Biểu đồ nhiệt] )

### Histograms {.unnumbered}

Histograms có thể trông giống như biểu đồ cột, nhưng sự khác biệt là nó đo lường sự phân phối của một biến *liên tục*. Không có khoảng cách giữa các “thanh” và chỉ có một biến số được cung cấp cho hàm `geom_histogram()`.

Dưới đây là code để tạo một **histograms**, mà sẽ nhóm dữ liệu liên tục thành các dải và hiển thị trong các thanh liền kề có độ cao khác nhau. Việc này được thực hiện bằng hàm `geom_histogram()`. Xem [mục "Biểu đồ cột" ](#ggplot_basics_bars) trong chương này để hiểu sự khác biệt giữa các hàm `geom_histogram()`, `geom_bar()`, và `geom_col()`.

Chúng ta sẽ hiển thị sự phân bố độ tuổi của các trường hợp. Bên trong đối số `mapping = aes()`, chỉ định cột bạn muốn xem phân phối. Bạn có thể gán cột này cho trục x hoặc trục y.

Các hàng sẽ được chỉ định tới các "bins" dựa trên số tuổi của chúng, và các bins này sẽ được đồ thị hóa bằng các cột. Nếu bạn chỉ định số lượng bins bnằg đối số `bins =`, các điểm ngắt được cách đều giữa các giá trị tối thiểu và tối đa của biểu đồ. Nếu `bins =` không được chỉ định, một số lượng bins thích hợp sẽ được chọn và một thông báo sẽ hiện ra ngay sau biểu đồ:

    ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

Nếu bạn không muốn chỉ định số lượng bins tới `bins =`, bạn có thể chỉ định `binwidth =` theo đơn vị của trục. Chúng tôi đưa ra một vài ví dụ trình bày sự khác biệt giữa bins và bin widths:

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Regular histogram
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram()+
  labs(title = "A) Default histogram (30 bins)")

# B) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 50)+
  labs(title = "B) Set to 50 bins")

# C) Fewer bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(bins = 5)+
  labs(title = "C) Set to 5 bins")


# D) More bins
ggplot(data = linelist, aes(x = age))+  # provide x variable
  geom_histogram(binwidth = 1)+
  labs(title = "D) binwidth of 1")

```

Để vẽ đường mật độ phân bố, bạn có thể sử dụng hàm `geom_density()`:

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional density")

# Stacked frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_density(size = 2, alpha = 0.2, position = "stack")+
  labs(title = "'Stacked' proportional densities")
```

Để vẽ một biểu đồ histogram "chồng" (của một biến liên tục trong dữ liệu),bạn có thể làm như sau:

1)  Dùng hàm `geom_histogram()` với đối số `fill =` bên trong `aes()` và gán tới cột được dùng để nhóm, hoặc\
2)  Dùng hàm `geom_freqpoly()`, có thể sẽ dễ đọc hơn (bạn vẫn có thể đặt `binwidth =`)\
3)  Để xem tỷ lệ của tất cả các giá trị, hãy thiết lập `y = after_stat(density)` (sử dụng chính xác cú pháp này - không thay đổi đối với dữ liệu của bạn). Lưu ý: các tỷ lệ này sẽ hiển thị theo *từng nhóm*.

Các kết quả được trình bày bên dưới (\*lưu ý cách sử dụng của `color =` và. `fill =`):

```{r, fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# "Stacked" histogram
ggplot(data = linelist, mapping = aes(x = age, fill = gender)) +
  geom_histogram(binwidth = 2)+
  labs(title = "'Stacked' histogram")

# Frequency 
ggplot(data = linelist, mapping = aes(x = age, color = gender)) +
  geom_freqpoly(binwidth = 2, size = 2)+
  labs(title = "Freqpoly")

# Frequency with proportion axis
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), color = gender)) +
  geom_freqpoly(binwidth = 5, size = 2)+
  labs(title = "Proportional freqpoly")

# Frequency with proportion axis, smoothed
ggplot(data = linelist, mapping = aes(x = age, y = after_stat(density), fill = gender)) +
  geom_density(size = 2, alpha = 0.2)+
  labs(title = "Proportional, smoothed with geom_density()")
```

Nếu bạn muốn nghịch vui một chút, hãy thử hàm `geom_density_ridges` từ package **ggridges** ([vignette tại đây](https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html).

Đọc thêm về histograms tại tài liệu về **tidyverse** [chương về geom_histogram()](https://ggplot2.tidyverse.org/reference/geom_histogram.html).

### Box plots {.unnumbered}

Box plots rất phổ biến, nhưng có những hạn chế quan trọng. Chúng có thể che khuất phân phối thực tế - vd: phân phối hai mode (bimodal distribution). Xem trang [R graph gallery](https://www.r-graph-gallery.com/boxplot.html) và trang [data-to-viz article](https://www.data-to-viz.com/caveat/boxplot.html) để biết thêm chi tiết. Tuy nhiên, chúng hiển thị tốt các khoảng tứ phân vị và các giá trị ngoại lai - vì vậy chúng có thể được phủ lên trên các loại biểu đồ khác thể hiện sự phân bố chi tiết hơn.

Dưới đây, chúng ta ôn lại về các thành phần khác nhau của boxplot:

```{r, out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "boxplot.png"))
```

Khi sử dụng `geom_boxplot()` để tạo biểu đồ box plot, bạn thường chỉ map duy nhất một trục (x hoặc y) bên trong `aes()`. Trục được chỉ định sẽ xác định xem các ô nằm ngang hay dọc.

Trong hầu hết các geoms, bạn tạo ra một biểu đồ theo từng nhóm bằng cách mapping các thuộc tính thẩm mỹ như `color =` hoặc `fill =` tới cột bên trong `aes()`. Tuy nhiên, biểu đồ box plots làm điều này bằng cách gán cột phân nhóm cho trục chưa được gán (x hoặc y). Dưới đây là code cho một boxplot của *tất cả* các giá trị tuổi trong bộ dữ liệu, và code còn lại là để hiển thị từng box plot cho từng nhóm giới tính (không-missing) trong dữ liệu. Lưu ý là giá trị missing `NA` sẽ xuất hiện dưới dạng một box plot riêng rẽ trừ khi nó được loại bỏ. Ở ví dụ này chúng tôi cũng thiết lập `fill` tới cột `outcome`, do đó mà mỗi biểu đồ sẽ có màu khác nhau- nhưng điều này không quan trọng.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# A) Overall boxplot
ggplot(data = linelist)+  
  geom_boxplot(mapping = aes(y = age))+   # only y axis mapped (not x)
  labs(title = "A) Overall boxplot")

# B) Box plot by group
ggplot(data = linelist, mapping = aes(y = age, x = gender, fill = gender)) + 
  geom_boxplot()+                     
  theme(legend.position = "none")+   # remove legend (redundant)
  labs(title = "B) Boxplot by gender")      
```

Code để thêm một box plot vào các cạnh của biểu đồ phân tán (còn gọi là "marginal" plots), vui lòng xem chương [Các tips với ggplot].

### Violin, jitter, và sina plots {.unnumbered}

Dưới đây là code để tạo **violin plots** (`geom_violin`) và **jitter plots** (`geom_jitter`) để hiển thị phân bố của biến. Bạn có thể chỉ định các màu sắc được xác định từ dữ liệu bằng cách chèn các tùy chọn này vào bên trong `aes()`.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}


# A) Jitter plot by group
ggplot(data = linelist %>% drop_na(outcome),      # remove missing values
       mapping = aes(y = age,                     # Continuous variable
           x = outcome,                           # Grouping variable
           color = outcome))+                     # Color variable
  geom_jitter()+                                  # Create the violin plot
  labs(title = "A) jitter plot by gender")     



# B) Violin plot by group
ggplot(data = linelist %>% drop_na(outcome),       # remove missing values
       mapping = aes(y = age,                      # Continuous variable
           x = outcome,                            # Grouping variable
           fill = outcome))+                       # fill variable (color)
  geom_violin()+                                   # create the violin plot
  labs(title = "B) violin plot by gender")    
```

Bạn cũng có thể kết hợp hai biểu đồ này làm một nhờ hàm `geom_sina()` từ package **ggforce**. Biểu đồ sina vẽ các điểm phân bố trên hình dạng của biểu đồ violin. Khi được phủ lên biểu đồ violin (bằng cách điều chỉnh độ trong suốt), nó giúp việc diễn giải một cách trực quan hơn.

```{r, warning=F, message=F}

# A) Sina plot by group
ggplot(
  data = linelist %>% drop_na(outcome), 
  aes(y = age,           # numeric variable
      x = outcome)) +    # group variable
  geom_violin(
    aes(fill = outcome), # fill (color of violin background)
    color = "white",     # white outline
    alpha = 0.2)+        # transparency
  geom_sina(
    size=1,                # Change the size of the jitter
    aes(color = outcome))+ # color (color of dots)
  scale_fill_manual(       # Define fill for violin background by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  scale_color_manual(      # Define colours for points by death/recover
    values = c("Death" = "#bf5300", 
              "Recover" = "#11118c")) + 
  theme_minimal() +                                # Remove the gray background
  theme(legend.position = "none") +                # Remove unnecessary legend
  labs(title = "B) violin and sina plot by gender, with extra formatting")      


```

### Hai biến liên tục {.unnumbered}

Theo cú pháp tương tự, `geom_point()` sẽ cho phép bạn vẽ biểu đồ hai biến liên tục dưới dạng một biểu đồ **phân tán**. Điều này hữu ích để hiển thị các giá trị thực tế hơn là phân phối của chúng. Một biểu đồ phân tán cơ bản của tuổi so với cân nặng được trình bày ở hình (A). Ở hình (B), chúng ta lại sử dụng `facet_grid()` để hiển thị mối quan hệ giữa hai biến liên tục trong bộ dữ liệu linelist.

```{r fig.show='hold', message=FALSE, warning=FALSE, out.width=c('50%', '50%')}
# Basic scatter plot of weight and age
ggplot(data = linelist, 
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "A) Scatter plot of weight and age")

# Scatter plot of weight and age by gender and Ebola outcome
ggplot(data = linelist %>% drop_na(gender, outcome), # filter retains non-missing gender/outcome
       mapping = aes(y = wt_kg, x = age))+
  geom_point() +
  labs(title = "B) Scatter plot of weight and age faceted by gender and outcome")+
  facet_grid(gender ~ outcome) 

```

### Ba biến liên tục {.unnumbered}

Bạn có thể hiển thị ba biến liên tục bằng cách sử dụng đối số `fill =` để tạo một *biểu đồ nhiệt*. Màu của mỗi “ô” sẽ phản ánh giá trị của biên liên tục thứ ba trong bộ dữ liệu. Xem chương [Các tips với ggplot] để biết thêm chi tiết và một số ví dụ.

Có nhiều cách để tạo biểu đồ 3D trong R, nhưng đối với dịch tễ học ứng dụng, chúng thường khó giải thích và do đó ít hữu ích hơn trong việc ra quyết định.

## Vẽ biểu đồ cho biến danh mục

Dữ liệu dạng danh mục có thể là các giá trị ký tự, có thể là logic (TRUE/FALSE), hoặc factors (Xem chương [Factors]).

### Chuẩn bị {.unnumbered}

#### Cấu trúc dữ liệu {.unnumbered}

Điều đầu tiên cần hiểu về dữ liệu dạng danh mục đó là kiểm tra xem nó đang tồn tại ở dạng dữ liệu thô như các trường hợp trong bộ dữ liệu linelist, hay dưới dạng dữ liệu tóm tắt hoặc tổng hợp chứa các số lượng hoặc tỷ lệ. Trạng thái dữ liệu của bạn sẽ quyết định hàm vẽ biểu đồ nào được sử dụng:

-   Nếu dữ liệu của bạn là các quan sát thô với một hàng cho mỗi quan sát, bạn có thể sử dụng hàm `geom_bar()`\
-   Nếu dữ liệu của bạn đã được tổng hợp thành số lượng hoặc tỷ lệ, bạn có thể sử dụng hàm `geom_col()`

#### Kiểu của cột và thứ tự các giá trị {.unnumbered}

Sau đó, kiểm tra kiểu dữ liệu của cột mà bạn muốn vẽ. Chúng ta xem xét cột `hospital`, đầu tiên bằng hàm `class()` từ **base** R, sau đó là với hàm `tabyl()` từ package **janitor**.

```{r}
# View class of hospital column - we can see it is a character
class(linelist$hospital)

# Look at values and proportions within hospital column
linelist %>% 
  tabyl(hospital)
```

Chúng ta có thể thấy các giá trị bên trong là các ký tự, vì chúng là tên bệnh viện và theo mặc định, chúng được sắp xếp theo thứ tự bảng chữ cái. Ngoài ra còn có các giá trị 'other' và 'missing', thứ mà chúng ta muốn nó sẽ là danh mục cuối cùng khi trình bày. Vì thế chúng ta cần chuyển cột này sang dạng factor và sắp xếp lại chúng. Xem chương [Factors] để biết chi tiết cách thực hiện.

```{r}
# Convert to factor and define level order so "Other" and "Missing" are last
linelist <- linelist %>% 
  mutate(
    hospital = fct_relevel(hospital, 
      "St. Mark's Maternity Hospital (SMMH)",
      "Port Hospital", 
      "Central Hospital",
      "Military Hospital",
      "Other",
      "Missing"))

```

```{r}
levels(linelist$hospital)
```

### `geom_bar()` {#ggplot_basics_bars .unnumbered}

Sử dụng `geom_bar()` nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) phản ánh *số lượng hàng có liên quan trong dữ liệu*. Các thanh này sẽ có khoảng trống giữa chúng, trừ khi `width =` được điều chỉnh.

-   Chỉ cung cấp phép gán cột trên một trục (thường là trục x). Nếu bạn cung cấp cả trục x và y, bạn sẽ nhận được thông báo `Error: stat_count() can only have an x or y aesthetic.`\
-   Bạn có thể tạo biểu đồ cột chồng bằng cách thêm `fill =` cột được chỉ định bên trong `mapping = aes()`\
-   Trục đối diện sẽ có tiêu đề là "số lượng" theo mặc định, bởi vì nó đại diện cho số hàng

Dưới đây, chúng ta đã chỉ định cột outcome tới trục y, nhưng nó cũng có thể dễ dàng thực hiện trên trục x. Nếu bạn có các giá trị ký tự dài hơn, đôi khi sẽ dễ nhìn hơn nếu bạn lật các thanh sang một bên và đặt chú giải ở dưới cùng. Điều này có thể ảnh hưởng đến cách sắp xếp các thứ bậc trong biến factor - trong trường hợp này, chúng tôi đảo ngược chúng với hàm `fct_rev()` để đặt giá trị missing và other ở dưới cùng.

```{r, out.width=c('50%', '50%'), fig.show='hold'}
# A) Outcomes in all cases
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital)), width = 0.7) +
  theme_minimal()+
  labs(title = "A) Number of cases by hospital",
       y = "Hospital")


# B) Outcomes in all cases by hosptial
ggplot(linelist %>% drop_na(outcome)) + 
  geom_bar(aes(y = fct_rev(hospital), fill = outcome), width = 0.7) +
  theme_minimal()+
  theme(legend.position = "bottom") +
  labs(title = "B) Number of recovered and dead Ebola cases, by hospital",
       y = "Hospital")

```

### `geom_col()` {.unnumbered}

Sử dụng `geom_col()` nếu bạn muốn chiều cao cột (hoặc chiều cao của các cột trong biểu đồ cột chồng) các *giá trị* được tính toán trước tồn tại trong dữ liệu. Thông thường, đây là các số lượng hoặc tỷ lệ đã được tóm tắt hoặc "tổng hợp".

Cung cấp phép gán cột cho *cả hai* trục tới hàm `geom_col()`. Thông thường, cột trục x của bạn là biến rời rạc và cột trục y của bạn là biến dạng số.

Giả sử chúng ta có một bộ dữ liệu có tên `outcomes`:

```{r, echo = F}
outcomes <- linelist %>% 
  drop_na() %>% 
  group_by(outcome) %>% 
  count %>% 
  ungroup() %>% # Ungroup so proportion is out of total
  mutate(proportion = n/sum(n)*100) # Caculate percentage
  
outcomes #View full table
```

Dưới đây là code sử dụng hàm `geom_col` để tạo biểu đồ cột đơn giản trình bày phân bố các outcome của bệnh nhân Ebola. Với `geom_col`, cả x và y đều cần được chỉ định. Ở đây x là biến phân loại dọc theo trục x và y là cột chứa tỷ lệ `proportion`.

```{r, fig.height = 3, fig.width=4.5}
# Outcomes in all cases
ggplot(outcomes) + 
  geom_col(aes(x=outcome, y = proportion)) +
  labs(subtitle = "Number of recovered and dead Ebola cases")

```

Để trình bày kết quả tách theo từng bệnh viện, chúng ta cần bảng phải chứa nhiều thông tin hơn, và ở định dạng "dài". Chúng ta tạo bảng này với các tần số là sự kết hợp của các danh mục của biến `outcome` và `hospital` (xem chương [Nhóm dữ liệu] để biết thêm các mẹo).

```{r, fig.height = 4, fig.width=6}
outcomes2 <- linelist %>% 
  drop_na(outcome) %>% 
  count(hospital, outcome) %>%  # get counts by hospital and outcome
  group_by(hospital) %>%        # Group so proportions are out of hospital total
  mutate(proportion = n/sum(n)*100) # calculate proportions of hospital total

head(outcomes2) # Preview data
```

Sau đó, chúng ta vẽ biểu đồ ggplot với một số định dạng được bổ sung:

-   **Lật trục**: Hoán đổi vị trị trục với `coord_flip()` để chúng ta có thể đọc tên các bệnh viện.
-   **Columns side-by-side**: Added a `position = "dodge"` argument so that the bars for death and recover are presented side by side rather than stacked. Lưu ý mặc định là các cột xếp chồng lên nhau.
-   **Độ rộng cột**: Chỉ định 'chiều rộng', do đó các cột mỏng bằng một nửa chiều rộng đầy đủ có thể.
-   **Thứ tự cột**: Đảo lại các danh mục trên trục y để 'Other' và 'Missing' ở dưới cùng, với hàm `scale_x_discrete(limits=rev)`. Lưu ý rằng chúng ta sử dụng cách này thay vì `scale_y_discrete` bởi vì hospital được nhắc tới trong đối số `x` của `aes()`, ngay cả khi một cách trực quan nó nằm trên trục y. Chúng ta làm vậy bởi vì ggplot dường như trình bày các danh mục từ sau lên trước trừ khi chúng ta yêu cầu nó không làm vậy.\
-   **Các chi tiết khác**: Nhãn/tiêu đề và màu sắc được thêm tương ứng vào bên trong lệnh `labs` và `scale_fill_color`.

```{r, fig.height = 4, fig.width=8}

# Outcomes in all cases by hospital
ggplot(outcomes2) +  
  geom_col(
    mapping = aes(
      x = proportion,                 # show pre-calculated proportion values
      y = fct_rev(hospital),          # reverse level order so missing/other at bottom
      fill = outcome),                # stacked by outcome
    width = 0.5)+                    # thinner bars (out of 1)
  theme_minimal() +                  # Minimal theme 
  theme(legend.position = "bottom")+
  labs(subtitle = "Number of recovered and dead Ebola cases, by hospital",
       fill = "Outcome",             # legend title
       y = "Count",                  # y axis title
       x = "Hospital of admission")+ # x axis title
  scale_fill_manual(                 # adding colors manually
    values = c("Death"= "#3B1c8C",
               "Recover" = "#21908D" )) 

```

Lưu ý rằng tỷ lệ là nhị phân, do đó chúng ta có thể loại bỏ các giá trị 'recover' và chỉ hiện thị tỷ lệ những người tử vong. Việc này chỉ nhằm cho mục đích minh họa.

Nếu sử dụng `geom_col()` cho dữ liệu ngày tháng (vd: đường cong dịch bệnh từ dữ liệu tổng hợp) - bạn sẽ muốn điều chỉnh đối số `width =` để loại bỏ "khoảng trống" giữa các cột. nếu sử dụng số liệu cập nhật hàng ngày, hãy thiết lập `width = 1`. Nếu là hàng tuần, `width = 7`. Không thể thiết lập cho tháng vì mỗi tháng có số ngày khác nhau.

### `geom_histogram()` {.unnumbered}

Histograms có thể trông giống biểu đồ cột, nhưng khác biệt vì nó đo lường sự phân bố của một biến *liên tục*. Không có khoảng cách giữa các "cột", và chỉ có một cột được cung cấp cho hàm `geom_histogram()`. Có các đối số cụ thể cho biểu đồ chẳng hạn như `bin_width =` và `breaks =` ể chỉ định cách dữ liệu nên được xếp. Phần bên trên về dữ liệu liên tục và chương [Đường cong dịch bệnh] sẽ cung cấp thêm các hi tiết.

## Tài nguyên học liệu

Có rất nhiều trợ giúp trực tuyến, đặc biệt là với ggplot. Xem:

-   [ggplot2 cheat sheet](http://r-statistics.co/ggplot2-cheatsheet.html)
-   [another cheat sheet](https://biostats.w.uib.no/the-ggplot2-cheat-sheet-by-rstudio/)
-   [tidyverse ggplot basics page](https://ggplot2.tidyverse.org/reference/)\
-   [plotting continuous variables](http://www.sthda.com/english/articles/32-r-graphics-essentials/131-plot-two-continuous-variables-scatter-graph-and-alternatives/)\
-   R for Data Science trang về [data visualization](https://r4ds.had.co.nz/data-visualisation.html)
-   [graphics for communicaton](https://r4ds.had.co.nz/graphics-for-communication.html)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/ggplot_basics.Rmd-->


# Các tips với ggplot {#ggplot-tips}

Trong trang này, chúng tôi sẽ đề cập đến các mẹo và thủ thuật để làm cho biểu đồ ggplots của bạn đẹp và bóng bẩy hơn. Xem thêm chương [ggplot cơ bản] để có các kiến thức nền tảng.  

Có một số [hướng dẫn **ggplot2**](https://ggplot2.tidyverse.org/) mở rộng được liên kết trong phần Nguồn. Bạn cũng có thể tải xuống [cheatsheet trực quan hóa số liệu với ggplot](https://rstudio.com/resources/cheatsheets/) từ trang web của RStudio. Chúng tôi thực sự khuyên bạn nên tìm thêm cảm hứng tại các trang web sau: [R graph gallery](https://www.r-graph-gallery.com/) và [Data-to-viz](https://www.data-to-viz.com/caveats.html). 



<!-- ======================================================= -->
## Chuẩn bị {}

### Gọi packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R. 

```{r}
pacman::p_load(
  tidyverse,      # includes ggplot2 and other
  rio,            # import/export
  here,           # file locator
  stringr,        # working with characters   
  scales,         # transform numbers
  ggrepel,        # smartly-placed labels
  gghighlight,    # highlight one part of plot
  RColorBrewer    # color scales
)
```

### Nhập dữ liệu {.unnumbered}  

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết.  

```{r,  echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

```

```{r, eval=F}
linelist <- rio::import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




<!-- ======================================================= -->
## Thang đo đối với màu sắc, tô màu, trục, v.v. {#ggplot_tips_colors}

Trong **ggplot2**, khi yếu tố thẩm mỹ của dữ liệu được vẽ (vd: kích thước, màu sắc, hình dạng, tô màu, trục biểu đồ) được gắn với các cột trong bộ dữ liệu, thì hiển thị chính xác có thể được điều chỉnh với lệnh "scale" tương ứng. Trong phần này, chúng tôi giải thích một số điều chỉnh thang đo phổ biến.  



### Phối màu

Một điều ban đầu có thể khó hiểu khi dùng **ggplot2** là kiểm soát các phối màu. Lưu ý rằng phần này thảo luận về màu sắc của *các đối tượng biểu đồ* (geoms/shapes) ví dụ như điểm, cột, đường, ô, v.v. Để điều chỉnh màu của các văn bản, tiêu đề hoặc màu nền, hãy xem phần [Chủ đề](#ggplot_basics_themes) trong chương [ggplot cơ bản]. 

Để kiểm soát "màu sắc" của *các đối tượng biểu đồ*, bạn sẽ điều chỉnh hoặc là `color = ` (màu *bên ngoài*) hoặc `fill = ` (màu *bên trong*). Một ngoại lệ đối với mẫu này là `geom_point()`, nơi bạn thực sự chỉ có thể điều khiển `color = `, để xác định màu của điểm (bên trong và bên ngoài).  

Khi thiết lập màu hoặc tô màu, bạn có thể sử dụng tên màu được R nhận dạng như `"red"` (xem [danh sách đầy đủ](http://sape.inf.usi.ch/quick-reference/ggplot2/colour) hoặc gõ `?colors`), hoặc cụ thể một mã màu hex như `"#ff0505"`.

```{r, warning=F, message=F}
# histogram - 
ggplot(data = linelist, mapping = aes(x = age))+       # set data and axes
  geom_histogram(              # display histogram
    binwidth = 7,                # width of bins
    color = "red",               # bin line color
    fill = "lightblue")          # bin interior color (fill) 
```



Như đã được giải thích trong chương [ggplot cơ bản] phần [chọn dữ liệu cho biểu đồ](#ggplot_basics_mapping), các yếu tố thẩm mỹ như `fill = ` và `color = ` có thể được định nghĩa ở *bên ngoài* của biểu thức `mapping = aes()` hoặc *bên trong* câu lệnh. Nếu đặt *bên ngoài* hàm `aes()`, giá trị được gán nên là giá trị tĩnh (vd: `color = "blue"`) và sẽ áp dụng cho *toàn bộ* dữ liệu được vẽ bởi geom. Nếu đặt *bên trong*, các aesthetic nên được gán tới cột, ví dụ như `color = hospital`, và sự biểu diễn sẽ thay đổi theo giá trị của hàng đó trong dữ liệu. Một vài ví dụ:  

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
# Static color for points and for line
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(color = "purple")+
  geom_vline(xintercept = 50, color = "orange")+
  labs(title = "Static color for points and line")

# Color mapped to continuous column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = temp))+         
  labs(title = "Color mapped to continuous column")

# Color mapped to discrete column
ggplot(data = linelist, mapping = aes(x = age, y = wt_kg))+     
  geom_point(mapping = aes(color = gender))+         
  labs(title = "Color mapped to discrete column")

# bar plot, fill to discrete column, color to static value
ggplot(data = linelist, mapping = aes(x = hospital))+     
  geom_bar(mapping = aes(fill = gender), color = "yellow")+         
  labs(title = "Fill mapped to discrete column, static color")

```


### Thang đo {#ggplot_tips_scales .unnumbered}  

Một khi bạn gán cột tới một yếu tố thẩm mỹ của biểu đồ (vd: `x = `, `y = `, `fill = `, `color = `...), biểu đồ của bạn sẽ hiển thị một thang đo/chú giải. Xem ở trên cách thang đo có thể là các giá trị liên tục, rời rạc, ngày tháng, v.v. tùy thuộc vào kiểu dữ liệu của cột được chỉ định. Nếu bạn có nhiều yếu tố thẩm mỹ được gán tới cột, biểu đồ của bạn sẽ có nhiều thang đo.  

Bạn có thể kiểm soát các thang đo bằng hàm `scales_()` thích hợp. Các hàm scale của **ggplot()** có 3 phần được viết như sau: `scale_AESTHETIC_METHOD()`.  

1) Phần đầu tiên, `scale_()`, là cố định.  
2) Phần thứ hai, AESTHETIC, là tên yếu tố thẩm mỹ bạn muốn điều chỉnh thang đó (`_fill_`, `_shape_`, `_color_`, `_size_`, `_alpha_`...) - các tùy chọn ở đây cũng bao gồm `_x_` và `_y_`.  
3) Phần thứ ba, METHOD, sẽ là một trong số các tùy chọn sau `_discrete()`, `continuous()`, `_date()`, `_gradient()`, hoặc `_manual()`, tùy thuộc vào kiểu dữ liệu của cột và *cách* bạn muốn kiểm soát nó. Có những tùy chọn khác, tuy nhiên những lựa chọn trên thường được sử dụng nhất.  

Hãy chắc chắn rằng bạn sử dụng đúng hàm scale! Nếu không, lệnh scale của bạn sẽ không xuất hiện để thay đổi bất cứ điều gì. Nếu bạn có nhiều thang đo, bạn có thể sử dụng nhiều hàm scale để điều chỉnh chúng! Ví dụ:  

### Các đối số của hàm Scale {.unnumbered}  

Mỗi loại thang đo có những đối số riêng của chúng, mặc dù cũng có những sự trùng nhau. Truy vấn hàm chẳng hạn như `?scale_color_discrete` trong cửa sổ R console để xem tài liệu về các đối số của hàm.  

Với thang đo liên tục, sử dụng `breaks = ` để cung cấp một chuỗi giá trị tới `seq()` (đặt `to = `, `from = `, và `by = ` như được minh họa trong ví dụ bên dưới. Thiết lập `expand = c(0,0)` để loại bỏ không gian đệm xung quanh các trục (điều này có thể được sử dụng trên bất kỳ thang đo của trục `_x_` hoặc `_y_` nào)  

Với thang đo rời rạc, bạn có thể điều chỉnh thứ tự của các giá trị với `breaks = `, và cách các giá trị hiển thị với đối số `labels = `. Cung cấp một vectơ ký tự cho mỗi cái đó (xem ví dụ bên dưới). Bạn cũng có thể loại bỏ `NA` dễ dàng bằng cách đặt `na.translate = FALSE`.  

Các điều chỉnh với thang đo ngày tháng được trình bãy rõ hơn trong chương [Đường cong dịch bệnh].  


### Điều chỉnh thủ công {.unnumbered}  

Một trong những thủ thuật hữu ích nhất là sử dụng các hàm scaling "một cách thủ công" để gán màu sắc như bạn mong muốn. Có những hàm với cú pháp `scale_xxx_manual()` (vd: `scale_colour_manual()` hoặc `scale_fill_manual()`). Mỗi đối số dưới đây được minh họa trong các code ví dụ bên dưới.

* Gán màu cho các giá trị dữ liệu với đối số `values = `  
* Cụ thể màu sắc cho giá trị `NA` với `na.value = `  
* Thay đổi cách các giá trị *được viết* trong chú giải với đối số `labels = ` 
* Thay đổi tiêu đề chú giải bằng `name = `  


Dưới đây, chúng ta tạo một biểu đồ cột và hiển thị cách nó xuất hiện theo mặc định, sau đó với ba thang đo được điều chỉnh  - thang đo trục y liên tục, thang đo trục x rời rạc, và điều chỉnh thủ công cách tô màu (màu bên trong cột).  


```{r, warning=F, message=F}
# BASELINE - no scale adjustment
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# SCALES ADJUSTED
ggplot(data = linelist)+
  
  geom_bar(mapping = aes(x = outcome, fill = gender), color = "black")+
  
  theme_minimal()+                   # simplify background
  
  scale_y_continuous(                # continuous scale for y-axis (counts)
    expand = c(0,0),                 # no padding
    breaks = seq(from = 0,
                 to = 3000,
                 by = 500))+
  
  scale_x_discrete(                   # discrete scale for x-axis (gender)
    expand = c(0,0),                  # no padding
    drop = FALSE,                     # show all factor levels (even if not in data)
    na.translate = FALSE,             # remove NA outcomes from plot
    labels = c("Died", "Recovered"))+ # Change display of values
    
  
  scale_fill_manual(                  # Manually specify fill (bar interior color)
    values = c("m" = "violetred",     # reference values in data to assign colors
               "f" = "aquamarine"),
    labels = c("m" = "Male",          # re-label the legend (use "=" assignment to avoid mistakes)
              "f" = "Female",
              "Missing"),
    name = "Gender",                  # title of legend
    na.value = "grey"                 # assign a color for missing values
  )+
  labs(title = "Adjustment of scales") # Adjust the title of the fill legend
```

### Thang đo liên tục trên trục {.unnumbered}  

Khi dữ liệu được ánh xạ tới các trục của biểu đồ, chúng cũng có thể được điều chỉnh bằng các lệnh scales.  Một ví dụ phổ biến là điều chỉnh hiển thị của một trục (ví dụ: trục y) được ánh xạ tới một cột có dữ liệu liên tục. 

Chúng ta có thể muốn điều chỉnh độ chia hoặc hiển thị của giá trị trong ggplot bằng cách sử dụng `scale_y_continuous()`. Như đã lưu ý ở trên, sử dụng đối số `breaks = ` để cung cấp một chuỗi các giá trị sẽ đóng vai trò là "ngắt các khoảng giá trị" dọc theo thang đo. Đây là những giá trị mà các số sẽ hiển thị. Đối với đối số này, bạn có thể cung cấp một vectơ `c()` chứa các giá trị để chia thang đo theo mong muốn hoặc bạn có thể cung cấp một chuỗi số thông thường bằng cách sử dụng hàm `seq()` từ **base** R. Hàm `seq()` này chấp nhận `to = `, `from = `, và `by = `.

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# BASELINE - no scale adjustment
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  labs(title = "Baseline - no scale adjustments")

# 
ggplot(data = linelist)+
  geom_bar(mapping = aes(x = outcome, fill = gender))+
  scale_y_continuous(
    breaks = seq(
      from = 0,
      to = 3000,
      by = 100)
  )+
  labs(title = "Adjusted y-axis breaks")

```



#### Hiển thị phần trăm {.unnumbered}  

Nếu giá trị dữ liệu ban đầu của bạn là tỷ lệ, bạn có thể dễ dàng hiển thị chúng dưới dạng phần trăm với "%" bằng cách cung cấp `labels = scales::percent` trong lệnh scales command, như được trình bày dưới đây.  

Mặc dù có một giải pháp thay thế là chuyển đổi các giá trị thành ký tự và thêm ký tự “%” vào cuối, cách tiếp cận này sẽ gây ra phức tạp vì dữ liệu của bạn sẽ không còn là các giá trị số liên tục.


```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# Original y-axis proportions
#############################
linelist %>%                                   # start with linelist
  group_by(hospital) %>%                       # group data by hospital
  summarise(                                   # create summary columns
    n = n(),                                     # total number of rows in group
    deaths = sum(outcome == "Death", na.rm=T),   # number of deaths in group
    prop_death = deaths/n) %>%                   # proportion deaths in group
  ggplot(                                      # begin plotting
    mapping = aes(
      x = hospital,
      y = prop_death))+ 
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis original proportions")



# Display y-axis proportions as percents
########################################
linelist %>%         
  group_by(hospital) %>% 
  summarise(
    n = n(),
    deaths = sum(outcome == "Death", na.rm=T),
    prop_death = deaths/n) %>% 
  ggplot(
    mapping = aes(
      x = hospital,
      y = prop_death))+
  geom_col()+
  theme_minimal()+
  labs(title = "Display y-axis as percents (%)")+
  scale_y_continuous(
    labels = scales::percent                    # display proportions as percents
  )

```

#### Thang đo Log {.unnumbered}  

Để biến đổi một trục liên tục sang thang đo log, hãy thêm `trans = "log2"` vào lệnh scale. Ví dụ: chúng ta tạo một data frame của các vùng với các giá trị `preparedness_index` và số trường hợp tích lũy tương ứng.  

```{r}
plot_data <- data.frame(
  region = c("A", "B", "C", "D", "E", "F", "G", "H", "I"),
  preparedness_index = c(8.8, 7.5, 3.4, 3.6, 2.1, 7.9, 7.0, 5.6, 1.0),
  cases_cumulative = c(15, 45, 80, 20, 21, 7, 51, 30, 1442)
)

plot_data
```

Các trường hợp tích lũy ở vùng "I" lớn hơn đáng kể so với tất cả các vùng khác. Trong những trường hợp như thế này, bạn có thể chọn hiển thị trục y bằng thang đo log để người đọc có thể thấy sự khác biệt giữa các vùng với ít trường hợp tích lũy hơn.  

```{r, warning=F, message=F, out.width=c('50%', '50%'), fig.show='hold'}
# Original y-axis
preparedness_plot <- ggplot(data = plot_data,  
       mapping = aes(
         x = preparedness_index,
         y = cases_cumulative))+
  geom_point(size = 2)+            # points for each region 
  geom_text(
    mapping = aes(label = region),
    vjust = 1.5)+                  # add text labels
  theme_minimal()

preparedness_plot                  # print original plot


# print with y-axis transformed
preparedness_plot+                   # begin with plot saved above
  scale_y_continuous(trans = "log2") # add transformation for y-axis
```



### Thang đo Gradient {.unnumbered}  

Tô màu thang đo gradient có thể liên quan đến sắc thái bổ sung. Các giá trị mặc định thường khá dễ chịu, nhưng bạn có thể muốn điều chỉnh các giá trị, điểm cắt, v.v.  

Để trình bày cách điều chỉnh thang màu liên tục, chúng tôi sẽ sử dụng bộ dữ liệu từ chương [Truy vết tiếp xúc] chứa độ tuổi của các trường hợp và các trường hợp tiếp xúc gốc của chúng.  


```{r, warning=F, message=F}
case_source_relationships <- rio::import(here::here("data", "godata", "relationships_clean.rds")) %>% 
  select(source_age, target_age) 
```

Dưới đây, chúng ta sẽ tạo ra một "raster" biểu đồ mật độ nhiệt. Chúng ta sẽ không đề cập chi tiết đến cách thức (xem link ở đoạn trên), nhưng chúng ta sẽ tập trung vào cách chúng ta có thể điều chỉnh thang màu. Đọc thêm về hàm `stat_density2d()` của package **ggplot2** [tại đây](https://ggplot2.tidyverse.org/reference/geom_density_2d.html). Lưu ý cách mà thang đo `fill` là *liên tục*.  

```{r, warn=F, message=F}
trans_matrix <- ggplot(
    data = case_source_relationships,
    mapping = aes(x = source_age, y = target_age))+
  stat_density2d(
    geom = "raster",
    mapping = aes(fill = after_stat(density)),
    contour = FALSE)+
  theme_minimal()
```

Bây giờ chúng ta hiển thị một số biến đổi trên fill scale: 

```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix
trans_matrix + scale_fill_viridis_c(option = "plasma")
```

Bây giờ chúng ta sẽ xem xét một số ví dụ về việc thực sự điều chỉnh các điểm ngắt của thang đo:  

* `scale_fill_gradient()` chấp nhận hai màu (cao/thấp)  
* `scale_fill_gradientn()` chấp nhận một vectơ có độ dài màu bất kỳ tới `values = ` (các giá trị trung gian sẽ được nội suy)  
* Sử dụng [`scales::rescale()`](https://www.rdocumentation.org/packages/scales/versions/0.4.1/topics/rescale) để điều chỉnh cách định vị màu sắc dọc theo gradient; nó sẽ cân chỉnh lại vectơ vị trí của bạn nằm giữa 0 và 1.  


```{r, out.width=c('50%', '50%'), fig.show='hold', warning=F, message=F}
trans_matrix + 
  scale_fill_gradient(     # 2-sided gradient scale
    low = "aquamarine",    # low value
    high = "purple",       # high value
    na.value = "grey",     # value for NA
    name = "Density")+     # Legend title
  labs(title = "Manually specify high/low colors")

# 3+ colors to scale
trans_matrix + 
  scale_fill_gradientn(    # 3-color scale (low/mid/high)
    colors = c("blue", "yellow","red") # provide colors in vector
  )+
  labs(title = "3-color scale")

# Use of rescale() to adjust placement of colors along scale
trans_matrix + 
  scale_fill_gradientn(    # provide any number of colors
    colors = c("blue", "yellow","red", "black"),
    values = scales::rescale(c(0, 0.05, 0.07, 0.10, 0.15, 0.20, 0.3, 0.5)) # positions for colors are rescaled between 0 and 1
    )+
  labs(title = "Colors not evenly positioned")

# use of limits to cut-off values that get fill color
trans_matrix + 
  scale_fill_gradientn(    
    colors = c("blue", "yellow","red"),
    limits = c(0, 0.0002))+
  labs(title = "Restrict value limits, resulting in grey space")

```


### Bảng màu {.unnumbered}  

#### Colorbrewer và Viridis {.unnumbered}
Nhìn chung, nếu bạn muốn sử dụng các bảng màu có sẵn, bạn có thể sử dụng các hàm `scale_xxx_brewer` hoặc `scale_xxx_viridis_y`.  

Càm hàm 'brewer' có thể rút ra từ bảng màu [colorbrewer.org](colorbrewer.org).  

Các hàm 'viridis' lấy từ các bảng màu viridis (thân thiện với người mù màu!), giúp “cung cấp các bản đồ màu sắc đồng nhất về mặt tri giác ở cả hai màu đen và trắng. Chúng cũng được thiết kế để người xem cảm nhận được các dạng mù màu phổ biến." (đọc thêm [tại đây](https://ggplot2.tidyverse.org/reference/scale_viridis.html) và [tại đây](https://bids.github.io/colormap/)). Xác định xem bảng màu là rời rạc, liên tục hay xếp chồng bằng cách cụ thể điều này ở cuối hàm (vd: nếu rời rạc sẽ là `scale_xxx_viridis_d`).

Bạn nên kiểm tra biểu đồ của mình trong [trình mô phỏng mù màu này](https://www.color-blindness.com/coblis-color-blindness-simulator/). Nếu bạn có phối màu đỏ/xanh lá cây, hãy thử phối "nóng-lạnh" (đỏ-xanh lam) như được môt tả [ở đây](https://www.visualisingdata.com/2019/08/five-ways-to-design-for-red-green-colour-blindness/#:~:text=The%20pink%2Dred%20through%20to,green%20hues%20used%20by%20default.)  

Sau đây là một ví dụ từ chương [ggplot cơ bản], sử dụng các phối màu khác nhau. 

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F} 
symp_plot <- linelist %>%                                         # begin with linelist
  select(c(case_id, fever, chills, cough, aches, vomit)) %>%     # select columns
  pivot_longer(                                                  # pivot longer
    cols = -case_id,                                  
    names_to = "symptom_name",
    values_to = "symptom_is_present") %>%
  mutate(                                                        # replace missing values
    symptom_is_present = replace_na(symptom_is_present, "unknown")) %>% 
  ggplot(                                                        # begin ggplot!
    mapping = aes(x = symptom_name, fill = symptom_is_present))+
  geom_bar(position = "fill", col = "black") +                    
  theme_classic() +
  theme(legend.position = "bottom")+
  labs(
    x = "Symptom",
    y = "Symptom status (proportion)"
  )

symp_plot  # print with default colors

#################################
# print with manually-specified colors
symp_plot +
  scale_fill_manual(
    values = c("yes" = "black",         # explicitly define colours
               "no" = "white",
               "unknown" = "grey"),
    breaks = c("yes", "no", "unknown"), # order the factors correctly
    name = ""                           # set legend to no title

  ) 

#################################
# print with viridis discrete colors
symp_plot +
  scale_fill_viridis_d(
    breaks = c("yes", "no", "unknown"),
    name = ""
  )


```



<!-- ======================================================= -->
## Thay đổi thứ tự của biến rời rạc {}  

Việc thay đổi thứ tự các biến rời rạc thường khó hiểu đối với những người mới làm quen với vẽ biểu đồ bằng `ggplot2`. Tuy nhiên, thật dễ hiểu cách thực hiện việc này khi bạn hiểu cách `ggplot2` xử lý các biến rời rạc. Nói chung, nếu một biến số rời rạc được sử dụng, nó sẽ tự động được chuyển đổi thành một biến dạng `factor` - theo mặc định sắp xếp các giá trị theo thứ tự bảng chữ cái. Để xử lý điều này, bạn chỉ cần sắp xếp lại các levels của biến factor để phản ánh thứ tự bạn muốn chúng xuất hiện trong biểu đồ. Để biết thêm thông tin chi tiết về cách sắp xếp lại các đối tượng `factor`, hãy xem chương factor trong cuốn sách này. 

Chúng ta có thể xem xét một ví dụ phổ biến bằng cách sử dụng các nhóm tuổi - theo mặc định, nhóm 5-9 tuổi sẽ được đặt ở giữa các nhóm tuổi (thứ tự chữ và số đã cho), nhưng chúng ta có thể di chuyển nó phía sau nhóm tuổi 0-4 của biểu đồ bằng cách sắp xếp lại thứ bậc của biến factor này.


```{r, , warning=F, message=F}
ggplot(
  data = linelist %>% drop_na(age_cat5),                         # remove rows where age_cat5 is missing
  mapping = aes(x = fct_relevel(age_cat5, "5-9", after = 1))) +  # relevel factor

  geom_bar() +
  
  labs(x = "Age group", y = "Number of hospitalisations",
       title = "Total hospitalisations by age group") +
  
  theme_minimal()


```

#### **ggthemr** {.unnnumbered}  

Bạn cũng có thể xem xét sử dụng package **ggthemr**.  Bạn có thể tải xuống package này từ Github theo hướng dẫn [này](https://github.com/Mikata-Project/ggthemr). INó cung cấp các bảng màu rất đẹp về mặt thẩm mỹ, nhưng hãy lưu ý rằng chúng thường có số lượng giá trị tối đa có thể bị giới hạn nếu bạn muốn nhiều hơn 7 hoặc 8 màu.  






## Đường đồng mức 

Contour plots rất hữu ích khi bạn có nhiều điểm cần biểu diễn có thể che lấp nhau ("overplotting"). Dữ liệu case-source bên trên một lần nữa được dùng để vẽ, nhưng đơn giản hơn bằng cách sử dụng hàm `stat_density2d()` và `stat_density2d_filled()` để tạo ra các mức đường đồng mức rời rạc - giống như một bản đồ địa hình. Đọc thêm về các số liệu thống kê [ở đây](https://ggplot2.tidyverse.org/reference/geom_density_2d.html).  


```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d()+
  geom_point()+
  theme_minimal()+
  labs(title = "stat_density2d() + geom_point()")


case_source_relationships %>% 
  ggplot(aes(x = source_age, y = target_age))+
  stat_density2d_filled()+
  theme_minimal()+
  labs(title = "stat_density2d_filled()")

```



## Phân phối biên 

Để hiển thị các phân phối trên các cạnh của biểu đồ tán xạ với hàm `geom_point()`, bạn có thể sử dụng package **ggExtra** với hàm `ggMarginal()`. Lưu biểu đồ ggplot nguyên gốc của bạn dưới dạng một đối tượng, sau đó chuyển nó tới hàm `ggMarginal()` như được trình bày dưới đây. Sau đây là những đối số chính:  

* Bạn phải cụ thể kiểu `type = ` theo một số lựa chọn sau: "histogram", "density" "boxplot", "violin", hoặc "densigram".  
* Theo mặc định, các đồ thị biên sẽ xuất hiện ở cả hai trục. Bạn có thể thiết lập `margins = ` thành "x" hoặc "y" nếu bạn chỉ muốn hiện thị ở một trong số chúng.  
* Các đối số tùy chọn khác bao gồm `fill = ` (màu cột), `color = ` (màu đường), `size = ` (kích thương biểu đồ so với kích thước biên, do đó số lớn hơn làm biểu đồ biên nhỏ hơn).  
* Bạn có thể cung cấp các đối số theo trục khác với `xparams = ` và `yparams = `. Ví dụ, để có các kích thước bin khác nhau trong biểu đồ histogram, như được minh họa dưới đây.  

Bạn có thể có các nhóm biểu đồ biên phản ánh (các cột đã được gán tới `color = ` trong đối số thẩm mỹ của `ggplot()`). Nếu đúng như vậy, hãy thiết lập các đối số của hàm `ggMarginal()` như `groupColour = ` hoặc `groupFill = ` thành `TRUE`, như được trình bày dưới đây.  

Đọc thêm ở [vignette này](https://cran.r-project.org/web/packages/ggExtra/vignettes/ggExtra.html), ở trang web [R Graph Gallery](https://www.r-graph-gallery.com/277-marginal-histogram-for-ggplot2.html) hoặc tài liệu trợ giúp hàm `?ggMarginal`.  

```{r, message=FALSE, warning=FALSE}
# Install/load ggExtra
pacman::p_load(ggExtra)

# Basic scatter plot of weight and age
scatter_plot <- ggplot(data = linelist)+
  geom_point(mapping = aes(y = wt_kg, x = age)) +
  labs(title = "Scatter plot of weight and age")
```

Để thêm biểu đồ biên, hãy sử dụng `type = "histogram"`. Bạn có thể tùy chọn thiết lập `groupFill = TRUE` để có biểu đồ histograms trầm.     

```{r, message=FALSE, warning=FALSE}
# with histograms
ggMarginal(
  scatter_plot,                     # add marginal histograms
  type = "histogram",               # specify histograms
  fill = "lightblue",               # bar fill
  xparams = list(binwidth = 10),    # other parameters for x-axis marginal
  yparams = list(binwidth = 5))     # other parameters for y-axis marginal
```

Biểu đồ mật độ biên với các giá trị được nhóm/tô màu:  

```{r, message=FALSE, warning=FALSE}

# Scatter plot, colored by outcome
# Outcome column is assigned as color in ggplot. groupFill in ggMarginal set to TRUE
scatter_plot_color <- ggplot(data = linelist %>% drop_na(gender))+
  geom_point(mapping = aes(y = wt_kg, x = age, color = gender)) +
  labs(title = "Scatter plot of weight and age")+
  theme(legend.position = "bottom")

ggMarginal(scatter_plot_color, type = "density", groupFill = TRUE)
```

Đặt kích thước `size = ` để điều chỉnh kích thước tương đối của ô biên. Số nhỏ hơn tạo ra biểu đồ cận biên lớn hơn. Bạn cũng có thể đặt `color = `. Dưới đây một biểu đồ boxplot cận biên, với sự minh họa của đối số `margins = ` để nó chỉ hiện thị trên một trục:  

```{r, message=FALSE, warning=FALSE}
# with boxplot 
ggMarginal(
  scatter_plot,
  margins = "x",      # only show x-axis marginal plot
  type = "boxplot")   
```



<!-- ======================================================= -->
## Dán nhãn thông minh {}  

Trong **ggplot2**, bạn có thể thêm văn bản vào biểu đồ. Tuy nhiên, điều này đi kèm với hạn chế đáng chú ý là các nhãn văn bản thường xung đột với các điểm dữ liệu trong một biểu đồ, khiến chúng trông lộn xộn hoặc khó đọc. Không có cách nào để giải quyết triệt để vấn đề này với các package trong base R, nhưng có một tiện ích bổ sung của **ggplot2** đó là **ggrepel** giúp xử lý vấn đề này rất đơn giản! 

Package **ggrepel** cung cấp hai hàm mới, `geom_label_repel()` và `geom_text_repel()`, thay thế cho `geom_label()` và `geom_text()`. Đơn giản chỉ cần sử dụng các hàm này thay vì các hàm cơ bản để tạo các nhãn. Bên trong hàm, hãy cụ thể các thông số cho hàm `aes()` như thường lệ, nhưng bao gồm thêm đối số `label = ` trong đó bạn cung cấp tên cột có chứa giá trị bạn muốn hiển thị (vd: id bệnh nhân, hoặc tên, v.v.). Bạn có thể tạo các nhãn phức tạp hơn bằng cách kết hợp các cột và dòng mới (`\n`) bên trong hàm `str_glue()` như được trình bày bên dưới.  

Một vào mẹo:  

* Sử dụng `min.segment.length = 0` để luôn vẽ các đoạn thẳng hoặc `min.segment.length = Inf` để không bao giờ vẽ chúng  
* Sử dụng `size = ` bên ngoài hàm `aes()` để thiết lập cỡ chữ  
* Sử dụng `force = ` để thay đổi khoảng cách giữa các nhãn và các điểm tương ứng của chúng (mặc định là 1)  
* Thêm đối số `fill = ` bên trong hàm `aes()` để có nhãn được tô màu theo giá trị  
  * Ký tự "a" có thể xuất hiện trong chú giải - hãy thêm `guides(fill = guide_legend(override.aes = aes(color = NA)))+` để xóa nó  

Hãy xem [hướng dẫn chuyên sâu này](https://ggrepel.slowkow.com/articles/examples.html) để biết thêm.  

```{r, , warning=F, message=F}
pacman::p_load(ggrepel)

linelist %>%                                               # start with linelist
  group_by(hospital) %>%                                   # group by hospital
  summarise(                                               # create new dataset with summary values per hospital
    n_cases = n(),                                           # number of cases per hospital
    delay_mean = round(mean(days_onset_hosp, na.rm=T),1),    # mean delay per hospital
  ) %>% 
  ggplot(mapping = aes(x = n_cases, y = delay_mean))+      # send data frame to ggplot
  geom_point(size = 2)+                                    # add points
  geom_label_repel(                                        # add point labels
    mapping = aes(
      label = stringr::str_glue(
        "{hospital}\n{n_cases} cases, {delay_mean} days")  # how label displays
      ), 
    size = 3,                                              # text size in labels
    min.segment.length = 0)+                               # show all line segments                
  labs(                                                    # add axes labels
    title = "Mean delay to admission, by hospital",
    x = "Number of cases",
    y = "Mean delay (days)")
```

Bạn chỉ có thể gắn nhãn một tập hợp con của các điểm dữ liệu - bằng cách sử dụng cú pháp `ggplot()` tiêu chuẩn để cung cấp các dữ liệu `data = ` khác nhau cho từng lớp `geom` của biểu đồ. Dưới đây, tất cả các trường hợp đều được vẽ biểu đồ, nhưng chỉ một số ít được gắn nhãn.   

```{r, warning=F, message=FALSE}

ggplot()+
  # All points in grey
  geom_point(
    data = linelist,                                   # all data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    color = "grey",
    alpha = 0.5)+                                              # grey and semi-transparent
  
  # Few points in black
  geom_point(
    data = linelist %>% filter(days_onset_hosp > 15),  # filtered data provided to this layer
    mapping = aes(x = ht_cm, y = wt_kg),
    alpha = 1)+                                                # default black and not transparent
  
  # point labels for few points
  geom_label_repel(
    data = linelist %>% filter(days_onset_hosp > 15),  # filter the data for the labels
    mapping = aes(
      x = ht_cm,
      y = wt_kg,
      fill = outcome,                                          # label color by outcome
      label = stringr::str_glue("Delay: {days_onset_hosp}d")), # label created with str_glue()
    min.segment.length = 0) +                                  # show line segments for all
  
  # remove letter "a" from inside legend boxes
  guides(fill = guide_legend(override.aes = aes(color = NA)))+
  
  # axis labels
  labs(
    title = "Cases with long delay to admission",
    y = "weight (kg)",
    x = "height(cm)")
```





<!-- ======================================================= -->
## Trục thời gian {}

Làm việc với các trục thời gian trong ggplot có vẻ khó khăn, nhưng được thực hiện rất dễ dàng với một vài hàm chính. Hãy nhớ rằng khi làm việc với thời gian hoặc ngày tháng, bạn phải đảm bảo rằng các biến cần được định dạng chính xác dưới kiểu date hoặc datetime - hãy xem chương [Làm việc với ngày tháng] để biết thêm chi tiết, hoặc chương [Đường con dịch bệnh] mục ggplot để xem các ví dụ.

Nhóm các hàm hữu dụng nhất khi làm việc với ngày tháng trong `ggplot2` là các hàm scale (`scale_x_date()`, `scale_x_datetime()`, và tương tự với các hàm trục y). Các hàm này cho phép bạn xác định tần suất bạn có nhãn trục và cách định dạng nhãn trục. Để tìm hiểu cách định dạng ngày tháng, hãy xem lại mục _làm việc với ngày tháng_ một lần nữa! Bạn có thể sử dụng các đối số `date_breaks` và `date_labels` để cụ thể ngày sẽ trông như thế nào:

  1. `date_breaks` cho phép bạn cụ thể khoảng cách ngắt trục bằng cách truyền một chuỗi tới đối số (vd: `"3 months"`, hoặc "`2 days"`)
  
  2. `date_labels` cho phép bạn định nghĩa định dạng ngày tháng hiển thị. Bạn có thể truyền một chuỗi định dạng ngày tháng tới đối số (vd: `"%b-%d-%Y"`):


```{r, , warning=F, message=F}
# make epi curve by date of onset when available
ggplot(linelist, aes(x = date_onset)) +
  geom_histogram(binwidth = 7) +
  scale_x_date(
    # 1 break every 1 month
    date_breaks = "1 months",
    # labels should show month then date
    date_labels = "%b %d"
  ) +
  theme_classic()

```



<!-- ======================================================= -->
## Làm nổi bật {}

Làm nổi bật các phần tử cụ thể trong biểu đồ là một cách hữu ích để thu hút sự chú ý đến một trường hợp cụ thể của một biến đồng thời cung cấp thông tin về sự phân tán của tập dữ liệu đầy đủ. Mặc dù điều này không dễ dàng thực hiện với **ggplot2**, tuy nhiên có một package bên ngoài giúp bạn làm điều đó có tên **gghighlight**. Nó rất dễ sử dụng cùng với cú pháp của ggplot.

Package **gghighlight** sử dụng hàm `gghighlight()` để thực hiện. Để sử dụng hàm này, hãy cung cấp một biểu thức logic tới hàm - điều này có thể có các kết quả khá linh hoạt, nhưng ở đây chúng ta sẽ trình bày một ví dụ về phân bổ độ tuổi của các trường hợp trong bộ dữ liệu linelist, làm nổi bật chúng theo outcome.

```{r, , warning=F, message=F}
# load gghighlight
library(gghighlight)

# replace NA values with unknown in the outcome variable
linelist <- linelist %>%
  mutate(outcome = replace_na(outcome, "Unknown"))

# produce a histogram of all cases by age
ggplot(
  data = linelist,
  mapping = aes(x = age_years, fill = outcome)) +
  geom_histogram() + 
  gghighlight::gghighlight(outcome == "Death")     # highlight instances where the patient has died.

```

Nó cũng hoạt động tốt khi faceting - cho phép người dùng tạo ra các biểu đồ con và làm nổi bật một nhóm dữ liệu mà không áp dụng cho toàn bộ biểu đồ con ! Dưới đây, chúng tôi đếm các ca bệnh theo tuần và vẽ đồ thị đường cong dịch bệnh theo bệnh viện (`color = ` và `facet_wrap()` được gán cho cột `hospital`).  

```{r, , warning=F, message=F}

# produce a histogram of all cases by age
linelist %>% 
  count(week = lubridate::floor_date(date_hospitalisation, "week"),
        hospital) %>% 
  ggplot()+
  geom_line(aes(x = week, y = n, color = hospital))+
  theme_minimal()+
  gghighlight::gghighlight() +                      # highlight instances where the patient has died
  facet_wrap(~hospital)                              # make facets by outcome

```





## Vẽ nhiều tập dữ liệu  

Lưu ý rằng việc căn chỉnh các trục một cách chính xác để vẽ biểu đồ từ nhiều tập dữ liệu trong cùng một biểu đồ có thể khó khăn. Hãy xem xét một trong các chiến lược sau:

* Hợp nhất dữ liệu trước khi vẽ biểu đồ và chuyển đổi sang định dạng "dài" với một cột biểu diễn tập dữ liệu  
* Sử dụng package **cowplot** hoặc các package tương tự để ghép hai biểu đồ (xem bên dưới)  






<!-- ======================================================= -->
## Ghép các biểu đồ {}

Hai packages phổ biến dùng để ghép các biểu đồ là **cowplot** và **patchwork**. Trong chương này chúng ta sẽ tập trung chủ yếu vào package **cowplot**, và một vài lần sử dụng package **patchwork**.  

Đây là tài liệu trực tuyến [giới thiệu về cowplot](https://cran.r-project.org/web/packages/cowplot/vignettes/introduction.html). Bạn có thể đọc thêm các tài liệu trực tuyến mở rộng hơn cho từng hàm  [tại đây](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1). Chúng tôi sẽ đề cập đến một vài trường hợp sử dụng và hàm phổ biến nhất bên dưới.  

Package **cowplot** hoạt động song song với **ggplot2** - về cơ bản, bạn sử dụng nó để sắp xếp và kết hợp các ggplots và chú giải của chúng thành một biểu đồ ghép. Package này cũng chấp nhận các biểu đồ vẽ bởi **base** R.  

```{r}
pacman::p_load(
  tidyverse,      # data manipulation and visualisation
  cowplot,        # combine plots
  patchwork       # combine plots
)
```


Trong khi faceting (được mô tả trong chương [ggplot cơ bản]) là cách tiếp cận thuận tiện để vẽ biểu đồ, nhưng đôi khi không thể đạt được kết quả bạn muốn từ cách tiếp cận tương đối hạn chế của nó. Tại đây, bạn có thể chọn kết hợp các biểu đồ bằng cách dán chúng lại với nhau thành một biểu đồ lớn hơn. Có ba packages tuyệt vời được sử dụng cho mục đích này - **cowplot**, **gridExtra**, và **patchwork**. Tuy nhiên, các package này phần lớn tương tự nhau, do đó chúng ta sẽ tập trung vào package **cowplot** trong phần này. 

### `plot_grid()` {.unnumbered}

Package **cowplot** có một số lượng lớn hàm, nhưng việc sử dụng nó dễ dàng nhất có thể đạt được thông qua việc sử dụng hàm `plot_grid()`. Đây là một cách hiệu quả để sắp xếp các biểu đồ được xác định trước theo dạng lưới. Chúng ta có thể làm việc thông qua một ví dụ khác với bộ dữ liệu sốt rét - ở đây chúng ta có thể vẽ biểu đồ tổng số ca bệnh theo huyện và cũng hiển thị đường cong dịch bệnh theo thời gian.


```{r, , warning=F, message=F}
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) 

# bar chart of total cases by district
p1 <- ggplot(malaria_data, aes(x = District, y = malaria_tot)) +
  geom_bar(stat = "identity") +
  labs(
    x = "District",
    y = "Total number of cases",
    title = "Total malaria cases by district"
  ) +
  theme_minimal()

# epidemic curve over time
p2 <- ggplot(malaria_data, aes(x = data_date, y = malaria_tot)) +
  geom_col(width = 1) +
  labs(
    x = "Date of data submission",
    y =  "number of cases"
  ) +
  theme_minimal()

cowplot::plot_grid(p1, p2,
                  # 1 column and two rows - stacked on top of each other
                   ncol = 1,
                   nrow = 2,
                   # top plot is 2/3 as tall as second
                   rel_heights = c(2, 3))


```




### Ghép các chú giải {.unnumbered}  

Nếu các biểu đồ của bạn có cùng chú giải, việc kết hợp chúng là tương đối dễ dàng. Đơn giản, hãy sử dụng phương pháp **cowplot** ở trên để kết hợp các biểu đồ, sau đó xóa chú giải khỏi một trong số chúng (loại bỏ trùng lặp).  

Nếu các biểu đồ có các chú giải khác nhau, bạn phải sử dụng cách khác:  

1) Tạo và lưu các biểu đồ *không có chú giải* bằng cách sử dụng `theme(legend.position = "none")`  
2) Trích xuất các chú giải từ từng biểu đồ sử dụng hàm `get_legend()` như được trình bày bên dưới - *nhưng trích xuất các chú giải từ các biểu đồ đã sửa đổi để thực sự hiển thị chú giải*  
3) Kết hợp các chú giải vào bảng chú giải  
4) Kết hợp các biểu đồ và bảng chú giải  


Với mục đích minh họa, chúng ta hiển thị hai biểu đồ một cách riêng biệt, sau đó sắp xếp trong một lưới với các chú giải của riêng chúng (xấu xí và không sử dụng hiệu quả không gian):  

```{r, out.width=c('50%'), fig.show='hold', warning=F, message=F}
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  labs(title = "Cases by outcome")


p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(axis.text.y = element_blank())+
  labs(title = "Cases by age")

```

Đây là khi hai biểu đồ được kết hợp sử dụng hàm `plot_grid()` mà không kết hợp các chú giải:  

```{r, warning=F, message=F}
cowplot::plot_grid(p1, p2, rel_widths = c(0.3))
```

Và bây giờ chúng ta sẽ kế hợp các chú giải. Về cơ bản chúng ta cần xác định từng biểu đồ mà *không bao gồm* chú giải của nó (`theme(legend.position = "none"`), sau đó chúng ta xác định từng chú giải của biểu đồ *một cách riêng biệt*, sử dụng hàm `get_legend()` từ package **cowplot**. Khi chúng ta trích xuất chú giải từ các biểu đồ đã lưu, chúng ta cần thêm `+` chú thích vào lại, bao gồm việc cụ thể vị trí ("bên phải") và các điều chỉnh nhỏ hơn để căn chỉnh các chú giải và tiêu đề của chúng. Sau đó, chúng ta kết hợp các chú giải lại với nhau theo chiều dọc, và rồi kết hợp hai biểu đồ lại với bảng chú giải mới.  

```{r, warning=F, message=F}

# Define plot 1 without legend
p1 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
  scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(legend.position = "none")+
  labs(title = "Cases by outcome")


# Define plot 2 without legend
p2 <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, age_cat) %>% 
  ggplot()+
  geom_col(mapping = aes(x = hospital, y = n, fill = age_cat))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+
  coord_flip()+
  theme_minimal()+
  theme(
    legend.position = "none",
    axis.text.y = element_blank(),
    axis.title.y = element_blank()
  )+
  labs(title = "Cases by age")


# extract legend from p1 (from p1 + legend)
leg_p1 <- cowplot::get_legend(p1 +
                                theme(legend.position = "right",        # extract vertical legend
                                      legend.justification = c(0,0.5))+ # so legends  align
                                labs(fill = "Outcome"))                 # title of legend
# extract legend from p2 (from p2 + legend)
leg_p2 <- cowplot::get_legend(p2 + 
                                theme(legend.position = "right",         # extract vertical legend   
                                      legend.justification = c(0,0.5))+  # so legends align
                                labs(fill = "Age Category"))             # title of legend

# create a blank plot for legend alignment
#blank_p <- patchwork::plot_spacer() + theme_void()

# create legends panel, can be one on top of the other (or use spacer commented above)
legends <- cowplot::plot_grid(leg_p1, leg_p2, nrow = 2, rel_heights = c(.3, .7))

# combine two plots and the combined legends panel
combined <- cowplot::plot_grid(p1, p2, legends, ncol = 3, rel_widths = c(.4, .4, .2))

combined  # print


```

Giải pháp này đã được học hỏi từ [bài đăng này](https://stackoverflow.com/questions/52060601/ggplot-multiple-legends-arrangement) với một thay đổi nhỏ để sắp xếp các chú giải từ [bài đăng này](https://github.com/wilkelab/cowplot/issues/33).  


<span style="color: darkgreen;">**_MẸO:_** Lưu ý vui - từ "cow" trong **cowplot** bằt nguồn từ tên của người sáng tạo ra nó - Claus O. Wilke.</span>  


### Thêm biểu đồ phụ {.unnumbered} 

Bạn cũng có thể thêm một biểu đồ nhỏ vào một biểu đồ khác sử dụng package **cowplot**. Dưới đây là những điều cần lưu ý:f:  

* Xác định biểu đồ chính với hàm `theme_half_open()` trong package **cowplot**; tốt nhất có thể có chú giải ở trên cùng hoặc dưới cùng  
* Xác định biểu đồ phụ. Tốt nhất là biểu đồ đó bạn không cần chú giải. Bạn có thể xóa các phần tử chủ đề của biểu đồ đó bằng hàm `element_blank()` như được trình bày bên dưới.  
* Kết hợp chúng bằng cách áp dụng hàm `ggdraw()` tới biểu đồ chính, rồi sau đó thêm hàm `draw_plot()` chỉ định biểu đồ phụ và cụ thể hệ trục tọa độ (x và y của góc dưới bên trái), chiều cao và chiều rộng theo tỷ lệ của toàn bộ biểu đồ chính)

```{r, out.width=c('100%'), fig.show='hold', warning=F, message=F}

# Define main plot
main_plot <- ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset, fill = hospital))+
  scale_fill_brewer(type = "qual", palette = 1, na.value = "grey")+ 
  theme_half_open()+
  theme(legend.position = "bottom")+
  labs(title = "Epidemic curve and outcomes by hospital")


# Define inset plot
inset_plot <- linelist %>% 
  mutate(hospital = recode(hospital, "St. Mark's Maternity Hospital (SMMH)" = "St. Marks")) %>% 
  count(hospital, outcome) %>% 
  ggplot()+
    geom_col(mapping = aes(x = hospital, y = n, fill = outcome))+
    scale_fill_brewer(type = "qual", palette = 4, na.value = "grey")+
    coord_flip()+
    theme_minimal()+
    theme(legend.position = "none",
          axis.title.y = element_blank())+
    labs(title = "Cases by outcome") 


# Combine main with inset
cowplot::ggdraw(main_plot)+
     draw_plot(inset_plot,
               x = .6, y = .55,    #x = .07, y = .65,
               width = .4, height = .4)

```


Kỹ thuật này được giải thích chi tiết hơn trong hai hướng dẫn sau:  

[Wilke lab](https://wilkelab.org/cowplot/articles/drawing_with_on_plots.html)  
[draw_plot() documentation](https://www.rdocumentation.org/packages/cowplot/versions/1.1.1/topics/draw_plot)




<!-- ======================================================= -->
## Trục kép {}

Trục y thứ hai thường là phần bổ sung được yêu cầu cho đồ thị `ggplot2`. Mặc dù có một cuộc tranh luận gay gắt về tính hợp lệ của các biểu đồ như vậy trong cộng đồng trực quan hóa dữ liệu và chúng thường không được khuyến nghị, nhưng người quản lý của bạn có thể vẫn muốn điều này. Dưới đây, chúng tôi trình bày một phương pháp để vẽ các biểu đồ như vậy: sử dụng package **cowplot** để kết hợp hai biểu đồ riêng biệt.  

Cách tiếp cận này bao gồm việc tạo hai biểu đồ riêng biệt - một biểu đồ có trục y ở bên trái và biểu đồ còn lại có trục y ở bên phải. Cả hai sẽ cùng sử dụng một `theme_cowplot()` và phải có cùng trục x. Sau đó, trong lệnh thứ ba, hai biểu đồ được căn chỉnh và chồng lên nhau. Các hàm chức năng của **cowplot**, được mô tả chi tiết tại trang web [này](https://wilkelab.org/cowplot/articles/aligning_plots.html).  

Để chứng minh kỹ thuật này, chúng ta sẽ phủ đường cong dịch bệnh bằng một đường biểu diễn phần trăm bệnh nhân tử vong hàng tuần. Chúng tôi sử dụng ví dụ này vì việc căn chỉnh ngày tháng trên trục x phức tạp hơn là căn chỉnh biểu đồ cột với một biểu đồ khác. Một số điều cần lưu ý:  

* Đường cong dịch bệnh và đường biểu diễn được tổng hợp thành nhiều tuần trước khi vẽ biểu đồ *và* `date_breaks` và `date_labels` giống hệt nhau - chúng ta làm điều này để trục x của hai biểu đồ giống nhau khi chúng được phủ lên nhau.  
* Trục y được chuyển sang phía bên phải cho biểu đồ 2 với đối số `position = ` của hàm `scale_y_continuous()`.  
* Cả hai biểu đồ cùng sử dụng `theme_cowplot()`  

Lưu ý rằng có một ví dụ khác về kỹ thuật này trong chương [Đường cong dịch bệnh] - phủ tỷ lệ mới mắc tích lũy lên trên đỉnh đường cong dịch bệnh.  

**Tạo biểu đồ 1**  
Đâu là biểu đồ đương cong dịch bệnh cơ bản. Chúng ta sử dụng hàm `geom_area()` chỉ để minh họa cách sử dụng của nó (mặc dịch là vùng dưới một đường)  

```{r, warning=F, message=F}
pacman::p_load(cowplot)            # load/install cowplot

p1 <- linelist %>%                 # save plot as object
     count(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     ggplot()+
          geom_area(aes(x = epiweek, y = n), fill = "grey")+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
     theme_cowplot()+
     labs(
       y = "Weekly cases"
     )

p1                                      # view plot 
```

**Tạo biểu đồ 2**  
Tạo biểu đồ thứ hai hiển thị một đường về tỷ lệ phần trăm trường hợp tử vong hàng tuần..  

```{r, warning=F, message=F}

p2 <- linelist %>%         # save plot as object
     group_by(
       epiweek = lubridate::floor_date(date_onset, "week")) %>% 
     summarise(
       n = n(),
       pct_death = 100*sum(outcome == "Death", na.rm=T) / n) %>% 
     ggplot(aes(x = epiweek, y = pct_death))+
          geom_line()+
          scale_x_date(
               date_breaks = "month",
               date_labels = "%b")+
          scale_y_continuous(
               position = "right")+
          theme_cowplot()+
          labs(
            x = "Epiweek of symptom onset",
            y = "Weekly percent of deaths",
            title = "Weekly case incidence and percent deaths"
          )

p2     # view plot
```

Bây giờ chúng ta căn chỉnh biểu đồ bằng cách sử dụng hàm `align_plots()`, cụ thể căn chỉnh theo chiều ngang và dọc ("hv", cũng có thể hoặc là "h", "v", "none"). Chúng ta cũng chỉ định căn chỉnh tất cả các trục (trên, dưới, trái, và phải) với "tblr". Đầu ra là một class list (2 phần tử).    

Sau đó, chúng tôi vẽ hai biểu đồ lại với nhau bằng cách sử dụng hàm `ggdraw()` (từ pakcage **cowplot**) à tham chiếu đến hai phần của đối tượng `aligned_plots`.  

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(p1, p2, align="hv", axis="tblr")         # align the two plots and save them as list
aligned_plotted <- ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])  # overlay them and save the visual plot
aligned_plotted                                                                # print the overlayed plots

```



<!-- ### Statistical transformation {.unnumbered}   -->
<!-- Another way to do this to have the second axis be a direct transformation of the secondary axis.  -->

<!-- Differences in axis values will be purely cosmetic - if you want to show two different variables on one graph, with different y-axis scales for each variable, this will not work without some work behind the scenes. To obtain this effect, you will have to transform one of your variables in the data, and apply the same transformation *in reverse* when specifying the axis labels. Based on this, you can either specify the transformation explicitly (e.g. variable a is around 10x as large as variable b) or calculate it in the code (e.g. what is the ratio between the maximum values of each dataset). -->


<!-- The syntax for adding a secondary axis is very straightforward! When calling a `scale_xxx_xxx()` function (e.g. `scale_y_continuous()`), use the `sec.axis` argument to call the `sec_axis()` function. The `trans` argument in this function allows you to specify the label transformation for the axis - provide this in standard tidyverse syntax.  -->

<!-- For example, if we want to show the number of positive RDTs in the malaria dataset for facility 1, showing 0-4 year olds and all cases on chart: -->


<!-- ```{r, , warning=F, message=F} -->

<!-- # take malaria data from facility 1 -->
<!-- malaria_facility_1 <- malaria_data %>% -->
<!--   filter(location_name == "Facility 1") -->

<!-- # calculate the ratio between malaria_rdt_0-4 and malaria_tot  -->

<!-- tf_ratio <- max(malaria_facility_1$malaria_tot, na.rm = T) / max(malaria_facility_1$`malaria_rdt_0-4`, na.rm = T) -->

<!-- # transform the values in the dataset -->

<!-- malaria_facility_1 <- malaria_facility_1 %>% -->
<!--   mutate(malaria_rdt_0_4_tf = `malaria_rdt_0-4` * tf_ratio) -->


<!-- # plot the graph with dual axes -->

<!-- ggplot(malaria_facility_1, aes(x = data_date)) + -->
<!--   geom_line(aes(y = malaria_tot, col = "Total cases")) + -->
<!--   geom_line(aes(y = malaria_rdt_0_4_tf, col = "Cases: 0-4 years old")) + -->
<!--   scale_y_continuous( -->
<!--     name = "Total cases", -->
<!--     sec.axis = sec_axis(trans = ~ . / tf_ratio, name = "Cases: 0-4 years old") -->
<!--   ) + -->
<!--   labs(x = "date of data collection") + -->
<!--   theme_minimal() + -->
<!--   theme(legend.title = element_blank()) -->



<!-- ``` -->






<!-- ## Sparklines   -->

<!-- UNDER CONSTRUCTION   -->
<!-- (perhaps move to Tables for presentation page) -->




## Packages giúp đỡ bạn  


Có một số package R thực sự gọn gàng được thiết kế đặc biệt để giúp bạn điều hướng **ggplot2**:  


### Giao diện kéo thả **ggplot2** với package **equisse**  {.unnumbered}

"Addin này cho phép bạn khám phá dữ liệu của mình một cách tương tác bằng cách trực quan hóa nó với package ggplot2. Nó cho phép bạn vẽ biểu đồ cột, đường cong, biểu đồ tán xạ, histograms, boxplot và các đối tượng sf, sau đó xuất biểu đồ hoặc truy xuất code để tái tạo biểu đồ."

Cài đặt và sau đó khởi chạy addin thông qua menu của RStudio hoặc gõ `esquisse::esquisser()`.

Xem thêm [Github page](https://github.com/dreamRs/esquisse)

[Documentation](https://dreamrs.github.io/esquisse/index.html)









## Tổng hợp  


### Hiển thị số {.unnumbered}  

Bạn có thể tắt ký hiệu khoa học bằng cách chạy lệnh này trước khi vẽ biểu đồ.  

```{r, eval=F}
options(scipen=999)
```

Hoặc áp dụng hàm `number_format()` từ package **scales** cho một giá trị cụ thể hoặc cột, như được trình bày bên dưới.  

Sử dụng các hàm từ package **scales** to easily adjust how numbers are displayed. để dễ dàng điều chỉnh cách hiển thị số. Chúng có thể được áp dụng cho các cột trong data frame của bạn, nhưng được hiển thị trên các số riêng lẻ cho mục đích ví dụ.  

```{r}
scales::number(6.2e5)
scales::number(1506800.62,  accuracy = 0.1,)
scales::comma(1506800.62, accuracy = 0.01)
scales::comma(1506800.62, accuracy = 0.01,  big.mark = "." , decimal.mark = ",")
scales::percent(0.1)
scales::dollar(56)
scales::scientific(100000)
```

## Nguồn

Cảm hứng
[ggplot graph gallery](https://www.tidyverse.org/blog/2018/07/ggplot2-3-0-0/)

Trình bày dữ liệu của Trung tâm Phòng ngừa và Kiểm soát Dịch bệnh Châu Âu [Guidelines of presentation of surveillance data](https://ecdc.europa.eu/sites/portal/files/documents/Guidelines%20for%20presentation%20of%20surveillance%20data-final-with-cover-for-we....pdf) 


Facets và dán nhãn
[Using labellers for facet strips](http://www.cookbook-r.com/Graphs/Facets_(ggplot2)/#modifying-facet-label-text)
[Labellers](https://ggplot2.tidyverse.org/reference/labellers.html)

Điều chỉnh thức bậc biến factors
[fct_reorder](https://forcats.tidyverse.org/reference/fct_reorder.html)  
[fct_inorder](https://forcats.tidyverse.org/reference/fct_inorder.html)  
[How to reorder a boxplot](https://cmdlinetips.com/2019/02/how-to-reorder-a-boxplot-in-r/)  
[Reorder a variable in ggplot2](https://www.r-graph-gallery.com/267-reorder-a-variable-in-ggplot2.html)  
[R for Data Science - Factors](https://r4ds.had.co.nz/factors.html)  

Chú giải  
[Adjust legend order](https://stackoverflow.com/questions/38425908/reverse-stacking-order-without-affecting-legend-order-in-ggplot2-bar-charts)  

Chú thích
[Caption alignment](https://stackoverflow.com/questions/64701500/left-align-ggplot-caption)  

Nhãn 
[ggrepel](https://ggrepel.slowkow.com/articles/examples.html)  

Cheatsheets  
[Beautiful plotting with ggplot2](http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/)  




<!-- TO DO - Under construction -->


<!-- * Straight horizontal, vertical, or other line -->

<!-- You can also add straight lines to your plot with `geom_hline()` (horizontal), `geom_vline()` (vertical) or `geom_abline()` (with a specified y intercept and slope) -->


<!-- Using option `label_wrap_gen` in facet_wrap to have multiple strip lines -->
<!-- labels and colors of strips -->

<!-- Axis text vertical adjustment -->
<!-- rotation -->
<!-- Labellers -->

<!-- limit range with limit() and coord_cartesian(), ylim(), or scale_x_continuous() -->
<!-- theme_classic() -->

<!-- expand = c(0,0) -->
<!-- coord_flip() -->
<!-- tick marks -->

<!-- ggrepel -->
<!-- animations -->

<!-- remove -->
<!-- remove title -->
<!-- using fill = or color = in labs() -->
<!-- flip order / don't flip order -->
<!-- move location -->
<!-- color?    theme(legend.title = element_text(colour="chocolate", size=16, face="bold"))+ scale_color_discrete(name="This color is\ncalled chocolate!?") -->
<!-- Color of boxes behind points in legend  -->
<!--      theme(legend.key=element_rect(fill='pink'))   or use fill = NA to remove them. http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/  -->
<!-- Change size of symbols in legend only guides(colour = guide_legend(override.aes = list(size=4))) -->


<!-- Turn off a layer in the legend -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp)), size=4) -->
<!-- geom_text(data=nmmaps, aes(date, temp, label=round(temp), size=4), show_guide=FALSE) -->

<!-- Force a legend even if there is no aes().  -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+ -->
<!--      geom_line(aes(color="Important line"))+ -->
<!--      geom_point(aes(color="My points")) -->
<!-- Control the shape in the legend with guides - a list with linetype and shape -->
<!-- ggplot(nmmaps, aes(x=date, y=o3))+geom_line(aes(color="Important line"))+ -->
<!--    geom_point(aes(color="Point values"))+ -->
<!--   scale_colour_manual(name='', values=c('Important line'='grey', 'Point values'='red'), guide='legend') + -->
<!--   guides(colour = guide_legend(override.aes = list(linetype=c(1,0) -->
<!--                                                       , shape=c(NA, 16)))) -->
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/ggplot_tips.Rmd-->

# Đường cong dịch bệnh {#epicurves}

```{r, out.width=c('75%'), echo=F, message=F}
knitr::include_graphics(here::here("images", "epicurve_top.png"))
```

Đường cong dịch bệnh (còn được gọi là "đường cong epi") là một biểu đồ dịch tễ học cốt lõi thường được sử dụng để trực quan xu hướng khởi phát bệnh theo thời gian trong một cụm hoặc nhóm ca bệnh.

Phân tích đường cong dịch bệnh có thể cho biết xu hướng theo thời gian, giá trị ngoại lai, mức độ bùng phát dịch, khoảng thời gian có khả năng bị phơi nhiễm cao nhất, khoảng thời gian giữa các thế hệ ca bệnh và thậm chí có thể giúp xác định phương thức lây truyền của một căn bệnh không xác định (ví dụ: điểm bắt nguồn, nguồn tiếp diễn phổ biến, lây truyền từ người sang người). Bạn có thể tìm thấy một bài học trực tuyến về giải thích các đường cong dịch bệnh tại trang web của [CDC Hoa Kỳ](https://www.cdc.gov/training/quicklearns/epimode/index.html).

Trong chương này, chúng tôi trình bày hai cách tiếp cận để tạo ra đường cong dịch bệnh trong R:

-   Package **incidence2**, có thể tạo ra đường cong dịch bệnh với các lệnh đơn giản\
-   Package **ggplot2**, cho phép khả năng tùy chỉnh nâng cao thông qua các lệnh phức tạp hơn

Chúng tôi cũng sẽ giải quyết các trường hợp cụ thể như:

-   Lập biểu đồ dữ liệu đếm tổng hợp\
-   Faceting hoặc tạo nhiều cấu phần nhỏ\
-   Áp dụng đường trung bình động\
-   Hiển thị dữ liệu "dự kiến" hoặc có thể bị chậm trễ trong báo cáo\
-   Thêm tỷ lệ ca nhiễm mới tích lũy bằng cách sử dụng trục thứ hai

<!-- ======================================================= -->

## Chuẩn bị

### Packages {.unnumbered}

Đoạn code này hiển thị cách gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, sẽ cài đặt package nếu cần *và* gọi package để sử dụng. Bạn cũng có thể cài đặt package với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r message=F, warning=F}
pacman::p_load(
  rio,          # file import/export
  here,         # relative filepaths 
  lubridate,    # working with dates/epiweeks
  aweek,        # alternative package for working with dates/epiweeks
  incidence2,   # epicurves of linelist data
  i2extras,     # supplement to incidence2
  stringr,      # search and manipulate character strings
  forcats,      # working with factors
  RColorBrewer, # Color palettes from colorbrewer2.org
  tidyverse     # data management + ggplot2 graphics
) 
```

### Nhập dữ liệu {.unnumbered}

Hai bộ dữ liệu mẫu được sử dụng trong chương này:

-   Bộ số liệu `linelist` về các ca bệnh từ một vụ dịch mô phỏng\
-   Số lượng tổng hợp theo bệnh viện từ cùng một dịch bệnh mô phỏng bên trên

Các bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau.

```{r, echo=F, message=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

**Bộ số liệu `linelist`**

Chúng ta nhập bộ dữ liệu về các ca bệnh mô phỏng từ một vụ dịch Ebola. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương [Tải sách và dữ liệu]. Chúng tôi giả sử các tệp tin nằm trong thư mục làm việc nên không có thư mục con nào được chỉ định trong đường dẫn này.

```{r, eval=F}
linelist <- import("linelist_cleaned.xlsx")
```

50 dòng đầu tiên được hiển thị như bên dưới:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

**Số lượng ca bệnh do bệnh viện tổng hợp**

Theo mục tiêu của cuốn sách này, bộ dữ liệu về số lượng tổng hợp hàng tuần theo bệnh viện được tạo từ `linelist` với đoạn code sau.

```{r, eval=F}
# import the counts data into R
count_data <- linelist %>% 
  group_by(hospital, date_hospitalisation) %>% 
  summarize(n_cases = dplyr::n()) %>% 
  filter(date_hospitalisation > as.Date("2013-06-01")) %>% 
  ungroup()
```

50 dòng đầu tiên được hiển thị như bên dưới:

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Thiết lập các tham số {.unnumbered}

Để tạo báo cáo, bạn có thể muốn thiết lập các thông số có thể chỉnh sửa, chẳng hạn như ngày dữ liệu hiện tại ("ngày dữ liệu"). Sau đó, bạn có thể tham chiếu đối tượng `data_date` trong code khi áp dụng bộ lọc hoặc trong chú thích động.

```{r set_parameters}
## set the report date for the report
## note: can be set to Sys.Date() for the current date
data_date <- as.Date("2015-05-15")
```

### Xác minh ngày {.unnumbered}

Xác minh rằng mỗi cột ngày có liên quan là phân lớp Ngày và có phạm vi giá trị thích hợp. Bạn có thể thực hiện việc này đơn giản bằng cách sử dụng hàm `hist()` cho histogram hoặc hàm `range()` với `na.rm=TRUE`, hoặc với hàm `ggplot()` như bên dưới.

```{r, out.width = c('50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# check range of onset dates
ggplot(data = linelist)+
  geom_histogram(aes(x = date_onset))
```

<!-- ======================================================= -->

## Đường cong dịch bệnh với package **incidence2**

Dưới đây, chúng tôi trình bày cách tạo các đường cong dịch bệnh bằng cách sử dụng package **precision2**. Các tác giả của package này đã cố gắng cho phép người dùng tạo và sửa đổi các đường cong dịch bệnh mà không cần biết cú pháp **ggplot2**. Phần lớn nội dung của chương này được điều chỉnh từ **minh họa** của package, bạn có thể tìm thấy tại trang [github](https://github.com/reconhub/incidence2) của package **incidence2**.

<!-- ======================================================= -->

### Ví dụ đơn giản {.unnumbered}

**Cần có 2 bước để vẽ đường cong dịch bệnh với package *incidence2*:**

1)  **Tạo** một *incidence object* (sử dụng hàm `incidence()`)

    -   Cung cấp dữ liệu\
    -   Xác định cột ngày tại `date_index =`\
    -   Xác định khoảng thời gian `interval =` các ca nên được tổng hợp (hàng ngày, tuần, tháng..)\
    -   Xác định bất kỳ cột dùng để nhóm nào (ví dụ như giới tính, bệnh viện, kết quả)\

2)  **Vẽ biểu đồ** incidence object

    -   Xác định nhãn, màu, tiêu đề, ...

Dưới đây, chúng tôi gọi package **incidence2**, tạo incidence object từ dữ liệu `linelist` trên cột `date_onset` và tổng hợp các trường hợp theo ngày. Sau đó, chúng tôi in ra tóm tắt về đối tượng incidence object.

```{r, warning=F, message=F}
# load incidence2 package
pacman::p_load(incidence2)

# create the incidence object, aggregating cases by day
epi_day <- incidence(       # create incidence object
  x = linelist,             # dataset
  date_index = date_onset,  # date column
  interval = "day"          # date grouping interval
  )
```

Đối tượng **incidence2** trông giống như một tibble (một kiểu data frame) và có thể được hiển thị hoặc thao tác thêm như một bộ dữ liệu.

```{r}
class(epi_day)
```

Đây là thông tin khi được hiển thị. Nó có một cột `date_index` và một cột `count` .

```{r}
epi_day
```

Bạn cũng có thể tổng hợp thông tin của đối tượng:

```{r}
# print summary of the incidence object
summary(epi_day)
```

Để *vẽ biểu đồ incidence object*, hãy sử dụng hàm `plot()` với *tên của incidence object*. Trong nền, hàm `plot.incidence2()` đã được gọi, vì vậy để đọc tài liệu cụ thể về **incidence2**, bạn cần chạy lệnh `?plot.incidence2`.

```{r}
# plot the incidence object
plot(epi_day)
```

Nếu bạn nhận thấy nhiều đường dọc nhỏ màu trắng, hãy cố gắng điều chỉnh kích thước hình ảnh của bạn. Ví dụ: nếu bạn xuất biểu đồ bằng `ggsave()`, bạn có thể cung cấp giá trị số cho `width =` và `height =`. Nếu bạn mở rộng biểu đồ, những đường đó có thể biến mất.

### Thay đổi khoảng thời gian tổng hợp ca bệnh {.unnumbered}

Đối số `interval =` của hàm `incidence()` xác định cách các quan sát được nhóm thành các cột dọc trong biểu đồ.

**Xác định khoảng thời gian**

**incidence2** đem lại sự linh hoạt và cú pháp dễ hiểu để bạn có thể dễ dàng tổng hợp số ca bệnh thành các biểu đồ cột-đường cong dịch bệnh. Cung cấp một giá trị như những giá trị bên dưới cho đối số `interval =`. Bạn có thể viết bất kỳ thông tin nào bên dưới dưới dạng số nhiều (ví dụ: "week**s**") và bạn có thể thêm số phía trước (ví dụ: "3 months").

| Tùy chọn đối số         | Giải thích thêm                                           |
|-------------------------|-----------------------------------------------------------|
| Số (1, 7, 13, 14, etc.) | số ngày cho mỗi khoảng thời gian                          |
| "weeks"                 | ghi chú: mặc định ngày bắt đầu là Thứ 2                   |
| "2 weeks"               | hoặc 3, 4, 5...                                           |
| "Sunday weeks"          | tuần bắt đầu tính từ Chủ nhật (cũng có thể là Thứ 5, ...) |
| "2 Sunday weeks"        | hoặc 3, 4, 5...                                           |
| "MMWRweek"              | tuần bắt đầu vào Chủ nhật - xem thêm tại CDC Hoa Kỳ       |
| "month"                 | ngày đầu tiên của tháng                                   |
| "quarter"               | ngày đầu tiên của tháng của một quí                       |
| "2 months"              | hoặc 3, 4, 5...                                           |
| "year"                  | ngày đầu tiên của năm                                     |

Dưới đây là ví dụ về các khoảng thời gian khác nhau trông như thế nào khi áp dụng vào bộ số liệu `linelist`. Lưu ý cách mà định dạng mặc định và tần suất của các *nhãn* thời gian trên trục x thay đổi khi khoảng thời gian thay đổi.

```{r incidence, out.width=c('50%', '50%', '50%', '50%'), fig.show='hold', warning=F, message=F}
# Create the incidence objects (with different intervals)
##############################
# Weekly (Monday week by default)
epi_wk      <- incidence(linelist, date_onset, interval = "Monday week")

# Sunday week
epi_Sun_wk  <- incidence(linelist, date_onset, interval = "Sunday week")

# Three weeks (Monday weeks by default)
epi_2wk     <- incidence(linelist, date_onset, interval = "2 weeks")

# Monthly
epi_month   <- incidence(linelist, date_onset, interval = "month")

# Quarterly
epi_quarter   <- incidence(linelist, date_onset, interval = "quarter")

# Years
epi_year   <- incidence(linelist, date_onset, interval = "year")


# Plot the incidence objects (+ titles for clarity)
############################
plot(epi_wk)+      labs(title = "Monday weeks")
plot(epi_Sun_wk)+  labs(title = "Sunday weeks")
plot(epi_2wk)+     labs(title = "2 (Monday) weeks")
plot(epi_month)+   labs(title = "Months")
plot(epi_quarter)+ labs(title = "Quarters")
plot(epi_year)+    labs(title = "Years")

```

<!--**Bắt đầu với ca đầu tiên**-->

<!--Nếu bạn muốn các khoảng thời gian bắt đầu ở trường hợp đầu tiên, bạn có thể thêm argument `standard = TRUE` vào lệnh `incidence()`. Điều này chỉ hoạt động nếu khoảng thời gian là "tuần", "tháng", "quý" hoặc "năm".-->

**Ngày đầu tiên**

Bạn có thể tùy chọn chỉ định một giá trị thuộc phân lớp Ngày (ví dụ: `as.Date("2016-05-01")`) tới đối số `firstdate =` trong lệnh `incidence()`. Nếu được cung cấp, dữ liệu sẽ được cắt bớt theo phạm vi này và khoảng thời gian sẽ bắt đầu từ ngày này.

### Nhóm {.unnumbered}

Các nhóm được chỉ định trong lệnh `incidence()` và có thể được sử dụng để tô màu cho các cột hoặc facet dữ liệu. Để chỉ định các nhóm trong dữ liệu của bạn, hãy cung cấp tên cột tới đối số `groups =` trong hàm `incidence()` (không có dấu ngoặc kép xung quanh tên cột). Nếu chỉ định nhiều cột, hãy để tên các cột bên trong hàm `c()`.

Bạn có thể chỉ định rằng các trường hợp có giá trị bị thiếu trong các cột được nhóm được liệt kê như một nhóm `NA` riêng biệt bằng cách thiết lập `na_as_group = TRUE`. Nếu không, chúng sẽ bị loại khỏi biểu đồ.

-   Để *tô màu các cột theo cột nhóm*, bạn cần cung cấp lại tên cột tới đối số `fill =` trong lệnh `plot()`.

-   Để *facet dựa trên cột nhóm*, hãy xem phần bên dưới về facet với **incidence2**.

Trong ví dụ dưới đây, các trường hợp trong toàn bộ đợt bùng phát được nhóm theo phân loại tuổi của họ. Các giá trị thiếu được đưa vào một nhóm. Khoảng thời gian của đường cong bệnh dịch là tuần.

```{r, message=F, warning=F}
# Create incidence object, with data grouped by age category
age_outbreak <- incidence(
  linelist,                # dataset
  date_index = date_onset, # date column
  interval = "week",       # Monday weekly aggregation of cases
  groups = age_cat,        # age_cat is set as a group
  na_as_group = TRUE)      # missing values assigned their own group

# plot the grouped incidence object
plot(
  age_outbreak,             # incidence object with age_cat as group
  fill = age_cat)+          # age_cat is used for bar fill color (must have been set as a groups column above)
labs(fill = "Age Category") # change legend title from default "age_cat" (this is a ggplot2 modification)
```

[***MẸO***: Thay đổi tiêu đề của chú giải bằng cách thêm `+` lệnh **ggplot2** `labs(fill = "your title")` vào biểu đồ **incidence2**.]{style="color: darkgreen;"}

Bạn cũng có thể để các cột được nhóm hiển thị cạnh nhau bằng cách đặt `stack = FALSE` trong `plot()`, như được hiển thị bên dưới:

```{r, warning=F, message=F}
# Make incidence object of monthly counts. 
monthly_gender <- incidence(
 linelist,
 date_index = date_onset,
 interval = "month",
 groups = gender            # set gender as grouping column
)

plot(
  monthly_gender,   # incidence object
  fill = gender,    # display bars colored by gender
  stack = FALSE)    # side-by-side (not stacked)
```

Bạn có thể đặt đối số `na_as_group =` thành FALSE trong lệnh `incidence()` để loại bỏ các hàng có giá trị bị thiếu khỏi biểu đồ.

### Lọc dữ liệu {.unnumbered}

Để vẽ biểu đồ đường cong dịch bệnh của một bộ dữ liệu con:

1)  Lọc bộ số liệu `linelist`\
2)  Cung cấp dữ liệu đã lọc vào lệnh `incidence()`\
3)  Vẽ biểu đồ incidence object

Ví dụ dưới đây sử dụng dữ liệu được lọc để chỉ hiển thị các trường hợp tại Central Hospital.

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(central_data, date_index = date_onset, interval = "week")

# plot the incidence object
plot(central_outbreak, title = "Weekly case incidence at Central Hospital")
```

### Số lượng tổng hợp {.unnumbered}

Nếu dữ liệu ban đầu của bạn được tổng hợp (số lượng), hãy cung cấp tên của cột chứa thông tin về số lượng ca tới đối số `count =` khi tạo incidence object với hàm `incidence()`.

Ví dụ, data frame `count_data` này được tổng hợp từ linelist theo số lượng hàng ngày theo bệnh viện. 50 hàng đầu tiên hiển thị như sau:

```{r message=FALSE, echo=F}
DT::datatable(head(count_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Nếu bạn đang bắt đầu phân tích với dữ liệu đếm hàng ngày như bộ dữ liệu ở trên, thì lệnh `incidence()` để chuyển đổi dữ liệu này thành đường cong dịch bệnh hàng tuần theo bệnh viện sẽ trông như sau:

```{r}
epi_counts <- incidence(              # create weekly incidence object
  count_data,                         # dataset with counts aggregated by day
  date_index = date_hospitalisation,  # column with dates
  count = n_cases,                    # column with counts
  interval = "week",                  # aggregate daily counts up to weeks
  groups = hospital                   # group by hospital
  )

# plot the weekly incidence epi curve, with stacked bars by hospital
plot(epi_counts,                      # incidence object
     fill = hospital)                 # color the bars by hospital
```

### Facets/Các biểu đồ nhỏ {.unnumbered}

Để facet dữ liệu theo nhóm (ví dụ tạo "các biểu đồ nhỏ"):

1)  Xác định các cột dùng để facet tới đối số `groups =` khi bạn tạo incidence object\
2)  Sử dụng lệnh `facet_plot()` thay cho `plot()`\
3)  Xác định cột nhóm nào được sử dụng cho `fill =` và cho `facets =`

Dưới đây, chúng ta thiết lập cả hai cột `hospital` và `outcome` làm cột chia nhóm trong lệnh `incidence()`. Sau đó, trong lệnh `facet_plot()`, chúng ta vẽ biểu đồ đường cong dịch bệnh, chỉ rõ rằng chúng ta muốn có các đường cong dịch bệnh khác nhau cho mỗi bệnh viện và trong mỗi đường cong dịch bệnh, các cột được xếp chồng lên nhau và được tô màu theo outcome.

```{r, warning=F, message=F}
epi_wks_hosp_out <- incidence(
  linelist,                      # dataset
  date_index = date_onset,       # date column
  interval = "month",            # monthly bars  
  groups = c(outcome, hospital)  # both outcome and hospital are given as grouping columns
  )

# plot
incidence2::facet_plot(
  epi_wks_hosp_out,      # incidence object
  facets = hospital,     # facet column
  fill = outcome)        # fill column

```

Lưu ý rằng package **ggtree** (được sử dụng để trực quan cây phả hệ) cũng có một hàm là `facet_plot()` - đây là lý do tại sao chúng ta phải cụ thể `incidence2::facet_plot()` như ở trên.

### Hiệu chỉnh với `plot()` {.unnumbered}

Một đường cong dịch bệnh được tạo ra bởi **incidence2** có thể được sửa đổi thông qua các đối số *trong hàm `plot()`*.

**Dưới đây là các đối số của hàm `plot()` dùng để điều chỉnh hình thức cột:**

+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| Đối số         | Mô tả                                                                                                                   | Ví dụ                                                                |
+================+=========================================================================================================================+======================================================================+
| `fill =`       | Màu cột. Tên màu hoặc tên cột đã được chỉ định trước đó tới đối số `groups =` trong lệnh `incidence()`                  | `fill = "red"`, hoặc `fill = gender`                                 |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| `color =`      | Tô màu xung quanh mỗi cột hoặc xung quanh mỗi nhóm trong một cột                                                        | `border = "white"`                                                   |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| `legend =`     | Vị trí danh mục                                                                                                         | Một trong các lựa chọn "bottom", "top", "left", "right", hoặc "none" |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| `alpha =`      | Độ trong suốt của cột                                                                                                   | 1 là đục hoàn toàn, 0 là trong suốt hoàn toàn                        |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| `width =`      | Giá trị từ 0 đến 1 cho biết kích thước tương đối của các cột với khoảng thời gian của chúng                             | `width = .7`                                                         |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+
| `show_cases =` | Giá trị logic; nếu TRUE, mỗi trường hợp hiển thị như một hộp. Cách hiển thị này là tốt nhất trên các đợt bùng phát nhỏ. | `show_cases = TRUE`                                                  |
+----------------+-------------------------------------------------------------------------------------------------------------------------+----------------------------------------------------------------------+

**Dưới đây là các đối số của hàm `plot()` để sửa đổi trục ngày tháng:**

+------------------+--------------------------------------------------------------------------------------------------------------------------------+
| Đối số           | Mô tả                                                                                                                          |
+==================+================================================================================================================================+
| `centre_dates =` | TRUE/FALSE tương đương với việc hiển thị ngày tháng xuất hiện ở dưới trung tâm các cột hay ở trên đỉnh các cột                 |
+------------------+--------------------------------------------------------------------------------------------------------------------------------+
| `date_format =`  | Điều chỉnh định dạng hiển thị ngày bằng cú pháp `strptime("%")`. Chỉ hoạt động nếu `centre_dates = FALSE` (chi tiết bên dưới). |
+------------------+--------------------------------------------------------------------------------------------------------------------------------+
| `n.breaks =`     | Khoảng số lượng nhãn ngắt khoảng trên trục x mong muốn.                                                                        |
+------------------+--------------------------------------------------------------------------------------------------------------------------------+
| `angle =`        | Góc nghiêng của nhãn ngày trên trục x (số độ)                                                                                  |
+------------------+--------------------------------------------------------------------------------------------------------------------------------+
| `size =`         | Kích thước của văn bản tính bằng điểm                                                                                          |
+------------------+--------------------------------------------------------------------------------------------------------------------------------+

Lưu ý rằng đối số `date_breaks =` chỉ hoạt động nếu `centre_dates = FALSE`. Cung cấp giá trị ký tự trong dấu ngoặc kép bằng cú pháp strptime như bên dưới, như đã được trình bày chi tiết trong chương [Làm việc với ngày tháng]. Bạn có thể sử dụng `\n` để tạo "dòng mới".

%d = Số ngày của tháng (5, 17, 28, ...)\
%j = Số ngày của năm (ngày Julian 001-366)\
%a = Ngày trong tuần viết tắt (Mon, Tue, Wed, ...)\
%A = Ngày trong tuần viết đầy đủ (Monday, Tuesday, ...)\
%w = Số thứ tự ngày của tuần (0-6, Chủ nhật là 0)\
%u = Số thứ tự ngày của tuần (1-7, Thứ hai là 1)\
%W = Số thứ tự tuần (00-53, Thứ hai là ngày bắt đầu tuần mới)\
%U = Số thứ tự tuần (01-53, Chủ nhật là ngày bắt đầu tuần mới)\
%m = Số thứ tự tháng (Ví dụ 01, 02, 03, 04)\
%b = Tháng viết tắt (Jan, Feb, ...)\
%B = Tháng viết đầy đủ (January, February, ...)\
%y = Năm viết dạng 2 ký tự (Ví dụ 89)\
%Y = Năm viết dạng 2 ký tự (Ví dụ 1989)\
%H = giờ (khung 24 giờ)\
%M = phút\
%S = giây\
%z = bù từ múi giờ GMT\
%Z = Múi giờ (ký tự)

<!--<span style="color: darkgreen;">**_MẸO:_** Đối với ngắt mỗi khoảng "thứ n" (ví dụ: mỗi khoảng thứ 4), hãy sử dụng `n.breaks = nrow(i)/n` (trong đó "i" là tên chỉ số tỷ lệ mắc bệnh và "n" là một số). Nếu dữ liệu của bạn được nhóm lại, bạn sẽ cần nhân "n" với số nhóm duy nhất.</span>-->

**Dưới đây là các đối số trong hàm `plot()` để hiệu chỉnh các nhãn trong biểu đồ:**

+-----------+----------------------------------------------------------------------------------------------------------------------------------------------+
| Đối số    | Mô tả                                                                                                                                        |
+===========+==============================================================================================================================================+
| `title =` | Tiêu đề của biểu đồ                                                                                                                          |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------+
| `xlab =`  | Tiêu đề của trục x                                                                                                                           |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------+
| `ylab =`  | Tiêu đề của trục y                                                                                                                           |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------+
| `size =`  | Kích thước của đoạn văn bản trên trục x tính bằng đơn vị pts (sử dụng hàm `theme()` trong ggplot để điều chỉnh các thông số kích thước khác) |
+-----------+----------------------------------------------------------------------------------------------------------------------------------------------+

Một ví dụ sử dụng kết hợp các đối số ở trên:

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = outcome)

# plot incidence object
plot(
  central_outbreak,
  fill = outcome,                       # box/bar color
  legend = "top",                       # legend on top
  title = "Cases at Central Hospital",  # title
  xlab = "Week of onset",               # x-axis label
  ylab = "Week of onset",               # y-axis label
  show_cases = TRUE,                    # show each case as an individual box
  alpha = 0.7,                          # transparency 
  border = "grey",                      # box border
  angle = 30,                           # angle of date labels
  centre_dates = FALSE,                 # date labels at edge of bar
  date_format = "%a %d %b %Y\n(Week %W)" # adjust how dates are displayed
  )
```

Để điều chỉnh thêm giao diện hiển thị của biểu đồ, hãy xem mục bên dưới về các hiệu chỉnh với hàm `ggplot()`.

### Hiệu chỉnh với ggplot2 {.unnumbered}

Bạn có thể hiệu chỉnh biểu đồ được tạo bởi **incidence2** bằng cách thêm các hiệu chỉnh **ggplot2** với dấu `+` sau khi đóng ngoặc hàm biểu diễn tỷ lệ mắc bệnh `plot()`, như được minh họa bên dưới.

Dưới đây, biểu đồ **incidence2** kết thúc và ngay sau đó các lệnh **ggplot2** được sử dụng để sửa đổi các trục, thêm chú thích và điều chỉnh phông chữ đậm và kích thước chữ.

Lưu ý rằng nếu bạn thêm `scale_x_date()`, hầu hết các định dạng ngày từ `plot()` sẽ bị ghi đè. Xem mục đường cong dịch bệnh với `ggplot()` và chương [Các tips với ggplot] để có thêm lựa chọn.

```{r, warning=F, message=F}
# filter the linelist
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")

# create incidence object using filtered data
central_outbreak <- incidence(
  central_data,
  date_index = date_onset,
  interval = "week",
  groups = c(outcome))

# plot incidence object
plot(
  central_outbreak,
  fill = outcome,                       # box/bar color
  legend = "top",                       # legend on top
  title = "Cases at Central Hospital",  # title
  xlab = "Week of onset",               # x-axis label
  ylab = "Week of onset",               # y-axis label
  show_cases = TRUE,                    # show each case as an individual box
  alpha = 0.7,                          # transparency 
  border = "grey",                      # box border
  centre_dates = FALSE,                   
  date_format = "%a %d %b\n%Y (Week %W)", 
  angle = 30                           # angle of date labels
  )+
  
  scale_y_continuous(
    breaks = seq(from = 0, to = 30, by = 5),  # specify y-axis increments by 5
    expand = c(0,0))+                         # remove excess space below 0 on y-axis
  
  # add dynamic caption
  labs(
    fill = "Patient outcome",                               # Legend title
    caption = stringr::str_glue(                            # dynamic caption - see page on characters and strings for details
      "n = {central_cases} from Central Hospital
      Case onsets range from {earliest_date} to {latest_date}. {missing_onset} cases are missing date of onset and not shown",
      central_cases = nrow(central_data),
      earliest_date = format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),
      latest_date = format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y'),      
      missing_onset = nrow(central_data %>% filter(is.na(date_onset)))))+
  
  # adjust bold face, and caption position
  theme(
    axis.title = element_text(size = 12, face = "bold"),    # axis titles larger and bold
    axis.text = element_text(size = 10, face = "bold"),     # axis text size and bold
    plot.caption = element_text(hjust = 0, face = "italic") # move caption to left
  )
  
```

### Đổi màu {.unnumbered}

#### Chỉ định bảng màu {.unnumbered}

Cung cấp tên của bảng màu đã được định danh trước tới tham số `col_pal =` trong hàm `plot()`. Package **incidence2** đi kèm với 2 bảng màu được xác định trước: "vibrant" và "muted". Trong "vibrant", có 6 màu đầu tiên là riêng biệt và trong "muted" có 9 màu đầu tiên là khác biệt. Sau những con số này, các màu là sự thêm vào/trung gian của các màu khác. Bạn có thể tìm thấy những bảng màu được xác định trước này tại [website này](https://personal.sron.nl/~pault/#sec:qualitative). Các bảng màu loại trừ màu xám, do nó được dành riêng cho dữ liệu bị thiếu (sử dụng `na_color =` để thay đổi mặc định này).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# Create incidence object, with data grouped by age category  
age_outbreak <- incidence(
  linelist,
  date_index = date_onset,   # date of onset for x-axis
  interval = "week",         # weekly aggregation of cases
  groups = age_cat)

# plot the epicurve with default palette
plot(age_outbreak, fill = age_cat, title = "'vibrant' default incidence2 palette")

# plot with different color palette
#plot(age_outbreak, fill = age_cat, col_pal = muted, title = "'muted' incidence2 palette")
```

Bạn cũng có thể sử dụng một trong các bảng màu trong **base** R (đặt tên của bảng màu *không* có dấu ngoặc kép).

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
# plot with base R palette
plot(age_outbreak, fill = age_cat, col_pal = heat.colors, title = "base R heat.colors palette")

# plot with base R palette
plot(age_outbreak, fill = age_cat, col_pal = rainbow, title = "base R rainbow palette")
```

Bạn cũng có thể thêm bảng màu từ package **viridis** hoặc package **RColorBrewer**. Đầu tiên các package đó cần được tải, sau đó thêm các hàm `scale_fill_*()` tương ứng của chúng bằng dấu `+`, như bên dưới đây.

```{r out.width = c('50%', '50%'), fig.show='hold', warning = F, message = F}
pacman::p_load(RColorBrewer, viridis)

# plot with color palette
plot(age_outbreak, fill = age_cat, title = "Viridis palette")+
  scale_fill_viridis_d(
    option = "inferno",     # color scheme, try also "plasma" or the default
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values

# plot with color palette
plot(age_outbreak, fill = age_cat, title = "RColorBrewer palette")+
  scale_fill_brewer(
    palette = "Dark2",      # color palette, try also Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3
    name = "Age Category",  # legend name
    na.value = "grey")      # for missing values
```

#### Xác định thủ công {.unnumbered}

Để chỉ định màu theo cách thủ công, hãy thêm hàm `scale_fill_manual()` trong **ggplot2** sau hàm `plot()` bằng dấu `+` và cung cấp vectơ tên màu hoặc mã HEX tới đối số `values =`. Số lượng màu được liệt kê phải bằng số nhóm. Hãy lưu ý, các giá trị bị thiếu có phải là một nhóm hay không - chúng có thể được chuyển đổi thành giá trị dạng ký tự chẳng hạn như "Missing" trong quá trình chuẩn bị dữ liệu của bạn bằng hàm `fct_explicit_na()`, như đã được giải thích trong chương [Factors].

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}
# manual colors
plot(age_outbreak, fill = age_cat, title = "Manually-specified colors")+
  scale_fill_manual(
    values = c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange", "red", "lightblue"),  # colors
    name = "Age Category")      # Name for legend
```

Như đã đề cập trong chương [Các tips với ggplot], bạn có thể tạo bảng màu của riêng mình bằng cách sử dụng hàm `colorRampPalette()` trên một vectơ chứa tên các màu sắc và chỉ định số màu bạn muốn trả về. Đây là một cách tốt để có thể thu được nhiều màu trong một lần bằng cách chỉ định một vài màu.

```{r}
my_cols <- c("darkgreen", "darkblue", "purple", "grey", "yellow", "orange")
my_palette <- colorRampPalette(my_cols)(12)  # expand the 6 colors above to 12 colors
my_palette
```

### Điều chỉnh thứ bậc {.unnumbered}

Để điều chỉnh thứ tự xuất hiện của nhóm (trên biểu đồ và trong chú giải), cột phân nhóm cần phải là kiểu Factor. Xem chương [Factors] để biết thêm thông tin.

Đầu tiên, chúng ta hãy quan sát một đường cong dịch bệnh hàng tuần theo bệnh viện với thứ tự mặc định:

```{r, message=F, warning=F}
# ORIGINAL - hospital NOT as factor
###################################

# create weekly incidence object, rows grouped by hospital and week
hospital_outbreak <- incidence(
  linelist,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# plot incidence object
plot(hospital_outbreak, fill = hospital, title = "ORIGINAL - hospital not a factor")
```

Bây giờ, để điều chỉnh thứ tự sao cho nhóm phân loại "Missing" và "Other" ở trên cùng của đường cong dịch bệnh, chúng ta có thể làm như sau:

-   Gọi package **forcats**, để làm việc với cột định dạng factor\

-   Điều chỉnh bộ dữ liệu - trong trường hợp này, chúng tôi sẽ xác định một bộ dữ liệu mới (`plot_data`) trong đó:

    -   Cột `gender` được xác định là một biến phân loại có thứ bậc được thiết lập bằng hàm `fct_relevel()` sao cho "Other" và "Missing" đứng đầu tiên, do đó chúng xuất hiện ở trên đầu các cột\

-   Incidence object được tạo và vẽ biểu đồ như trước đó\

-   Chúng ta thêm các điều chỉnh **ggplot2**

    -   `scale_fill_manual()` để gán màu theo cách thủ công sao cho "Missing" là màu xám và "Other" là màu be

```{r, message=F, warning=F}
# MODIFIED - hospital as factor
###############################

# load forcats package for working with factors
pacman::p_load(forcats)

# Convert hospital column to factor and adjust levels
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Set "Missing" and "Other" as top levels


# Create weekly incidence object, grouped by hospital and week
hospital_outbreak_mod <- incidence(
  plot_data,
  date_index = date_onset, 
  interval = "week", 
  groups = hospital)

# plot incidence object
plot(hospital_outbreak_mod, fill = hospital)+
  
  # manual specify colors
  scale_fill_manual(values = c("grey", "beige", "darkgreen", "green2", "orange", "red", "pink"))+                      

  # labels added via ggplot
  labs(
      title = "MODIFIED - hospital as factor",   # plot title
      subtitle = "Other & Missing at top of epicurve",
      y = "Weekly case incidence",               # y axis title  
      x = "Week of symptom onset",               # x axis title
      fill = "Hospital")                         # title of legend     
```

[***MẸO***: Nếu bạn chỉ muốn đảo ngược thứ tự của chú giải, hãy thêm lệnh **ggplot2** này `guides(fill = guide_legend(reverse = TRUE))`.]{style="color: darkgreen;"}

### Đường lưới dọc {.unnumbered}

Nếu bạn vẽ biểu đồ với các thiết lập mặc định của **incidence2**, bạn có thể nhận thấy rằng các đường lưới dọc xuất hiện ở từng nhãn ngày và giữa mỗi nhãn ngày. Điều này có thể dẫn đến các đường lưới giao nhau với đỉnh của một số cột.

<!--[Lưu ý đoạn này không áp dụng với phiên bản 1.0.0 của incidence2]. Bạn có thể chỉ định khoảng thời gian cho các đường lưới bằng cách thêm lệnh **ggplot2**'s `scale_x_date()` vào biểu đồ **incidence2**. Trong đó, chỉ định khoảng thời gian cho `date_breaks = ` và `date_minor_breaks = ` (ví dụ: "tuần" hoặc "3 tuần" hoặc "tháng"). Lưu ý rằng việc sử dụng `scale_x_date()` sẽ làm sai bất kỳ định dạng nào của nhãn ngày trong `plot()`, vì vậy bạn sẽ cần chỉ định bất kỳ định dạng chuỗi nào cho `date_labels = ` như bên dưới.-->

Bạn có thể xóa tất cả các đường lưới bằng cách thêm lệnh **ggplot2** `theme_classic()`.

```{r, warning=F, message=F, out.width = c('50%', '50%', '50%'), fig.show='hold'}
# make incidence object
a <- incidence(
  central_data,
  date_index = date_onset,
  interval = "Monday weeks"
)

# Default gridlines
plot(a, title = "Default lines")

# Specified gridline intervals
# NOT WORKING WITH INCIDENCE2 1.0.0
# plot(a, title = "Weekly lines")+
#   scale_x_date(
#     date_breaks = "4 weeks",      # major vertical lines align on weeks
#     date_minor_breaks = "weeks",  # minor vertical lines every week
#     date_labels = "%a\n%d\n%b")   # format of date labels

# No gridlines
plot(a, title = "No lines")+
  theme_classic()                 # remove all gridlines
```

Tuy nhiên, lưu ý rằng nếu sử dụng tuần, các đối số `date_breaks` và `date_minor_breaks` chỉ hoạt động cho các tuần được quy định bắt đầu vào *Thứ Hai*. Nếu các tuần của bạn bắt đầu vào một ngày khác trong tuần, thay vào đó, bạn sẽ cần cung cấp vectơ ngày cho các đối số `breaks =` và `minor_breaks =` theo cách thủ công. Xem mục **ggplot2** để biết các ví dụ về điều này bằng cách sử dụng hàm `seq.Date()`.

### Số mới mắc tích lũy {.unnumbered}

Bạn có thể dễ dàng tạo ra một biểu đồ số mới mắc tích lũy bằng cách chuyển incidence object đến lệnh **incidence2** `cumulate()` và sau đó đến lệnh `plot()`. Điều này cũng tương tự với lệnh `facet_plot()`.

```{r}
# make weekly incidence object
wkly_inci <- incidence(
  linelist,
  date_index = date_onset,
  interval = "week"
)

# plot cumulative incidence
wkly_inci %>% 
  cumulate() %>% 
  plot()
```

Xem phần sau để biết phương pháp thay thế để vẽ biểu đồ số mới mắc tích lũy với **ggplot2** - ví dụ: để chồng một đường số mới mắc tích lũy lên trên đường cong dịch bệnh.

### Trung bình động {.unnumbered}

Bạn có thể thêm đường trung bình động vào biểu đồ tạo bởi **incidence2** một cách dễ dàng với hàm `add_rolling_average()` từ package **i2extras**. Chuyển đối tượng incidence2 của bạn tới hàm này, và sau đó vẽ bằng hàm `plot()`. Thiết lập `before =` là số ngày trước đó bạn muốn đưa vào đường trung bình động (mặc định là 2). Nếu dữ liệu của bạn được nhóm lại, trung bình động sẽ được tính cho mỗi nhóm.

```{r, warning=F, message=F}
rolling_avg <- incidence(                    # make incidence object
  linelist,
  date_index = date_onset,
  interval = "week",
  groups = gender) %>% 
  
  i2extras::add_rolling_average(before = 6)  # add rolling averages (in this case, by gender)

# plot
plot(rolling_avg, n.breaks = 3) # faceted automatically because rolling average on groups
```

Để tìm hiểu cách áp dụng đường trung bình động một cách tổng quát hơn trên dữ liệu, hãy xem chương [Đường trung bình động](#moving-average).

<!-- ======================================================= -->

## Đường cong dịch bệnh với ggplot2

Sử dụng `ggplot()` để xây dựng đường cong dịch bệnh cho phép sự linh hoạt và tùy chỉnh nhiều hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về sử dụng `ggplot()`.

Không giống như sử dụng package **incidence2**, bạn phải kiểm soát *thủ công* việc tổng hợp các trường hợp theo thời gian (theo tuần, tháng, v.v.) *và* khoảng thời gian của các nhãn trên trục ngày thág. Việc này phải được quản lý rất cẩn thận.

Các ví dụ này sử dụng một tập con của bộ dữ liệu `linelist` - chỉ các trường hợp từ Central Hospital.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r}
central_data <- linelist %>% 
  filter(hospital == "Central Hospital")
```

```{r, eval=F, echo=F}
detach("package:tidyverse", unload=TRUE)
library(tidyverse)
```

Để tạo ra một đường cong dịch bệnh với `ggplot()`, có ba yếu tố chính:

-   Một histogram, với các ca bệnh `linelist` được tổng hợp thành các "bins" được phân biệt bằng các điểm "ngắt" cụ thể\
-   Cân chỉnh các trục và nhãn\
-   Chủ đề của biểu đồ, bao gồm tiêu đề, nhãn, chú thích, v.v.

### Xác định bins của số liệu {.unnumbered}

Ở đây chúng ta trình bày cách xác định các ca bệnh sẽ được tổng hợp thành các bins của một histogram ("cột"). Điều quan trọng cần nhận ra là việc tổng hợp số ca bệnh thành các bins của một histogram không nhất thiết phải có cùng khoảng với thời gian xuất hiện trên trục x.

Dưới đây có lẽ là đoạn code đơn giản nhất để tạo ra các đường cong dịch bệnh hàng ngày và hàng tuần.

Trong lệnh `ggplot()` tổng quát, bộ dữ liệu được đưa vào `data =`. Trên nền tảng này, dạng hình học của histogram được thêm bằng một dấu `+`. Trong `geom_histogram()`, chúng ta ánh xạ các yếu tố thẩm mỹ sao cho cột `date_onset` được ánh xạ tới trục x. Cũng trong hàm `geom_histogram()` nhưng *không* phải trong đối số `aes()`, chúng ta đặt `binwidth =` bằng số bins của histogram, tính bằng ngày. Nếu cú pháp **ggplot2** này khó hiểu, hãy xem lại chương [ggplot cơ bản].

[***THẬN TRỌNG***: Lập biểu đồ các trường hợp hàng tuần bằng cách sử dụng `binwidth = 7` bắt đầu cột 7 ngày đầu tiên ở ca bệnh đầu tiên, mà có thể là bất kỳ ngày nào trong tuần! Để tạo các tuần cụ thể, hãy xem phần bên dưới.]{style="color: orange;"}

```{r ggplot_simple,  out.width = c('50%', '50%'), fig.show='hold', warning= F, message = F}
# daily 
ggplot(data = central_data) +          # set data
  geom_histogram(                      # add histogram
    mapping = aes(x = date_onset),     # map date column to x-axis
    binwidth = 1)+                     # cases binned by 1 day 
  labs(title = "Central Hospital - Daily")                # title

# weekly
ggplot(data = central_data) +          # set data 
  geom_histogram(                      # add histogram
      mapping = aes(x = date_onset),   # map date column to x-axis
      binwidth = 7)+                   # cases binned every 7 days, starting from first case (!) 
  labs(title = "Central Hospital - 7-day bins, starting at first case") # title
```

Chúng tôi xin lưu ý rằng ca bệnh đầu tiên trong bộ dữ liệu của Central Hospital có triệu chứng khởi phát vào ngày:

```{r}
format(min(central_data$date_onset, na.rm=T), "%A %d %b, %Y")
```

**Để chỉ định thủ công chia biểu đồ cột, *không* sử dụng argument `binwidth =` và thay vào đó cung cấp vectơ ngày để `breaks =`.**

Tạo vectơ ngày tháng với hàm `seq.Date()` trong **base** R. Hàm này sử dụng các đối số `to =`, `from =`, và `by =`. Ví dụ: lệnh bên dưới trả về ngày mỗi tháng bắt đầu từ ngày 15 Tháng 1 và kết thúc trước ngày 28 Tháng 6.

```{r}
monthly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                           to = as.Date("2015-07-15"),
                           by = "months")

monthly_breaks   # print
```

Vectơ này có được cung cấp cho hàm `geom_histogram()` dưới dạng `breaks =`:

```{r, warning=F, message=F}
# monthly 
ggplot(data = central_data) +  
  geom_histogram(
    mapping = aes(x = date_onset),
    breaks = monthly_breaks)+         # provide the pre-defined vector of breaks                    
  labs(title = "Monthly case bins")   # title
```

Một chuỗi ngày hàng tuần đơn giản có thể được trả về bằng cách đặt `by = "week"`. Ví dụ:

```{r}
weekly_breaks <- seq.Date(from = as.Date("2014-02-01"),
                          to = as.Date("2015-07-15"),
                          by = "week")
```

Một giải pháp thay thế cho việc xác định ngày bắt đầu và ngày kết thúc cụ thể là viết code *động* để các cột hàng tuần bắt đầu vào *thứ Hai trước ca đầu tiên*. **Chúng tôi sẽ sử dụng các vectơ ngày này trong suốt các ví dụ dưới đây**.

```{r}
# Sequence of weekly Monday dates for CENTRAL HOSPITAL
weekly_breaks_central <- seq.Date(
  from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```

Hãy giải mã đoạn code khá "khoai" ở trên:

-   Giá trị "from" (ngày sớm nhất của chuỗi) được tạo như sau: giá trị ngày nhỏ nhất (`min()` với `na.rm=TRUE`) trong cột `date_onset` được đưa vào hàm `floor_date()` thuộc package **lubridate**. `floor_date()` được đặt thành "tuần" trả về ngày bắt đầu của "tuần" của trường hợp đó, với điều kiện là ngày bắt đầu của mỗi tuần là Thứ Hai (`week_start = 1`).\
-   Tương tự như vậy, giá trị "to" (ngày kết thúc của chuỗi) được tạo bằng cách sử dụng hàm ngược lại `ceiling_date()` để trả về thứ hai *sau* ca cuối cùng.\
-   Đối số "by" của `seq.Date()` có thể được đặt thành bất kỳ số ngày, tuần hoặc tháng nào.\
-   Sử dụng `week_start = 7` cho tuần bắt đầu vào Chủ nhật

Vì chúng ta sẽ sử dụng các vectơ ngày dạng này trong toàn bộ chương này, chúng ta cũng xác định một vectơ cho toàn bộ đợt bùng phát (ở trên chỉ dành cho Central Hospital).

```{r}
# Sequence for the entire outbreak
weekly_breaks_all <- seq.Date(
  from = floor_date(min(linelist$date_onset, na.rm=T),   "week", week_start = 1), # monday before first case
  to   = ceiling_date(max(linelist$date_onset, na.rm=T), "week", week_start = 1), # monday after last case
  by   = "week")
```

Các kết quả trả về của `seq.Date()` có thể được sử dụng để tạo các khoảng chia bins trong histogram, cũng như khoảng chia cho các nhãn ngày mà có thể độc lập với các bins. Đọc thêm về nhãn ngày trong các phần sau.

[***MẸO***: Đối với lệnh `ggplot()` đơn giản hơn, hãy lưu các khoảng chia bins và khoảng chia nhãn ngày dưới dạng các vectơ đã đặt tên trước và gán tên này vào đối số `breaks =`.]{style="color: darkgreen;"}

### Ví dụ về đường cong dịch bệnh theo tuần {.unnumbered}

**Dưới đây là code ví dụ chi tiết để tạo đường cong dịch bệnh hàng tuần cho các tuần bắt đầu vào Thứ Hai, với các cột, nhãn ngày và đường lưới dọc đã được căn chỉnh**. Phần này dành cho người dùng có nhu cầu code nhanh. Để hiểu sâu từng khía cạnh (chủ đề, nhãn ngày, v.v.), hãy tiếp tục xem các phần tiếp theo. Chú ý:

-   Các *đoạn chia bins của histogram* được xác định bằng hàm `seq.Date()` như được giải thích ở trên để bắt đầu vào thứ Hai trước ca sớm nhất và kết thúc vào thứ Hai sau ca cuối cùng\
-   Khoảng *nhãn ngày* được xác định bởi `date_breaks =` bên trong `scale_x_date()`\
-   Khoảng đường lưới dọc nhỏ giữa các nhãn ngày được xác định bởi `date_minor_breaks =`\
-   `expand = c(0,0)` trong trục x và y loại bỏ không gian thừa trên mỗi cạnh của trục, điều này cũng đảm bảo các nhãn ngày bắt đầu từ cột đầu tiên.

```{r, warning=F, message=F}
# TOTAL MONDAY WEEK ALIGNMENT
#############################
# Define sequence of weekly breaks
weekly_breaks_central <- seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 1), # Monday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 1), # Monday after last case
      by   = "week")    # bins are 7-days 


ggplot(data = central_data) + 
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    
    # mapping aesthetics
    mapping = aes(x = date_onset),  # date column mapped to x-axis
    
    # histogram bin breaks
    breaks = weekly_breaks_central, # histogram bin breaks defined previously
    
    # bars
    color = "darkblue",     # color of lines around bars
    fill = "lightblue"      # color of fill within bars
  )+ 
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),           # remove excess x-axis space before and after case bars
    date_breaks       = "4 weeks",        # date labels and major vertical gridlines appear every 3 Monday weeks
    date_minor_breaks = "week",           # minor vertical lines appear every Monday week
    date_labels       = "%a\n%d %b\n%Y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+             # remove excess y-axis space below 0 (align histogram flush with x-axis)
  
  # aesthetic themes
  theme_minimal()+                # simplify plot background
  
  theme(
    plot.caption = element_text(hjust = 0,        # caption on left side
                                face = "italic"), # caption in italics
    axis.title = element_text(face = "bold"))+    # axis titles in bold
  
  # labels including dynamic caption
  labs(
    title    = "Weekly incidence of cases (Monday weeks)",
    subtitle = "Note alignment of bars, vertical gridlines, and axis labels on Monday weeks",
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### Tuần bắt đầu bằng Chủ nhật {.unnumbered}

Để vẽ được biểu đồ cho các tuần bắt đầu bằng Chủ nhật, cần có một số sửa đổi, vì `date_breaks = "weeks"` chỉ hoạt động cho các tuần bắt đầu bằng thứ Hai.

-   Các điểm ngắt của các *histogram bins* phải được đặt thành Chủ nhật (`week_start = 7`)\
-   Trong `scale_x_date()`, các đoạn ngắt ngày tương tự nên được gắn với `breaks =` và `minor_breaks =` để đảm bảo các nhãn ngày và đường lưới dọc căn chỉnh vào ngày Chủ nhật.

Ví dụ: lệnh `scale_x_date()` cho các tuần bắt đầu vào Chủ nhật có thể trông như sau:

```{r, eval=F}
scale_x_date(
    expand = c(0,0),
    
    # specify interval of date labels and major vertical gridlines
    breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "4 weeks"),
    
    # specify interval of minor vertical gridline 
    minor_breaks = seq.Date(
      from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7), # Sunday before first case
      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7), # Sunday after last case
      by   = "week"),
   
    # date label format
    date_labels = "%a\n%d %b\n%Y")+         # day, above month abbrev., above 2-digit year

```

### Nhóm/tô màu theo giá trị {.unnumbered}

Các cột histogram có thể được tô màu theo nhóm và "xếp chồng lên nhau". Để chỉ định cột nhóm, hãy thực hiện các thay đổi sau. Xem chương [ggplot cơ bản] để biết thêm chi tiết.

-   Bên trong đối số `aes()` của hàm vẽ histogram, ánh xạ tên cột tới đối số `group =` và `fill =`\
-   Loại bỏ bất kỳ tham số `fill =` nào bên ngoài đối số `aes()`, vì nó sẽ ghi đè giá trị bên trong\
-   Đối số *bên trong* `aes()` sẽ áp dụng *theo nhóm*, trong khi bất kỳ đối số *bên ngoài* nào đều sẽ áp dụng cho tất cả các cột (ví dụ: bạn có thể vẫn muốn tô màu `color =` bên ngoài, vì vậy mỗi cột có cùng một đường viền)

Đây là lệnh `aes()` hiển thị nhóm và tô màu các cột theo giới tính:

```{r, eval=F}
aes(x = date_onset, group = gender, fill = gender)
```

Đây là kết quả khi áp dụng:

```{r, warning=F, message=F}
ggplot(data = linelist) +     # begin with linelist (many hospitals)
  
  # make histogram: specify bin break points: starts the Monday before first case, end Monday after last case
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = hospital,       # set data to be grouped by hospital
      fill = hospital),       # bar fill (inside color) by hospital
    
    # bin breaks are Monday weeks
    breaks = weekly_breaks_all,   # sequence of weekly Monday bin breaks for whole outbreak, defined in previous code       
    
    # Color around bars
    color = "black")
```

### Hiệu chỉnh màu {.unnumbered}

-   Để thiết lập *thủ công* tô màu cho từng nhóm, hãy sử dụng `scale_fill_manual()` (lưu ý: `scale_color_manual()` là một cái khác!)

    -   Sử dụng đối số `values =` để áp dụng một vectơ màu\
    -   Sử dụng `na.value =` để xác định màu cho giá trị `NA`\
    -   Sử dụng đối số `labels =` để thay đổi văn bản trong mục chú thích. Để cho an toàn, sử dụng một vectơ được đặt tên kiểu như `c("old" = "new", "old" = "new")` hoặc điều chỉnh giá trị trong bộ dữ liệu\
    -   Sử dụng `name =` để đặt một tiêu đề thích hợp cho mục chú thích\

-   Để biết thêm mẹo về thang màu và bảng màu, hãy xem chương [ggplot cơ bản].

```{r, warning=F, message=F}
ggplot(data = linelist)+           # begin with linelist (many hospitals)
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,          # cases grouped by hospital
        fill = hospital),          # bar fill by hospital
    
    # bin breaks
    breaks = weekly_breaks_all,        # sequence of weekly Monday bin breaks, defined in previous code
    
    # Color around bars
    color = "black")+              # border color of each bar
  
  # manual specification of colors
  scale_fill_manual(
    values = c("black", "orange", "grey", "beige", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital") # specify fill colors ("values") - attention to order!
```

### Hiệu chỉnh thứ bậc {.unnumbered}

Thứ tự mà các cột được nhóm xếp chồng lên nhau được điều chỉnh tốt nhất bằng cách phân loại cột nhóm dưới dạng Factor. Sau đó, bạn có thể chỉ định thứ tự cấp độ phân loại (và nhãn hiển thị của chúng). Xem chương về [Factors] hoặc [Các tips với ggplot] để biết thêm chi tiết.

Trước khi tạo biểu đồ, hãy sử dụng hàm `fct_relevel()` từ package **forcats** để chuyển đổi cột phân nhóm thành kiểu Factor và điều chỉnh thứ tự cấp độ theo cách thủ công, như được trình bày chi tiết trong chương về [Factors].

```{r}
# load forcats package for working with factors
pacman::p_load(forcats)

# Define new dataset with hospital as factor
plot_data <- linelist %>% 
  mutate(hospital = fct_relevel(hospital, c("Missing", "Other"))) # Convert to factor and set "Missing" and "Other" as top levels to appear on epicurve top

levels(plot_data$hospital) # print levels in order
```

Trong biểu đồ dưới đây, điểm khác biệt duy nhất so với trước đó là cột `hospital` đã được hợp nhất như trên và chúng ta sử dụng các `guides()` để đảo ngược thứ tự chú thích, do đó "nhãn Missing" nằm ở cuối chú thích.

```{r, warning=F, message=F}
ggplot(plot_data) +                     # Use NEW dataset with hospital as re-ordered factor
  
  # make histogram
  geom_histogram(
    mapping = aes(x = date_onset,
        group = hospital,               # cases grouped by hospital
        fill = hospital),               # bar fill (color) by hospital
    
    breaks = weekly_breaks_all,         # sequence of weekly Monday bin breaks for whole outbreak, defined at top of ggplot section
    
    color = "black")+                   # border color around each bar
    
  # x-axis labels
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space before and after case bars
    date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
    date_minor_breaks = "week",         # vertical lines appear every Monday week
    date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(
    expand = c(0,0))+                   # remove excess y-axis space below 0
  
  # manual specification of colors, ! attention to order
  scale_fill_manual(
    values = c("grey", "beige", "black", "orange", "blue", "brown"),
    labels = c("St. Mark's Maternity Hospital (SMMH)" = "St. Mark's"),
    name = "Hospital")+ 
  
  # aesthetic themes
  theme_minimal()+                      # simplify plot background
  
  theme(
    plot.caption = element_text(face = "italic", # caption on left side in italics
                                hjust = 0), 
    axis.title = element_text(face = "bold"))+   # axis titles in bold
  
  # labels
  labs(
    title    = "Weekly incidence of cases by hospital",
    subtitle = "Hospital as re-ordered factor",
    x        = "Week of symptom onset",
    y        = "Weekly cases")
```

[***MẸO***: Để chỉ đảo ngược thứ tự của chú thích, hãy thêm lệnh **ggplot2** này: `guides(fill = guide_legend(reverse = TRUE))`.]{style="color: darkgreen;"}

### Hiệu chỉnh chú thích {.unnumbered}

Đọc thêm về chú thích và scale trong chương [Các tips với ggplot]. Dưới đây là một vài điểm nổi bật:

-   Chỉnh sửa tiêu đề chú thích trong hàm scale hoặc với `labs(fill = "Legend title")` (nếu bạn đang sử dụng `color =`, thì hãy sử dụng `labs(color = "")`)\

-   `theme(legend.title = element_blank())` để bỏ trống tiêu đề chú thích\

-   `theme(legend.position = "top")` ("bottom", "left", "right", hoặc "none" để bỏ chú thích)

-   `theme(legend.direction = "horizontal")` xoay ngang chú thích

-   `guides(fill = guide_legend(reverse = TRUE))` để đảo ngược thứ tự các mục chú thích

### Cột kề cột {.unnumbered}

Hiển thị song song các cột nhóm (trái ngược với xếp chồng lên nhau) được chỉ định trong `geom_histogram()` với `position = "dodge"` được đặt bên ngoài `aes()`.

Nếu có nhiều hơn hai nhóm giá trị, nó có thể gây khó đọc. Thay vào đó, hãy cân nhắc sử dụng một biểu đồ được chia nhỏ (gồm nhiều biểu đồ nhỏ). Để dễ xem trong ví dụ này, các giá trị giới tính bị thiếu sẽ bị xóa.

```{r, warning=F, message=F}
ggplot(central_data %>% drop_na(gender))+   # begin with Central Hospital cases dropping missing gender
    geom_histogram(
        mapping = aes(
          x = date_onset,
          group = gender,         # cases grouped by gender
          fill = gender),         # bars filled by gender
        
        # histogram bin breaks
        breaks = weekly_breaks_central,   # sequence of weekly dates for Central outbreak - defined at top of ggplot section
        
        color = "black",          # bar edge color
        
        position = "dodge")+      # SIDE-BY-SIDE bars
                      
  
  # The labels on the x-axis
  scale_x_date(expand            = c(0,0),         # remove excess x-axis space below and after case bars
               date_breaks       = "3 weeks",      # labels appear every 3 Monday weeks
               date_minor_breaks = "week",         # vertical lines appear every Monday week
               date_labels       = "%d\n%b\n'%y")+ # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+             # removes excess y-axis space between bottom of bars and the labels
  
  #scale of colors and legend labels
  scale_fill_manual(values = c("brown", "orange"),  # specify fill colors ("values") - attention to order!
                    na.value = "grey" )+     

  # aesthetic themes
  theme_minimal()+                                               # a set of themes to simplify plot
  theme(plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
        axis.title = element_text(face = "bold"))+               # axis titles in bold
  
  # labels
  labs(title    = "Weekly incidence of cases, by gender",
       subtitle = "Subtitle",
       fill     = "Gender",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported")
```

### Giới hạn trục {.unnumbered}

Có hai cách để giới hạn phạm vi các giá trị trên trục.

Nói chung, cách khuyến khích sử dụng là lệnh `coord_cartesian()`, chấp nhận `xlim = c(min, max)` và `ylim = c(min, max)` (trong đó bạn cung cấp giá trị nhỏ nhất và lớn nhất). Cách này hoạt động như một "thu phóng kích thước" mà không thực sự loại bỏ bất kỳ dữ liệu nào, điều này rất quan trọng đối với các số liệu thống kê và các thang đo tổng hợp.

Ngoài ra, bạn có thể thiết lập giá trị ngày tối đa và tối thiểu bằng cách sử dụng `limits = c()` bên trong hàm `scale_x_date()`. Ví dụ:

```{r eval=F}
scale_x_date(limits = c(as.Date("2014-04-01"), NA)) # sets a minimum date but leaves the maximum open.  
```

Tương tự như vậy, nếu bạn muốn trục x kéo dài đến một ngày cụ thể (ví dụ: ngày hiện tại), ngay cả khi không có trường hợp mới nào được báo cáo, bạn có thể sử dụng:

```{r eval=F}
scale_x_date(limits = c(NA, Sys.Date()) # ensures date axis will extend until current date  
```

[***LƯU Ý***: Hãy thận trọng khi đặt giới hạn hoặc chia tỷ lệ trục y (ví dụ: 0 đến 30 với khoảng là 5: `seq(0, 30, 5)`). Những con số tĩnh như vậy có thể cắt bớt biểu đồ quá ngắn nếu dữ liệu thay đổi vượt quá giới hạn!.]{style="color: red;"}

### Nhãn/đường lưới của trục ngày {.unnumbered}

[***MẸO***: Hãy nhớ rằng các **nhãn** trục ngày độc lập với việc tổng hợp dữ liệu thành các cột, nhưng về mặt trực quan, điều quan trọng là phải căn chỉnh các cột, nhãn ngày và các đường lưới dọc.]{style="color: darkgreen;"}

Để **sửa đổi nhãn ngày và đường lưới**, hãy sử dụng `scale_x_date()` theo một trong những cách sau:

-   **Nếu histogram bins là ngày, tuần bắt đầu vào thứ hai, tháng hoặc năm:**

    -   Sử dụng `date_breaks =` để xác định khoảng thời gian của các nhãn và đường lưới chính (ví dụ: "day", "week", "3 weeks", "month" hoặc "year")
    -   Sử dụng `date_minor_breaks =` để xác định khoảng của các đường lưới dọc nhỏ (giữa các nhãn ngày)\
    -   Thêm `expand = c(0,0)` để bắt đầu các nhãn ở cột đầu tiên\
    -   Sử dụng `date_labels =` để xác định định dạng của nhãn ngày - hãy xem chương Ngày để biết các mẹo (sử dụng `\n` cho một dòng mới)\

-   **Nếu histogram bins là các tuần bắt đầu vào Chủ nhật:**

    -   Sử dụng `breaks =` và `minor_breaks =` bằng cách cung cấp một chuỗi ngày cho mỗi khoảng chia
    -   Vẫn có thể sử dụng `date_labels =` và `expand =` để định dạng như mô tả ở trên

Một số ghi chú:

-   Xem phần mở đầu của mục ggplot về hướng dẫn cách tạo chuỗi ngày bằng `seq.Date()`.\
-   Xem [trang này](https://rdrr.io/r/base/strptime.html) hoặc chương [Làm việc với ngày tháng] để biết thêm mẹo tạo nhãn ngày.

#### Minh họa {.unnumbered}

Dưới đây là minh họa biểu đồ trong đó các cột và nhãn biểu đồ/đường lưới được căn chỉnh thẳng hàng và không thẳng hàng:

```{r fig.show='hold', class.source = 'fold-hide', warning=F, message=F}
# 7-day bins + Monday labels
#############################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,                 # 7-day bins with start at first case
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),               # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",       # Monday every 3 weeks
    date_minor_breaks = "week",    # Monday weeks
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+              # remove excess space under x-axis, make flush
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays at first case\nDate labels and gridlines on Mondays\nNote how ticks don't align with bars")



# 7-day bins + Months
#####################
ggplot(central_data) +
  geom_histogram(
    mapping = aes(x = date_onset),
    binwidth = 7,
    color = "darkblue",
    fill = "lightblue") +
  
  scale_x_date(
    expand = c(0,0),                  # remove excess x-axis space below and after case bars
    date_breaks = "months",           # 1st of month
    date_minor_breaks = "week",       # Monday weeks
    date_labels = "%a\n%d %b\n%Y")+    # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "MISALIGNED",
    subtitle = "! CAUTION: 7-day bars start Thursdays with first case\nMajor gridlines and date labels at 1st of each month\nMinor gridlines weekly on Mondays\nNote uneven spacing of some gridlines and ticks unaligned with bars")


# TOTAL MONDAY ALIGNMENT: specify manual bin breaks to be mondays
#################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,    # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "4 weeks",           # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%a\n%d %b\n%Y")+      # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(
    title = "ALIGNED Mondays",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels and gridlines on Mondays as well")


# TOTAL MONDAY ALIGNMENT WITH MONTHS LABELS:
############################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Monday before first case
    breaks = weekly_breaks_central,            # defined earlier in this page
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "months",            # Monday every 4 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%b\n%Y")+          # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  theme(panel.grid.major = element_blank())+  # Remove major gridlines (fall on 1st of month)
          
  labs(
    title = "ALIGNED Mondays with MONTHLY labels",
    subtitle = "7-day bins manually set to begin Monday before first case (28 Apr)\nDate labels on 1st of Month\nMonthly major gridlines removed")


# TOTAL SUNDAY ALIGNMENT: specify manual bin breaks AND labels to be Sundays
############################################################################
ggplot(central_data) + 
  geom_histogram(
    mapping = aes(x = date_onset),
    
    # histogram breaks set to 7 days beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "7 days"),
    
    color = "darkblue",
    
    fill = "lightblue") + 
  
  scale_x_date(
    expand = c(0,0),
    # date label breaks and major gridlines set to every 3 weeks beginning Sunday before first case
    breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                      to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                      by   = "3 weeks"),
    
    # minor gridlines set to weekly beginning Sunday before first case
    minor_breaks = seq.Date(from = floor_date(min(central_data$date_onset, na.rm=T),   "week", week_start = 7),
                            to   = ceiling_date(max(central_data$date_onset, na.rm=T), "week", week_start = 7),
                            by   = "7 days"),
    
    date_labels = "%a\n%d\n%b\n'%y")+  # label format
  
  scale_y_continuous(
    expand = c(0,0))+                # remove excess space under x-axis, make flush 
  
  labs(title = "ALIGNED Sundays",
       subtitle = "7-day bins manually set to begin Sunday before first case (27 Apr)\nDate labels and gridlines manually set to Sundays as well")

```

### Dữ liệu tổng hợp {.unnumbered}

Thông thường, thay vì bắt đầu với bộ số liệu `linelist`, bạn có thể bắt đầu với số lượng tổng hợp từ các cơ sở y tế, quận, huyện, v.v. Bạn có thể tạo đường cong dịch bệnh với `ggplot()` nhưng code sẽ hơi khác một chút. Phần này sẽ tận dụng bộ dữ liệu `count_data` đã được nạp trước đó trong mục chuẩn bị dữ liệu. Bộ dữ liệu này là `linelist` được tổng hợp thành số lượng bệnh viện theo ngày. 50 hàng đầu tiên được hiển thị dưới đây.

```{r message=FALSE, warning=F, echo=F}
# display the linelist data as a table
DT::datatable(head(count_data, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Vẽ biểu đồ dữ liệu đếm hàng ngày {.unnumbered}

Chúng ta có thể vẽ biểu đồ đường cong dịch bệnh từ *dữ liệu đếm hàng ngày*. Dưới đây là sự khác biệt trong đoạn code:

-   Khi ánh xạ các yếu tố trong hàm `aes()`, hãy cụ thể `y =` bằng một cột đếm (trong trường hợp này, tên cột là `n_cases`)

-   Thêm đối số `stat = "identity"` trong `geom_histogram()`, giúp xác định rằng chiều cao cột phải là giá trị `y =`, không phải số hàng như mặc định\

-   Thêm đối số `width =` để tránh các đường trắng dọc giữa các cột. Đối với dữ liệu hàng ngày được đặt thành 1. Đối với dữ liệu đếm hàng tuần được đặt thành 7. Đối với dữ liệu đếm hàng tháng, các đường màu trắng là một vấn đề (mỗi tháng có số ngày khác nhau) - hãy xem xét chuyển đổi trục x của bạn thành cột phân loại (factor) theo thứ tự (tháng) và sử dụng `geom_col()`.

```{r, message=FALSE, warning=F}
ggplot(data = count_data)+
  geom_histogram(
   mapping = aes(x = date_hospitalisation, y = n_cases),
   stat = "identity",
   width = 1)+                # for daily counts, set width = 1 to avoid white space between bars
  labs(
    x = "Date of report", 
    y = "Number of cases",
    title = "Daily case incidence, from daily count data")
```

#### Vẽ biểu đồ dữ liệu đếm hàng tuần {.unnumbered}

Nếu dữ liệu của bạn đã là số lượng ca bệnh đếm theo tuần, chúng có thể trông giống như bộ dữ liệu này (được gọi là `count_data_weekly`):

```{r, warning=F, message=F, echo=F}
# Create weekly dataset with epiweek column
count_data_weekly <- count_data %>%
  mutate(epiweek = lubridate::floor_date(date_hospitalisation, "week")) %>% 
  group_by(hospital, epiweek, .drop=F) %>% 
  summarize(n_cases_weekly = sum(n_cases, na.rm=T))   
```

50 hàng đầu tiên của `count_data_weekly` được hiển thị bên dưới. Bạn có thể thấy rằng số lượng đếm đã được tổng hợp thành các tuần. Mỗi tuần được hiển thị theo ngày đầu tiên của tuần (mặc định là Thứ Hai).

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(count_data_weekly, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Bây giờ vẽ biểu đồ sao cho `x =` cột epiweek. Hãy nhớ thêm `y =` cột đếm khi ánh xạ trục và thêm `stat = "identity"` như đã giải thích ở trên.

```{r, warning=F, message=F}
ggplot(data = count_data_weekly)+
  
  geom_histogram(
    mapping = aes(
      x = epiweek,           # x-axis is epiweek (as class Date)
      y = n_cases_weekly,    # y-axis height in the weekly case counts
      group = hospital,      # we are grouping the bars and coloring by hospital
      fill = hospital),
    stat = "identity")+      # this is also required when plotting count data
     
  # labels for x-axis
  scale_x_date(
    date_breaks = "2 months",      # labels every 2 months 
    date_minor_breaks = "1 month", # gridlines every month
    date_labels = '%b\n%Y')+       #labeled by month with year below
     
  # Choose color palette (uses RColorBrewer package)
  scale_fill_brewer(palette = "Pastel2")+ 
  
  theme_minimal()+
  
  labs(
    x = "Week of onset", 
    y = "Weekly case incidence",
    fill = "Hospital",
    title = "Weekly case incidence, from aggregated count data by hospital")
```

### Đường trung bình động {.unnumbered}

Xem chương về [Đường trung bình động](#moving-average) để có mô tả chi tiết và một số tùy chọn. Dưới đây là một tùy chọn để tính toán đường trung bình động với package **slider**. Theo cách tiếp cận này, *trung bình động được tính toán trong bộ dữ liệu trước khi vẽ biểu đồ*:

1)  Tổng hợp dữ liệu thành số lượng nếu cần thiết (hàng ngày, hàng tuần, v.v.) (xem chương [Nhóm dữ liệu])\
2)  Tạo một cột mới để giữ đường trung bình động, được tạo bằng hàm `slide_index()` từ package **slider**\
3)  Vẽ đường trung bình động dưới dạng một `geom_line()` ở trên đỉnh (phía sau) histogram đường cong dịch bệnh

Tham khảo thêm tại [vignette của package **slider**](https://cran.r-project.org/web/packages/slider/vignettes/slider.html)

```{r, warning=F, message=F}
# load package
pacman::p_load(slider)  # slider used to calculate rolling averages

# make dataset of daily counts and 7-day moving average
#######################################################
ll_counts_7day <- linelist %>%    # begin with linelist
  
  ## count cases by date
  count(date_onset, name = "new_cases") %>%   # name new column with counts as "new_cases"
  drop_na(date_onset) %>%                     # remove cases with missing date_onset
  
  ## calculate the average number of cases in 7-day window
  mutate(
    avg_7day = slider::slide_index(    # create new column
      new_cases,                       # calculate based on value in new_cases column
      .i = date_onset,                 # index is date_onset col, so non-present dates are included in window 
      .f = ~mean(.x, na.rm = TRUE),    # function is mean() with missing values removed
      .before = 6,                     # window is the day and 6-days before
      .complete = FALSE),              # must be FALSE for unlist() to work in next step
    avg_7day = unlist(avg_7day))       # convert class list to class numeric


# plot
######
ggplot(data = ll_counts_7day) +  # begin with new dataset defined above 
    geom_histogram(              # create epicurve histogram
      mapping = aes(
        x = date_onset,          # date column as x-axis
        y = new_cases),          # height is number of daily new cases
        stat = "identity",       # height is y value
        fill="#92a8d1",          # cool color for bars
        colour = "#92a8d1",      # same color for bar border
        )+ 
    geom_line(                   # make line for rolling average
      mapping = aes(
        x = date_onset,          # date column for x-axis
        y = avg_7day,            # y-value set to rolling average column
        lty = "7-day \nrolling avg"), # name of line in legend
      color="red",               # color of line
      size = 1) +                # width of line
    scale_x_date(                # date scale
      date_breaks = "1 month",
      date_labels = '%d/%m',
      expand = c(0,0)) +
    scale_y_continuous(          # y-axis scale
      expand = c(0,0),
      limits = c(0, NA)) +       
    labs(
      x="",
      y ="Number of confirmed cases",
      fill = "Legend")+ 
    theme_minimal()+
    theme(legend.title = element_blank())  # removes title of legend
```

### Faceting/chia nhỏ biểu đồ {.unnumbered}

Như với các ggplots khác, bạn có thể tạo các biểu đồ được chia nhỏ ("nhiều biểu đồ con"). Như đã giải thích trong chương [Các tips với ggplot] trong cuốn sách này, bạn có thể sử dụng `facet_wrap()` hoặc `facet_grid()`. Ở đây chúng tôi sẽ minh họa bằng hàm `facet_wrap()`. Đối với đường cong dịch bệnh, sử dụng `facet_wrap()` thường dễ dàng hơn vì khả năng bạn thường chỉ cần chia nhỏ biểu đồ theo một biến.

Cú pháp chung là `facet_wrap(rows ~ cols)`, trong đó bên trái dấu ngã (\~) là tên của biến sẽ được trải trên các "hàng" của biểu đồ chia nhỏ và ở bên phải dấu ngã là tên của biến sẽ được trải trên các "cột" của biểu đồ chia nhỏ. Đơn giản nhất, chỉ cần sử dụng một tên cột, ở bên phải dấu ngã: `facet_wrap(~age_cat)`.

**Trục tự do**\
Bạn sẽ cần phải quyết định xem tỷ lệ của các trục cho mỗi biểu đồ nhỏ là "cố định" với cùng một kích thước (mặc định) hay "tự do" (nghĩa là chúng sẽ thay đổi dựa trên dữ liệu của chúng). Thực hiện điều này với đối số `scales =` trong hàm `facet_wrap()` bằng cách chỉ định "free_x" hoặc "free_y" hoặc "free".

**Số cột và hàng của các biểu đồ con**\
Điều này có thể xác định với `ncol =` và `nrow =` trong hàm `facet_wrap()`.

**Thứ tự các biểu đồ con**\
Để thay đổi thứ tự xuất hiện, hãy thay đổi thứ tự cơ bản của các cấp của cột phân loại được sử dụng để tạo các biểu đồ con.

**Đinh dạng trục**\
Kích thước phông chữ và mặt biểu đồ, dải màu, v.v. có thể được sửa đổi thông qua `theme()` với các đối số như:

-   `strip.text = element_text()` (kích thước, màu sắc, mặt, góc ...)

-   `strip.background = element_rect()` (ví dụ: `element_rect(fill = "grey")`)\

-   `strip.position =` (vị trị "dưới", "trên", "trái", hoặc "phải")

**Dải nhãn**\
Nhãn của các biểu đồ con có thể được sửa đổi thông qua "nhãn" của cột như một factor hoặc bằng cách sử dụng một "người dán nhãn - labeller".

Để tạo một labeller như thế, sử dụng hàm `as_labeller()` từ **ggplot2**. Sau đó, cung cấp labeller cho đối số `labeller =` của `facet_wrap()` như dưới đây.

```{r, class.source = 'fold-show'}
my_labels <- as_labeller(c(
     "0-4"   = "Ages 0-4",
     "5-9"   = "Ages 5-9",
     "10-14" = "Ages 10-14",
     "15-19" = "Ages 15-19",
     "20-29" = "Ages 20-29",
     "30-49" = "Ages 30-49",
     "50-69" = "Ages 50-69",
     "70+"   = "Over age 70"))
```

**Một ví dụ về chia nhỏ biểu đồ** - chia bằng cột `age_cat`.

```{r, warning=F, message=F}
# make plot
###########
ggplot(central_data) + 
  
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),    # arguments inside aes() apply by group
      
    color = "black",      # arguments outside aes() apply to all data
        
    # histogram breaks
    breaks = weekly_breaks_central)+  # pre-defined date vector (see earlier in this page)
                      
  # The labels on the x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+                       # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "grey"))+         # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,
    ncol = 4,
    strip.position = "top",
    labeller = my_labels)+             
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

Xem [link](https://ggplot2.tidyverse.org/reference/labellers.html) để biết thêm thông tin về labellers.

#### Tổng vụ dịch trong nền của biểu đồ con {.unnumbered}

Để hiển thị tổng vụ dịch trong nền của mỗi biểu đồ con, hãy thêm hàm `gghighlight()` với dấu ngoặc đơn trống vào ggplot. Hàm này thuộc package **gghighlight**. Lưu ý rằng trục y tối đa trong tất cả các biểu đồ con hiện dựa vào đỉnh của toàn bộ vụ dịch. Có nhiều ví dụ hơn về package này trong chương [Các tips với ggplot].

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # epicurves by group
  geom_histogram(
    mapping = aes(
      x = date_onset,
      group = age_cat,
      fill = age_cat),  # arguments inside aes() apply by group
    
    color = "black",    # arguments outside aes() apply to all data
    
    # histogram breaks
    breaks = weekly_breaks_central)+     # pre-defined date vector (see top of ggplot section)                
  
  # add grey epidemic in background to each facet
  gghighlight::gghighlight()+
  
  # labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space below 0
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom",
    strip.text = element_text(face = "bold", size = 10),
    strip.background = element_rect(fill = "white"))+        # axis titles in bold
  
  # create facets
  facet_wrap(
    ~age_cat,                          # each plot is one value of age_cat
    ncol = 4,                          # number of columns
    strip.position = "top",            # position of the facet title/strip
    labeller = my_labels)+             # labeller defines above
  
  # labels
  labs(
    title    = "Weekly incidence of cases, by age category",
    subtitle = "Subtitle",
    fill     = "Age category",                                      # provide new title for legend
    x        = "Week of symptom onset",
    y        = "Weekly incident cases reported",
    caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

#### Dữ liệu một biểu đồ con {.unnumbered}

Nếu bạn muốn có một hộp biểu đồ con chứa tất cả dữ liệu, hãy sao chép toàn bộ dữ liệu và coi các bản sao như một giá trị cho các biểu đồ con. Hàm "trợ giúp" `CreateAllFacet()` bên dưới có thể hỗ trợ việc này (nhờ bài đăng trên [blog](https://stackoverflow.com/questions/18933575/easily-add-an-all-facet-to-facet-wrap-in-ggplot2) này). Khi nó được chạy, số hàng tăng gấp đôi và sẽ có một cột mới được gọi là `facet`, trong đó các hàng được sao chép sẽ có giá trị "tất cả" và các hàng ban đầu có giá trị ban đầu của cột phân chia. Bây giờ bạn chỉ cần phân chia cột `facet` .

Dưới đây là hàm trợ giúp. Chạy code này và nó sẽ luôn sẵn sàng để bạn sử dụng.

```{r}
# Define helper function
CreateAllFacet <- function(df, col){
     df$facet <- df[[col]]
     temp <- df
     temp$facet <- "all"
     merged <-rbind(temp, df)
     
     # ensure the facet value is a factor
     merged[[col]] <- as.factor(merged[[col]])
     
     return(merged)
}
```

Bây giờ hãy áp dụng hàm trợ giúp cho bộ dữ liệu, trên cột `age_cat`:

```{r}
# Create dataset that is duplicated and with new column "facet" to show "all" age categories as another facet level
central_data2 <- CreateAllFacet(central_data, col = "age_cat") %>%
  
  # set factor levels
  mutate(facet = fct_relevel(facet, "all", "0-4", "5-9",
                             "10-14", "15-19", "20-29",
                             "30-49", "50-69", "70+"))

# check levels
table(central_data2$facet, useNA = "always")
```

Những thay đổi đáng chú ý đối với lệnh `ggplot()` là:

-   Dữ liệu được sử dụng bây giờ là `central_data2` (nhân đôi các hàng, với cột mới là "facet")

-   Labeller sẽ cần được cập nhật, nếu được sử dụng\

-   Tùy chọn: để có các biểu đồ con xếp chồng lên nhau theo chiều dọc: cột chia được chuyển sang các hàng bên cạnh của phương trình và ở bên phải được thay thế bằng "." (`facet_wrap(facet~.)`), và `ncol = 1`. Bạn cũng có thể cần điều chỉnh chiều rộng và chiều cao của ảnh biểu đồ đã lưu dưới dạng png (xem `ggsave()` trong chương [Các tips với ggplot]).

```{r, fig.height=12, fig.width=5, warning=F, message=F}
ggplot(central_data2) + 
  
  # actual epicurves by group
  geom_histogram(
        mapping = aes(
          x = date_onset,
          group = age_cat,
          fill = age_cat),  # arguments inside aes() apply by group
        color = "black",    # arguments outside aes() apply to all data
        
        # histogram breaks
        breaks = weekly_breaks_central)+    # pre-defined date vector (see top of ggplot section)
                     
  # Labels on x-axis
  scale_x_date(
    expand            = c(0,0),         # remove excess x-axis space below and after case bars
    date_breaks       = "2 months",     # labels appear every 2 months
    date_minor_breaks = "1 month",      # vertical lines appear every 1 month 
    date_labels       = "%b\n'%y")+     # date labels format
  
  # y-axis
  scale_y_continuous(expand = c(0,0))+  # removes excess y-axis space between bottom of bars and the labels
  
  # aesthetic themes
  theme_minimal()+                                           # a set of themes to simplify plot
  theme(
    plot.caption = element_text(face = "italic", hjust = 0), # caption on left side in italics
    axis.title = element_text(face = "bold"),
    legend.position = "bottom")+               
  
  # create facets
  facet_wrap(facet~. ,                            # each plot is one value of facet
             ncol = 1)+            

  # labels
  labs(title    = "Weekly incidence of cases, by age category",
       subtitle = "Subtitle",
       fill     = "Age category",                                      # provide new title for legend
       x        = "Week of symptom onset",
       y        = "Weekly incident cases reported",
       caption  = stringr::str_glue("n = {nrow(central_data)} from Central Hospital; Case onsets range from {format(min(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')} to {format(max(central_data$date_onset, na.rm=T), format = '%a %d %b %Y')}\n{nrow(central_data %>% filter(is.na(date_onset)))} cases missing date of onset and not shown"))
```

## Dữ liệu dự kiến

Dữ liệu gần đây nhất được biểu thị trong đường cong dịch tễ nên được đánh dấu là dự kiến hoặc có thể báo cáo chậm trễ. Điều này có thể được thực hiện bằng cách thêm một đường thẳng đứng và/hoặc hình chữ nhật trong một số ngày cụ thể. Đây là hai tùy chọn:

1)  Sử dụng `annotate()`:

    -   Để sử dụng dạng đường `annotate(geom = "segment")`. Cung cấp `x`, `xend`, `y`, và `yend`. Hiệu chỉnh kích thước, kiểu dòng (`lty`), và màu.\
    -   Để sử dụng dạng hình chữ nhật `annotate(geom = "rect")`. Cung cấp xmin/xmax/ymin/ymax. Hiệu chỉnh màu và hệ số alpha.\

2)  Nhóm dữ liệu theo trạng thái tạm thời và tô màu các cột đó theo cách khác nhau

[***THẬN TRỌNG***: Bạn có thể thử hàm `geom_rect()` để vẽ hình chữ nhật, nhưng việc điều chỉnh độ trong suốt không khả thi trong bối cảnh cảnh bộ số liệu `linelist`. Hàm này sẽ phủ lên một hình chữ nhật cho mỗi hàng/quan sát!. Sử dụng hệ số alpha rất thấp (ví dụ: 0.01) hoặc một cách tiếp cận khác.]{style="color: orange;"}

### Sử dụng `annotate()` {.unnumbered}

-   Trong `annotate(geom = "rect")`, đối số `xmin` và `xmax` cần được định dạng phân lớp ngày\
-   Lưu ý rằng vì những dữ liệu này được tổng hợp thành các cột hàng tuần và cột cuối cùng kéo dài đến Thứ Hai sau điểm dữ liệu cuối cùng, vùng được tô bóng có thể bao gồm 4 tuần\
-   Đây là một [ví dụ trực tuyến](https://ggplot2.tidyverse.org/reference/annotate.html) về `annotate()`

```{r, warning=F, message=F}
ggplot(central_data) + 
  
  # histogram
  geom_histogram(
    mapping = aes(x = date_onset),
    
    breaks = weekly_breaks_central,   # pre-defined date vector - see top of ggplot section
    
    color = "darkblue",
    
    fill = "lightblue") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "1 month",           # 1st of month
    date_minor_breaks = "1 month",     # 1st of month
    date_labels = "%b\n'%y")+          # label format
  
  # labels and theme
  labs(
    title = "Using annotate()\nRectangle and line showing that data from last 21-days are tentative",
    x = "Week of symptom onset",
    y = "Weekly case indicence")+ 
  theme_minimal()+
  
  # add semi-transparent red rectangle to tentative data
  annotate(
    "rect",
    xmin  = as.Date(max(central_data$date_onset, na.rm = T) - 21), # note must be wrapped in as.Date()
    xmax  = as.Date(Inf),                                          # note must be wrapped in as.Date()
    ymin  = 0,
    ymax  = Inf,
    alpha = 0.2,          # alpha easy and intuitive to adjust using annotate()
    fill  = "red")+
  
  # add black vertical line on top of other layers
  annotate(
    "segment",
    x     = max(central_data$date_onset, na.rm = T) - 21, # 21 days before last data
    xend  = max(central_data$date_onset, na.rm = T) - 21, 
    y     = 0,         # line begins at y = 0
    yend  = Inf,       # line to top of plot
    size  = 2,         # line size
    color = "black",
    lty   = "solid")+   # linetype e.g. "solid", "dashed"

  # add text in rectangle
  annotate(
    "text",
    x = max(central_data$date_onset, na.rm = T) - 15,
    y = 15,
    label = "Subject to reporting delays",
    angle = 90)
```

Đường thẳng đứng màu đen có thể tạo ra với code bên dưới, nhưng sử dụng `geom_vline()`, bạn sẽ mất khả năng kiểm soát chiều cao:

```{r, eval=F}
geom_vline(xintercept = max(central_data$date_onset, na.rm = T) - 21,
           size = 2,
           color = "black")
```

### Màu cột {.unnumbered}

Một cách tiếp cận thay thế có thể là điều chỉnh màu sắc hoặc cách hiển thị của chính các cột dữ liệu dự kiến. Bạn có thể tạo một cột mới trong giai đoạn chuẩn bị dữ liệu và sử dụng cột đó để nhóm dữ liệu, sao cho `aes(fill = )` của dữ liệu tạm thời có thể có màu hoặc hệ số alpha khác với các cột khác.

```{r, message=F, warning=F}
# add column
############
plot_data <- central_data %>% 
  mutate(tentative = case_when(
    date_onset >= max(date_onset, na.rm=T) - 7 ~ "Tentative", # tenative if in last 7 days
    TRUE                                       ~ "Reliable")) # all else reliable

# plot
######
ggplot(plot_data, aes(x = date_onset, fill = tentative)) + 
  
  # histogram
  geom_histogram(
    breaks = weekly_breaks_central,   # pre-defined data vector, see top of ggplot page
    color = "black") +

  # scales
  scale_y_continuous(expand = c(0,0))+
  scale_fill_manual(values = c("lightblue", "grey"))+
  scale_x_date(
    expand = c(0,0),                   # remove excess x-axis space below and after case bars
    date_breaks = "3 weeks",           # Monday every 3 weeks
    date_minor_breaks = "week",        # Monday weeks 
    date_labels = "%d\n%b\n'%y")+      # label format
  
  # labels and theme
  labs(title = "Show days that are tentative reporting",
    subtitle = "")+ 
  theme_minimal()+
  theme(legend.title = element_blank())                 # remove title of legend
  
```

## Nhãn ngày nhiều cấp độ

Nếu bạn muốn phân nhiều cấp nhãn ngày (ví dụ: tháng và năm) mà *không sao chép các cấp nhãn cấp độ thấp hơn*, hãy xem xét một trong các cách tiếp cận bên dưới:

Hãy nhớ rằng - bạn có thể sử dụng các công cụ như `\n` *trong* các đối số `date_labels` hoặc `labels` để đặt các phần của mỗi nhãn trên một dòng mới bên dưới. Tuy nhiên, đoạn code dưới đây giúp bạn thực hiện nhiều năm hoặc tháng (ví dụ) ở dòng thấp hơn *và chỉ một lần*. Một số lưu ý về code bên dưới:

-   Số lượng ca bệnh được tổng hợp thành các tuần vì lý do thẩm mỹ. Xem chương Đường cong dịch bệnh (tab dữ liệu tổng hợp) để biết chi tiết.\
-   Một miền `geom_area()` được sử dụng thay vì một histogram, vì phương pháp tiếp cận chia biểu đồ dưới đây không hoạt động tốt với histogram.

**Tổng hợp dữ đếm hàng tuần**

```{r out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F}

# Create dataset of case counts by week
#######################################
central_weekly <- linelist %>%
  filter(hospital == "Central Hospital") %>%   # filter linelist
  mutate(week = lubridate::floor_date(date_onset, unit = "weeks")) %>%  
  count(week) %>%                              # summarize weekly case counts
  drop_na(week) %>%                            # remove cases with missing onset_date
  complete(                                    # fill-in all weeks with no cases reported
    week = seq.Date(
      from = min(week),   
      to   = max(week),
      by   = "week"),
    fill = list(n = 0))                        # convert new NA values to 0 counts
```

**Vẽ biểu đồ**

```{r, warning=F, message=F}
# plot with box border on year
##############################
ggplot(central_weekly) +
  geom_area(aes(x = week, y = n),    # make line, specify x and y
            stat = "identity") +             # because line height is count number
  scale_x_date(date_labels="%b",             # date label format show month 
               date_breaks="month",          # date labels on 1st of each month
               expand=c(0,0)) +              # remove excess space on each end
  scale_y_continuous(
    expand  = c(0,0))+                       # remove excess space below x-axis
  facet_grid(~lubridate::year(week), # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",                # x-axes adapt to data range (not "fixed")
             switch="x") +                   # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",         # facet labels placement
        strip.background = element_rect(fill = NA, # facet labels no fill grey border
                                        colour = "grey50"),
        panel.spacing = unit(0, "cm"))+      # no space between facet panels
  labs(title = "Nested year labels, grey label border")


# plot with no box border on year
#################################
ggplot(central_weekly,
       aes(x = week, y = n)) +              # establish x and y for entire plot
  geom_line(stat = "identity",              # make line, line height is count number
            color = "#69b3a2") +            # line color
  geom_point(size=1, color="#69b3a2") +     # make points at the weekly data points
  geom_area(fill = "#69b3a2",               # fill area below line
            alpha = 0.4)+                   # fill transparency
  scale_x_date(date_labels="%b",            # date label format show month 
               date_breaks="month",         # date labels on 1st of each month
               expand=c(0,0)) +             # remove excess space
  scale_y_continuous(
    expand  = c(0,0))+                      # remove excess space below x-axis
  facet_grid(~lubridate::year(week),        # facet on year (of Date class column)
             space="free_x",                
             scales="free_x",               # x-axes adapt to data range (not "fixed")
             switch="x") +                  # facet labels (year) on bottom
  theme_bw() +
  theme(strip.placement = "outside",                     # facet label placement
          strip.background = element_blank(),            # no facet lable background
          panel.grid.minor.x = element_blank(),          
          panel.border = element_rect(colour="grey40"),  # grey border to facet PANEL
          panel.spacing=unit(0,"cm"))+                   # No space between facet panels
  labs(title = "Nested year labels - points, shaded, no label border")
```

Các kỹ thuật trên được điều chỉnh từ [đây](https://stackoverflow.com/questions/44616530/axis-labels-on-two-lines-with-nested-x-variables-year-below-months) và bài đăng [này](https://stackoverflow.com/questions/20571306/multi-row-x-axis-labels-in-ggplot-line-chart) trên stackoverflow.com.

<!-- ======================================================= -->

## Trục kép

Mặc dù có những cuộc thảo luận gay gắt về tính hợp lệ của trục kép trong cộng đồng về trực quan hóa dữ liệu, nhiều chuyên gia dịch tễ vẫn muốn nhìn nhận biểu đồ đường cong dịch bệnh hoặc biểu đồ tương tự với phần trăm trên trục thứ hai. Điều này được thảo luận nhiều hơn trong chương [Các tips với ggplot], nhưng một ví dụ sử dụng phương pháp **cowplot** được trình bày bên dưới:

-   Hai biểu đồ riêng biệt được tạo, và sau đó được kết hợp với package **cowplot**.\
-   Các biểu đồ phải có chính xác cùng trục x (đã đặt giới hạn), nếu không dữ liệu và nhãn sẽ không được căn chỉnh phù hợp\
-   Mỗi biểu đồ sử dụng `theme_cowplot()` và một biểu đồ có trục y được di chuyển sang phía bên phải của biểu đồ

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
#######################################
plot_cases <- linelist %>% 
  
  # plot cases per week
  ggplot()+
  
  # create histogram  
  geom_histogram(
    
    mapping = aes(x = date_onset),
    
    # bin breaks every week beginning monday before first case, going to monday after last case
    breaks = weekly_breaks_all)+  # pre-defined vector of weekly dates (see top of ggplot section)
        
  # specify beginning and end of date axis to align with other plot
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  # labels
  labs(
      y = "Daily cases",
      x = "Date of symptom onset"
    )+
  theme_cowplot()


# make second plot of percent died per week
###########################################
plot_deaths <- linelist %>%                        # begin with linelist
  group_by(week = floor_date(date_onset, "week")) %>%  # create week column
  
  # summarise to get weekly percent of cases who died
  summarise(n_cases = n(),
            died = sum(outcome == "Death", na.rm=T),
            pct_died = 100*died/n_cases) %>% 
  
  # begin plot
  ggplot()+
  
  # line of weekly percent who died
  geom_line(                                # create line of percent died
    mapping = aes(x = week, y = pct_died),  # specify y-height as pct_died column
    stat = "identity",                      # set line height to the value in pct_death column, not the number of rows (which is default)
    size = 2,
    color = "black")+
  
  # Same date-axis limits as the other plot - perfect alignment
  scale_x_date(
    limits = c(min(weekly_breaks_all), max(weekly_breaks_all)))+  # min/max of the pre-defined weekly breaks of histogram
  
  
  # y-axis adjustments
  scale_y_continuous(                # adjust y-axis
    breaks = seq(0,100, 10),         # set break intervals of percent axis
    limits = c(0, 100),              # set extent of percent axis
    position = "right")+             # move percent axis to the right
  
  # Y-axis label, no x-axis label
  labs(x = "",
       y = "Percent deceased")+      # percent axis label
  
  theme_cowplot()                   # add this to make the two plots merge together nicely
```

Bây giờ sử dụng **cowplot** để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_deaths, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

## Số mới mắc tích lũy

Lưu ý: Nếu sử dụng **incidence2**, hãy xem chương về cách bạn có thể tính số mới mắc tích lũy bằng một hàm đơn giản. Chương này sẽ đề cập đến cách tính số mới mắc tích lũy và vẽ biểu đồ bằng `ggplot()`.

Nếu bắt đầu bằng bộ số liệu `linelist`, hãy tạo một cột mới chứa số ca bệnh tích lũy mỗi ngày trong đợt bùng phát bằng cách sử dụng `cumsum()` từ **base** R:

```{r}
cumulative_case_counts <- linelist %>% 
  count(date_onset) %>%                # count of rows per day (returned in column "n")   
  mutate(                         
    cumulative_cases = cumsum(n)       # new column of the cumulative number of rows at each date
    )
```

10 hàng đầu tiên được hiển thị bên dưới:

```{r message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(cumulative_case_counts, 10), rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

Sau đó, cột tích lũy này có thể được vẽ dựa trên `date_onset`, sử dụng `geom_line()`:

```{r, warning=F, message=F}
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")

plot_cumulative
```

Nó cũng có thể được phủ đè lên đường cong dịch bệnh, với trục kép bằng cách sử dụng phương pháp **cowplot** được mô tả ở trên và trong chương [Các tips với ggplot]:

```{r, warning=F, message=F}
#load package
pacman::p_load(cowplot)

# Make first plot of epicurve histogram
plot_cases <- ggplot()+
  geom_histogram(          
    data = linelist,
    aes(x = date_onset),
    binwidth = 1)+
  labs(
    y = "Daily cases",
    x = "Date of symptom onset"
  )+
  theme_cowplot()

# make second plot of cumulative cases line
plot_cumulative <- ggplot()+
  geom_line(
    data = cumulative_case_counts,
    aes(x = date_onset, y = cumulative_cases),
    size = 2,
    color = "blue")+
  scale_y_continuous(
    position = "right")+
  labs(x = "",
       y = "Cumulative cases")+
  theme_cowplot()+
  theme(
    axis.line.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.x = element_blank(),
    axis.ticks = element_blank())
```

Bây giờ sử dụng **cowplot** để chồng lên hai biểu đồ. Sự chú ý đã được tập trung vào việc căn chỉnh trục x, cạnh của trục y và việc sử dụng `theme_cowplot()`.

```{r, warning=F, message=F}
aligned_plots <- cowplot::align_plots(plot_cases, plot_cumulative, align="hv", axis="tblr")
ggdraw(aligned_plots[[1]]) + draw_plot(aligned_plots[[2]])
```

<!-- ======================================================= -->

## Nguồn tham khảo
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/epicurves.Rmd-->


# Tháp dân số và thang đo Likert {#age-pyramid}  



```{r, out.width = c('50%', '50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "pop_pyramid_baseline.png"))

knitr::include_graphics(here::here("images", "likert.png"))
```


Kim tự tháp nhân khẩu học rất hữu ích khi bạn muốn hiển thị sự phân bố về độ tuổi và giới tính. Code tương tự cũng có thể được sử dụng để trực quan hóa kết quả của các câu hỏi khảo sát kiểu Likert (ví dụ: “Hoàn toàn đồng ý”, “Đồng ý”, “Trung lập”, “Không đồng ý”, “Hoàn toàn không đồng ý”). Trong chương này, chúng tôi đề cập đến những điều sau

* Tạo một tháp dân số nhanh & dễ dàng với package **apyramid**  
* Tùy biến tháp dân số với `ggplot()`  
* Hiển thị dữ liệu nhân khẩu học "nền" trong tháp dân số  
* Sử dụng các biểu đồ kiểu kim tự tháp để hiển thị các loại dữ liệu khác (ví dụ: câu trả lời cho các câu hỏi khảo sát **kiểu Likert**)  





<!-- ======================================================= -->
## Chuẩn bị {}



### Gọi package {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.  

```{r}
pacman::p_load(rio,       # to import data
               here,      # to locate files
               tidyverse, # to clean, handle, and plot the data (includes ggplot2 package)
               apyramid,  # a package dedicated to creating age pyramids
               janitor,   # tables and cleaning data
               stringr)   # working with strings for titles, captions, etc.
```




### Nhập dữ liệu {.unnumbered}  

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết.    

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Làm sạch {.unnumbered}  

Để tạo tháp nhân khẩu học theo độ tuổi/giới tính truyền thống, trước tiên dữ liệu phải được làm sạch theo những cách sau:  

* Cột gender phải được làm sạch.  
* Tùy thuộc vào phương pháp của bạn, độ tuổi phải được lưu trữ dưới dạng số hoặc trong cột *age category*.  

Nếu sử dụng nhóm tuổi, các giá trị trong cột phải được sắp xếp thứ tự, hoặc là thứ tự chữ-số mặc định hoặc được đặt có chủ ý bằng cách chuyển đổi thành kiểu factor.  

Sau đây chúng ta sử dụng hàm `tabyl()` từ package **janitor** để khảo sát hai cột `gender` và `age_cat5`.  

```{r}
linelist %>% 
  tabyl(age_cat5, gender)
```


Chúng ta có thể vẽ biểu đồ histogram đối với cột `age` để chắc chắn rằng nó đã được làm sạch và phân loại chính xác:  

```{r}
hist(linelist$age)
```


<!-- ======================================================= -->
## **apyramid** package {}

Package **apyramid** là một sản phẩm của dự án [R4Epis](https://r4epis.netlify.com/). Bạn có thể đọc thêm về package này [tại đây](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html). Nó cho phép bạn nhanh chóng tạo một tháp tuổi. Để tùy biến đẹp hơn, xem mục [sử dụng `ggplot()`](#demo_pyr_gg). Bạn có thể đọc thêm về package **apyramid** tại trang Help bằng cách nhập `?age_pyramid` vào R console. 

### Dữ liệu Linelist {.unnumbered}  


Sử dụng dữ liệu `linelist` đã làm sạch, chúng ta có thể tạo một tháp tuổi chỉ với một lệnh `age_pyramid()` cơ bản. Trong lệnh này:  

* Đối số `data = ` sử dụng bộ dữ liệu `linelist`  
* Đối số `age_group = ` (trục y) lấy thông tin từ cột nhóm tuổi (trong ngoặc kép)  
* Đối số `split_by = ` (trục x) lấy thông tin từ cột giới  

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender")
```


Tháp có thể hiện thị phần trăm của tất cả các trường hợp trên trục x, thay vì chỉ số lượng, bằng cách thêm `proportional = TRUE`.  

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender",
                      proportional = TRUE)
```


Khi sử dụng package **agepyramid**, nếu cột được phân chia `split_by` là nhị phân (vd. nam/nữ, hoặc có/không), thì kết quả sẽ xuất hiện dưới dạng một kim tự tháp. Tuy nhiên nếu có nhiều hơn hai giá trị trong cột được phân chia `split_by` (không bao gồm `NA`), kim tự tháp sẽ xuất hiện dưới dạng nhiều biểu đồ cột ngang với các thanh màu xám trong "background" cho biết phạm vi của dữ liệu không có mặt cho nhóm tuổi đó. Trong trường hợp này, giá trị của `split_by = ` sẽ xuất hiện dưới dạng nhãn ở đỉnh mỗi biểu đồ. Chẳng hạn, bên dưới là những gì xảy ra nếu `split_by = ` được chỉ định tới cột `hospital`.  

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "hospital")  
```

#### Giá trị Missing {.unnumbered}  

Các hàng chứa giá trị missing `NA` của các cột `split_by = ` hoặc `age_group = `, nếu được mã hóa là `NA`, sẽ không tự động kích hoạt việc phân chia biểu đồ như được hiển thị ở trên. Mặc định những hàng này không được hiển thị. Tuy nhiên, bạn có thể chỉ định các giá trị missing hiển thị, trong một biểu đồ liền kề và dưới dạng một nhóm tuổi riêng biệt, bằng cách chỉ định `na.rm = FALSE`.  

```{r, warning=F, message=F}
apyramid::age_pyramid(data = linelist,
                      age_group = "age_cat5",
                      split_by = "gender",
                      na.rm = FALSE)         # show patients missing age or gender
```

#### Tỷ lệ, màu sắc, & thẩm mỹ {.unnumbered}  

Theo mặc định, các cột hiển thị số lượng (không phải %), đường gạch ngang giữa cho mỗi nhóm được hiển thị và màu sắc là xanh lục/tím. Các thông số này có thể được điều chỉnh, như được trình bày dưới đây:

Bạn cũng có thể thêm các lệnh `ggplot()` vào biểu đồ bằng cách sử dụng các cú pháp chuẩn của `ggplot()` "+" , chẳng hạn như chủ đề trang trí và điều chỉnh nhãn: 

```{r, warning=F, message=F}
apyramid::age_pyramid(
  data = linelist,
  age_group = "age_cat5",
  split_by = "gender",
  proportional = TRUE,              # show percents, not counts
  show_midpoint = FALSE,            # remove bar mid-point line
  #pal = c("orange", "purple")      # can specify alt. colors here (but not labels)
  )+                 
  
  # additional ggplot commands
  theme_minimal()+                               # simplfy background
  scale_fill_manual(                             # specify colors AND labels
    values = c("orange", "purple"),              
    labels = c("m" = "Male", "f" = "Female"))+
  labs(y = "Percent of all cases",              # note x and y labs are switched
       x = "Age categories",                          
       fill = "Gender", 
       caption = "My data source and caption here",
       title = "Title of my plot",
       subtitle = "Subtitle with \n a second line...")+
  theme(
    legend.position = "bottom",                          # legend to bottom
    axis.text = element_text(size = 10, face = "bold"),  # fonts/sizes
    axis.title = element_text(size = 12, face = "bold"))
```



### Dữ liệu được tổng hợp {.unnumbered}  

Ví dụ bên trên giả định rằng dữ liệu của bạn có định dạng mỗi hàng cho một quan sát. Nếu dữ liệu của bạn đã được tổng hợp thành số lượng theo nhóm tuổi, bạn vẫn có thể sử dụng package **apyramid**, như được trình bày dưới đây.  

Để minh họa, chúng ta sẽ tổng hợp dữ liệu linelist theo số lượng đối với nhóm tuổi và giới, dưới định dạng "ngang". Việc này sẽ mô phỏng như thể dữ liệu ban đầu của bạn đang được trình bày dưới dạng số lượng. Tìm hiểu thêm về [Nhóm dữ liệu] và [Xoay trục dữ liệu] ở các chương tương ứng.  

```{r, warning=F, message=F}
demo_agg <- linelist %>% 
  count(age_cat5, gender, name = "cases") %>% 
  pivot_wider(
    id_cols = age_cat5,
    names_from = gender,
    values_from = cases) %>% 
  rename(`missing_gender` = `NA`)
```

...lệnh trên sẽ khiến bộ dữ liệu trông như thế này: bao gồm các cột nhóm tuổi, số lượng nam, nữ, và missing.  

```{r, echo=F, warning=F, message=F}
# View the aggregated data
DT::datatable(demo_agg, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Để thiết lập chủ đề cho tháp tuổi, chúng ta sẽ xoay trục dữ liệu sang dạng "dọc" bằng hàm `pivot_longer()` trong package **dplyr**. Đó là bởi vì `ggplot()` thường thích dữ liệu được bố trí ở dạng "dọc", và package **apyramid** đang sử dụng `ggplot()`.  

```{r, warning=F, message=F}
# pivot the aggregated data into long format
demo_agg_long <- demo_agg %>% 
  pivot_longer(
    col = c(f, m, missing_gender),            # cols to elongate
    names_to = "gender",                # name for new col of categories
    values_to = "counts") %>%           # name for new col of counts
  mutate(
    gender = na_if(gender, "missing_gender")) # convert "missing_gender" to NA
``` 

```{r, echo=F, warning=F, message=F}
# View the aggregated data
DT::datatable(demo_agg_long, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Sau đó sử dụng các đối số `split_by = ` và `count = ` của hàm `age_pyramid()` để chỉ định các cột tương ứng trong bộ dữ liệu:  

```{r, warning=F, message=F}
apyramid::age_pyramid(data = demo_agg_long,
                      age_group = "age_cat5",# column name for age category
                      split_by = "gender",   # column name for gender
                      count = "counts")      # column name for case counts
```

Lưu ý rằng ở trên, thứ tự của "m" và "f" là khác nhau (tháp bị đảo ngược). Để điều chỉnh thự tự, bạn phải định nghĩa lại cột giới trong dữ liệu được tổng hợp thành kiểu Factor và sắp xếp thứ tự như mong muốn. Xem chương [Factors].  




<!-- ======================================================= -->
## `ggplot()` {#demo_pyr_gg}


Sử dụng `ggplot()` cho phép bạn xây dựng tháp tuổi một cách linh hoạt hơn, nhưng đòi hỏi nhiều nỗ lực và hiểu biết hơn về cách hoạt động của `ggplot()`. Việc vô tình mắc sai lầm cũng dễ dàng hơn.  

Để sử dụng `ggplot()` tạo tháp nhân khẩu học, bạn tạo hai biểu đồ cột (cho từng giới tính), chuyển đổi các giá trị trong một biểu đồ thành âm và cuối cùng lật các trục x và y để hiển thị các biểu đồ cột theo chiều dọc, xuất phát điểm của chúng gặp nhau ở chính giữa biểu đồ.  


### Chuẩn bị {.unnumbered}

Cách tiếp cận này sử dụng cột tuổi ở dạng *numeric*, không phải cột nhóm tuổi `age_cat5` dạng *categorical*. Vì vậy, chúng ta cần kiểm tra để đảm bảo rằng kiểu của cột này thực sự là dạng số.  

```{r}
class(linelist$age)
```

Bạn có thể sử dụng logic tương tự như dưới đây để xây dựng một kim tự tháp từ dữ liệu dạng danh mục sử dụng `geom_col()` thay vì `geom_histogram()`.  

<!-- ======================================================= -->
### Xây dựng biểu đồ {.unnumbered} 

Trước tiên, hãy hiểu rằng để tạo một kim tự tháp như vậy bằng cách sử dụng `ggplot()`, cách tiếp cận sẽ là như sau:

* Bên trong hàm `ggplot()`, tạo **hai** biểu đồ histograms sử dụng cột tuổi dạng numeric, tương ứng cho hai nhóm (trong trường hợp này là giới nam và nữ). Để thực hiện việc này, dữ liệu cho mỗi biểu đồ được chỉ định trong các lệnh `geom_histogram()` tương ứng của chúng, với các bộ lọc tương ứng được áp dụng cho bộ dữ liệu `linelist`.    

* Một biểu đồ sẽ có các giá trị dương, trong khi biểu đồ kia sẽ có các giá trị được chuyển thành giá trị âm - điều này tạo ra “kim tự tháp” với giá trị `0` ở giữa biểu đồ. Các giá trị âm được tạo bằng cách sử dụng thuật ngữ đặc biệt của  **ggplot2** là `..count..` và nhân với -1.  

* Lệnh `coord_flip()` chuyển trục X và Y, dẫn đến các đồ thị quay dọc và tạo ra hình kim tự tháp.

* Cuối cùng, các nhãn giá trị trục đếm phải được thay đổi để chúng xuất hiện dưới dạng số "dương" trên cả hai mặt của kim tự tháp (mặc dù các giá trị thực tế ở một mặt là âm). 

Một phiên bản **đơn giản** của biểu đồ, sử dụng hàm `geom_histogram()`, như dưới đây:

```{r, warning=F, message=F}
  # begin ggplot
  ggplot(mapping = aes(x = age, fill = gender)) +
  
  # female histogram
  geom_histogram(data = linelist %>% filter(gender == "f"),
                 breaks = seq(0,85,5),
                 colour = "white") +
  
  # male histogram (values converted to negative)
  geom_histogram(data = linelist %>% filter(gender == "m"),
                 breaks = seq(0,85,5),
                 mapping = aes(y = ..count..*(-1)),
                 colour = "white") +
  
  # flip the X and Y axes
  coord_flip() +
  
  # adjust counts-axis scale
  scale_y_continuous(limits = c(-600, 900),
                     breaks = seq(-600,900,100),
                     labels = abs(seq(-600, 900, 100)))
```

<span style="color: red;">**_NGUY HIỂM:_** Nếu như **giới hạn** của trục counts được thiết lập quá nhỏ, và cột số lượng vượt quá giá trị đó, cột sẽ biến mất hoàn toàn hoặc bị rút ngắn một cách không tự nhiên! Hãy chú ý điều này nếu dữ liệu phân tích thường xuyên được cập nhật. Có thể ngăn chặn điều này bằng cách tự động điều chỉnh các giới hạn trục count cho phù hợp với dữ liệu của bạn, như dưới đây.</span>  

Có nhiều thứ bạn có thể thay đổi/thêm vào phiên bản đơn giản này, bao gồm:  

* Tự động điều chỉnh tỷ lệ trục count cho dữ liệu của bạn (tránh các lỗi được thảo luận trong cảnh báo bên dưới)  
* Chỉ định màu sắc và nhãn chú giải một cách thủ công  

**Chuyển đổi số lượng thành tỷ lệ phần trăm**  

Để chuyển đổi số lượng thành phần trăm (của tổng số), hãy thực hiện điều này với dữ liệu của bạn trước khi vẽ biểu đồ. Dưới đây, chúng ta lấy số lượng của age-gender, sau đó `ungroup()`, và tiếp tục `mutate()` để tạo cột phần trăm mới. Nếu bạn muốn phần trăm theo giới tính, hãy bỏ qua bước hủy nhóm.  


```{r, warning=F, message=F}
# create dataset with proportion of total
pyramid_data <- linelist %>%
  count(age_cat5,
        gender,
        name = "counts") %>% 
  ungroup() %>%                 # ungroup so percents are not by group
  mutate(percent = round(100*(counts / sum(counts, na.rm=T)), digits = 1), 
         percent = case_when(
            gender == "f" ~ percent,
            gender == "m" ~ -percent,     # convert male to negative
            TRUE          ~ NA_real_))    # NA val must by numeric as well
```

Quan trọng là, chúng ta lưu các giá trị lớn nhất vầ nhỏ nhất để chúng ta biết giới hạn của thang đo. Chúng sẽ được sử dụng trong lệnh `ggplot()` dưới đây.    

```{r}
max_per <- max(pyramid_data$percent, na.rm=T)
min_per <- min(pyramid_data$percent, na.rm=T)

max_per
min_per
```

Cuối cùng, chúng ta dùng hàm `ggplot()` trên dữ liệu phần trăm. Chúng ta chỉ rõ `scale_y_continuous()` để mở rộng độ dài được xác định trước theo mỗi hướng (dương và "âm"). Chúng ta sử dụng hàm `floor()` vả `ceiling()` để làm tròn số thập phân theo cách thích hợp (làm tròn xuống hoặc lên).  

```{r, warning=F, message=F}
# begin ggplot
  ggplot()+  # default x-axis is age in years;

  # case data graph
  geom_col(data = pyramid_data,
           mapping = aes(
             x = age_cat5,
             y = percent,
             fill = gender),         
           colour = "white")+       # white around each bar
  
  # flip the X and Y axes to make pyramid vertical
  coord_flip()+
  

  # adjust the axes scales
  # scale_x_continuous(breaks = seq(0,100,5), labels = seq(0,100,5)) +
  scale_y_continuous(
    limits = c(min_per, max_per),
    breaks = seq(from = floor(min_per),                # sequence of values, by 2s
                 to = ceiling(max_per),
                 by = 2),
    labels = paste0(abs(seq(from = floor(min_per),     # sequence of absolute values, by 2s, with "%"
                            to = ceiling(max_per),
                            by = 2)),
                    "%"))+  

  # designate colors and legend labels manually
  scale_fill_manual(
    values = c("f" = "orange",
               "m" = "darkgreen"),
    labels = c("Female", "Male")) +
  
  # label values (remember X and Y flipped now)
  labs(
    title = "Age and gender of cases",
    x = "Age group",
    y = "Percent of total",
    fill = NULL,
    caption = stringr::str_glue("Data are from linelist \nn = {nrow(linelist)} (age or sex missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases) \nData as of: {format(Sys.Date(), '%d %b %Y')}")) +
  
  # display themes
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0.5), 
    plot.caption = element_text(hjust=0, size=11, face = "italic")
    )

```



<!-- ======================================================= -->
### So sánh với đường cơ sở  {.unnumbered} 

With the flexibility of `ggplot()`, you can have a second layer of bars in the background that represent the "true" or "baseline" population pyramid. This can provide a nice visualization to compare the observed with the baseline.  

Với sự linh hoạt của `ggplot()`, bạn có thể có lớp thanh thứ hai trong nền đại diện cho tháp dân số “chuẩn” hoặc “đường cơ sở”. Điều này có thể cung cấp khả năng trực quan hóa tốt để so sánh những gì quan sát được với đường cơ sở.

Nhập và xem dữ liệu dân số (xem chương [Tải sách và dữ liệu]):

```{r echo=F}
# import the population demographics data
pop <- rio::import(here::here("data", "standardization", "country_demographics.csv"))
```

```{r eval=F}
# import the population demographics data
pop <- rio::import("country_demographics.csv")
```

```{r, echo=F, warning=F, message=F}
# display the linelist data as a table
DT::datatable(pop, rownames = FALSE, options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


Đầu tiên là một số bước quản lý dữ liệu:  

Ở đây chúng ta sắp xếp lại thứ tự của các danh mục tuổi mà chúng ta muốn chúng xuất hiện. Do một số điểm khác biệt trong cách thực thi `ggplot()`, trong trường hợp cụ thể này, dễ dàng nhất là lưu trữ chúng dưới dạng vectơ ký tự và sử dụng chúng sau này trong hàm vẽ đồ thị.  

```{r}
# record correct age cat levels
age_levels <- c("0-4","5-9", "10-14", "15-19", "20-24",
                "25-29","30-34", "35-39", "40-44", "45-49",
                "50-54", "55-59", "60-64", "65-69", "70-74",
                "75-79", "80-84", "85+")
```

Kết hợp dữ liệu quần thể và dữ liệu trường hợp thông qua hàm `bind_rows()` của package  **dplyr**:  

* Trước tiên, hãy đảm bảo hai bộ dữ liệu có tên cột *giống nhau*, các giá trị nhóm tuổi và giá trị giới tính  
* Làm cho chúng có cấu trúc dữ liệu giống nhau: cột nhóm tuổi, giới tính, số lượng và phần trăm tổng số 
* Gắn chúng lại với nhau, một bộ dữ liệu này ở trên bộ dữ liệu kia (`bind_rows()`)  



```{r, warning=F, message=F}
# create/transform populaton data, with percent of total
########################################################
pop_data <- pop %>% 
  pivot_longer(      # pivot gender columns longer
    cols = c(m, f),
    names_to = "gender",
    values_to = "counts") %>% 
  
  mutate(
    percent  = round(100*(counts / sum(counts, na.rm=T)),1),  # % of total
    percent  = case_when(                                                        
     gender == "f" ~ percent,
     gender == "m" ~ -percent,               # if male, convert % to negative
     TRUE          ~ NA_real_))
```

Xem lại bộ dữ liệu dân số đã thay đổi

```{r, echo=F, warning=F, message=F}
# display the linelist data as a table
DT::datatable(pop_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Bây giờ thực hiện tương tự cho bộ linelist. Sẽ hơi khác một chút bởi vì nó bắt đầu với các trường hợp theo hàng, không phải số lượng.  

```{r, warning=F, message=F}
# create case data by age/gender, with percent of total
#######################################################
case_data <- linelist %>%
  count(age_cat5, gender, name = "counts") %>%  # counts by age-gender groups
  ungroup() %>% 
  mutate(
    percent = round(100*(counts / sum(counts, na.rm=T)),1),  # calculate % of total for age-gender groups
    percent = case_when(                                     # convert % to negative if male
      gender == "f" ~ percent,
      gender == "m" ~ -percent,
      TRUE          ~ NA_real_))
```

Xem lại bộ dữ liệu trường hợp đã thay đổi  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(case_data, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Bây giờ hai data frame sẽ được kết hợp, cái này ở trên cái kia (chúng có cùng tên cột). Chúng ta có thể "đặt tên" cho từng data frame, và sử dụng đối số `.id = ` để tạo một cột mới "data_source" sẽ cho biết dữ liệu có nguồn gốc từ data frame nào. Chúng tôi có thể sử dụng cột này để lọc với hàm `ggplot()`.  



```{r, warning=F, message=F}
# combine case and population data (same column names, age_cat values, and gender values)
pyramid_data <- bind_rows("cases" = case_data, "population" = pop_data, .id = "data_source")
```

Lưu trữ các giá trị phần trăm tối đa và tối thiểu, được sử dụng trong hàm vẽ biểu đồ để xác định phạm vi của biểu đồ (và không cắt ngắn bất kỳ cột nào!)

```{r}
# Define extent of percent axis, used for plot limits
max_per <- max(pyramid_data$percent, na.rm=T)
min_per <- min(pyramid_data$percent, na.rm=T)
```

Bây giờ biểu đồ được tạo bởi `ggplot()` có: 

* Một biểu đồ cột ngang của dữ liệu dan số (rộng hơn, trong suốt)
* Một biểu đồ cột ngang của dữ liệu các trường hợp (nhỏ hơn, đậm hơn)  


```{r, warning=F, message=F}

# begin ggplot
##############
ggplot()+  # default x-axis is age in years;

  # population data graph
  geom_col(
    data = pyramid_data %>% filter(data_source == "population"),
    mapping = aes(
      x = age_cat5,
      y = percent,
      fill = gender),
    colour = "black",                               # black color around bars
    alpha = 0.2,                                    # more transparent
    width = 1)+                                     # full width
  
  # case data graph
  geom_col(
    data = pyramid_data %>% filter(data_source == "cases"), 
    mapping = aes(
      x = age_cat5,                               # age categories as original X axis
      y = percent,                                # % as original Y-axis
      fill = gender),                             # fill of bars by gender
    colour = "black",                               # black color around bars
    alpha = 1,                                      # not transparent 
    width = 0.3)+                                   # half width
  
  # flip the X and Y axes to make pyramid vertical
  coord_flip()+
  
  # manually ensure that age-axis is ordered correctly
  scale_x_discrete(limits = age_levels)+     # defined in chunk above
  
  # set percent-axis 
  scale_y_continuous(
    limits = c(min_per, max_per),                                          # min and max defined above
    breaks = seq(floor(min_per), ceiling(max_per), by = 2),                # from min% to max% by 2 
    labels = paste0(                                                       # for the labels, paste together... 
              abs(seq(floor(min_per), ceiling(max_per), by = 2)), "%"))+                                                  

  # designate colors and legend labels manually
  scale_fill_manual(
    values = c("f" = "orange",         # assign colors to values in the data
               "m" = "darkgreen"),
    labels = c("f" = "Female",
               "m"= "Male"),      # change labels that appear in legend, note order
  ) +

  # plot labels, titles, caption    
  labs(
    title = "Case age and gender distribution,\nas compared to baseline population",
    subtitle = "",
    x = "Age category",
    y = "Percent of total",
    fill = NULL,
    caption = stringr::str_glue("Cases shown on top of country demographic baseline\nCase data are from linelist, n = {nrow(linelist)}\nAge or gender missing for {sum(is.na(linelist$gender) | is.na(linelist$age_years))} cases\nCase data as of: {format(max(linelist$date_onset, na.rm=T), '%d %b %Y')}")) +
  
  # optional aesthetic themes
  theme(
    legend.position = "bottom",                             # move legend to bottom
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.background = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.title = element_text(hjust = 0), 
    plot.caption = element_text(hjust=0, size=11, face = "italic"))

```


<!-- ======================================================= -->
## Thang đo Likert {}

Các kỹ thuật được sử dụng để tạo tháp dân số với `ggplot()` cũng có thể được sử dụng để lập các biểu đồ của dữ liệu khảo sát từ thang đo Likert.  

```{r, eval=F, echo=F}
data_raw <- import("P:/Shared/equateur_mve_2020/lessons learned/Ebola After-Action Survey - HQ epi team (form responses).csv")


likert_data <- data_raw %>% 
  select(2, 4:11) %>% 
  rename(status = 1,
         Q1 = 2,
         Q2 = 3,
            Q3 = 4,
            Q4 = 5,
            Q5 = 6,
            Q6 = 7,
            Q7 = 8,
            Q8 = 9) %>% 
  mutate(status = case_when(
           stringr::str_detect(status, "Mar") ~ "Senior",
           stringr::str_detect(status, "Jan") ~ "Intermediate",
           stringr::str_detect(status, "Feb") ~ "Junior",
           TRUE ~ "Senior")) %>% 
  mutate(Q4 = recode(Q4, "Not applicable" = "Very Poor"))

table(likert_data$status)

rio::export(likert_data, here::here("data", "likert_data.csv"))
```

Nhập dữ liệu (xem chương [Tải sách và dữ liệu] nếu cần).  

```{r echo=F}
# import the likert survey response data
likert_data <- rio::import(here::here("data", "likert_data.csv"))
```

```{r, eval=F}
# import the likert survey response data
likert_data <- rio::import("likert_data.csv")
```

Bắt đầu với dữ liệu giống như sau, với một biến phân loại từng người trả lời (`status`) và câu trả lời của họ cho 8 câu hỏi trên thang điểm Likert 4 mức độ ("Rất kém", "Kém", "Tốt", "Rất tốt").  

```{r, echo=F, message=FALSE}
# display the linelist data as a table
DT::datatable(likert_data, rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```

Đầu tiên là một vài bước quản lý số liệu:  

* Xoay trục dữ liệu dài hơn
* Tạo cột mới `direction` tùy thuộc vào việc phản hồi "tích cực" hay "tiêu cực"
* Thiết lập thứ bậc kiểu factor cho cột `status` và cột `Response`  
* Lưu trữ giá trị đếm tối đa để các giới hạn của biểu đồ là phù hợp  


```{r, warning=F, message=F}
melted <- likert_data %>% 
  pivot_longer(
    cols = Q1:Q8,
    names_to = "Question",
    values_to = "Response") %>% 
  mutate(
    
    direction = case_when(
      Response %in% c("Poor","Very Poor")  ~ "Negative",
      Response %in% c("Good", "Very Good") ~ "Positive",
      TRUE                                 ~ "Unknown"),
    
    status = fct_relevel(status, "Junior", "Intermediate", "Senior"),
    
    # must reverse 'Very Poor' and 'Poor' for ordering to work
    Response = fct_relevel(Response, "Very Good", "Good", "Very Poor", "Poor")) 

# get largest value for scale limits
melted_max <- melted %>% 
  count(status, Question) %>% # get counts
  pull(n) %>%                 # column 'n'
  max(na.rm=T)                # get max
```


Bây giờ hãy cùng vẽ biểu đồ. Tương tự các tháp tuổi ở trên, chúng ta đang tạo hai biểu đồ thanh và đảo các giá trị của một trong số chúng thành âm. 

Chúng ta sử dụng hàm `geom_bar()` bởi vì dữ liệu của chúng ta mỗi quan sát nằm trên một hàng, không phải là số lượng tổng hợp. Chúng ta sử dụng thuật ngữ đặc biệt của **ggplot2** là `..count..` ở một biểu đồ thanh để đảo ngược các giá trị thành âm(*-1), sau đó chúng ta thiết lập `position = "stack"` để các giá trị xếp chồng lên nhau.  

```{r, warning=F, message=F}
# make plot
ggplot()+
     
  # bar graph of the "negative" responses 
     geom_bar(
       data = melted %>% filter(direction == "Negative"),
       mapping = aes(
         x = status,
         y = ..count..*(-1),    # counts inverted to negative
         fill = Response),
       color = "black",
       closed = "left",
       position = "stack")+
     
     # bar graph of the "positive responses
     geom_bar(
       data = melted %>% filter(direction == "Positive"),
       mapping = aes(
         x = status,
         fill = Response),
       colour = "black",
       closed = "left",
       position = "stack")+
     
     # flip the X and Y axes
     coord_flip()+
  
     # Black vertical line at 0
     geom_hline(yintercept = 0, color = "black", size=1)+
     
    # convert labels to all positive numbers
    scale_y_continuous(
      
      # limits of the x-axis scale
      limits = c(-ceiling(melted_max/10)*11,    # seq from neg to pos by 10, edges rounded outward to nearest 5
                 ceiling(melted_max/10)*10),   
      
      # values of the x-axis scale
      breaks = seq(from = -ceiling(melted_max/10)*10,
                   to = ceiling(melted_max/10)*10,
                   by = 10),
      
      # labels of the x-axis scale
      labels = abs(unique(c(seq(-ceiling(melted_max/10)*10, 0, 10),
                            seq(0, ceiling(melted_max/10)*10, 10))))) +
     
    # color scales manually assigned 
    scale_fill_manual(
      values = c("Very Good"  = "green4", # assigns colors
                "Good"      = "green3",
                "Poor"      = "yellow",
                "Very Poor" = "red3"),
      breaks = c("Very Good", "Good", "Poor", "Very Poor"))+ # orders the legend
     
    
     
    # facet the entire plot so each question is a sub-plot
    facet_wrap( ~ Question, ncol = 3)+
     
    # labels, titles, caption
    labs(
      title = str_glue("Likert-style responses\nn = {nrow(likert_data)}"),
      x = "Respondent status",
      y = "Number of responses",
      fill = "")+

     # display adjustments 
     theme_minimal()+
     theme(axis.text = element_text(size = 12),
           axis.title = element_text(size = 14, face = "bold"),
           strip.text = element_text(size = 14, face = "bold"),  # facet sub-titles
           plot.title = element_text(size = 20, face = "bold"),
           panel.background = element_rect(fill = NA, color = "black")) # black box around each facet
```


<!-- ======================================================= -->
## Nguồn {}

[apyramid documentation](https://cran.r-project.org/web/packages/apyramid/vignettes/intro.html)



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/age_pyramid.Rmd-->


# Biểu đồ nhiệt {#heatmaps}  


Biểu đồ nhiệt, còn được gọi là "bản đồ nhiệt" hoặc "bảng nhiệt", là những hình ảnh trực quan hữu ích khi cố gắng hiển thị 3 biến (trục x, trục y và màu sắc). Dưới đây chúng tôi minh họa hai ví dụ:

* Ma trận trực quan về các sự kiện lây truyền theo độ tuổi ("ai lây nhiễm cho ai")
* Theo dõi các chỉ số báo cáo trên nhiều cơ sở/khu vực theo thời gian 

```{r, out.width = c('50%', '50%'), fig.show='hold', warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "transmission_matrix.png"))

knitr::include_graphics(here::here("images", "heat_tile.png"))

```





<!-- ======================================================= -->
## Chuẩn bị { }

### Gọi packages {.unnumbered}  

Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho việc phân tích dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt packages nếu cần *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các packages trong R. 

```{r}
pacman::p_load(
  tidyverse,       # data manipulation and visualization
  rio,             # importing data 
  lubridate        # working with dates
  )
```

**Bộ dữ liệu**  

Chương này sẽ sử dụng bộ dữ liệu linelist-một vụ dịch mô phỏng trong mục ma trận lây truyền và bộ dữ liệu về số trường hợp sốt rét được ghi nhận hàng ngày theo cơ sở trong phần theo dõi các chỉ số báo cáo. Các bộ dữ liệu sẽ được gọi và làm sạch trong khi trình bày. 






## Ma trận lây truyền 

Bảng nhiệt có thể hữu ích để trực quan hóa ma trận. Một ví dụ là hiển thị "ai đã lây nhiễm cho ai" trong một vụ dịch. Giả sử rằng bạn có đầy đủ thông tin về các sự kiện lây truyền. 

Lưu ý rằng chương [Truy vết tiếp xúc] có một ví dụ khác về tạo ma trận tiếp xúc thành bảng nhiệt, sử dụng một dataset khác (có lẽ đơn giản hơn) trong đó tuổi của các trường hợp và nguồn lây của chúng được căn chỉnh gọn gàng trên cùng một hàng của data frame. Dataset này cũng được sử dụng để tạo bản đồ *mật độ* trong chương [Các tips với ggplot]. Ví dụ dưới đây bắt đầu từ một danh sách các trường hợp và yêu cầu nhiều thao tác biến đổi dữ liệu trước khi thành một data frame sẵn sàng để vẽ biểu đồ. Vì vậy, có rất nhiều kịch bản để bạn lựa chọn...


Chúng tôi bắt đầu từ danh sách trường hợp của một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải bộ dữ liệu linelist "đã làm sạch"</a> (as .rds file). Nhập dữ liệu của bạn bằng hàm `import()` từ package **rio**  (hàm này chấp nhận nhiều loại tệp như .xlsx, .rds, .csv - Xem chương [Nhập xuất dữ liệu] để biết thêm chi tiết). 


Danh sách dưới đây bao gồm 50 hàng đầu tiên của linelist: 


```{r, echo=F}
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```


```{r, eval=F}
linelist <- import("linelist_cleaned.rds")
```


Trong bộ dữ liệu linelist này:  

* Mỗi trường hợp được thể hiện trên một hàng, được định danh bằng `case_id`  
* Kéo sang phải bạn sẽ thấy cột `infector` có chứa `case_id` của *nguồn lây*, mỗi nguồn lây cũng là một trường hợp trong linelist


```{r message=FALSE, echo=F}
# display the population as a table
DT::datatable(head(linelist, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



### Chuẩn bị dữ liệu {.unnumbered}  

**Mục tiêu**: Chúng ta cần tạo một data frame dạng "dọc", tức là mỗi đường lây truyền theo lứa tuổi có thể có nằm trên một hàng, với một cột số chứa tỷ lệ của hàng đó đối với tất cả các sự kiện lây nhiễm được quan sát trong linelist. 

Để đạt được mục tiêu này, một số bước biến đổi dữ liệu cần được thực hiện:  

#### Tạo data frame các trường hợp {.unnumbered} 

Để bắt đầu, chúng ta tạo một data frame về các trường hợp, bao gồm độ tuổi và nguồn lây nhiễm của chúng - chúng ta đặt tên data frame này là `case_ages`. 50 hàng đầu tiên của bộ dữ liệu dữ liệu được hiển thị bên dưới.   

```{r}
case_ages <- linelist %>% 
  select(case_id, infector, age_cat) %>% 
  rename("case_age_cat" = "age_cat")
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(case_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

#### Tạo data frame nguồn lây nhiễm {.unnumbered}  

Tiếp theo, chúng ta tạo một data frame các nguồn lây nhiễm - tại thời điểm này, nó chỉ gồm một cột duy nhất. Đây là các ID của các nguồn lâu nhiễm trong bộ dữ liệu linelist. Không phải mọi trường hợp đều xác định được nguồn lây, vì vậy chúng ta cần loại bỏ các giá trị missing. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
infectors <- linelist %>% 
  select(infector) %>% 
  drop_na(infector)
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infectors, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Tiếp theo, chúng ta sử dụng hàm join để thu thập tuổi của những nguồn lây nhiễm. Điều này không đơn giản, vì trong `linelist`, tuổi của người lây nhiễm không được liệt kê như vậy. Chúng ta sẽ đạt được kết quả này bằng cách nối dữ liệu các trường hợp trong `linelist` với dữ liệu những người lây nhiễm. Chúng ta bắt đầu với bộ dữ liệu infectors, sau đó dùng hàm `left_join()` thêm các trường hợp trong `linelist` sao cho cột id của các trường hợp lây nhiễm trong bộ dữ liệu `infector` nối với cột `case_id` trong bộ dữ liệu `linelist`. 

Do đó, dữ liệu từ bản ghi trường hợp của người lây nhiễm trong linelist (bao gồm cả tuổi) được thêm vào hàng của người lây nhiễm. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
infector_ages <- infectors %>%             # begin with infectors
  left_join(                               # add the linelist data to each infector  
    linelist,
    by = c("infector" = "case_id")) %>%    # match infector to their information as a case
  select(infector, age_cat) %>%            # keep only columns of interest
  rename("infector_age_cat" = "age_cat")   # rename for clarity
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(infector_ages, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Sau đó, chúng ta kết hợp các trường hợp và tuổi của chúng với những người lây nhiễm và tuổi của những người này lại. Mỗi data frame đều có chung cột `infector`, vì vậy nó được sử dụng cho phép nối. Các hàng đầu tiên được hiển thị bên dưới: 

```{r}
ages_complete <- case_ages %>%  
  left_join(
    infector_ages,
    by = "infector") %>%        # each has the column infector
  drop_na()                     # drop rows with any missing data
```


```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(ages_complete, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Dưới đây là bảng chéo đơn giản về số lượng các trường hợp và người lây nhiễm theo nhóm tuổi. Nhãn được thêm vào để phân biệt. 

```{r}
table(cases = ages_complete$case_age_cat,
      infectors = ages_complete$infector_age_cat)
```


Chúng ta có thể chuyển đổi bảng này thành data frame với hàm `data.frame()` từ **base** R, hàm sẽ tự động chuyển đổi dữ liệu sang dạng "dọc" để có thể áp dụng trong hàm `ggplot()`. Các hàng đầu tiên được hiển thị bên dưới. 

```{r}
long_counts <- data.frame(table(
    cases     = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_counts, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


Bây giờ chúng ta làm tương tự, nhưng áp dụng hàm `prop.table()` từ **base** R vào bảng để thay vì nhận số lượng, chúng ta nhận được tỷ lệ của tất cả các biến. 50 hàng đầu tiên được hiển thị bên dưới. 

```{r}
long_prop <- data.frame(prop.table(table(
    cases = ages_complete$case_age_cat,
    infectors = ages_complete$infector_age_cat)))
```

```{r message=FALSE, echo=F}
# display the shapefile as a table
DT::datatable(head(long_prop, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```




### Tạo biểu đồ nhiệt {.unnumbered}  

Cuối cùng, chúng ta có thể vẽ biểu đồ nhiệt với hàm `geom_tile()` trong package **ggplot2**. Xem chương [Các tips với ggplot] để tìm hiểu sâu hơn về thang màu/tô màu cho biểu đồ, đặc biệt là hàm `scale_fill_gradient()`. 

* Bên trong hàm `aes()` của hàm `geom_tile()`, thiết lập trục x và y tương ứng với tuổi của các trường hợp và tuổi của người lây nhiễm  
* Ngoài ra trong hàm `aes()`, hãy đặt đối số `fill = ` tới cột tần suất `Freq` -  đây là giá trị sẽ được chuyển đổi thành màu gạch
* Đặt màu thang đo với `scale_fill_gradient()` -  bạn có thể chỉ định màu cao/thấp  
  * Lưu ý rằng `scale_color_gradient()` là một cái khác! Trong trường hợp này, bạn sẽ sử dụng fill
* Bởi vì màu được tạo thông qua "fill", bạn có thể sử dụng đối số  `fill = ` đối số trong hàm `labs()` để thay đổi tiêu đề chú giải 

```{r}
ggplot(data = long_prop)+       # use long data, with proportions as Freq
  geom_tile(                    # visualize it in tiles
    aes(
      x = cases,         # x-axis is case age
      y = infectors,     # y-axis is infector age
      fill = Freq))+            # color of the tile is the Freq column in the data
  scale_fill_gradient(          # adjust the fill color of the tiles
    low = "blue",
    high = "orange")+
  labs(                         # labels
    x = "Case age",
    y = "Infector age",
    title = "Who infected whom",
    subtitle = "Frequency matrix of transmission events",
    fill = "Proportion of all\ntranmsission events"     # legend title
  )
  
```



<!-- ======================================================= -->
## Các chỉ số báo cáo theo thời gian { }

Thông thường, trong lĩnh vực y tế công cộng, một mục tiêu là đánh giá xu hướng theo thời gian của nhiều thực thể (cơ sở, khu vực pháp lý, v.v.). Một cách để hình dung các xu hướng như vậy theo thời gian là biểu đồ nhiệt trong đó trục x là thời gian và trên trục y là các thực thể. 


### Chuẩn bị dữ liệu {.unnumbered}

Chúng ta bắt đầu bằng cách nhập bộ dữ liệu báo cáo về bệnh sốt rét hàng ngày từ nhiều cơ sở. Các báo cáo chứa dữu liệu về ngày, tỉnh, huyện và số trường hợp sốt rét. Xem chương [Tải sách và dữ liệu] để biết thông tin về cách tải xuống các dữ liệu này. Dưới đây là 30 hàng đầu tiên: 

```{r, echo=F}
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  select(location_name, data_date, District, malaria_tot)
```

```{r, eval=F}
facility_count_data <- import("malaria_facility_count_data.rds")
```


```{r, echo=F}
DT::datatable(head(facility_count_data,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


#### Tổng hợp và tóm tắt {.unnumbered}

**Mục tiêu của ví dụ này** là chuyển đổi *tổng số* số ca bệnh sốt rét hàng ngày tại các cơ sở (xem trong tab trước) thành số liệu thống kê tóm tắt *hàng tuần* về hiệu suất báo cáo của cơ sở - trong trường hợp này là *tỷ lệ số ngày mỗi tuần mà cơ sở báo cáo bất kỳ dữ liệu nào*. Đối với ví dụ này, chúng ta sẽ chỉ hiển thị dữ liệu cho **Spring District**. 

Để đạt được điều này, chúng ta sẽ thực hiện các bước quản lý dữ liệu sau:

1) Lọc dữ liệu phù hợp (theo địa điểm, ngày tháng)   
2) Tạo cột tuần bằng cách sử dụng hàm `floor_date()` trong package **lubridate**  
    + Hàm này trả về ngày bắt đầu trong tuần của một ngày cụ thể, sử dụng ngày bắt đầu được chỉ định của mỗi tuần (ví dụ: "Thứ Hai") 
3) Dữ liệu được nhóm theo cột "location" và "week" để tạo ra các đơn vị phân tích "facility-week"  
4) Hàm `summarise()` tạo các cột mới để trình bày thống kê tóm tắt cho từng nhóm cơ sở theo tuần (facility-week):  
    + Số ngày mỗi tuần (7 - một giá trị không đổi)  
    + Số lượng báo cáo nhận được từ cơ sở-tuần (có thể nhiều hơn 7!)  
    + Tổng số ca sốt rét do cơ sở báo cáo trong tuần (chỉ dành cho ai quan tâm)   
    + Số ngày *duy nhất* trong mỗi cơ sở-tuần có dữ liệu được báo cáo  
    + **Phần trăm trong số 7 ngày mỗi cơ sở-tuần mà dữ liệu được báo cáo**  
5) Data frame được kết hợp bằng hàm `right_join()` thành một danh sách hoàn chỉnh về tất cả các kết hợp cơ sở-tuần có thể có, để làm cho tập dữ liệu hoàn thiện. Ma trận của tất cả các kết hợp có thể có được tạo bằng cách áp dụng hàm `expand()` cho hai cột đó của data frame giống như tại thời điểm đó trong chuỗi pipe (được biểu thị bằng `.`). Vì sử dụng hàm `right_join()`, nên tất cả các hàng trong data frame `expand()` mở rộng được giữ lại và được thêm vào `agg_weeks` nếu cần. Các hàng mới này xuất hiện với các giá trị tóm tắt `NA` (missing). 


Dưới đây là từng bước thực hiện: 

```{r, message=FALSE, warning=FALSE}
# Create weekly summary dataset
agg_weeks <- facility_count_data %>% 
  
  # filter the data as appropriate
  filter(
    District == "Spring",
    data_date < as.Date("2020-08-01")) 
```

Bây giờ tập dữ liệu có số lượng hàng tính theo agg_week ` nrow(agg_weeks)`, trong khi trước được tính theo facility_count_data ` nrow(facility_count_data)`.  
 
Tiếp theo, chúng ta tạo cột `tuần` để phản ánh ngày bắt đầu trong tuần cho mỗi bản ghi. Thực hiện điều này với hàm `floor_date ()` trong package **lubridate**, giúp thiết lập theo "tuần" và các tuần sẽ bắt đầu vào Thứ Hai (ngày 1 trong tuần - Chủ Nhật sẽ là 7). Các hàng đầu tiên được hiển thị như bên dưới. 

```{r}
agg_weeks <- agg_weeks %>% 
  # Create week column from data_date
  mutate(
    week = lubridate::floor_date(                     # create new column of weeks
      data_date,                                      # date column
      unit = "week",                                  # give start of the week
      week_start = 1))                                # weeks to start on Mondays 
```

Cột tuần mới này có thể được nhìn thấy ở ngoài cùng bên phải của data frame được tạo ra: 

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Bây giờ chúng ta nhóm dữ liệu thành các cơ sở-tuần và tóm tắt chúng để tạo ra số liệu thống kê cho mỗi cơ sở-tuần. Xem thêm chương [Bảng mô tả] để biết các mẹo. Bản thân việc nhóm sẽ không làm thay đổi data frame, nhưng nó ảnh hưởng đến cách các thống kê tóm tắt tiếp theo được tính toán. 

Các hàng đầu tiên được hiển thị bên dưới. Lưu ý cách các cột đã thay đổi hoàn toàn để phản ánh thống kê tóm tắt mong muốn. Mỗi hàng phản ánh một cơ sở-tuần. 

```{r, warning=F, message=F}
agg_weeks <- agg_weeks %>%   

  # Group into facility-weeks
  group_by(location_name, week) %>%
  
  # Create summary statistics columns on the grouped data
  summarize(
    n_days          = 7,                                          # 7 days per week           
    n_reports       = dplyr::n(),                                 # number of reports received per week (could be >7)
    malaria_tot     = sum(malaria_tot, na.rm = T),                # total malaria cases reported
    n_days_reported = length(unique(data_date)),                  # number of unique days reporting per week
    p_days_reported = round(100*(n_days_reported / n_days)))      # percent of days reporting
```

```{r, echo=F}
DT::datatable(head(agg_weeks,30), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Cuối cùng, chúng ta chạy lệnh bên dưới để đảm bảo rằng TẤT CẢ các cơ sở-tuần có thể có trong dữ liệu, ngay cả khi chúng bị missing trước đó. 

Chúng ta đang sử dụng hàm `right_join()` trên chính nó (tập dữ liệu được thể hiện bởi dấu ".") nhưng đã được mở rộng để bao gồm tất cả các kết hợp có thể có của các cột `week` và `location_name`. Xem tài liệu về hàm `expand()` trong chương [Xoay trục dữ liệu]. Trước khi chạy đoạn code này, tập dữ liệu cần chứa `nrow(agg_weeks)` hàng. 

```{r, message=F, warning=F}
# Create data frame of every possible facility-week
expanded_weeks <- agg_weeks %>% 
  mutate(week = as.factor(week)) %>%         # convert date to a factor so expand() works correctly
  tidyr::expand(., week, location_name) %>%  # expand data frame to include all possible facility-week combinations
                                             # note: "." represents the dataset at that moment in the pipe chain
  mutate(week = as.Date(week))               # re-convert week to class Date so the subsequent right_join works
```

Đây là `expanded_weeks`:  

```{r, echo=F}
DT::datatable(expanded_weeks, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

TRước khi chạy dòng lệnh này, `agg_weeks` bao gồm `nrow(agg_weeks)` hàng.    

```{r}
# Use a right-join with the expanded facility-week list to fill-in the missing gaps in the data
agg_weeks <- agg_weeks %>%      
  right_join(expanded_weeks) %>%                            # Ensure every possible facility-week combination appears in the data
  mutate(p_days_reported = replace_na(p_days_reported, 0))  # convert missing values to 0                           
```

Sau khi chạy dòng lệnh này, `agg_weeks` vẫn bao gồm ` nrow(agg_weeks)` hàng.    


<!-- ======================================================= -->
### Tạo biểu đồ nhiệt {.unnumbered}


Hàm `ggplot()` được thực hiện bằng cách sử dụng hàm `geom_tile()` từ package **ggplot2**:  

* Các tuần trên trục x được chuyển đổi thành ngày tháng, cho phép sử dụng `scale_x_date()`  
* `location_name` trên trục y sẽ hiển thị tất cả các tên cơ sở 
* `fill` được gán cho `p_days_reported`, hiệu suất cho cơ sở-tuần đó (dạng số) 
* `scale_fill_gradient()` được sử dụng để tô màu cho biến dạng số, cụ thể màu sắc gồm cao, thấp và `NA`  
* `scale_x_date()` được sử dụng trên trục x, chỉ định các nhãn 2 tuần một lần và định dạng của chúng   
* Các chủ đề và nhãn hiển thị có thể được điều chỉnh khi cần thiết 




<!-- ======================================================= -->
### Cơ bản {.unnumbered}  

Biểu đồ nhiệt cơ bản sẽ được tạo như bên dưới, sử dụng màu, thang đo, v.v mặc định. Như đã giải thích ở trên, trong `aes()` của hàm `geom_tile()`, bạn phải cung cấp cột trục x, cột trục y, **và** một cột cho `fill = `. Phần tô là giá trị số thể hiện dưới dạng màu ô. 

```{r}
ggplot(data = agg_weeks)+
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported))
```

### Làm sạch biểu đồ nhiệt {.unnumbered}

Chúng ta có thể làm cho biểu đồ này trông đẹp hơn bằng cách thêm các hàm **ggplot2** bổ sung, như được hiển thị bên dưới. Xem thêm chương [Các tips với ggplot] để biết thêm chi tiết.  

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Sắp xếp thứ tự trục y {.unnumbered}  
 
Hiện tại, các cơ sở được sắp xếp theo thứ tự "theo bảng chữ cái" từ dưới lên trên. Nếu bạn muốn điều chỉnh thứ tự các cơ sở trục y, hãy chuyển đổi chúng thành factor thứ bậc và cung cấp thứ tự. Xem thêm chương [Factors] để biết các mẹo để thực hiện điều này. 

Vì có rất nhiều cơ sở và chúng ta không muốn viết hết chúng ra, chúng ta sẽ thử một cách tiếp cận khác - sắp xếp thứ tự các cơ sở trong data frame và sử dụng cột tên kết quả làm thứ tự của factor. Bên dưới, cột `location_name` được chuyển đổi thành một factor và thứ tự của các cấp của nó được đặt dựa trên tổng số ngày báo cáo do cơ sở nộp trong toàn bộ khoảng thời gian. 

Để làm điều này, chúng ta tạo một data frame đại diện cho tổng số báo cáo cho mỗi cơ sở, được sắp xếp theo thứ tự tăng dần. Chúng ta có thể sử dụng vectơ này để sắp xếp các mức thứ tự trong biểu đồ.   

```{r}
facility_order <- agg_weeks %>% 
  group_by(location_name) %>% 
  summarize(tot_reports = sum(n_days_reported, na.rm=T)) %>% 
  arrange(tot_reports) # ascending order
```

Xem data frame bên dưới:   

```{r, echo=F}
DT::datatable(facility_order, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



Bây giờ, hãy sử dụng một cột từ data frame bên trên (`facility_order$location_name`) để trở thành thứ bậc factors của biến `location_name` trong data frame `agg_weeks`: 

```{r, warning=F, message=F}
# load package 
pacman::p_load(forcats)

# create factor and define levels manually
agg_weeks <- agg_weeks %>% 
  mutate(location_name = fct_relevel(
    location_name, facility_order$location_name)
    )
```

Và bây giờ dữ liệu được vẽ lại, với `location_name` trở thành một factor có thứ tự: 

```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                  # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```





<!-- ======================================================= -->
### Biểu diễn các giá trị {.unnumbered}  


Bạn có thể thêm lớp văn bản `geom_text()` lên phía trên các ô, để hiển thị số lượng thực của mỗi ô. Hãy lưu ý rằng điều này có thể trông không đẹp nếu bạn có nhiều ô nhỏ! 
 
Đoạn code sau đã được thêm vào: `geom_text(aes(label = p_days_reported))`. Điều này giúp thêm văn bản vào từng ô. Văn bản được hiển thị là giá trị được gán cho đối số `label = `, trong trường hợp này đã được đặt thành cùng một cột số `p_days_reported` cũng được sử dụng để tạo gradient màu.  



  
```{r, message=FALSE, warning=FALSE}
ggplot(data = agg_weeks)+ 
  
  # show data as tiles
  geom_tile(
    aes(x = week,
        y = location_name,
        fill = p_days_reported),      
    color = "white")+                 # white gridlines
  
  # text
  geom_text(
    aes(
      x = week,
      y = location_name,
      label = p_days_reported))+      # add text on top of tile
  
  # fill scale
  scale_fill_gradient(
    low = "orange",
    high = "darkgreen",
    na.value = "grey80")+
  
  # date axis
  scale_x_date(
    expand = c(0,0),             # remove extra space on sides
    date_breaks = "2 weeks",     # labels every 2 weeks
    date_labels = "%d\n%b")+     # format is day over month (\n in newline)
  
  # aesthetic themes
  theme_minimal()+                                    # simplify background
  
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),           # height of legend key
    legend.key.width  = grid::unit(0.6,"cm"),         # width of legend key
    
    axis.text.x = element_text(size=12),              # axis text size
    axis.text.y = element_text(vjust=0.2),            # axis text alignment
    axis.ticks = element_line(size=0.4),               
    axis.title = element_text(size=12, face="bold"),  # axis title size and bold
    
    plot.title = element_text(hjust=0,size=14,face="bold"),  # title right-aligned, large, bold
    plot.caption = element_text(hjust = 0, face = "italic")  # caption right-aligned and italic
    )+
  
  # plot labels
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",           # legend title, because legend shows fill
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, May-July 2020",
       caption = "7-day weeks beginning on Mondays.")
```




<!-- ======================================================= -->
## Nguồn { }

[scale_fill_gradient()](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  

[R graph gallery - heatmap](https://ggplot2.tidyverse.org/reference/scale_gradient.html)  




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/heatmaps.Rmd-->


# Sơ đồ và biểu đồ {#diagrams}  



```{r out.width = c('50%'), fig.show='hold', echo=F}
knitr::include_graphics(here::here("images", "flow_chart.png"))
knitr::include_graphics(here::here("images", "sankey_diagram.png"))
```


Chương này này bao gồm hướng dẫn sử dụng code để vẽ: 

* Biểu đồ flow diagram bằng **DiagrammeR** và ngôn ngữ DOT  
* Biểu đồ Alluvial/Sankey  
* Chuỗi sự kiện theo thời gian 

<!-- * DAGs (Directed Acyclic Graphs)   -->
<!-- * GANTT charts   -->


<!-- ======================================================= -->
## Chuẩn bị { }

### Gọi packages {.unnumbered}  

Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt gói nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` từ **base** R. Xem chương [R Cơ bản] để biết thêm thông tin về các package R. 

```{r}
pacman::p_load(
  DiagrammeR,     # for flow diagrams
  networkD3,      # For alluvial/Sankey diagrams
  tidyverse)      # data management and visualization
```

### Nhập dữ liệu {.unnumbered}  

Hầu hết nội dung trong chương này không yêu cầu bộ dữ liệu. Tuy nhiên, trong phần sơ đồ Sankey, chúng ta sẽ sử dụng bộ dữ liệu linelist từ một vụ dịch Ebola mô phỏng. Để tiện theo dõi, hãy <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải bộ dữ liệu linelist "đã làm sạch" ở đây</a> (as .rds file). Nhập dữ liệu bằng hàm `import ()` từ package **rio** (có thể xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương [Nhập xuất dữ liệu] để biết chi tiết). 

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của linelist được hiển thị bên dưới:

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
## Sơ đồ flow { }

Chúng ta có thể sử dụng package R **DiagrammeR** để vẽ biểu đồ/sơ đồ flow. Chúng có thể là sơ đồ tĩnh hoặc có động dựa thay đổi theo những thay đổi trong tập dữ liệu. 

**Công cụ**  

Hàm `grViz()` được sử dụng để tạo sơ đồ "Graphviz". Hàm này chấp nhận một *chuỗi ký tự đầu vào chứa các hướng dẫn* để tạo sơ đồ. Trong chuỗi đó, các hướng dẫn được viết bằng một ngôn ngữ khác, được gọi là ngôn ngữ [DOT](https://graphviz.org/doc/info/lang.html) - khá dễ dàng để học những điều cơ bản. 

**Cấu trúc cơ bản**  

1) Mở hướng dẫn `grViz("`  
2) Chỉ định hướng và tên của biểu đồ, đồng thời mở ngoặc, vd: `digraph my_flow_chart {`
3) Câu lệnh biểu đồ (bố cục, hướng sắp xếp các biến số)  
4) Câu lệnh nút (tạo nút) 
5) Câu lệnh Edges (cung cấp liên kết giữa các nút)  
6) Đóng các hướng dẫn `}")`  

### Ví dụ đơn giản {.unnumbered} 

Dưới đây là hai ví dụ đơn giản  

Một ví dụ rất đơn giản:   

```{r out.width='50%'}
# A minimal plot
DiagrammeR::grViz("digraph {
  
graph[layout = dot, rankdir = LR]

a
b
c

a -> b -> c
}")
```

Một ví dụ khác áp dụng trong y tế công cộng: 

```{r out.width='50%'}
grViz("                           # All instructions are within a large character string
digraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name 
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,
         overlap = true,
         fontsize = 10]
  
  # nodes
  #######
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]               # width of circles
  
  Primary                         # names of nodes
  Secondary
  Tertiary

  # edges
  #######
  Primary   -> Secondary [label = ' case transfer']
  Secondary -> Tertiary [label = ' case transfer']
}
")
```

### Cú pháp  {.unnumbered}

**Cú pháp cơ bản**  

Tên nút hoặc biểu thức cạnh, có thể được phân tách bằng dấu cách, dấu chấm phẩy hoặc dòng mới. 

**Điều hướng**  

Một biểu đồ có thể được định hướng lại để di chuyển từ trái sang phải bằng cách điều chỉnh đối số `rankdir` trong câu lệnh biểu đồ. Mặc định là TB (từ trên xuống dưới), nhưng nó có thể là LR (trái sang phải), RL hoặc BT. 

**Tên nút**  

Tên nút có thể là các từ đơn, như trong ví dụ đơn giản ở trên. Để sử dụng tên nhiều từ hoặc các ký tự đặc biệt (ví dụ: dấu ngoặc đơn, dấu gạch ngang), hãy đặt tên nút trong dấu ngoặc đơn (' '). Có thể dễ dàng hơn để có một tên nút ngắn và gán một *nhãn*, như được hiển thị bên dưới trong dấu ngoặc vuông [ ]. Nếu bạn muốn có một dòng mới trong tên của nút, bạn phải thực hiện điều đó thông qua một nhãn - sử dụng `\n` trong nhãn của nút trong bên dấu ngoặc kép, như được trình bày bên dưới. 

**Nhóm phụ**  

Trong các biểu thức cạnh, nhóm phụ có thể được tạo ở hai bên của cạnh bằng dấu ngoặc nhọn ({ }). Sau đó, cạnh áp dụng cho tất cả các nút trong dấu ngoặc - nó là cách viết tắt. 

**Bố cục**  

* dot (đặt đối số `rankdir` cho một trong các giá trị sau TB, LR, RL, BT, )
* neato  
* twopi  
* circo  


**Nút - có thể chỉnh sửa**  

* `label` (ký tự, trong dấu ngoặc kép nếu nhiều từ)  
* `fillcolor` (nhiều màu)  
* `width of shape borderfontcolor`  
* `alpha` (độ trong suốt 0-1)  
* `shape` (hình elip, hình bầu dục, kim cương, trứng, bản rõ, điểm, hình vuông, hình tam giác)  
* `style`  
* `sides`  
* `peripheries`  
* `fixedsize` (h x w)  
* `height`  
* `width`  
* `distortion`  
* `penwidth` (độ dày của đường viền)  
* `x` (dịch chuyển trái/phải)  
* `y` (dịch chuyển lên/xuống )  
* `fontname`  
* `fontsize`  
* `icon`  


**Các cạnh - có thể chỉnh sửa**  

* `arrowsize`  
* `arrowhead` (normal, box, crow, curve, diamond, dot, inv, none, tee, vee)  
* `arrowtail`  
* `dir` (điều hướng, )  
* `style` (gạch ngang, ...)  
* `color`  
* `alpha`  
* `headport` (văn bản phía trước đầu mũi tên )  
* `tailport` (văn bản phía sau đuôi mũi tên)  
* `fontname`  
* `fontsize`  
* `fontcolor`  
* `penwidth` (độ dày của mũi tên)  
* `minlen` (chiều dài tối thiểu)

**Tên màu**: mã màu theo bảng mã hex hoặc tên màu 'X11', xem [tại đây để biết thông tin chi tiết về X11](http://rich-iannone.github.io/DiagrammeR/graphviz_and_mermaid.html) 


### Ví dụ phức tạp  {.unnumbered}

Ví dụ dưới đây mở rộng trên một sơ đồ giám sát, thêm các tên nút phức tạp, các cạnh được nhóm lại, màu sắc và style 


```
DiagrammeR::grViz("               # All instructions are within a large character string
digraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name 
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,            # layout top-to-bottom
         fontsize = 10]
  

  # nodes (circles)
  #################
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = 'Primary\nFacility'] 
  Secondary [label = 'Secondary\nFacility'] 
  Tertiary  [label = 'Tertiary\nFacility'] 
  SC        [label = 'Surveillance\nCoordination',
             fontcolor = darkgreen] 
  
  # edges
  #######
  Primary   -> Secondary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = ' case transfer',
                          fontcolor = red,
                          color = red]
  
  # grouped edge
  {Primary Secondary Tertiary} -> SC [label = 'case reporting',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```


```{r out.width='50%', echo=F}
DiagrammeR::grViz("               # All instructions are within a large character string
digraph surveillance_diagram {    # 'digraph' means 'directional graph', then the graph name 
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,            # layout top-to-bottom
         fontsize = 10]
  

  # nodes (circles)
  #################
  node [shape = circle,           # shape = circle
       fixedsize = true
       width = 1.3]                      
  
  Primary   [label = 'Primary\nFacility'] 
  Secondary [label = 'Secondary\nFacility'] 
  Tertiary  [label = 'Tertiary\nFacility'] 
  SC        [label = 'Surveillance\nCoordination',
             fontcolor = darkgreen] 
  
  # edges
  #######
  Primary   -> Secondary [label = 'case transfer',
                          fontcolor = red,
                          color = red]
  Secondary -> Tertiary [label = 'case transfer',
                          fontcolor = red,
                          color = red]
  
  # grouped edge
  {Primary Secondary Tertiary} -> SC [label = 'case reporting',
                                      fontcolor = darkgreen,
                                      color = darkgreen,
                                      style = dashed]
}
")
```

**Các cụm biểu đồ phụ**  

Để nhóm các nút thành các cụm có khung, hãy đặt chúng trong cùng một đồ thị con được đặt tên (`subgraph name {}`). Để xác định từng đồ thị con trong một khung giới hạn, hãy bắt đầu tên của đồ thị con bằng "cluster", như được trình bày ở 4 khung bên dưới. 

```
DiagrammeR::grViz("             # All instructions are within a large character string
digraph surveillance_diagram {  # 'digraph' means 'directional graph', then the graph name 
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # nodes (circles)
  #################
  node [shape = circle,                  # shape = circle
       fixedsize = true
       width = 1.3]                      # width of circles
  
  subgraph cluster_passive {
    Primary   [label = 'Primary\nFacility'] 
    Secondary [label = 'Secondary\nFacility'] 
    Tertiary  [label = 'Tertiary\nFacility'] 
    SC        [label = 'Surveillance\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # nodes (boxes)
  ###############
  node [shape = box,                     # node shape
        fontname = Helvetica]            # text font in node
  
  subgraph cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'Event-Based\nSurveillance (EBS)'] 
    'Social Media'
    Radio
  }
  
  subgraph cluster_CBS {
    CBS [label = 'Community-Based\nSurveillance (CBS)']
    RECOs
  }

  
  # edges
  #######
  {Primary Secondary Tertiary} -> SC [label = 'case reporting']

  Primary   -> Secondary [label = 'case transfer',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'case transfer',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {'Social Media' Radio} -> EBS
  
  RECOs -> CBS
}
")

```


```{r out.width='120%', echo=F}
DiagrammeR::grViz("             # All instructions are within a large character string
digraph surveillance_diagram {  # 'digraph' means 'directional graph', then the graph name 
  
  # graph statement
  #################
  graph [layout = dot,
         rankdir = TB,            
         overlap = true,
         fontsize = 10]
  

  # nodes (circles)
  #################
  node [shape = circle,                  # shape = circle
       fixedsize = true
       width = 1.3]                      # width of circles
  
  subgraph cluster_passive {
    Primary   [label = 'Primary\nFacility'] 
    Secondary [label = 'Secondary\nFacility'] 
    Tertiary  [label = 'Tertiary\nFacility'] 
    SC        [label = 'Surveillance\nCoordination',
               fontcolor = darkgreen] 
  }
  
  # nodes (boxes)
  ###############
  node [shape = box,                     # node shape
        fontname = Helvetica]            # text font in node
  
  subgraph cluster_active {
    Active [label = 'Active\nSurveillance'] 
    HCF_active [label = 'HCF\nActive Search']
  }
  
  subgraph cluster_EBD {
    EBS [label = 'Event-Based\nSurveillance (EBS)'] 
    'Social Media'
    Radio
  }
  
  subgraph cluster_CBS {
    CBS [label = 'Community-Based\nSurveillance (CBS)']
    RECOs
  }

  
  # edges
  #######
  {Primary Secondary Tertiary} -> SC [label = 'case reporting']

  Primary   -> Secondary [label = 'case transfer',
                          fontcolor = red]
  Secondary -> Tertiary [label = 'case transfer',
                          fontcolor = red]
  
  HCF_active -> Active
  
  {'Social Media' Radio} -> EBS
  
  RECOs -> CBS
}
")

```


**Hình dạng nút**  

Ví dụ dưới đây, tham khảo từ[tài liệu trực tuyến này](http://rich-iannone.github.io/DiagrammeR/), hiển thị các hình dạng nút được áp dụng và cách viết tắt cho các kết nối cạnh nối tiếp. 

```{r out.width='75%'}
DiagrammeR::grViz("digraph {

graph [layout = dot, rankdir = LR]

# define the global styles of the nodes. We can override these in box if we wish
node [shape = rectangle, style = filled, fillcolor = Linen]

data1 [label = 'Dataset 1', shape = folder, fillcolor = Beige]
data2 [label = 'Dataset 2', shape = folder, fillcolor = Beige]
process [label =  'Process \n Data']
statistical [label = 'Statistical \n Analysis']
results [label= 'Results']

# edge definitions with the node IDs
{data1 data2}  -> process -> statistical -> results
}")
```


### Kết quả đầu ra {.unnumbered}

Cách xử lý và lưu kết quả đầu ra

* Kết quả đầu ra sẽ xuất hiện trong cửa sổ RStudio's Viewer, theo mặc định ở phía dưới bên phải cùng với các mục Files, Plots, Packages, và Help.
* Để xuất, bạn có thể chọn "Save as image" để lưu dưới dạng ảnh hoặc "Copy to clipboard" để sao chép vào bộ nhớ tạm từ Viewer. Hình ảnh sẽ điều chỉnh theo kích thước được chỉ định. 




### Đồ thị được tham số hóa {.unnumbered} 

Mục này được trích dẫn từ nguồn sau: https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/  

"Các biểu đồ được tham số hóa: Lợi ích tuyệt vời của việc thiết kế các đồ thị trong R là chúng ta có thể kết nối các đồ thị trực tiếp với phân tích của mình bằng cách đọc các giá trị R trực tiếp vào flowchart của chúng ta. Ví dụ: giả sử bạn đã tạo một quy trình lọc để loại bỏ các giá trị sau mỗi giai đoạn của một quy trình, bạn có thể có một đồ thị hiển thị số lượng giá trị còn lại trong tập dữ liệu sau mỗi giai đoạn trong quy trình của bạn. Để làm điều này, chúng ta có thể sử dụng ký hiệu @@X trực tiếp trong đồ thị, sau đó tham chiếu tới footer của biểu đồ bằng cách sử dụng [X]:, trong đó X là chỉ số số duy nhất. " 

Chúng tôi khuyến khích bạn xem lại hướng dẫn này nếu tham số hóa là điều bạn quan tâm. 


<!-- And below is some example code from this tutorial. -->

<!-- ```{r, eval=F} -->
<!-- # Define some sample data -->
<!-- data <- list(a=1000, b=800, c=600, d=400) -->


<!-- DiagrammeR::grViz(" -->
<!-- digraph graph2 { -->

<!-- graph [layout = dot] -->

<!-- # node definitions with substituted label text -->
<!-- node [shape = rectangle, width = 4, fillcolor = Biege] -->
<!-- a [label = '@@1'] -->
<!-- b [label = '@@2'] -->
<!-- c [label = '@@3'] -->
<!-- d [label = '@@4'] -->

<!-- a -> b -> c -> d -->

<!-- } -->

<!-- [1]:  paste0('Raw Data (n = ', data$a, ')') -->
<!-- [2]: paste0('Remove Errors (n = ', data$b, ')') -->
<!-- [3]: paste0('Identify Potential Customers (n = ', data$c, ')') -->
<!-- [4]: paste0('Select Top Priorities (n = ', data$d, ')') -->
<!-- ") -->

<!-- ``` -->



<!-- ### CONSORT diagram  {.unnumbered} -->

<!-- THIS SECTION IS UNDER CONSTRUCTION   -->

<!-- https://scriptsandstatistics.wordpress.com/2017/12/22/how-to-draw-a-consort-flow-diagram-using-r-and-graphviz/ -->

<!-- Note above is out of date via DiagrammeR -->




<!-- ======================================================= -->
## Sơ đồ Alluvial/Sankey { }

### Gọi packages {.unnumbered}  

Đoạn code dưới đây hiển thị cách gọi các packages cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt gói nếu cần *và* gọi nó ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` từ **base** R. Xem chương [R Cơ bản] để biết thêm thông tin về các package R. 

Chúng ta gọi package **networkD3** để vẽ sơ đồ và package **tidyverse** cho các bước chuẩn bị dữ liệu. 

```{r}
pacman::p_load(
  networkD3,
  tidyverse)
```

### Vẽ đồ thị từ một tập dữ liệu {.unnumbered} 

Vẽ những mối liên quan trong một tập dữ liệu. Dưới đây, chúng tôi minh họa việc sử dụng package này với bộ số liệu `linelist`. Hãy đọc thêm [hướng dẫn trực tuyến sau.](https://www.r-graph-gallery.com/321-introduction-to-interactive-sankey-diagram-2.html).

Chúng ta sẽ bắt đầu bằng cách lấy số lượng các trường hợp theo sự kết hợp của nhóm tuổi và bệnh viện. Chúng ta cũng xóa các giá trị thiếu nhóm tuổi để làm sạch. Chúng ta cũng gắn lại nhãn các cột `hospital` và cột `age_cat` tương ứng là `source` và `target`. Đây sẽ là hai mặt của sơ đồ Alluvial. 

```{r}
# counts by hospital and age category
links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = hospital,
         target = age_cat)
```

Tập dữ liệu bây giờ trông như thế này:

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


Bây giờ chúng ta tạo một data frame cho tất cả các nút của sơ đồ, dưới cột `name`. Điều này bao gồm tất cả các giá trị cho cột `hospital` và cột `age_cat`. Lưu ý rằng chúng ta cần đảm bảo tất cả chúng đều có kiểu Ký tự trước khi kết hợp chúng và điều chỉnh cột ID thành dạng số thay vì dạng nhãn:  

```{r}
# The unique node names
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

nodes  # print
```

Chúng ta tiếp tục chỉnh sửa data frame có tên `links` mà chúng ta đã tạo ở trên với hàm `count()`. Chúng ta thêm hai cột dạng số là cột `IDsource` và `IDtarget` để thực sự phản ánh/tạo liên kết giữa các nút. Các cột này sẽ giữ số thứ tự hàng (vị trí) của nút nguồn và nút đích. Số 1 sẽ bị trừ để các số vị trí này bắt đầu bằng 0 (không phải 1).  
```{r}
# match to numbers, not names
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1
```

Tập dữ liệu link bây giờ trông như sau: 

```{r message=FALSE, echo=F}
DT::datatable(links, rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```

Bây giờ, chúng ta vẽ sơ đồ Sankey với hàm `sankeyNetwork()`. Bạn có thể đọc thêm về từng đối số bằng cách chạy lệnh `?sankeyNetwork` trong bảng điều khiển. Lưu ý rằng trừ khi bạn đặt `iterations = 0`, thứ tự các nút của bạn có thể sẽ không như bạn mong đợi. 


```{r}

# plot
######
p <- sankeyNetwork(
  Links = links,
  Nodes = nodes,
  Source = "IDsource",
  Target = "IDtarget",
  Value = "n",
  NodeID = "name",
  units = "TWh",
  fontSize = 12,
  nodeWidth = 30,
  iterations = 0)        # ensure node order is as in data
p
```


Đây là một ví dụ trong đó Kết quả của bệnh nhân cũng được bao gồm. Lưu ý trong bước chuẩn bị dữ liệu, chúng ta phải tính toán số lượng các trường hợp giữa tuổi và bệnh viện, và phân biệt biệt giữa bệnh viện và outcome - sau đó liên kết tất cả các số lượng này với nhau bằng hàm `bind_rows()`. 

```{r}
# counts by hospital and age category
age_hosp_links <- linelist %>% 
  drop_na(age_cat) %>% 
  select(hospital, age_cat) %>%
  count(hospital, age_cat) %>% 
  rename(source = age_cat,          # re-name
         target = hospital)

hosp_out_links <- linelist %>% 
    drop_na(age_cat) %>% 
    select(hospital, outcome) %>% 
    count(hospital, outcome) %>% 
    rename(source = hospital,       # re-name
           target = outcome)

# combine links
links <- bind_rows(age_hosp_links, hosp_out_links)

# The unique node names
nodes <- data.frame(
  name=c(as.character(links$source), as.character(links$target)) %>% 
    unique()
  )

# Create id numbers
links$IDsource <- match(links$source, nodes$name)-1 
links$IDtarget <- match(links$target, nodes$name)-1

# plot
######
p <- sankeyNetwork(Links = links,
                   Nodes = nodes,
                   Source = "IDsource",
                   Target = "IDtarget",
                   Value = "n",
                   NodeID = "name",
                   units = "TWh",
                   fontSize = 12,
                   nodeWidth = 30,
                   iterations = 0)
p

```


https://www.displayr.com/sankey-diagrams-r/



<!-- ======================================================= -->
## Chuỗi sự kiện trong thời gian { }

Để tạo dòng thời gian hiển thị các sự kiện cụ thể, bạn có thể sử dụng package `vistime`. 

Xem thêm [vignette](https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning) này

```{r}
# load package
pacman::p_load(vistime,  # make the timeline
               plotly    # for interactive visualization
               )
```

```{r, echo=F}
# reference: https://cran.r-project.org/web/packages/vistime/vignettes/vistime-vignette.html#ex.-2-project-planning

data <- read.csv(text="event, group, start, end, color
                       Event 1, Group A,2020-01-22,2020-01-22, #90caf9
                       Event 1, Group B,2020-01-23,2020-01-23, #90caf9
                       Event 1, Group C,2020-01-23,2020-01-23, #1565c0
                       Event 1, Group D,2020-01-25,2020-01-25, #f44336
                       Event 1, Group E,2020-01-25,2020-01-25, #90caf9
                       Event 1, Group F,2020-01-26,2020-01-26, #8d6e63
                       Event 1, Group G,2020-01-27,2020-01-27, #1565c0
                       Event 1, Group H,2020-01-27,2020-01-27, #90caf9
                       Event 1, Group I,2020-01-27,2020-01-27,#90a4ae
                       Event 2, Group A,2020-01-28,2020-01-28,#fc8d62
                       Event 2, Group C,2020-01-28,2020-01-28, #6a3d9a
                       Event 2, Group J,2020-01-28,2020-01-28, #90caf9
                       Event 2, Group J,2020-01-28,2020-01-28, #fc8d62
                       Event 2, Group J,2020-01-28,2020-01-28, #1565c0
")
```

Đây là tập dữ liệu mà chúng ta sẽ bắt đầu sử dụng: 

```{r message=FALSE, echo=F}
DT::datatable(data, rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```



```{r}
p <- vistime(data)    # apply vistime

library(plotly)

# step 1: transform into a list
pp <- plotly_build(p)

# step 2: Marker size
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "markers") pp$x$data[[i]]$marker$size <- 10
}

# step 3: text size
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textfont$size <- 10
}


# step 4: text position
for(i in 1:length(pp$x$data)){
  if(pp$x$data[[i]]$mode == "text") pp$x$data[[i]]$textposition <- "right"
}

#print
pp

```



<!-- ======================================================= -->
## Sơ đồ DAGs { }

Bạn có thể tạo sơ đồ DAG theo cách thủ công bằng cách sử dụng package **DiagammeR** và ngôn ngữ DOT như đã mô tả ở trên. 

Ngoài ra, có các package như  **ggdag** và **daggity**

[Giới thiệu về sơ đồ DAGs](https://cran.r-project.org/web/packages/ggdag/vignettes/intro-to-dags.html)   

[Suy luận nhân quả với dags trong R](https://www.r-bloggers.com/2019/08/causal-inference-with-dags-in-r/#:~:text=In%20a%20DAG%20all%20the,for%20drawing%20and%20analyzing%20DAGs.)  





<!-- ======================================================= -->
## Tài nguyên học liệu { }


Phần lớn nội dung ở trên liên quan đến ngôn ngữ DOT được tham khảo từ hướng dẫn [này](https://mikeyharper.uk/flowcharts-in-r-using-diagrammer/)  

Một tài liệu khác chuyên sâu hơn tại đây [Tài liệu về DiagammeR](http://rich-iannone.github.io/DiagrammeR/)

Xem thêm về [Sơ đồ Sankey tại đây](https://www.displayr.com/sankey-diagrams-r/)  




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/diagrams.Rmd-->


# Biểu đồ kết hợp {#combination-analysis}  

```{r echo=F, out.width= "75%", warning=F, message=F}
pacman::p_load(tidyverse,
               UpSetR,
               ggupset)

# Adds new symptom variables to the linelist, with random "yes" or "no" values 
linelist_sym <- linelist %>% 
  mutate(fever  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.80, 0.20)),
         chills = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.20, 0.80)),
         cough  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.9, 0.15)),
         aches  = sample(c("yes", "no"), nrow(linelist), replace = T, prob = c(0.10, 0.90)),
         vomit = sample(c("yes", "no"), nrow(linelist), replace = T))

linelist_sym_2 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into the symptom name itself
  mutate(fever = case_when(fever == "yes" ~ 1,          # if old value is "yes", new value is "fever"
                           TRUE           ~ 0),   # if old value is anything other than "yes", the new value is NA
         
         chills = case_when(chills == "yes" ~ 1,
                           TRUE           ~ 0),
         
         cough = case_when(cough == "yes" ~ 1,
                           TRUE           ~ 0),
         
         aches = case_when(aches == "yes" ~ 1,
                           TRUE           ~ 0),
         
         vomit = case_when(vomit == "yes" ~ 1,
                           TRUE           ~ 0))

# Make the plot
UpSetR::upset(
  select(linelist_sym_2, fever, chills, cough, aches, vomit),
  sets = c("fever", "chills", "cough", "aches", "vomit"),
  order.by = "freq",
  sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # optional colors
  empty.intersections = "on",
  # nsets = 3,
  number.angles = 0,
  point.size = 3.5,
  line.size = 2, 
  mainbar.y.label = "Symptoms Combinations",
  sets.x.label = "Patients with Symptom")

```



Phân tích này vẽ biểu đồ tần suất của các **kết hợp** giá trị/phản hồi khác nhau. Trong ví dụ này, chúng ta sẽ vẽ biểu đồ tần suất các trường hợp có biểu hiện kết hợp nhiều triệu chứng khác nhau.  

Phân tích này còn thường được gọi bằng những tên khác như:  

* **"Phân tích nhiều lựa chọn"**  
* **"Phân tích các bộ (sets)"**  
* **"Phân tích kết hợp"**  

Trong biểu đồ minh họa bên trên, năm triệu chứng được trình bày. Bên dưới mỗi thanh dọc là một đường và dấu chấm biểu thị sự kết hợp của các triệu chứng được phản ánh bởi thanh ở trên. Ở bên trái, các thanh ngang phản ánh tần suất của từng triệu chứng riêng lẻ.  

Phương pháp đầu tiên chúng tôi sẽ trình bày sử dụng package **ggupset**, phương pháp thứ hai sử dụng package **UpSetR**. 




  



<!-- ======================================================= -->
## Chuẩn bị {  }

### Gọi package {.unnumbered}

Đoạn code này hiển thị việc gọi các gói cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package nếu cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.  

```{r, warning=F, message=F}
pacman::p_load(
  tidyverse,     # data management and visualization
  UpSetR,        # special package for combination plots
  ggupset)       # special package for combination plots
```

<!-- ======================================================= -->
### Nhập dữ liệu {.unnumbered}  


Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết.  



```{r, echo=F}
# import the linelist into R
linelist_sym <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist_sym <- import("linelist_cleaned.rds")
```


Bộ số liệu linelist bao gồm năm biến "có/không" về các triệu chứng được ghi nhận. Chúng ta sẽ cần phải biến đổi các biến số này một chút trước khi sử dụng package **ggupset** để tạo biểu đồ. Xem dữ liệu (cuộn sang phải để xem các biến triệu chứng).  

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist_sym, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```



<!-- ======================================================= -->
### Định dạng lại giá trị {.unnumbered}  

Để tương đồng với định dạng của package **ggupset**, chúng ta cần đổi giá trị "yes" và "no" thành tên các triệu chứng thực tế, sử dụng hàm `case_when()` từ package **dplyr**. Nếu giá trị là "no", chúng ta sẽ bỏ trống, nghĩa là biến mới sẽ có giá trị hoặc là `NA` hoặc là triệu chứng.  
 

```{r, warning=F, message=F}
# create column with the symptoms named, separated by semicolons
linelist_sym_1 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into the symptom name itself
  mutate(
    fever = case_when(
      fever == "yes" ~ "fever",          # if old value is "yes", new value is "fever"
      TRUE           ~ NA_character_),   # if old value is anything other than "yes", the new value is NA
         
    chills = case_when(
       chills == "yes" ~ "chills",
       TRUE           ~ NA_character_),
    
    cough = case_when(
      cough == "yes" ~ "cough",
      TRUE           ~ NA_character_),
         
    aches = case_when(
      aches == "yes" ~ "aches",
      TRUE           ~ NA_character_),
         
    vomit = case_when(
      vomit == "yes" ~ "vomit",
      TRUE           ~ NA_character_)
    )
```

Bây giờ chúng ta tạo hai cột cuối cùng:  

1. Kết hợp (ghép lại với nhau) tất cả các triệu chứng của bệnh nhân (thành một cột ký tự)  
2. Chuyển đổi định dạng cột bên trên thành kiểu *danh sách* để được chấp nhận bởi package **ggupset** khi vẽ biểu đồ  

Xem thêm chương [Ký tự và chuỗi] để biết thêm về hàm `unite()` trong package **stringr**

```{r, warning=F, message=F}
linelist_sym_1 <- linelist_sym_1 %>% 
  unite(col = "all_symptoms",
        c(fever, chills, cough, aches, vomit), 
        sep = "; ",
        remove = TRUE,
        na.rm = TRUE) %>% 
  mutate(
    # make a copy of all_symptoms column, but of class "list" (which is required to use ggupset() in next step)
    all_symptoms_list = as.list(strsplit(all_symptoms, "; "))
    )
```

Bây giờ chúng ta cùng xem dữ liệu mới. Lưu ý hai cột ở cuối bên phải - các giá trị kết hợp được ghép và danh sách

```{r, echo=F, , warning=F, message=F}
DT::datatable(head(linelist_sym_1,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap')
```


<!-- ======================================================= -->
## **ggupset** {  }

Gọi package

```{r}
pacman::p_load(ggupset)
```


Vẽ biểu đồ. Chúng ta bắt đầu bằng hàm `ggplot()` và `geom_bar()`, nhưng sau đó chúng ta thêm hàm đặc biệt `scale_x_upset()` từ package **ggupset**.  

```{r, warning=F, message=F}
ggplot(
  data = linelist_sym_1,
  mapping = aes(x = all_symptoms_list)) +
geom_bar() +
scale_x_upset(
  reverse = FALSE,
  n_intersections = 10,
  sets = c("fever", "chills", "cough", "aches", "vomit"))+
labs(
  title = "Signs & symptoms",
  subtitle = "10 most frequent combinations of signs and symptoms",
  caption = "Caption here.",
  x = "Symptom combination",
  y = "Frequency in dataset")

```
  
Bạn có thể đọc thêm về package **ggupset** [ở tài liệu online này](https://rdrr.io/cran/ggupset/man/scale_x_upset.html) hoặc trong tài liệu trợ giúp của package bằng cách gõ vào cửa RStudio Help lệnh `?ggupset`.  


<!-- ======================================================= -->
## `UpSetR` {  }

Package **UpSetR** cho phép tùy chỉnh biểu đồ sâu hơn, nhưng nó cũng khó thực hiện hơn:


**Gọi package**  

```{r}
pacman::p_load(UpSetR)
```

**Làm sạch dữ liệu**  

Chúng ta phải chuyển đổi các triệu chứng trong bộ dữ liệu `linelist` thành các giá trị 1 / 0. 

```{r}
# Make using upSetR

linelist_sym_2 <- linelist_sym %>% 
  
  # convert the "yes" and "no" values into the symptom name itself
  mutate(
    fever = case_when(
      fever == "yes" ~ 1,    # if old value is "yes", new value is 1
      TRUE           ~ 0),   # if old value is anything other than "yes", the new value is 0
         
    chills = case_when(
      chills == "yes" ~ 1,
      TRUE           ~ 0),
         
    cough = case_when(
      cough == "yes" ~ 1,
      TRUE           ~ 0),
         
    aches = case_when(
      aches == "yes" ~ 1,
      TRUE           ~ 0),
         
    vomit = case_when(
      vomit == "yes" ~ 1,
      TRUE           ~ 0)
    )
```

Bây giờ chúng ta hãy vẽ biểu đồ bằng hàm tùy chỉnh `upset()` - chỉ sử dụng các cột triệu chứng. Bạn phải chỉ định “bộ” nào để so sánh (tên của các cột triệu chứng). Một cách khác, sử dụng `nsets = ` và `order.by = "freq"` để chỉ hiện thị X các sự kết hợp nhiều nhất.  

```{r, warning=F, message=F}

# Make the plot
UpSetR::upset(
  select(linelist_sym_2, fever, chills, cough, aches, vomit),
  sets = c("fever", "chills", "cough", "aches", "vomit"),
  order.by = "freq",
  sets.bar.color = c("blue", "red", "yellow", "darkgreen", "orange"), # optional colors
  empty.intersections = "on",
  # nsets = 3,
  number.angles = 0,
  point.size = 3.5,
  line.size = 2, 
  mainbar.y.label = "Symptoms Combinations",
  sets.x.label = "Patients with Symptom")

```


<!-- ======================================================= -->
## Nguồn {  }

[The github page on UpSetR](https://github.com/hms-dbmi/UpSetR)  

[A Shiny App version - you can upload your own data](https://gehlenborglab.shinyapps.io/upsetr/)  

[*documentation - difficult to interpret](https://cran.r-project.org/web/packages/UpSetR/UpSetR.pdf)  


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/combination_analysis.Rmd-->

# Chuỗi lây nhiễm {#transmission-chains}

<!-- ======================================================= -->

## Tổng quan

Công cụ chính để xử lý, phân tích và trực quan hóa chuỗi lây nhiễm và dữ liệu theo dõi tiếp xúc là package **epicontacts**, được phát triển bởi những chuyên gia làm việc tại RECON. Hãy thử biểu đồ tương tác bên dưới bằng cách di chuột qua các nút để biết thêm thông tin, kéo-thả để di chuyển chúng và nhấp vào chúng để đánh dấu các trường hợp phía dưới.

```{r out.width=c('25%', '25%'), fig.show='hold', echo=F}

## install development version of epicontacts
if(
  !"epicontacts" %in% rownames(installed.packages()) |
  packageVersion("epicontacts") != "1.2.0"
) remotes::install_github("reconhub/epicontacts@timeline")

## install and load packages
pacman::p_load(tidyverse, epicontacts, magrittr, here, webshot, visNetwork)

## load linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds")) %>%
  filter(!duplicated(case_id))

## generate contacts
contacts <- linelist %>%
  transmute(
    from = infector,
    to = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(from)

## generate epicontacts
epic <- epicontacts::make_epicontacts(
  linelist = linelist,
  contacts = contacts, 
  directed = TRUE
)

## subset object
epic %<>% subset(
  node_attribute = list(date_onset = c(as.Date(c("2014-06-01", "2014-07-01"))))
) %>%
  thin("contacts")

## plot with date of onset as x-axis
plot(
  epic,
  x_axis = "date_onset",
  label = FALSE,
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  node_shape = "gender",
  shapes = c(f = "female", m = "male"),
  unlinked_pos = "bottom",
  date_labels = "%b %d %Y",
  node_size = 35,
  font_size = 20,
  arrow_size = 0.5,
  height = 800,
  width = 700,
  edge_linetype = "location",
  legend_width = 0.15,
  highlight_downstream = TRUE,
  selector = FALSE
)

```

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đầu tiên hãy tải các package tiêu chuẩn cần thiết để nhập và xử lý dữ liệu. Trong cuốn sách này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, sẽ cài đặt package nếu cần *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các package bằng hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các package trong R.

```{r transmission_chains_packages, eval = FALSE}
pacman::p_load(
   rio,          # File import
   here,         # File locator
   tidyverse,    # Data management + ggplot2 graphics
   remotes       # Package installation from github
)
```

Bạn sẽ sử dụng phiên bản phát triển của **epicontacts**, có thể được cài đặt từ github bằng cách sử dụng hàm `p_install_github()` từ package **pacman**. Bạn chỉ cần chạy lệnh này dưới đây một lần, không phải bất cứ khi nào bạn sử dụng package (sau đó, bạn có thể sử dụng hàm `p_load()` như bình thường).

```{r transmission_chains_epicontacts_install, eval = FALSE}
pacman::p_install_gh("reconhub/epicontacts@timeline")
```

### Nhập dữ liệu {.unnumbered}

Chúng ta nhập bộ dữ liệu về các trường hợp bệnh từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải xuống dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương [Tải sách và dữ liệu]. Bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau.

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import the linelist
linelist <- import("linelist_cleaned.xlsx")
```

50 hàng đầu tiên của bộ dữ liệu `linelist` được hiển thị bên dưới. Mối quan tâm đặc biệt là các cột `case_id`, `generation`, `infector`, và `source`.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Tạo đối tượng epicontacts {.unnumbered}

Sau đó, chúng ta cần tạo một đối tượng **epicontacts**, với yêu cầu hai kiểu dữ liệu như sau:

-   Một bộ dữ liệu `linelist` ghi lại các trường hợp trong đó các cột là các biến và các hàng tương ứng với các trường hợp duy nhất
-   Một danh sách các cạnh (edge) thể hiện liên kết giữa các quan sát trên ID duy nhất (có thể là liên hệ, sự kiện lây nhiễm, v.v.)

Bởi vì chúng ta đã có sẵn bộ dữ liệu `linelist`, chúng ta chỉ cần tạo một danh sách các đường liên kết giữa các trường hợp, cụ thể hơn là giữa các ID. Chúng ta có thể trích xuất các đường liên kết lây nhiễm từ bộ số liệu `linelist` bằng cách liên kết cột `infector` với cột `case_id`. Tại đây, chúng ta cũng có thể thêm các "thuộc tính cạnh - edge properties", nghĩa là bất kỳ biến nào mô tả mối liên kết giữa hai trường hợp, không phải bản thân các trường hợp đó. Để minh họa, chúng ta sẽ thêm một biến `location` mô tả vị trí của sự kiện truyền nhiễm và một biến mô tả khoảng thời gian tiếp xúc tính bằng ngày.

Trong đoạn code dưới đây, hàm `transmute` thuộc package **dplyr** tương tự như hàm `mutate`, ngoại trừ nó chỉ giữ các cột mà chúng ta đã chỉ định trong hàm. Hàm `drop_na` sẽ lọc ra bất kỳ hàng nào mà các cột được chỉ định có giá trị `NA` ; trong trường hợp này, chúng ta chỉ muốn giữ lại các hàng mà tác nhân lây nhiễm đã biết.

```{r transmission_chains_create_contacts,}
## generate contacts
contacts <- linelist %>%
  transmute(
    infector = infector,
    case_id = case_id,
    location = sample(c("Community", "Nosocomial"), n(), TRUE),
    duration = sample.int(10, n(), TRUE)
  ) %>%
  drop_na(infector)
```

Bây giờ chúng ta có thể tạo đối tượng **epicontacts** bằng cách sử dụng hàm `make_epicontacts`. Chúng ta cần chỉ định cột trong bộ dữ liệu `linelist` trỏ đến mã định danh trường hợp duy nhất (ID), cũng như cột trong điểm tiếp xúc tới mã định danh duy nhất của các trường hợp có liên quan trong mỗi liên kết. Các liên kết này có tính định hướng, nghĩa là việc lây nhiễm sẽ đi *từ* người lây nhiễm *đến* ca bệnh, vì vậy chúng ta cần chỉ định các đối số `from` và `to` cho phù hợp. Chúng ta cũng đặt đối số `directed` thành `TRUE`, điều này sẽ ảnh hưởng đến các hoạt động về sau.

```{r transmission_chains_create_epicontacts,}
## generate epicontacts object
epic <- make_epicontacts(
  linelist = linelist,
  contacts = contacts,
  id = "case_id",
  from = "infector",
  to = "case_id",
  directed = TRUE
)
```

Sau khi kiểm tra các đối tượng **epicontacts**, chúng ta có thể thấy rằng cột `case_id` trong bộ dữ liệu `linelist` đã được đổi tên thành `id` và các cột `case_id` và cột `infector` trong liên hệ đã được đổi tên thành `from` và `to`. Điều này đảm bảo tính nhất quán trong các hoạt động xử lý, trực quan và phân tích tiếp theo.

```{r transmission_chains_view_epicontacts,}
## view epicontacts object
epic
```

<!-- ======================================================= -->

## Xử lý

### Chia nhỏ bộ dữ liệu {.unnumbered}

Phương thức `subset()` cho các đối tượng **epicontacts** cho phép lọc các mạng lưới dựa trên các thuộc tính của bộ dữ liệu `linelist` ("thuộc tính nút") và cơ sở dữ liệu tiếp xýc ("thuộc tính cạnh"). Các giá trị này phải được chuyển đổi dưới dạng danh sách đã đặt tên cho đối số tương ứng. Ví dụ: trong đoạn code bên dưới, chúng tôi chỉ giữ lại các trường hợp nam giới trong bộ số liệu `linelist` có ngày lây nhiễm từ tháng 4 đến tháng 7 năm 2014 (ngày tháng được chỉ định dưới dạng khoảng) và các liên kết lây nhiễm xảy ra trong bệnh viện.

```{r transmission_chains_subset_nodes,}
sub_attributes <- subset(
  epic,
  node_attribute = list(
    gender = "m",
    date_infection = as.Date(c("2014-04-01", "2014-07-01"))
  ), 
  edge_attribute = list(location = "Nosocomial")
)
sub_attributes
```

Chúng ta có thể sử dụng hàm `thin` để lọc trong bộ số liệu `linelist` để bao gồm các trường hợp được tìm thấy trong danh sách "contacts" bằng cách đặt đối số `what = "linelist"`, hoặc lọc trong danh sách "contacts" để bao gồm các trường hợp được tìm thấy trong bộ số liệu `linelist` bằng cách đặt đối số `what = "contacts"`. Trong đoạn code dưới đây, chúng ta đang lọc thêm từ đối tượng epicontacts để chỉ giữ lại  các đường liên kết lây nhiễm có liên quan đến các trường hợp nam giới bị lây nhiễm giữa tháng 4 và tháng 7 mà chúng ta đã lọc ở trên. Chúng ta có thể thấy rằng chỉ có hai liên kết lây nhiễm đã biết phù hợp với đặc điểm đó.

```{r transmission_chains_thin,}
sub_attributes <- thin(sub_attributes, what = "contacts")
nrow(sub_attributes$contacts)
```

Bên cạnh việc subset theo thuộc tính nút (node) và cạnh (edge), các mạng liên kết có thể được cắt tỉa để chỉ bao gồm các thành phần được kết nối với một số nút nhất định. Đối số `cluster_id` sẽ lấy một vectơ chứa ID các ca bệnh và trả về danh sách của các cá nhân được liên kết một cách trực tiếp hoặc gián tiếp tới các ID đó. Trong đoạn code dưới đây, chúng ta có thể thấy rằng tổng cộng 13 trường hợp trong bộ số liệu `linelist` có liên quan đến các cụm chứa `2ae019` và `71577a`.

```{r}
sub_id <- subset(epic, cluster_id = c("2ae019","71577a"))
nrow(sub_id$linelist)
```

Phương pháo `subset()` cho các đối tượng `epicontacts` cũng cho phép lọc theo kích thước cụm bằng cách sử dụng các đối số `cs`, `cs_min` và `cs_max`. Trong đoạn code bên dưới, chúng ta chỉ giữ lại các trường hợp được liên kết với các cụm 10 trường hợp hoặc lớn hơn và có thể thấy rằng 271 trường hợp trong trong bộ số liệu `linelist` có liên quan đến các cụm đó.

```{r}
sub_cs <- subset(epic, cs_min = 10)
nrow(sub_cs$linelist)
```

### Truy cập thông tin ID {.unnumbered}

Hàm `get_id()` truy xuất thông tin về ID ca bệnh trong bộ dữ liệu và có thể được tham số hóa như sau:

-   **linelist**: ID trong bộ dữ liệu `linelist`
-   **contacts**: ID trong bộ dữ liệu contact (kết hợp "from" và "to")
-   **from**: ID trong cột "from" của bộ dữ liệu contact
-   **to**: ID trong cột "to" của bộ dữ liệu contact
-   **all**: các ID xuất hiện ở bất kỳ một trong hai bộ dữ liệu
-   **common**: các ID xuất hiện trong cả bộ dữ liệu contact và bộ dữ liệu `linelist`

Ví dụ: xem 10 ID đầu tiên trong bộ dữ liệu contact?

```{r transmission_chains_get_ids,}
contacts_ids <- get_id(epic, "contacts")
head(contacts_ids, n = 10)
```

Có bao nhiêu ID được tìm thấy trong cả hai bộ dữ liệu tiếp xúc và `linelist`?

```{r transmission_chains_get_both,}
length(get_id(epic, "common"))
```

<!-- ======================================================= -->

## Trực quan hóa

### Biểu đồ cơ bản {.unnumbered}

Tất cả các hình ảnh trực quan của các đối tượng **epicontacts** được xử lý bởi hàm `plot`. Trước tiên, chúng ta sẽ lọc đối tượng **epicontacts** để chỉ bao gồm các trường hợp có ngày bắt đầu vào tháng 6 năm 2014 bằng cách sử dụng hàm `subset`, và chỉ bao gồm các tiếp xúc được liên kết với các trường hợp đó bằng cách sử dụng hàm `thin`.

```{r transmission_chains_basic_plot_sub,}
## subset epicontacts object
sub <- epic %>%
  subset(
    node_attribute = list(date_onset = c(as.Date(c("2014-06-30", "2014-06-01"))))
  ) %>%
 thin("contacts")
```

Sau đó, chúng ta có thể tạo biểu đồ cơ bản, có tính tương tác rất đơn giản như sau:

```{r transmission_chains_basic_plot,}
## plot epicontacts object
plot(
  sub,
  width = 700,
  height = 700
)
```

Bạn có thể di chuyển các nút xung quanh bằng cách kéo chúng, di chuột qua chúng để biết thêm thông tin và nhấp vào chúng để đánh dấu các trường hợp được kết nối.

Có một số lượng lớn các đối số để tùy chỉnh biểu đồ này. Chúng ta sẽ trình bày những vấn đề chính ở đây, nhưng bạn có thể xem thêm tài liệu thông qua lệnh `?vis_epicontacts` (hàm được gọi khi sử dụng biểu đồ trên đối tượng **epicontacts**) để có được mô tả đầy đủ về các đối số của hàm.

#### Trực quan hóa các thuộc tính của nút {.unnumbered}

Màu nút, hình dạng nút và kích thước nút có thể được ánh xạ tới một cột nhất định trong bộ số liệu `linelist` bằng cách sử dụng các đối số `node_color`, `node_shape` và `node_size`. Điều này tương tự với cú pháp `aes` mà bạn có thể thấy trong **ggplot2**.

Màu sắc, hình dạng và kích thước cụ thể của các nút có thể được chỉ định như sau:

-   **Màu sắc** thông qua đối số `col_pal`, bằng cách cung cấp một danh sách tên được chỉ định cho từng màu cụ thể như được thực hiện bên dưới hoặc bằng cách cung cấp một hàm bảng màu như `colorRampPalette(c("black", "red", "orange"))`, mà sẽ giúp cung cấp một dải màu giữa các màu được chỉ định.

-   **Hình dạng** bằng cách chuyển một danh sách đã đặt tên đến đối số `shapes`, chỉ định một hình dạng cho mỗi phần tử duy nhất trong cột bộ số liệu `linelist` được chỉ định bởi đối số `node_shape`. Xem `codeawesome` để biết các hình dạng có sẵn.

-   **Kích thước** bằng cách chuyển một phạm vi kích thước của các nút tới đối số `size_range`.

Dưới đây là một ví dụ, trong đó màu sắc thể hiện cho outcome, hình dạng thể hiện cho giới tính và kích thước thể hiện cho độ tuổi:

```{r transmission_chains_node_attribute,}
plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  height = 700,
  width = 700
)
```

#### Trực quan hóa các thuộc tính cạnh {.unnumbered}

Màu, độ dày và kiểu đường có thể được ánh xạ tới một cột nhất định trong bộ dữ liệu tiếp xúc bằng cách sử dụng các đối số `edge_color`, `edge_width` và `edge_linetype`. Các màu cụ và độ dày của các cạnh có thể được chỉ định như sau:

-   **Màu sắc** thông qua đối số `edge_col_pal`, theo cách tương tự được sử dụng cho `col_pal`.

-   **Độ rộng** bằng cách chuyển phạm vi kích thước của các nút tới đối số `width_range`.

Dưới đây là ví dụ:

```{r transmission_chains_edge_attribute,}

plot(
  sub, 
  node_color = "outcome",
  node_shape = "gender",
  node_size = 'age',
  col_pal = c(Death = "firebrick", Recover = "green"),
  shapes = c(f = "female", m = "male"),
  size_range = c(40, 60),
  edge_color = 'location',
  edge_linetype = 'location',
  edge_width = 'duration',
  edge_col_pal = c(Community = "orange", Nosocomial = "purple"),
  width_range = c(1, 3),
  height = 700,
  width = 700
)

```

### Trục thời gian {.unnumbered}

Chúng ta cũng có thể trực quan hóa mạng lây nhiễm dọc theo trục thời gian bằng cách ánh xạ đối số `x_axis` vào một cột trong bộ số liệu `linelist`. Trong ví dụ dưới đây, trục x biểu thị ngày bắt đầu triệu chứng. Chúng ta cũng đã chỉ định đối số `arrow_size` để đảm bảo các mũi tên không quá lớn và đặt `label = FALSE` để làm cho hình bớt lộn xộn.

```{r transmission_chains_x_axis,}
plot(
  sub,
  x_axis = "date_onset",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Có một số lượng lớn các đối số bổ sung để cụ thể hơn cách mà mạng lưới này được hiển thị dọc theo trục thời gian, bạn có thể kiểm tra thông qua lệnh `?vis_temporal_interactive` (hàm được gọi khi sử dụng hàm `plot` trên đối tượng **epicontacts** với đối số `x_axis` được chỉ định). Chúng tôi sẽ mô tả kỹ hơn ở bên dưới.

#### Chỉ định hình dạng cây lây nhiễm {.unnumbered}

Có hai hình dạng chính mà cây lây nhiễm có thể giả định, được chỉ định bằng cách sử dụng đối số `network_shape`. Đầu tiên là hình dạng nhánh `branching` như hình trên, trong đó một cạnh thẳng nối hai nút bất kỳ. Đây là cách trình bày trực quan nhất, tuy nhiên có thể dẫn đến các cạnh chồng lên nhau trong một mạng kết nối dày đặc. Kiểu hình thứ hai là `rectangle`, sẽ tạo ra một cái cây giống như cây phát sinh loài. Ví dụ:

```{r transmission_chains_rectangle,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Mỗi nút có thể được gán một vị trí dọc duy nhất bằng cách chuyển đổi đối số `position_dodge`. Vị trí của các trường hợp không được kết nối (tức là không có lây nhiễm được báo cáo) được xác định bằng cách sử dụng đối số `unlinked_pos`.

```{r transmission_chains_dodge,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  position_dodge = TRUE,
  unlinked_pos = "bottom",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

Vị trí của nút "mẹ" so với các nút "con" có thể được xác định bằng cách sử dụng đối số `parent_pos`. Tùy chọn mặc định là đặt nút "mẹ" ở giữa, tuy nhiên nó có thể được đặt ở dưới cùng (`parent_pos = 'bottom'`) hoặc ở trên cùng (`parent_pos = 'top'`).

```{r transmission_chains_parent_pos,}
plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
)
```

#### Lưu biểu đồ {.unnumbered}

Bạn có thể lưu một biểu đồ dưới dạng tệp tin html tương tác, độc lập với hàm `visSave` từ package **VisNetwork**:

```{r transmission_chains_save, eval=F}

plot(
  sub,
  x_axis = "date_onset",
  network_shape = "rectangle",
  node_color = "outcome",
  col_pal = c(Death = "firebrick", Recover = "green"),
  parent_pos = "top",
  arrow_size = 0.5,
  node_size = 13,
  label = FALSE,
  height = 700,
  width = 700
) %>%
  visNetwork::visSave("network.html")

```

Rất tiếc, việc lưu các kết quả đầu ra mạng lưới lây nhiễm này dưới dạng hình ảnh trở nên khó khăn và bạn cần lưu dưới dạng tệp tin html và sau đó chụp ảnh màn hình của tệp tin này bằng backage **webshot**. Trong đoạn code dưới đây, chúng ta đang chuyển đổi tệp tin html được lưu ở trên thành dạng file ảnh PNG:

```{r transmission_chains_webshot, eval=F}
webshot(url = "network.html", file = "network.png")
```

### Dòng thời gian {.unnumbered}

Bạn cũng có thể thêm dòng thời gian cho mạng lưới truyền nhiễm, được biểu diễn trên trục x của mỗi trường hợp. Nó có thể được sử dụng để trực quan hóa các vị trí ca bệnh, hoặc thời gian dẫn đến outcome. Để tạo dòng thời gian, chúng ta cần tạo một data.frame gồm ít nhất ba cột bao gồm ID, ngày bắt đầu của "sự kiện" và ngày kết thúc của "sự kiện". Bạn cũng có thể thêm bất kỳ cột giá trị nào khác mà sau đó có thể được ánh xạ tới các thuộc tính nút và cạnh của dòng thời gian. Trong đoạn code dưới đây, chúng ta tạo một dòng thời gian từ ngày bắt đầu có triệu chứng đến ngày có outcome và giữ các biến outcome và bệnh viện mà chúng ta đã sử dụng để xác định hình dạng và màu sắc của nút. Lưu ý rằng bạn có thể có nhiều hơn một dòng thời gian hàng/sự kiện cho mỗi trường hợp, ví dụ: nếu một trường hợp được chuyển viện giữa nhiều bệnh viện.

```{r transmission_chains_create_timeline,}

## generate timeline
timeline <- linelist %>%
  transmute(
    id = case_id,
    start = date_onset,
    end = date_outcome,
    outcome = outcome,
    hospital = hospital
  )

```

Sau đó, chúng ta chuyển phần tử dòng thời gian vào đối số `timeline`. Chúng ta có thể ánh xạ các thuộc tính dòng thời gian với màu sắc, hình dạng và kích thước của nút dòng thời gian theo cùng một cách đã xác định trong các phần trước, ngoại trừ việc chúng ta có hai nút: nút bắt đầu và nút kết thúc của mỗi dòng thời gian, có các đối số riêng biệt. Ví dụ: `tl_start_node_color` xác định cột dòng thời gian nào được ánh xạ với màu của nút bắt đầu, trong khi `tl_end_node_shape` xác định cột dòng thời gian nào được ánh xạ tới hình dạng của nút kết thúc. Chúng ta cũng có thể ánh xạ màu, độ dày, kiểu đường kẻ và nhãn vào *cạnh* dòng thời gian thông qua các đối số `tl_edge_`.

Xem `?vis_temporal_interactive` (hàm được gọi khi vẽ biểu đồ một đối tượng epicontacts) để biết tài liệu chi tiết về các đối số. Mỗi đối số cũng được chú thích trong đoạn code bên dưới:

```{r transmission_chains_vis_timeline,}

## define shapes
shapes <- c(
  f = "female",
  m = "male",
  Death = "user-times",
  Recover = "heartbeat",
  "NA" = "question-circle"
)

## define colours
colours <- c(
  Death = "firebrick",
  Recover = "green",
  "NA" = "grey"
)

## make plot
plot(
  sub,
  ## max x coordinate to date of onset
  x_axis = "date_onset",
  ## use rectangular network shape
  network_shape = "rectangle",
  ## mape case node shapes to gender column
  node_shape = "gender",
  ## we don't want to map node colour to any columns - this is important as the
  ## default value is to map to node id, which will mess up the colour scheme
  node_color = NULL,
  ## set case node size to 30 (as this is not a character, node_size is not
  ## mapped to a column but instead interpreted as the actual node size)
  node_size = 30,
  ## set transmission link width to 4 (as this is not a character, edge_width is
  ## not mapped to a column but instead interpreted as the actual edge width)
  edge_width = 4,
  ## provide the timeline object
  timeline = timeline,
  ## map the shape of the end node to the outcome column in the timeline object
  tl_end_node_shape = "outcome",
  ## set the size of the end node to 15 (as this is not a character, this
  ## argument is not mapped to a column but instead interpreted as the actual
  ## node size)
  tl_end_node_size = 15,
  ## map the colour of the timeline edge to the hospital column
  tl_edge_color = "hospital",
  ## set the width of the timeline edge to 2 (as this is not a character, this
  ## argument is not mapped to a column but instead interpreted as the actual
  ## edge width)
  tl_edge_width = 2,
  ## map edge labels to the hospital variable
  tl_edge_label = "hospital",
  ## specify the shape for everyone node attribute (defined above)
  shapes = shapes,
  ## specify the colour palette (defined above)
  col_pal = colours,
  ## set the size of the arrow to 0.5
  arrow_size = 0.5,
  ## use two columns in the legend
  legend_ncol = 2,
  ## set font size
  font_size = 15,
  ## define formatting for dates
  date_labels = c("%d %b %Y"),
  ## don't plot the ID labels below nodes
  label = FALSE,
  ## specify height
  height = 1000,
  ## specify width
  width = 1200,
  ## ensure each case node has a unique y-coordinate - this is very important
  ## when using timelines, otherwise you will have overlapping timelines from
  ## different cases
  position_dodge = TRUE
)

```

<!-- ======================================================= -->

## Phân tích

### Tổng hợp {.unnumbered}

Chúng ta có thể xem tổng quan về một số thuộc tính mạng lưới bằng cách sử dụng hàm `summary`.

```{r transmission_chains_summarise_epicontacts,}
## summarise epicontacts object
summary(epic)
```

Ví dụ, chúng ta có thể thấy rằng chỉ có 57% các tiếp xúc có cả hai trường hợp trong bộ số liệu `linelist`; điều này có nghĩa là chúng ta không có dữ liệu trong bộ số liệu `linelist` về một số lượng đáng kể các trường hợp liên quan đến các chuỗi lây nhiễm này.

### Đặc điểm ghép cặp {.unnumbered}

Hàm `get_pairwise()` cho phép xử lý (các) biến trong bộ số liệu `linelist` theo từng cặp trong bộ dữ liệu tiếp xúc. Ở ví dụ dưới đây, ngày khởi phát bệnh được trích xuất từ bộ số liệu `linelist` để tính toán sự khác biệt giữa ngày khởi phát bệnh cho từng cặp. Giá trị được tạo ra từ phép so sánh này đại diện cho **khoảng nối tiếp (serial interval - si)**.

```{r transmission_chains_pairwise,}
si <- get_pairwise(epic, "date_onset")   
summary(si)
tibble(si = si) %>%
  ggplot(aes(si)) +
  geom_histogram() +
  labs(
    x = "Serial interval",
    y = "Frequency"
  )
```

`get_pairwise()` sẽ diễn giải phân lớp của cột đang được sử dụng để so sánh và sẽ điều chỉnh phương pháp so sánh các giá trị của nó cho phù hợp. Đối với số và ngày (như ví dụ **si** ở trên), hàm sẽ trừ các giá trị. Khi được áp dụng cho các cột là ký tự hoặc phân loại, `get_pairwise()` sẽ gán các giá trị lại với nhau. Bởi vì hàm cũng cho phép xử lý tùy ý (xem đối số "f"), các kết hợp rời rạc này có thể dễ dàng được mô tả và phân tích.

```{r transmission_chains_pairwise_2,}
head(get_pairwise(epic, "gender"), n = 10)
get_pairwise(epic, "gender", f = table)
fisher.test(get_pairwise(epic, "gender", f = table))
```

Ở đây, chúng ta thấy có một mối liên hệ lớn giữa các liên kết lây nhiễm và giới tính.

### Xác định cụm {.unnumbered}

Hàm `get_clusters()` có thể được sử dụng để xác định các thành phần được kết nối trong một đối tượng `epicontacts`. Đầu tiên, chúng ta sử dụng nó để truy xuất `data.frame` chứa thông tin cụm:

```{r transmission_chains_cluster,}
clust <- get_clusters(epic, output = "data.frame")
table(clust$cluster_size)
ggplot(clust, aes(cluster_size)) +
  geom_bar() +
  labs(
    x = "Cluster size",
    y = "Frequency"
  )
```

Giờ chúng ta hãy xem xét các cụm lớn nhất. Đối với điều này, chúng ta thêm thông tin cụm vào đối tượng `epicontacts` và sau đó subset nó để chỉ giữ lại các cụm lớn nhất:

```{r transmission_chains_cluster_2,}
epic <- get_clusters(epic)
max_size <- max(epic$linelist$cluster_size)
plot(subset(epic, cs = max_size))
```

### Tính toán mức độ {.unnumbered}

Mức độ của một nút tương ứng với số cạnh hoặc kết nối của nó với các nút khác. `get_degree()` cung cấp một phương pháp dễ dàng để tính toán giá trị này cho các mạng lưới `epicontacts`. Mức độ cao trong ngữ cảnh này cho biết một cá nhân đã tiếp xúc với nhiều người khác. Đối sôs `type` chỉ ra rằng chúng ta muốn đếm cả mức độ trong và ngoài, đối số `only_linelist` chỉ ra rằng chúng ta chỉ muốn tính mức độ cho các trường hợp trong bộ số liệu `linelist`.

```{r transmission_chains_degree,}
deg_both <- get_degree(epic, type = "both", only_linelist = TRUE)
```

Những cá nhân nào có 10 tiếp xúc?

```{r}
head(sort(deg_both, decreasing = TRUE), 10)
```

Số lượng lây nhiễm trung bình là bao nhiêu?

```{r}
mean(deg_both)
```

<!-- ======================================================= -->

## Tham khảo

[Epicontacts page](https://www.repidemicsconsortium.org/epicontacts/index.html) cung cấp tổng quan về các hàm và package bao gồm một số thông tin chi tiết chuyên sâu hơn.

[Github page](http://github.com/reconhub/epicontacts) có thể được sử dụng để nêu vấn đề và yêu cầu chỉnh sửa.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/transmission_chains.Rmd-->


# Cây phả hệ {#phylogenetic-trees}  


<!-- ======================================================= -->

## Tổng quan {}


**Cây phả hệ** được sử dụng để trực quan hóa và mô tả mối liên hệ cũng như sự tiến hóa của các sinh vật dựa trên trình tự mã di truyền của chúng.  

Chúng có thể được xây dựng từ trình tự di truyền bằng các phương pháp dựa trên khoảng cách (distance-based methods) (chẳng hạn như phương pháp neighbor-joining) hoặc các phương pháp dựa trên ký tự (character-based methods) (chẳng hạn như phương pháp maximum likelihood và Bayesian Markov Chain Monte Carlo). Công nghệ giải trình tự gen thế hệ mới (Next Generation Sequencing - NGS) có giá thành ngày càng hợp lý và ngày càng được sử dụng rộng rãi hơn trong y tế công cộng để mô tả các mầm bệnh gây ra các bệnh truyền nhiễm. Các thiết bị giải trình tự di động giúp giảm thời gian quay vòng và hứa hẹn cung cấp dữ liệu để hỗ trợ điều tra ổ dịch trong thời gian thực. Dữ liệu NGS có thể được sử dụng để xác định nguồn gốc hoặc nguồn gốc của một chủng bùng phát và sự lan truyền của nó, cũng như xác định sự hiện diện của các gen kháng thuốc kháng sinh. Để trực quan hóa mối quan hệ di truyền giữa các mẫu, một cây phát sinh loài được xây dựng.  

Trong chương này chúng ta sẽ học cách sử dụng package **ggtree**, cho phép kết hợp cây phả hệ với dữ liệu bổ sung dưới dạng một dataframe. Điều này sẽ cho phép chúng ta quan sát các xu hướng và nâng cao hiểu biết về động học của dịch bệnh.

```{r, phylogenetic_trees_overview_graph, out.width=c('80%'), fig.align='center', fig.show='hold', echo = FALSE}

pacman::p_load(here, ggplot2, dplyr, ape, ggtree, treeio, ggnewscale)

tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))

sample_data <- read.csv(here::here("data","phylo", "sample_data_Shigella_tree.csv"),sep=",", na.strings=c("NA"), head = TRUE, stringsAsFactors=F)


ggtree(tree, layout="circular", branch.length='none') %<+% sample_data + # the %<+% is used to add your dataframe with sample data to the tree
  aes(color=I(Belgium))+ # color the branches according to a variable in your dataframe
  scale_color_manual(name = "Sample Origin", # name of your color scheme (will show up in the legend like this)
                    breaks = c("Yes", "No"), # the different options in your variable
                   labels = c("NRCSS Belgium", "Other"), # how you want the different options named in your legend, allows for formatting
                 values= c("blue", "black"), # the color you want to assign to the variable 
                 na.value = "black") + # color NA values in black as well
  new_scale_color()+ # allows to add an additional color scheme for another variable
     geom_tippoint(aes(color=Continent), size=1.5)+ # color the tip point by continent, you may change shape adding "shape = "
scale_color_brewer(name = "Continent",  # name of your color scheme (will show up in the legend like this)
                       palette="Set1", # we choose a set of colors coming with the brewer package
                   na.value="grey")+ # for the NA values we choose the color grey
  theme(legend.position= "bottom")

```

<!-- ======================================================= -->

## Chuẩn bị

### Gọi packages {.unnumbered}

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.  

```{r, phylogenetic_trees_loading_packages}
pacman::p_load(
  rio,             # import/export
  here,            # relative file paths
  tidyverse,       # general data management and visualization
  ape,             # to import and export phylogenetic files
  ggtree,          # to visualize phylogenetic files
  treeio,          # to visualize phylogenetic files
  ggnewscale)      # to add additional layers of color schemes

```

### Nhập dữ liệu {.unnumbered}  

Dữ liệu sử dụng trong chương này có thể tải xuống với hướng dẫn từ chương [Tải sách và dữ liệu].  

Có một số định dạng khác nhau mà cây phát sinh loài có thể được lưu trữ (vd: Newick, NEXUS, Phylip). Định dạng phổ biến là ở dạng tệp Newick (.nwk), là tiêu chuẩn để biểu diễn cây ở dạng máy tính có thể đọc được. Điều này có nghĩa là toàn bộ cây có thể được biểu diễn ở định dạng chuỗi chẳng hạn như  "((t2:0.04,t1:0.34):0.89,(t5:0.37,(t4:0.03,t3:0.67):0.9):0.59); ", liệt kê toàn bộ các nút và tips cũng như mối quan hệ của chúng (độ dài nhánh) với nhau.  

Lưu ý: Điều quan trọng là phải hiểu rằng bản thân tệp cây phát sinh loài không chứa dữ liệu trình tự, mà chỉ đơn thuần là kết quả của khoảng cách gen giữa các trình tự. Do đó, chúng ta không thể trích xuất dữ liệu trình tự từ tệp cây.

Đầu tiên, chúng ta sử dụng hàm `read.tree()` từ package **ape** để nhập một tệp cây phát sinh loài Newick ở định dạng .txt, và lưu nó dưới dạng một đối tượng danh sách với kiểu dữ liệu (class) "phylo". Nếu cần, hãy sử dụng hàm  `here()` từ package **here** để chỉ định đường dẫn tệp tương đối.

Lưu ý: Trong trường hợp này, newick tree được lưu dưới dạng tệp .txt để dễ dàng xử lý và tải xuống từ Github.

```{r, echo=F}
tree <- ape::read.tree(here::here("data", "phylo", "Shigella_tree.txt"))
```


```{r, echo=T, eval=F}
tree <- ape::read.tree("Shigella_tree.txt")
```

Chúng ta khảo sát đối tượng cây của chúng ta và thấy nó chứa 299 tips (hoặc mẫu) và 236 nút (nodes).  

```{r}
tree
```

Thứ hai, chúng ta nhập một bảng được lưu trữ dưới dạng tệp .csv với thông tin bổ sung cho từng mẫu được giải trình tự, chẳng hạn như giới tính, quốc gia xuất xứ và các thuộc tính kháng kháng sinh, bằng cách sử dụng hàm `import()` từ package **rio**:

```{r, echo=F}
sample_data <- import(here("data", "phylo", "sample_data_Shigella_tree.csv"))
```

```{r, echo=T, eval=F}
sample_data <- import("sample_data_Shigella_tree.csv")
```

Dưới đây là 50 dòng đầu tiên của bộ dữ liệu:  

```{r message=FALSE, echo=F}
DT::datatable(head(sample_data,50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

### Làm sạch và khảo sát dữ liệu {.unnumbered}  

Chúng ta làm sạch và khảo sát dữ liệu để gán dữ liệu mẫu chính xác cho cây phát sinh loài, các giá trị trong cột `Sample_ID` của data frame `sample_data` cần phải khớp với giá trị `tip.labels` ở trong tệp `tree`: 

Chúng ta kiểm tra định dạng của `tip.labels` trong tệp `tree` bằng cách xem xét 6 hàng đầu tiên với hàm `head()` của **base** R.
```{r, phylogenetic_trees_inspect_sampledata}
head(tree$tip.label) 
```

Chúng ta cũng cần chắc chắn rằng cột đầu tiên trong data frame `sample_data` là cột `Sample_ID`. Chúng ta xem tên các cột của dataframe bằng cách sử dụng hàm `colnames()` từ **base** R.

```{r}
colnames(sample_data)   
```

Chúng ta hãy để ý cột `Sample_IDs` trong data frame để chắc chắn rằng các định dạng là tương tự với `tip.label` (vd: các chữ cái đều viết hoa, không có dấu gạch dưới thừa `_` giữa ký tự và số, v.v.)

```{r}
head(sample_data$Sample_ID) # we again inspect only the first 6 using head()
```

Chúng ta cũng có thể so sánh nếu tất cả các mẫu có trong tệp `tree` và ngược lại bằng cách tạo một vectơ logic TRUE hoặc FALSE khi chúng khớp hoặc không khớp. Chúng không được in ở đây để cho đơn giản.  

```{r, eval=F}
sample_data$Sample_ID %in% tree$tip.label

tree$tip.label %in% sample_data$Sample_ID
```

Chúng ta có thể sử dụng các vectơ này để hiển thị bất kỳ ID mẫu nào không có trên cây (không có ID nào).  

```{r}
sample_data$Sample_ID[!tree$tip.label %in% sample_data$Sample_ID]
```

Sau khi khảo sát, chúng ta có thể thấy định dạng của cột `Sample_ID` trong dataframe tương ứng với định dạng của tên mẫu tại `tip.labels`. Chúng không cần phải được sắp xếp theo cùng một thứ tự để có thể khớp.

Bây giờ chúng ta đã sẵn sàng!




<!-- ======================================================= -->

## Trực quan hóa cây đơn giản {}


### Các bố cục cây khác nhau {.unnumbered}  

**ggtree** cung cấp nhiều định dạng bố cục khác nhau và một số có thể phù hợp với mục đích cụ thể của bạn hơn những định dạng khác. Dưới đây là một vài minh hoạt. Đối với các tùy chọn khác, hãy xem [cuốn sách trực tuyến này](http://yulab-smu.top/treedata-book/chapter4.html).  

Dưới đây là một số bố cục cây mẫu:
```{r, phylogenetic_trees_example_formats, out.width=c('50%'), fig.show='hold'}

ggtree(tree)                                            # simple linear tree
ggtree(tree,  branch.length = "none")                   # simple linear tree with all tips aligned
ggtree(tree, layout="circular")                         # simple circular tree
ggtree(tree, layout="circular", branch.length = "none") # simple circular tree with all tips aligned

```

### Cây đơn giản cộng với dữ liệu mẫu {.unnumbered}  

Toán tử **%<+%** được sử dụng để kết nối data frame `sample_data` tới tệp `tree`.
Cách chú thích dễ dàng nhất cho cây của bạn là thêm tên mẫu ở các ngọn, cũng như tô màu các điểm ngọn và các nhánh nếu muốn :

Here is an example of a circular tree: 
```{r, phylogenetic_trees_adding_sampledata, fig.align='center', warning=F, message=F}

ggtree(tree, layout = "circular", branch.length = 'none') %<+% sample_data + # %<+% adds dataframe with sample data to tree
  aes(color = I(Belgium))+                       # color the branches according to a variable in your dataframe
  scale_color_manual(
    name = "Sample Origin",                      # name of your color scheme (will show up in the legend like this)
    breaks = c("Yes", "No"),                     # the different options in your variable
    labels = c("NRCSS Belgium", "Other"),        # how you want the different options named in your legend, allows for formatting
    values = c("blue", "black"),                  # the color you want to assign to the variable 
    na.value = "black") +                        # color NA values in black as well
  new_scale_color()+                             # allows to add an additional color scheme for another variable
    geom_tippoint(
      mapping = aes(color = Continent),          # tip color by continent. You may change shape adding "shape = "
      size = 1.5)+                               # define the size of the point at the tip
  scale_color_brewer(
    name = "Continent",                    # name of your color scheme (will show up in the legend like this)
    palette = "Set1",                      # we choose a set of colors coming with the brewer package
    na.value = "grey") +                    # for the NA values we choose the color grey
  geom_tiplab(                             # adds name of sample to tip of its branch 
    color = 'black',                       # (add as many text lines as you wish with + , but you may need to adjust offset value to place them next to each other)
    offset = 1,
    size = 1,
    geom = "text",
    align = TRUE)+    
  ggtitle("Phylogenetic tree of Shigella sonnei")+       # title of your graph
  theme(
    axis.title.x = element_blank(), # removes x-axis title
    axis.title.y = element_blank(), # removes y-axis title
    legend.title = element_text(    # defines font size and format of the legend title
      face = "bold",
      size = 12),   
    legend.text=element_text(       # defines font size and format of the legend text
      face = "bold",
      size = 10),  
    plot.title = element_text(      # defines font size and format of the plot title
      size = 12,
      face = "bold"),  
    legend.position = "bottom",     # defines placement of the legend
    legend.box = "vertical",        # defines placement of the legend
    legend.margin = margin())   
```

Bạn có thể xuất biểu đồ cây với hàm `ggsave()` như cách bạn làm với bất kỳ đối tượng ggplot nào khác. Được viết theo cách này,
`ggsave()` lưu hình ảnh cuối cùng được tạo vào đường dẫn tệp bạn chỉ định. Hãy nhớ rằng bạn có thể sử dụng hàm `here()` và các đường dẫn tệp tương đối để dễ dàng lưu trong các thư mục con, v.v.  

```{r, eval=F}
ggsave("example_tree_circular_1.png", width = 12, height = 14)

```


<!-- ======================================================= -->

## Thao tác với cây {}

Đôi khi bạn có thể có một cây phát sinh loài rất lớn và bạn chỉ quan tâm đến một phần của cây. Ví dụ, bạn muốn tạo ra một cây bao gồm các mẫu lịch sử hoặc quốc tế để có cái nhìn tổng quan về vị trí mà tập dữ liệu của bạn có thể phù hợp trong bức tranh lớn hơn. Nhưng sau đó để xem xét kỹ hơn dữ liệu của bạn, bạn chỉ muốn kiểm tra phần đó của cây lớn hơn.

Vì tệp cây phát sinh loài chỉ là sản phẩm đầu ra của phân tích dữ liệu trình tự, chúng ta không thể thao tác trên thứ tự của các nút và nhánh trên chính tệ đó. Chúng đã được xác định trong phân tích trước đó từ dữ liệu NGS thô. Mặc dù vậy, chúng ta có thể phóng to các thành phần, ẩn các thành phần và thậm chí tạo tập con một phần của cây. 

### Phóng to {.unnumbered}  

Nếu bạn không muốn "chặt" cây của mình mà chỉ kiểm tra kỹ hơn một phần của nó, bạn có thể phóng to để xem một phần cụ thể.

Đầu tiên, chúng ta vẽ toàn bộ cây ở định dạng tuyến tính và thêm các nhãn số cho mỗi nút trong cây.
```{r, phylogenetic_trees_zoom_in, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(tree,) %<+% sample_data +
  geom_tiplab(size = 1.5) +                # labels the tips of all branches with the sample name in the tree file
  geom_text2(
    mapping = aes(subset = !isTip,
                  label = node),
    size = 5,
    color = "darkred",
    hjust = 1,
    vjust = 1)                            # labels all the nodes in the tree

p  # print

```

Để phóng to vào một nhánh cụ thể (nhô ra bên phải), hãy sử dụng hàm `viewClade()` trên đối tượng ggtree có tên `p` và cung cấp số nút để xem gần hơn:
```{r phylogenetic_trees_zoom_in_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

viewClade(p, node = 452)

```

### Thu gọn nhánh {.unnumbered} 

Tuy nhiên, chúng ta có thể muốn bỏ qua nhánh này và có thể thu gọn nó tại cùng một nút đó (nút nr. 452) bằng cách sử dụng hàm `collapse()`. Cây này sẽ được gán cho đối tượng mới có tên `p_collapsed`. 

```{r phylogenetic_trees_collapse_452, out.width=c('50%'), fig.show='hold', fig.align='center'}

p_collapsed <- collapse(p, node = 452)
p_collapsed
```

Để rõ ràng, khi chúng ta in `p_collapsed`, chúng ta thêm một điểm (viên kim cương màu xanh) với hàm `geom_point2()` tại nút của nhánh được thu gọn.  
```{r}
p_collapsed + 
geom_point2(aes(subset = (node == 452)),  # we assign a symbol to the collapsed node
            size = 5,                     # define the size of the symbol
            shape = 23,                   # define the shape of the symbol
            fill = "steelblue")           # define the color of the symbol
```

### Tạo tập con một cây {.unnumbered} 

Nếu chúng ta muốn thực hiện một thay đổi lâu dài hơn và tạo một cây mới, gọn hơn để làm việc, chúng ta có thể subset một phần của nó với hàm `tree_subset()`. Sau đó, bạn có thể lưu nó dưới dạng tệp newick tree hoặc tệp .txt mới. 

Đầu tiên, chúng ta kiểm tra các nút cây và các nhãn của tips để quyết định cái gì sẽ được subset.  

```{r, phylogenetic_trees_subsetting, out.width=c('50%'), fig.show='hold', fig.align='center'}
ggtree(
  tree,
  branch.length = 'none',
  layout = 'circular') %<+% sample_data +               # we add the asmple data using the %<+% operator
  geom_tiplab(size = 1)+                                # label tips of all branches with sample name in tree file
  geom_text2(
    mapping = aes(subset = !isTip, label = node),
    size = 3,
    color = "darkred") +                                # labels all the nodes in the tree
 theme(
   legend.position = "none",                            # removes the legend all together
   axis.title.x = element_blank(),
   axis.title.y = element_blank(),
   plot.title = element_text(size = 12, face="bold"))
```

Bây giờ, giả sử chúng ta đã quyết định subset cây tại nút số 528 (chỉ giữ lại các tips bên trong nhánh sau nút 528) và lưu nó vào một đối tượng mới `sub_tree1`:

```{r}
sub_tree1 <- tree_subset(
  tree,
  node = 528)                                            # we subset the tree at node 528
```

Hãy cùng xem cây con 1:

```{r}
ggtree(sub_tree1) +
  geom_tiplab(size = 3) +
  ggtitle("Subset tree 1")
```

Bạn cũng có thể subset dựa trên một mẫu cụ thể, bằng cách chỉ định số lượng nút "backwards" bạn muốn đưa vào. Hãy subset chính phần đó của cây dựa trên một mẫu, trong trường hợp này là S17BD07692, quay lại 9 nút và chúng ta lưu nó dưới dạng đối tượng `sub_tree2` mớit:

```{r}
sub_tree2 <- tree_subset(
  tree,
  "S17BD07692",
  levels_back = 9) # levels back defines how many nodes backwards from the sample tip you want to go
```

Giờ hãy cùng xem cây con 2:

```{r}
ggtree(sub_tree2) +
  geom_tiplab(size =3)  +
  ggtitle("Subset tree 2")

```

Bạn cũng có thể lưu cây mới của mình dưới dạng kiểu Newick hoặc thậm chí là tệp văn bản bằng cách sử dụng hàm `write.tree()` từ package **ape**:

```{r, eval=F, phylogenetic_trees_write_tree}
# to save in .nwk format
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.nwk')

# to save in .txt format
ape::write.tree(sub_tree2, file='data/phylo/Shigella_subtree_2.txt')

```

### Xoay các nút trong một cây {.unnumbered} 


Như đã đề cập bên trên, chúng ta không thể thay đổi thứ tự của các tips hoặc nút trong cây, vì điều này dựa trên mối liên hệ di truyền của chúng và không phải là đối tượng cho các điều chỉnh thị giác. Nhưng chúng ta có thể xoay các nhánh xung quanh nút nếu điều đó giúp chúng ta dễ nhìn hơn.

Đầu tiên, chúng ta hãy vẽ subset tree 2 với nhãn nút để chọn nút mà chúng ta muốn thao tác và lưu nó vào một đối tượng biểu đồ ggtree có tên `p`.

```{r, phylogenetic_trees_rotating_1, out.width=c('50%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) +  
  geom_tiplab(size = 4) +
  geom_text2(aes(subset=!isTip, label=node), # labels all the nodes in the tree
             size = 5,
             color = "darkred", 
             hjust = 1, 
             vjust = 1) 
p
```

Sau đó chúng ta có thể thao tác với các nút bằng cách áp dụng hàm **ggtree::rotate()** hoặc **ggtree::flip()**: 
Lưu ý: để biểu diễn những nút nào chúng ta đang thao tác, trước tiên chúng ta áp dụng hàm **geom_hilight()** từ package **ggtree** để đánh dấu các mẫu trong các nút mà chúng ta quan tâm và lưu trữ sang một đối tượng biểu đồ mới có tên `p1`.

```{r, phylogenetic_trees_rotating_2, out.width=c('50%'), fig.show='hold', fig.align='center'}

p1 <- p + geom_hilight(  # highlights node 39 in blue, "extend =" allows us to define the length of the color block
  node = 39,
  fill = "steelblue",
  extend = 0.0017) +  
geom_hilight(            # highlights the node 37 in yellow
  node = 37,
  fill = "yellow",
  extend = 0.0017) +               
ggtitle("Original tree")


p1 # print
```

Bây giờ chúng ta có thể xoay nút 37 trong đối tượng `p1` để các mẫu trên nút 38 di chuyển lên đỉnh. Chúng ta lưu trữ cây đã xoay trong một đối tượng mới có tên `p2`.
```{r}
p2 <- rotate(p1, 37) + 
      ggtitle("Rotated Node 37")


p2   # print
```

Hoặc chúng ta có thể sử dụng lệnh `flip` để xoay nút 36 trong đối tượng `p1` và đổi nút 37 lên đỉnh và nút 39 xuống dưới đáy. Chúng ta lưu cây đã được lật lại vào một đối tượng mới có tên `p3`.
```{r}

p3 <-  flip(p1, 39, 37) +
      ggtitle("Rotated Node 36")


p3   # print
```

### Ví dụ về cây con với chú thích dữ liệu mẫu {.unnumbered} 

Giả sử chúng tôi đang điều tra cụm các trường hợp với nhân bản vô tính xảy ra vào năm 2017 và 2018 tại nút 39 trong cây con của chúng ta. Chúng ta thêm năm phân lập chủng cũng như lịch sử di chuyển và màu sắc theo quốc gia để xem nguồn gốc của các chủng có liên quan gần khác:

```{r, phylogenetic_trees_inspect_subset_example, out.width=c('80%'), fig.show='hold', fig.align='center', warning=F, message=F}

ggtree(sub_tree2) %<+% sample_data +     # we use th %<+% operator to link to the sample_data
  geom_tiplab(                          # labels the tips of all branches with the sample name in the tree file
    size = 2.5,
    offset = 0.001,
    align = TRUE) + 
  theme_tree2()+
  xlim(0, 0.015)+                       # set the x-axis limits of our tree
  geom_tippoint(aes(color=Country),     # color the tip point by continent
                size = 1.5)+ 
  scale_color_brewer(
    name = "Country", 
    palette = "Set1", 
    na.value = "grey")+
  geom_tiplab(                          # add isolation year as a text label at the tips
    aes(label = Year),
    color = 'blue',
    offset = 0.0045,
    size = 3,
    linetype = "blank" ,
    geom = "text",
    align = TRUE)+ 
  geom_tiplab(                          # add travel history as a text label at the tips, in red color
    aes(label = Travel_history),
    color = 'red',
    offset = 0.006,
    size = 3,
    linetype = "blank",
    geom = "text",
    align = TRUE)+ 
  ggtitle("Phylogenetic tree of Belgian S. sonnei strains with travel history")+  # add plot title
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+                    # add a label to the x-axis 
  theme(
    axis.title.x = element_text(size = 10),
    axis.title.y = element_blank(),
    legend.title = element_text(face = "bold", size = 12),
    legend.text = element_text(face = "bold", size = 10),
    plot.title = element_text(size = 12, face = "bold"))

```

Quan sát của chúng ta hướng tới một sự kiện nhập khẩu các chủng từ châu Á, sau đó lưu hành ở Bỉ trong nhiều năm và dường như đã gây ra đợt bùng phát mới nhất của chúng ta.

<!-- ======================================================= -->

## Các cây phức tạp hơn: thêm bản đồ nhiệt của dữ liệu mẫu {.unnumbered}


Chúng tôi có thể thêm thông tin phức tạp hơn, chẳng hạn như sự phân loại của các gen kháng thuốc và các giá trị đo lường về khả năng kháng thuốc dưới dạng bản đồ nhiệt bằng cách sử dụng hàm **ggtree::gheatmap()**.

Trước tiên, chúng ta cần vẽ cây của mình (có thể là tuyến tính hoặc hình tròn) và lưu trữ nó trong một đối tượng biểu đồ ggtree mới có tên `p`: Chúng ta sẽ sử dụng sub_tree từ phần 3.)
```{r, phylogenetic_trees_sampledata_heatmap, out.width=c('60%'), fig.align='center', fig.show='hold'}

p <- ggtree(sub_tree2, branch.length='none', layout='circular') %<+% sample_data +
  geom_tiplab(size =3) + 
 theme(
   legend.position = "none",
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    plot.title = element_text(
      size = 12,
      face = "bold",
      hjust = 0.5,
      vjust = -15))
p

```

Thứ hai, chúng ta chuẩn bị dữ liệu của mình. Để trực quan hóa các biến khác nhau bằng các phối màu mới, chúng ta subset dataframe thành các biến mong muốn. Điều quan trọng là phải thêm `Sample_ID` làm tên hàng nếu không nó không thể khớp dữ liệu với cây `tip.labels`:

Trong ví dụ của này, chúng ta muốn xem xét giới tính và các đột biến có thể dẫn đến kháng Ciprofloxacin, một loại kháng sinh hàng đầu quan trọng được sử dụng để điều trị nhiễm trùng Shigella.

Chúng ta tạo một dataframe cho biến giới tính: 
```{r, phylogenetic_trees_sampledata_heatmap_data}
gender <- data.frame("gender" = sample_data[,c("Gender")])
rownames(gender) <- sample_data$Sample_ID
```

Chúng ta tạo một dataframe cho đột biến ở gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:
```{r}
cipR <- data.frame("cipR" = sample_data[,c("gyrA_mutations")])
rownames(cipR) <- sample_data$Sample_ID

```
Chúng ta tạo một dataframe đối với nồng độ ức chế tối thiểu đo được (MIC) đối với Ciprofloxacin trong phòng thí nghiệm:
```{r}
MIC_Cip <- data.frame("mic_cip" = sample_data[,c("MIC_CIP")])
rownames(MIC_Cip) <- sample_data$Sample_ID
```

Chúng ta tạo một biểu đồ đầu tiên và thêm bản đồ nhiệt nhị phân cho giới tính vào cây phát sinh loài và lưu trữ nó trong một đối tượng biểu đồ ggtree mới `h1`:
```{r, phylogenetic_trees_sampledata_heatmap_gender, out.width=c('70%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender,                                 # we add a heatmap layer of the gender dataframe to our tree plot
                offset = 10,                               # offset shifts the heatmap to the right,
                width = 0.10,                              # width defines the width of the heatmap column,
                color = NULL,                              # color defines the boarder of the heatmap columns
         colnames = FALSE) +                               # hides column names for the heatmap
  scale_fill_manual(name = "Gender",                       # define the coloring scheme and legend for gender
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1

```

Sau đó, chúng ta thêm thông tin về các đột biến trong gen gyrA, gen này tạo ra khả năng kháng Ciprofloxacin:

Lưu ý: Sự hiện diện của đột biến điểm nhiễm sắc thể trong dữ liệu WGS đã được xác định trước bằng cách sử dụng công cụ PointFinder do Zankari et al phát triển. (xem tham khảo trong phần tài liệu tham khảo bổ sung)

Đầu tiên, chúng ta gán một bảng màu mới cho đối tượng biểu đồ `h1` có sẵn và lưu nó thành một đối tượng mới có tên `h2`. Điều này cho phép chúng ta xác định và thay đổi màu sắc cho biến thứ hai của chúng tôi trong bản đồ nhiệt.
```{r}
h2 <- h1 + new_scale_fill() 
```

Sau đó, chúng ta thêm lớp bản đồ nhiệt thứ hai vào `h2` và lưu biểu đồ thành đối tượng mới có tên `h3`:

```{r, phylogenetic_trees_sampledata_heatmap_cip_genes, out.width=c('80%'), fig.show='hold', fig.align='center'}

h3 <- gheatmap(h2, cipR,         # adds the second row of heatmap describing Ciprofloxacin resistance mutations
               offset = 12, 
               width = 0.10, 
               colnames = FALSE) +
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l")) +
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
h3
```

Chúng tôi lặp lại quy trình trên, trước tiên bằng cách thêm một lớp thang màu mới vào đối tượng hiện có `h3`, sau đó thêm dữ liệu liên tục về nồng độ ức chế tối thiểu (MIC) của Ciprofloxacin cho mỗi chủng vào đối tượng kết quả `h4` để tạo ra đối tượng cuối cùng `h5`:
```{r, phylogenetic_trees_sampledata_heatmap_cip_MIC, out.width=c('90%'), fig.show='hold', fig.align='center'}
# First we add the new coloring scheme:
h4 <- h3 + new_scale_fill()

# then we combine the two into a new plot:
h5 <- gheatmap(h4, MIC_Cip,  
               offset = 14, 
               width = 0.10,
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",  # here we define a gradient color scheme for the continuous variable of MIC
                      low = "yellow", high = "red",
                      breaks = c(0, 0.50, 1.00),
                      na.value = "white") +
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h5

```

Chúng ta có thể thực hiện tương tự đối với cây tuyến tính:
```{r, phylogenetic_trees_sampledata_heatmap_linear_1, out.width=c('80%'), fig.show='hold', fig.align='center'}

p <- ggtree(sub_tree2) %<+% sample_data +
  geom_tiplab(size = 3) + # labels the tips
  theme_tree2()+
  xlab("genetic distance (0.001 = 4 nucleotides difference)")+
  xlim(0, 0.015)+
 theme(legend.position = "none",
      axis.title.y = element_blank(),
      plot.title = element_text(size = 12, 
                                face = "bold",
                                hjust = 0.5,
                                vjust = -15))
p
```

Đầu tiên chúng ta thêm giới:  

```{r, phylogenetic_trees_sampledata_heatmap_linear_2, out.width=c('80%'), fig.show='hold', fig.align='center'}

h1 <-  gheatmap(p, gender, 
                offset = 0.003,
                width = 0.1, 
                color="black", 
         colnames = FALSE)+
  scale_fill_manual(name = "Gender",
                    values = c("#00d1b1", "purple"),
                    breaks = c("Male", "Female"),
                    labels = c("Male", "Female"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())
h1
```


Sau đó, chúng ta thêm các đột biến kháng Ciprofloxacin sau khi thêm một lớp phối màu khác:


```{r, phylogenetic_trees_sampledata_heatmap_linear_3, out.width=c('80%'), fig.show='hold', fig.align='center'}

h2 <- h1 + new_scale_fill()
h3 <- gheatmap(h2, cipR,   
               offset = 0.004, 
               width = 0.1,
               color = "black",
                colnames = FALSE)+
  scale_fill_manual(name = "Ciprofloxacin resistance \n conferring mutation",
                    values = c("#fe9698","#ea0c92"),
                    breaks = c( "gyrA D87Y", "gyrA S83L"),
                    labels = c( "gyrA d87y", "gyrA s83l"))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 12),
        legend.text = element_text(size = 10),
        legend.box = "vertical", legend.margin = margin())+
  guides(fill = guide_legend(nrow = 2,byrow = TRUE))
 h3
```

Sau đó, chúng ta thêm nồng độ ức chế tối thiểu được xác định bởi phòng thí nghiệm (MIC):

```{r, phylogenetic_trees_sampledata_heatmap_linear_4, out.width=c('80%'), fig.show='hold', fig.align='center'}

h4 <- h3 + new_scale_fill()
h5 <- gheatmap(h4, MIC_Cip, 
               offset = 0.005,  
               width = 0.1,
               color = "black", 
                colnames = FALSE)+
  scale_fill_continuous(name = "MIC for Ciprofloxacin",
                      low = "yellow", high = "red",
                      breaks = c(0,0.50,1.00),
                      na.value = "white")+
   guides(fill = guide_colourbar(barwidth = 5, barheight = 1))+
   theme(legend.position = "bottom",
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 8),
        legend.box = "horizontal", legend.margin = margin())+
  guides(shape = guide_legend(override.aes = list(size = 2)))
h5

```


<!-- ======================================================= -->
## Nguồn {}

http://hydrodictyon.eeb.uconn.edu/eebedia/index.php/Ggtree# Clade_Colors
https://bioconductor.riken.jp/packages/3.2/bioc/vignettes/ggtree/inst/doc/treeManipulation.html
https://guangchuangyu.github.io/ggtree-book/chapter-ggtree.html
https://bioconductor.riken.jp/packages/3.8/bioc/vignettes/ggtree/inst/doc/treeManipulation.html

Ea Zankari, Rosa Allesøe, Katrine G Joensen, Lina M Cavaco, Ole Lund, Frank M Aarestrup, PointFinder: a novel web tool for WGS-based detection of antimicrobial resistance associated with chromosomal point mutations in bacterial pathogens, Journal of Antimicrobial Chemotherapy, Volume 72, Issue 10, October 2017, Pages 2764–2768, https://doi.org/10.1093/jac/dkx217


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/phylogenetic_trees.Rmd-->


# Biểu đồ tương tác {#interactive-plots}  

Trực quan hóa dữ liệu ngày càng đòi hỏi có khả năng truy vấn được bởi người đọc. Hệ quả là, các biểu đồ tương tác ngày càng được tạo ra nhiều hơn. Có nhiều cách để tạo biểu đồ tương tác, nhưng hai cách phổ biến nhất là sử dụng package **plotly** và **shiny**. 

Trong chương này chúng ta sẽ tập trung vào việc chuyển đổi một biểu đồ có sẵn được tạo bởi `ggplot()` thành một biểu đồ tương tác với **plotly**. Bạn có thể đọc thêm về **shiny** trong chương [Dashboards với Shiny]. Cũng cần nhấn mạnh là biểu đồ tương tác chỉ sử dụng được ở định dạng HTML trong tệp R markdown và không dùng được với tệp PDF hoặc Word.

Dưới đây là một đường cong dịch bệnh đơn giản đã được biến đổi thành thành biểu đồ tương tác với sự kết hợp của **ggplot2** và **plotly** (hover trỏ chuột phía trên biểu đồ, phóng to, hoặc nhấp vào một item trong chú thích). 

```{r plotly_demo, out.width=c('75%'), out.height=c('500px'), echo=F, warning=F, message=F}
pacman::p_load(plotly, rio, here, ggplot2, dplyr, lubridate)
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

## these buttons are superfluous/distracting
plotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',
                              'zoomOut2d','autoScale2d','hoverClosestCartesian',
                              'toggleSpikelines','hoverCompareCartesian')

p <- linelist %>% 
  mutate(outcome = if_else(is.na(outcome), "Unknown", outcome),
         date_earliest = if_else(is.na(date_infection), date_onset, date_infection),
         week_earliest = floor_date(date_earliest, unit = "week",week_start = 1))%>% 
  count(week_earliest, outcome) %>% 
  ggplot()+
  geom_col(aes(week_earliest, n, fill = outcome))+
  xlab("Week of infection/onset") + ylab("Cases per week")+
  theme_minimal()

p %>% 
  ggplotly() %>% 
  partial_bundle() %>% 
  config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)

```

<!-- ======================================================= -->
## Chuẩn bị {  }

### Gọi packages {.unnumbered}  

Đoạn code này hiển thị việc gọi các package cần thiết cho các phân tích. Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R.


```{r}
pacman::p_load(
  rio,       # import/export
  here,      # filepaths
  lubridate, # working with dates
  plotly,    # interactive plots
  scales,    # quick percents
  tidyverse  # data management and visualization
  ) 
```

### Bắt đầu với `ggplot()` {.unnumbered}  

Trong chương này chúng ta giả định rằng bạn đang bắt đầu với một biểu đồ tạo bởi `ggplot()` và muốn chuyển đổi nó thành biểu đồ tương tác. Chúng ta sẽ xây dựng một số biểu đồ như vậy trong chương này, sử dụng bộ dữ liệu `linelist` đã được đề cập ở rất nhiều chương trong cuốn sổ tay này.  


### Nhập dữ liệu {.unnumbered}

Để bắt đầu, chúng ta nhập bộ dữ liệu có tên linelist đã làm sạch bao gồm các trường hợp từ vụ dịch Ebola mô phỏng. Để tiện theo dõi, <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'>bấm để tải dữ liệu linelist "đã được làm sạch" </a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem thêm chương [Nhập xuất dữ liệu] để biết thêm chi tiết).  

```{r, echo=F}
# import the linelist into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# import case linelist 
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của bộ dữ liệu được hiển thị như bên dưới.

```{r, message=FALSE, echo=F}
# display the linelist data as a table
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```






  
<!-- ======================================================= -->
## Vẽ biểu đồ với `ggplotly()` {  }

Hàm `ggplotly()` thuộc package **plotly** hỗ trợ chuyển đổi dễ dàng một biểu đồ `ggplot()` thành có tính tương tác. Đơn giản chỉ cần lưu biểu đồ `ggplot()` và sau đó pipe nó tới hàm `ggplotly()`.  


Dưới đây, chúng ta biểu diễn một đường đơn giản đại diện cho tỷ lệ các trường hợp tử vong trong một tuần xác định:  

Chúng ta bắt đầu bằng cách tạo một bộ dữ liệu tổng hợp cho từng tuần dịch tễ học, và phần trăm các trường hợp có outcome là tử vong.  

```{r}
weekly_deaths <- linelist %>%
  group_by(epiweek = floor_date(date_onset, "week")) %>%  # create and group data by epiweek column
  summarise(                                              # create new summary data frame:
    n_known_outcome = sum(!is.na(outcome), na.rm=T),      # number of cases per group with known outcome
    n_death  = sum(outcome == "Death", na.rm=T),          # number of cases per group who died
    pct_death = 100*(n_death / n_known_outcome)           # percent of cases with known outcome who died
  )
```
Đây là 50 hàng đầu tiên của bộ dữ liệu `weekly_deaths`.  

```{r message=FALSE, echo=F}
DT::datatable(head(weekly_deaths, 50), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```
Sau đó chúng ta vẽ biểu đồ với hàm `geom_line()` thuộc **ggplot2**.  

```{r, warning=F, message=F}
deaths_plot <- ggplot(data = weekly_deaths)+            # begin with weekly deaths data
  geom_line(mapping = aes(x = epiweek, y = pct_death))  # make line 

deaths_plot   # print
```


Chúng ta có thể tạo tính tương tác cho biểu đồ bằng cách chuyển nó tới hàm `ggplotly()` như dưới đây. Di chuyển trỏ chuột của bạn tới vị trí các đường để hiện thị giá trị x và y. Bạn có thể phóng to và kéo thả trong biểu đồ. Bạn cũng sẽ thấy các biểu tượng ở góc phải trên của biểu đồ. Theo thứ tự, chúng cho phép bạn:  

* Tải xuống trạng thái hiện tại của biểu đồ dưới dạng ảnh PNG  
* Phóng to với hộp thoại lựa chọn  
* "Pan", hay còn gọi là di chuyển biểu đồ bằng cách nhấp và kéo thả biểu đồ  
* Phóng to, thu nhỏ, hoặc quay trở về mặc định  
* Reset trục về mặc định  
* Bật/tắt "spike lines - đường vnah đai", là các đường chấm chấm mở rộng theo trục x và y từ các điểm tương tác  
* Điều chỉnh hiển thị dữ liệu ngay cả khi bạn không rê chuột tới đường thẳng  


```{r}
deaths_plot %>% plotly::ggplotly()
```

Dữ liệu được nhóm cũng hoạt động với hàm `ggplotly()`. Dưới đây đường cong dịch tễ theo tuần được tạo, nhóm theo outcome. Các cột chồng có tính tương tác. Hãy thử nhấp vào các items khác nhau trong phần chú giải (chúng sẽ xuất hiện/biến mất).  


```{r plot_show, eval=F}
# Make epidemic curve with incidence2 pacakge
p <- incidence2::incidence(
  linelist,
  date_index = date_onset,
  interval = "weeks",
  groups = outcome) %>% plot(fill = outcome)
```

```{r, echo=T, eval=F}
# Plot interactively  
p %>% plotly::ggplotly()
```
  
```{r, warning = F, message = F, , out.width=c('95%'), out.height=c('500px'), echo=FALSE}
p %>% 
  ggplotly() %>% 
  partial_bundle() 
```
  
<!-- ======================================================= -->
## Điều chỉnh {  }

### Kích thước tệp {.unnumbered}  

Khi xuất một tệp HTML sinh ra bởi một tệp R Markdown (như cuốn sách này!), bạn sẽ muốn dung lượng của biểu đồ nhỏ nhất có thể (mà không có các tác dụng phụ tiêu cực trong phần lớn trường hợp). Để làm điều này, chỉ cần pipe biểu đồ tương tác tới hàm `partial_bundle()`, cũng thuộc **plotly**.  

```{r plot_tidyshow, eval=F}
p <- p %>% 
  plotly::ggplotly() %>%
  plotly::partial_bundle()
```

### Nút bấm {.unnumbered}  

Một số nút bẩm trong biểu đồ plotly khá thừa thải vã gây mất tập trung, vì vậy bạn có thể loại bỏ chúng. Đơn giản bạn chỉ cần piping đầu ra tới hàm `config()` thuộc **plotly** và cụ thể tên của nút bấm muốn loại bỏ. Trong ví dụ dưới đây, chúng ta cụ thể trước tên của nút bấm muốn loại bỏ vào một danh sách, sau đó cung cấp chúng tới đối số `modeBarButtonsToRemove = `. Chúng ta cũng thiết lập `displaylogo = FALSE` để loại bỏ logo của plotly.  

```{r plot_tidyshow2, eval=F}
## these buttons are distracting and we want to remove them
plotly_buttons_remove <- list('zoom2d','pan2d','lasso2d', 'select2d','zoomIn2d',
                              'zoomOut2d','autoScale2d','hoverClosestCartesian',
                              'toggleSpikelines','hoverCompareCartesian')

p <- p %>%          # re-define interactive plot without these buttons
  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)
```



<!-- ======================================================= -->
## Biểu đồ nhiệt {  }

Bạn có thể khiến bất kỳ loại biểu đồ nào tạo bởi `ggplot()` có khả năng tương tác, bao gồm biểu đồ nhiệt. Trong chương [Biểu đò nhiệt], bạn có thể đọc thêm về cách tạo biểu đồ dưới đây để hiển thị tỷ lệ số ngày trong tuần mà các cơ sở y tế báo cáo dữ liệu lên tuyến tỉnh.  

Sau đây là code, mặc dù chúng tôi sẽ không giải thích chi tiết tại đây.  

```{r  message=F, warning=F}
# import data
facility_count_data <- rio::import(here::here("data", "malaria_facility_count_data.rds"))

# aggregate data into Weeks for Spring district
agg_weeks <- facility_count_data %>% 
  filter(District == "Spring",
         data_date < as.Date("2020-08-01")) %>% 
  mutate(week = aweek::date2week(
    data_date,
    start_date = "Monday",
    floor_day = TRUE,
    factor = TRUE)) %>% 
  group_by(location_name, week, .drop = F) %>%
  summarise(
    n_days          = 7,
    n_reports       = n(),
    malaria_tot     = sum(malaria_tot, na.rm = T),
    n_days_reported = length(unique(data_date)),
    p_days_reported = round(100*(n_days_reported / n_days))) %>% 
  right_join(tidyr::expand(., week, location_name)) %>% 
  mutate(week = aweek::week2date(week))

# create plot
metrics_plot <- ggplot(agg_weeks,
       aes(x = week,
           y = location_name,
           fill = p_days_reported))+
  geom_tile(colour="white")+
  scale_fill_gradient(low = "orange", high = "darkgreen", na.value = "grey80")+
  scale_x_date(expand = c(0,0),
               date_breaks = "2 weeks",
               date_labels = "%d\n%b")+
  theme_minimal()+ 
  theme(
    legend.title = element_text(size=12, face="bold"),
    legend.text  = element_text(size=10, face="bold"),
    legend.key.height = grid::unit(1,"cm"),
    legend.key.width  = grid::unit(0.6,"cm"),
    axis.text.x = element_text(size=12),
    axis.text.y = element_text(vjust=0.2),
    axis.ticks = element_line(size=0.4),
    axis.title = element_text(size=12, face="bold"),
    plot.title = element_text(hjust=0,size=14,face="bold"),
    plot.caption = element_text(hjust = 0, face = "italic")
    )+
  labs(x = "Week",
       y = "Facility name",
       fill = "Reporting\nperformance (%)",
       title = "Percent of days per week that facility reported data",
       subtitle = "District health facilities, April-May 2019",
       caption = "7-day weeks beginning on Mondays.")

metrics_plot # print
```

Sau đó, chúng tôi biến nó trở thành biểu đồ tương tác và điều chỉnh các nút bấm và dung lượng tệp.  

```{r,  out.width=c('95%'), out.height=c('500px')}
metrics_plot %>% 
  plotly::ggplotly() %>% 
  plotly::partial_bundle() %>% 
  plotly::config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove)
```

<!-- ## Maps {.unnumbered}   -->

<!-- You can also make `ggplot()` GIS maps interactive, although it makes a bit more care.  -->

<!-- THIS SECTION IS UNDER CONSTRUCTION  -->

<!-- Although **plotly** works well with `ggplot2::geom_sf` in RStudio, when you try to include its outputs in R Markdown HTML files (like this book), it doesn't work well.   -->

<!-- So instead you can use {**plotly**}'s own mapping tools which can be tricky but are easy when you know how. Read on...   -->

<!-- We're going to use Covid-19 incidence across African countries for this example. The data used can be found on the [World Health Organisation website](https://covid19.who.int/table).   -->

<!-- You'll also need a new type of file, a GeoJSON, which is sort of similar to a shp file for those familiar with GIS. For this book, we used one from [here](https://geojson-maps.ash.ms).   -->

<!-- GeoJSON files are stored in R as complex lists and you'll need to maipulate them a little. -->

<!-- ```{r, echo=T,} -->
<!-- ## You need two new packages: {rjson} and {purrr} -->
<!-- pacman::p_load(plotly, rjson, purrr) -->

<!-- ## This is a simplified version of the WHO data -->
<!-- df <- rio::import(here::here("data", "gis", "covid_incidence.csv")) -->

<!-- ## Load your geojson file -->
<!-- geoJSON <- rjson::fromJSON(file=here::here("data", "gis", "africa_countries.geo.json")) -->

<!-- ## Here are some of the properties for each element of the object -->
<!-- head(geoJSON$features[[1]]$properties) -->

<!-- ``` -->


<!-- This is the tricky part. For {**plotly**} to match your incidence data to GeoJSON, the countries in the geoJSON need an id in a specific place in the list of lists. For this we need to build a basic function: -->
<!-- ```{r} -->
<!-- ## The property column we need to choose here is "sovereignt" as it is the names for each country -->
<!-- give_id <- function(x){ -->

<!--   x$id <- x$properties$sovereignt  ## Take sovereignt from properties and set it as the id -->

<!--   return(x) -->
<!-- } -->

<!-- ## Use {purrr} to apply this function to every element of the features list of the geoJSON object -->
<!-- geoJSON$features <- purrr::map(.x = geoJSON$features, give_id) -->
<!-- ``` -->

<!-- <!-- ======================================================= --> -->
<!-- ### Maps - plot {  } -->

<!-- UNDER CONSTRUCTION -->

<!-- ```{r, echo=FALSE, eval=FALSE, out.width=c('95%'), out.height=c('500px'),warning=F} -->
<!-- plotly::plot_ly() %>%  -->
<!--   plotly::add_trace(                    #The main plot mapping functionn -->
<!--     type="choropleth", -->
<!--     geojson=geoJSON, -->
<!--     locations=df$Name,          #The column with the names (must match id) -->
<!--     z=df$Cumulative_incidence,  #The column with the incidence values -->
<!--     zmin=0, -->
<!--     zmax=57008, -->
<!--     colorscale="Viridis", -->
<!--     marker=list(line=list(width=0)) -->
<!--   ) %>% -->
<!--   colorbar(title = "Cases per million") %>% -->
<!--   layout(title = "Covid-19 cumulative incidence", -->
<!--                  geo = list(scope = 'africa')) %>%  -->
<!--   config(displaylogo = FALSE, modeBarButtonsToRemove = plotly_buttons_remove) -->
<!-- ``` -->

<!-- ======================================================= -->
## Tài nguyên học liệu {  }

Plotly không chỉ dành riêng cho R mà còn hoạt động tốt với Python (và bất cứ ngôn ngữ khoa học dữ liệu nào khác bởi vì nó được xây dựng trên JavaScript). Bạn có thể tìm hiểu thêm về nở ở [website của plotly](https://plotly.com/r/)


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/interactive_plots.Rmd-->

# (PART) Báo cáo và dashboards {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_reports_dashboards.Rmd-->


# Báo cáo với R Markdown {#rmarkdown}  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_overview.png"))
```

R Markdown là một công cụ được sử dụng rộng rãi nhằm tạo ra tài liệu tự động, tái lập và chia sẻ được, như các báo cáo. Nó có thể tạo ra kết quả thống kê hoặc tương tác, ở định dạng Word, pdf, html, powerpoint, và các định dạng khác. 

Một R Markdown script chứa xen kẽ các code R và văn bản khiến script này thật sự *trở thành một tài liệu đầu ra của bạn*. Bạn có thể tạo ra một tài liệu đã được định dạng toàn bộ, gồm có văn bản thuần túy (có thể thay đổi dựa trên số liệu của bạn), bảng, biểu đồ, đầu mục/số, thư mục, v.v.   

Những tài liệu như vậy có thể được cập nhật thường xuyên (ví dụ: báo cáo giám sát hàng ngày) và/hoặc chạy một tập dữ liệu (ví dụ: báo cáo cho mỗi *jurisdiction*-quyền xét xử).    

Những chương khác trong cuốn sách này mở rộng các chủ đề khác:  

* Chương [Tổ chức báo cáo định kỳ] trình bày cách tự động hóa các báo cáo sản phẩm với các tập tin tự tạo kèm theo thời gian.  
* Chương [Dashboards với R Markdown] giải thích cách định dạng một báo cáo R Markdown dưới dạng một dashboard.  


Một lưu ý là dự án [R4Epis](https://r4epis.netlify.app/) đã tạo ra các mẫu R Markdown script cho những đợt dịch và trường hợp khảo sát phổ biến ở vị trí dự án MSF.  


<!-- ======================================================= -->
## Chuẩn bị {  }

**Nền tảng về R Markdown**

Nhằm giải thích một số khái niệm và packages cần thiết:

* **Markdown** là một "ngôn ngữ" cho phép bạn soạn tài liệu bằng chữ thuần túy, sau đó có thể chuyển đổi sang html và các định dạng khác. Nó không dành riêng cho R. Các tệp được viết trong Markdown có đuôi '.md'.  
* **R Markdown**: là một biến thể trên markdown _chỉ dành riêng cho R_ - nó cho phép bạn soạn một tài liệu sử dụng markdown để tạo chữ cũng như *nhúng code R và hiển thị kết quả đầu ra*. Các tệp R Markdown có đuôi '.Rmd'.   
* **Package rmarkdown**: Package được R sử dụng để chuyển tệp .Rmd thành đầu ra mong muốn. Nó tập trung vào việc chuyển cú pháp markdown (chữ), vì vậy chúng ta cũng cần tới... 
* **knitr**: Package R này sẽ đọc các đoạn code, thực thi chúng, và 'knit' (kết hợp) chúng vào lại tài liệu. Đây là cách bảng, biểu đồ được thêm vào văn bản.  
* **Pandoc**: Cuối cùng, pandoc thật sự chuyển đổi kết quả đầu ra thành word/pdf/powerpoint, v.v. Nó là một phần mềm tách biệt khỏi R nhưng được cài đặt tự động cùng với RStudio.  

Tổng kết lại, quá trình được tiến hành *trong nền* (bạn không cần biết tới tất cả những bước này!), gồm chuyển tệp .Rmd tới **knitr** để thực thi các đoạn code R và tạo một tệp .md (markdown) mới bao gồm cả code R lẫn kết quả đầu ra đã được chuyển đổi. Các tệp .md này sau đó được pandoc chạy để tạo ra sản phẩm hoàn thiện như là một tài liệu Microsoft Word, tệp HTML, tài liệu powerpoint, pdf, v.v.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/0_rmd.png"))
```

(Nguồn: https://rmarkdown.rstudio.com/authoring_quick_tour.html):

**Cài đặt**

Để tạo một kết quả đầu ra của R Markdown, bạn cần phải cài đặt:  

* Package **rmarkdown** (**knitr** cũng sẽ được cài đặt tự động)  
* Pandoc sẽ được cài đặt cùng với RStudio. Nếu bạn không dùng RStudio, bạn có thể tải Pandoc tại đây:  http://pandoc.org.  
* Nếu bạn muốn tạo đầu ra là tệp PDF (phức tạp hơn một chút), bạn sẽ cần cài đặt LaTex. Với những người dùng R Markdown chưa cài đặt LaTex trước đó, các bạn có thể cài đặt TinyTeX (https://yihui.name/tinytex/). Bạn có thể sử dụng lệnh sau để cài đặt:

```{r, eval=F}
pacman::p_load(tinytex)     # install tinytex package
tinytex::install_tinytex()  # R command to install TinyTeX software 
```

<!-- ======================================================= -->
## Bắt đầu {  }

### Cài đặt package rmarkdown  {.unnumbered}

Cài đặt R package **rmarkdown**. Trong quyển sổ tay này chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt package nếu cần *và* gọi ra để sử dụng. Bạn cũng có thể cài đặt package với `library()` từ **base** R. Xem thêm ở chương [R cơ bản] để biết thêm thông tin về R packages.  

```{r, eval=F}
pacman::p_load(rmarkdown)
```

### Bắt đầu một tệp Rmd mới {.unnumbered}

Trong RStudio, để mở một tệp R markdown mới, bắt đầu với 'File', rồi 'New file', rồi 'R markdown...'.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstarted.png"))
```

R Studio sẽ đưa ra cho bạn một số lựa chọn kết quả đầu ra. Trong ví dụ bên dưới, chúng tôi chọn "HTML" bởi chúng tôi muốn tạo ra một văn bản html. Tiêu đề và tên các tác giả không quan trọng. Nếu loại tài liệu đầu ra bạn muốn không có, đừng lo - bạn có thể chọn bất kỳ loại nào và thay đổi trong script sau đó.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/1_gettingstartedB.png"))
```

Như vậy sẽ mở ra một script .Rmd mới.  

### Điều quan trọng cần phải biết {.unnumbered}
 
**Thư mục làm việc**

Thư mục làm việc của một tệp markdown là ở bất kỳ vị trí nào tệp được lưu. Ví dụ, nếu R project nằm trong `~/Documents/projectX ` và tệp Rmd được lưu ở thư mục con `~/Documents/projectX/markdownfiles/markdown.Rmd`, thì lệnh `read.csv(“data.csv”)` trong markdown sẽ tìm tệp csv trong thư mục `markdownfiles`, mà không phải là ở thư mục gốc nơi mà scripts trong projects sẽ thường tự động tìm kiếm.  

Để tìm kiếm các tệp này ở chỗ khác, bạn sẽ vừa cần sử dụng cả đường dẫn tệp đầy đủ và sử dụng package **here**. Package **here** cài đặt thư mục làm việc tới thư mục gốc của R project và sẽ được giải thích chi tiết trong các chương [Dự án R] và [Nhập xuất dữ liệu] của sổ tay này. Ví dụ, để nhập một tệp tên "data.csv" từ trong thư mục `projectX`, code sẽ là `import(here(“data.csv”))`.  

Lưu ý rằng không nên sử dụng `setwd()` trong R Markdown scripts - nó chỉ dùng cho các đoạn code được viết trong đó. 

**Làm việc với ổ cứng mạng so với trên máy tính của bạn**

Vì R Markdown có thể gặp các vấn đề với pandoc khi chạy trên một ổ cứng mạng được chia sẻ, thư mục của bạn nên nằm ở ở cứng vật lý, ví dụ trong dự án thuộc 'My Documents'. Nếu bạn dùng Git (rất khuyến khích!), nó sẽ thân thuộc hơn. Để biết thêm chi tiết, xem thêm chương [R trên ổ cứng mạng] và [Các lỗi thường gặp].  


<!-- ======================================================= -->
## Các cấu phần của R Markdown {  }

Một tài liệu R Markdown có thể chỉnh sửa trong RStudio giống như một R script tiêu chuẩn. Khi bạn tạo một R Markdown script mới, RStudio vô cùng hữu ích bằng cách đưa ra một mẫu có các phần khác nhau của một tệp R Markdown script.  

Dưới đây là khung hiển thị khi bắt đầu một Rmd script mới có kết quả đầu ra là html (như phần trước)  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_defaultRMD.png"))
```

Như bạn có thể thấy, một tệp Rmd gồm có 3 cấu phần: YAML, chữ Markdown, và đoạn code R.    

Chúng sẽ *tạo ra và trở thành tài liệu đầu ra của bạn*. Xem biểu đồ bên dưới:  

```{r out.width = "100%", out.height="150%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_translation.png"))
```



### YAML metadata {.unnumbered}

'YAML metadata' hoặc chỉ 'YAML' nằm ở trên cùng trong tài liệu R Markdown. Phần này của script sẽ cho tệp Rmd của bạn biết cần tạo loại kết quả đầu ra nào, định dạng mong muốn, và metadata khác như tiêu đề tài liệu, tác giả, và ngày. Có những công dụng khác không được nhắc ở đây (nhưng được nhắc tới trong 'Tạo kết quả đầu ra'). Lưu ý rằng có sự thụt đầu dòng, nhưng chỉ chấp nhận spaces chứ không nhận tabs.  

Phần này phải được bắt đầu với với một dòng gồm có 3 dấu gạch ngang `---` và phải kết thúc với một dòng chỉ có 3 dấu gạch ngang `---`. Tham số của YAML ở dạng cặp `key:value`. Dấu hai chấm trong YAML có vị trí quan trọng - cặp `key:value` được tách ra bởi dấu hai chấm (không phải dấu bằng!)  

YAML nên bắt đầu với metadata cho tài liệu. Thứ tự của những tham số YAML chính (không thụt lề) không quan trọng. Ví dụ:  

```yaml
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

Bạn có thể sử dụng code R trong giá trị YAML bằng cách viết nó như code tại dòng (mở đầu bằng `r` trong dấu back-ticks/nháy đơn ngược) nhưng nằm trong trích dẫn (xem tại ví dụ phía trên với `date: `).  

Trong hình ảnh phía trên, vì chúng ta ấn vào kết quả đầu ra mặc định là tệp html, chúng ta có thể thấy rằng YAML hiện `output: html_document`. Tuy nhiên, chúng ta cũng có thể thay đổi thành `powerpoint_presentation` hoặc `word_document` hoặc cả `pdf_document`.


### Văn bản {.unnumbered}

Đây là phần diễn giải trong tài liệu của bạn, gồm các tiêu đề và đề mục. Nó được viết bằng ngôn ngữ "markdown", được sử dụng trên nhiều phần mềm khác nhau.  

Dưới đây là những cách cốt lõi để viết văn bản định dạng này. Xem thêm tài liệu mở rộng có sẵn trên R Markdown "cheatsheet" tại [Trang web RStudio](https://rstudio.com/resources/cheatsheets/).  

#### Dòng mới {.unnumbered}  

Duy nhất trong R Markdown, để bắt đầu một dòng mới, nhập *hai dấu cách** vào cuối dòng trước đó và ấn Enter/Return.  


#### Định dạng {.unnumbered}  

Đặt các chữ bình thường bên trong các kí tự sau để thay đổi định dạng của chúng ở đầu ra.  


* Gạch dưới (`_chữ_`) hoặc dấu hoa thị đơn (`*chữ*`) để _in nghiêng_
* Dấu hoa thị kép (`**chữ**`) để **in đậm**
* Dấu nháy đơn ngược (````chữ````) để hiển thị chữ như code  

Phông chữ hiển thị thực tế có thể được đặt bằng cách sử dụng các mẫu cụ thể (được chỉ định trong YAML metadata; xem các tab ví dụ).  

#### Màu sắc {.unnumbered}  

Không có cơ chế đơn giản nào để thay đổi màu chữ trong R Markdown. Một giải pháp khác, *NẾU đầu ra của bạn là tệp HTML*, là thêm một dòng HTML vào văn bản markdown. Đoạn mã HTML dưới đây sẽ in ra một dòng văn bản có màu đỏ đậm.  

```md
<span style="color: red;">**_DANGER:_** This is a warning.</span>  
```

<span style="color: red;">**_DANGER:_** This is a warning.</span>  


#### Tiêu đề và đầu mục {.unnumbered}  

Dấu thăng trong phần văn bản của một script R Markdown tạo ra đầu mục. Điều này khác với một đoạn code R trong script, trong đó ký hiệu thăng là cơ chế nhận xét/chú thích/hủy kích hoạt, như trong R script bình thường.  

Các mức tiêu đề khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau khi bắt đầu một dòng mới. Một ký hiệu thăng là tiêu đề hoặc đầu mục chính. Hai ký hiệu thăng là một đầu mục cấp hai. Các đầu mục cấp ba và cấp bốn có thể được tạo bằng các ký hiệu thăng liên tiếp.  

```md
# Đầu mục cấp một / Tiêu đề

## Đầu mục cấp hai

### Đầu mục cấp ba
```


#### Dấu đầu dòng và đánh số {.unnumbered}  

Sử dụng dấu hoa thị (`*`) để tạo danh sách gạch đầu dòng. Kết thúc câu trước, nhập hai dấu cách, Enter/Return *hai lần*, và bắt đầu tạo gạch đầu dòng. Thêm một dấu cách vào giữa dấu hoa thị và chữ đầu dòng. Sau mỗi đầu dòng nhập hai dấu cách và Enter/Return. Gạch đầu dòng phụ được tạo tương tự nhưng được thụt vào. Các số cũng hoạt động tương tự nhưng thay vì dấu hoa thị, viết 1), 2), v.v. Dưới đây là cách văn bản R Markdown script của bạn trông như thế nào.  


```md
Đây là gạch đầu dòng của tôi (có hai dấu cách sau dấu hai chấm này):  

* Gạch đầu dòng 1 (theo sau là 2 dấu cách và Enter/Return)  
* Gạch đầu dòng 2 (theo sau là 2 dấu cách và Enter/Return)  
  * Gạch đầu dòng phụ 1 (theo sau là 2 dấu cách và Enter/Return)  
  * Gạch đầu dòng phụ 2 (theo sau là 2 dấu cách và Enter/Return)  
  
```


#### Chữ chú giải {.unnumbered}

Bạn có thể "chú giải" văn bản R Markdown giống như bạn sử dụng "#" để chú giải một dòng code R trong một đoạn code R. Chỉ cần đánh dấu văn bản và nhấn Ctrl+Shift+c (Cmd+Shift+c cho Mac). Văn bản sẽ được bao quanh bởi các mũi tên và chuyển sang màu xanh lục. Nó sẽ không xuất hiện trong kết quả đầu ra của bạn.  


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/rmarkdown_hide_text.png"))
```


### Đoạn Code {.unnumbered}

Các phần của script dành riêng để chạy code R được gọi là "chunk - đoạn". Đây là nơi bạn có thể tải các package, nhập dữ liệu và thực hiện quản lý và trực quan hóa dữ liệu thực tế. Có thể có nhiều đoạn code, vì vậy chúng có thể giúp bạn tổ chức code R của mình thành các phần, có thể xen kẽ với văn bản. Cần lưu ý:  
Những 'đoạn' này sẽ có màu nền hơi khác so với phần diễn giải của tài liệu.  

Mỗi đoạn code được mở với một dòng bắt đầu với 3 dấu nháy đơn ngược, và ngoặc nhọn chứa các tham số cho đoạn (`{ }`). Đoạn code kết thúc với 3 dấu nháy đơn ngược.    

Bạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, hoặc bằng cách sử dụng phím tắt "Ctrl + Alt + i" (hoặc Cmd + Shift + r trong Mac), hoặc bằng cách nhấp vào biểu tượng 'insert a new code chunk' màu xanh lục ở đầu trình chỉnh sửa script của bạn.  

Một số lưu ý về nội dung bên trong dấu ngoặc nhọn `{ }`:

*	Chúng bắt đầu bằng ‘r’ để chỉ ra rằng tên ngôn ngữ trong đoạn này là R
*	Sau chữ r, bạn có thể tùy ý viết "tên" đoạn - việc này không cần thiết nhưng có thể giúp bạn sắp xếp công việc của mình tốt hơn. Lưu ý rằng nếu bạn đặt tên cho các phần của mình, bạn phải LUÔN sử dụng các tên độc nhất, nếu không R sẽ báo lỗi khi bạn cố gắng kết xuất.  
*	Dấu ngoặc nhọn cũng có thể bao gồm các tùy chọn khác, được viết dưới dạng `tag = value`, chẳng hạn như:  
  * `eval = FALSE` để không chạy code R   
  * `echo = FALSE` để không hiển thị mã nguồn code R của đoạn trong kết quả đầu ra  
  * `warning = FALSE` để không hiển thị cảnh báo được tạo bởi code R  
  * `message = FALSE` để không hiển thị bất kỳ thông báo nào được tạo bởi code R  
  * `include =` TRUE/FALSE có bao gồm đầu ra đoạn code (ví dụ: các đồ thị) trong tài liệu hay không  
  * `out.width = ` và `out.height =` - cung cấp theo kiểu `out.width = "75%"`  
  * `fig.align = "center"` điều chỉnh cách một hình được căn trên trang  
  * `fig.show='hold'` nếu đoạn code của bạn hiển thị nhiều biểu đồ và bạn muốn chúng hiển thị cạnh nhau  (cùng với `out.width = c("33%", "67%")`. Có thể đặt là `fig.show='asis'` để hiển thị chúng dưới code tạo chúng, `'hide'` để ẩn, hoặc `'animate'` để nối nhiều cái thành một ảnh động.  
* Tiêu đề đoạn phải được viết trên *một dòng*   
* Cố gắng tránh dấu chấm, dấu gạch dưới và dấu cách. Sử dụng dấu gạch ngang ( - ) thay thế nếu bạn cần dấu ngăn cách.  

Đọc kĩ hơn về các tùy chọn **knitr** [tại đây](https://yihui.org/knitr/options/).  

Một số tùy chọn ở trên có thể được định cấu hình với trỏ và nhấp bằng cách sử dụng các nút cài đặt ở trên cùng bên phải của đoạn. Tại đây, bạn có thể chỉ định những phần nào của đoạn mà bạn muốn tài liệu được kết xuất bao gồm cụ thể là code, kết quả đầu ra và cảnh báo. Điều này sẽ xuất hiện dưới dạng tùy chọn được viết trong dấu ngoặc nhọn, ví dụ `echo = FALSE` nếu bạn muốn 'Chỉ hiển thị đầu ra'.  

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunk.png"))
```

Ngoài ra còn có hai mũi tên ở trên cùng bên phải của mỗi đoạn code. Chúng rất hữu ích để chạy code trong một đoạn hoặc tất cả code trong các đoạn trước. Di chuột lên chúng để xem chúng làm gì.  


Để các tùy chọn toàn cục được áp dụng cho tất cả các đoạn trong tập lệnh, bạn có thể thiết lập điều này trong đoạn code R đầu tiên của mình trong tập lệnh. Ví dụ, để chỉ các kết quả đầu ra được hiển thị cho mỗi đoạn code chứ không phải bản thân code, bạn có thể đưa lệnh này vào đoạn code R:

```{r, eval=F}
knitr::opts_chunk$set(echo = FALSE) 
```



#### Code R trong văn bản {.unnumbered}  

Bạn cũng có thể bao gồm code R đơn giản trong dấu nháy đơn ngược. Trong dấu nháy đơn ngược, hãy bắt đầu mã bằng "r" và một dấu cách, để RStudio biết đánh giá code đó là code R. Xem ví dụ bên dưới.  

Ví dụ bên dưới hiển thị nhiều cấp tiêu đề, dấu đầu dòng và sử dụng code R cho ngày hiện tại (`Sys.Date ()`) để chuyển thành ngày in.  

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/2_text.png"))
```



  

Phía trên là một ví dụ đơn giản (hiển thị ngày hiện tại), nhưng sử dụng cùng một cú pháp, bạn có thể hiển thị các giá trị được tạo bởi code R phức tạp hơn (ví dụ: để tính toán giá trị nhỏ nhất, trung bình, giá trị lớn nhất của một cột). Bạn cũng có thể tích hợp các đối tượng hoặc giá trị R đã được tạo trong các đoạn code R trước đó trong script.  

Ví dụ, script dưới đây tính toán tỷ lệ các trường hợp dưới 18 tuổi, sử dụng các hàm **tidyverse** và tạo các đối tượng `less18`,` total` và `less18prop`. Giá trị động này được chèn vào văn bản tiếp theo. Chúng ta thấy nó trông như thế nào khi được knit vào một tài liệu word.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/3_chunktext.png"))
```


### Ảnh {.unnumbered}  

Bạn có thể đưa hình ảnh vào R Markdown của mình theo một trong hai cách:  

```{r, eval=F}
![]("path/to/image.png")  
```

Nếu cách trên không được, thử dùng `knitr::include_graphics()`  

```{r, eval=F}
knitr::include_graphics("path/to/image.png")
```

(hãy nhớ rằng, đường dẫn tệp của bạn có thể được viết bằng cách sử dụng package **here**)

```{r, eval=F}
knitr::include_graphics(here::here("path", "to", "image.png"))
```


### Bảng {.unnumbered}  

Tạo bảng bằng dấu gạch ngang ( - ) và dấu thanh ( | ). Số lượng dấu gạch nối trước/giữa các thanh cho phép số lượng khoảng trắng trong ô trước khi văn bản bắt đầu được bao lại.  


```md
Cột 1    |Cột  2    |Cột 3
---------|----------|--------
Ô A      |Ô B       |Ô C
Ô D      |Ô E       |Ô F
```

Code trên tạo ra bảng ở dưới:  

Cột 1    |Cột  2    |Cột 3
---------|----------|--------
Ô A      |Ô B       |Ô C
Ô D      |Ô E       |Ô F


### Các phần được chia thẻ {.unnumbered}  


Đối với đầu ra là tệp HTML, bạn có thể sắp xếp các phần thành các "tab - thẻ". Chỉ cần thêm `.tabset` vào trong dấu ngoặc nhọn` {} `được đặt *sau đề mục*. Bất kỳ đề mục phụ nào bên dưới tiêu đề đó (cho đến khi tiêu đề khác cùng cấp) sẽ xuất hiện dưới dạng các tab mà người dùng có thể nhấp qua. Đọc thêm [tại đây](https://bookdown.org/yihui/rmarkdown-cookbook/html-tabs.html)  


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/tabbed_script.png"))
knitr::include_graphics(here::here("images", "markdown/tabbed_view.gif"))

```


Bạn có thể thêm một tùy chọn bổ sung `.tabset-pills` sau `.tabset` để tạo cho các thẻ có giao diện "được tô màu". Lưu ý rằng khi xem đầu ra HTML theo thẻ, chức năng tìm kiếm Ctrl+f sẽ chỉ tìm kiếm các tab "đang hoạt động" chứ không phải các thẻ ẩn.  





<!-- ======================================================= -->
## Cấu trúc tệp {}


Có nhiều cách để tổ chức R Markdown của bạn và bất kỳ script R nào liên quan. Mỗi cách đều có cả ưu điểm và nhược điểm:  

* R Markdown khép kín - mọi thứ cần thiết cho báo cáo đều được nhập hoặc tạo trong R Markdown  
  * Nguồn từ các tệp khác - Bạn có thể chạy các script R bên ngoài bằng lệnh `source ()` và sử dụng đầu ra của chúng trong Rmd  
  * Scipt con - một cơ chế thay thế cho `source()`  
* Sử dụng "runfile" - Chạy các lệnh trong script R *trước khi* kết xuất tệp R Markdown  


### Rmd khép kín {.unnumbered}  

Đối với một báo cáo tương đối đơn giản, bạn có thể chọn tổ chức tập lệnh R Markdown của mình sao cho nó "khép kín" và không liên quan đến bất kỳ tập lệnh bên ngoài nào.    


Mọi thứ bạn cần để chạy R markdown đều được nhập hoặc tạo trong tệp Rmd, bao gồm tất cả các đoạn code và package. Cách tiếp cận "khép kín" này phù hợp khi bạn không cần xử lý nhiều dữ liệu (ví dụ: nó mang đến một tệp dữ liệu sạch hoặc gần sạch) và việc kết xuất R Markdown sẽ không mất quá nhiều thời gian.  

Trong trường hợp này, một cấu trúc hợp lý của script R Markdown có thể là:  

1) Thiết lập các tùy chọn **knitr** chung  
2) Tải packages  
3) Nhập dữ liệu  
4) Xử lý dữ liệu  
5) Tạo kết quả đầu ra (bảng, đồ thị, etc.)  
6) Lưu kết quả đầu ra nếu cần (.csv, .png, v.v.)  

#### Nguồn từ các tệp khác {.unnumbered}

Một biến thể của cách tiếp cận "khép kín" là có các đoạn code R Markdown "nguồn" (chạy) chạy các script R khác. Điều này có thể làm cho tập lệnh R Markdown của bạn ít lộn xộn hơn, đơn giản hơn và dễ tổ chức hơn. Nó cũng có thể hữu ích nếu bạn muốn hiển thị số liệu cuối cùng ở đầu báo cáo. Theo cách tiếp cận này, script R Markdown cuối cùng chỉ đơn giản là kết hợp các đầu ra được xử lý trước thành một tài liệu.  

Một cách để làm điều này là cung cấp script R (đường dẫn tệp và tên có phần mở rộng) cho lệnh R **base** `source()`.  

```{r, eval=F}
source("your-script.R", local = knitr::knit_global())
# or sys.source("your-script.R", envir = knitr::knit_global())
```

Lưu ý rằng khi sử dụng `source ()` *trong* R Markdown, các tệp bên ngoài sẽ vẫn được chạy *trong quá trình kết xuất tệp Rmd* của bạn. Do đó, mỗi tập lệnh được chạy mỗi lần bạn kết xuất báo cáo. Do đó, việc có các lệnh `source ()` này *trong* R Markdown không tăng tốc thời gian chạy của bạn, cũng như không hỗ trợ nhiều cho việc gỡ lỗi, vì lỗi vẫn được hiển thị khi tạo R Markdown.  

Một giải pháp thay thế là sử dụng tùy chọn `child = ` của **knitr**. GIẢI THÍCH THÊM ĐỂ LÀM

Bạn phải để ý các *môi trường* R khác nhau. Các đối tượng được tạo trong một môi trường sẽ không nhất thiết phải có sẵn cho môi trường được R Markdown sử dụng.


### Runfile {.unnumbered}  

Cách tiếp cận này liên quan đến việc sử dụng R script có chứa (các) lệnh `render ()` để xử lý trước các đối tượng đưa vào R markdown.  

Ví dụ, bạn có thể tải các package, tải và làm sạch dữ liệu, và thậm chí tạo các biểu đồ trước khi `render()`. Các bước này có thể xảy ra trong R script hoặc trong các script khác được lưu nguồn. Miễn là các lệnh này diễn ra trong cùng một phiên RStudio và các đối tượng được lưu vào môi trường, các đối tượng sau đó có thể được gọi trong nội dung Rmd. Sau đó, bản thân R markdown sẽ chỉ được sử dụng cho bước cuối cùng - để tạo ra kết quả với tất cả các đối tượng được xử lý trước. Điều này dễ dàng hơn để gỡ lỗi nếu có sự cố.  


Cách tiếp cận này hữu ích vì những lý do sau:  


* Thông báo lỗi mang nhiều thông tin hơn - những thông báo này sẽ được tạo từ R script, không phải R Markdown. Lỗi R Markdown có xu hướng cho bạn biết đoạn nào có vấn đề, nhưng sẽ không cho bạn biết dòng nào.

* Nếu có thể, bạn có thể chạy các bước xử lý dài trước lệnh `render ()` - chúng sẽ chỉ chạy một lần.  



Trong ví dụ bên dưới, chúng ta có một R script riêng biệt, trong đó chúng tôi xử lý trước một đối tượng `data` vào Môi trường R và sau đó kết xuất "create_output.Rmd" bằng cách sử dụng `render()`.  

```{r, eval=F}
data <- import("datafile.csv") %>%       # Load data and save to environment
  select(age, hospital, weight)          # Select limited columns

rmarkdown::render(input = "create_output.Rmd")   # Create Rmd file
```





### Cấu trúc thư mục {.unnumbered}  

Quy trình làm việc cũng liên quan đến cấu trúc thư mục tổng thể, chẳng hạn như có thư mục 'đầu ra' cho các tài liệu và số liệu đã tạo và thư mục 'dữ liệu' hoặc 'đầu vào' cho dữ liệu đã được làm sạch. Chúng tôi không đi sâu vào chi tiết ở đây, nhưng hãy xem chương [Tổ chức báo cáo định kỳ].  






## Tạo tài liệu  

Bạn có thể tạo tài liệu theo những cách sau:  

* Thủ công bằng cách nhấn nút "Knit" ở đầu trình chỉnh sửa script RStudio (nhanh chóng và dễ dàng)  
* Chạy lệnh `render()` (được thực thi bên ngoài R Markdown script)  


### Cách 1: Nút "Knit" {.unnumbered}  

Khi bạn mở tệp Rmd, hãy nhấn vào biểu tượng/nút 'Knit' ở đầu tệp.  

R Studio sẽ cho bạn thấy tiến trình trong tab ‘R Markdown’ gần R console của bạn. Tài liệu sẽ tự động mở khi hoàn tất.  

Tài liệu sẽ được lưu trong cùng một thư mục với R markdown script của bạn và có cùng tên tệp (ngoại trừ phần mở rộng). Điều này rõ ràng không phải là lý tưởng cho việc kiểm soát phiên bản (nó sẽ bị ghi đè lên mỗi lần bạn knit, trừ khi được di chuyển theo cách thủ công), như sau đó bạn có thể cần phải tự đổi tên tệp (ví dụ: thêm ngày).  

Đây là nút tắt của RStudio cho hàm `render ()` từ **rmarkdown**. Cách tiếp cận này chỉ tương thích với R markdown khép kín, nơi tất cả các thành phần cần thiết tồn tại hoặc có nguồn trong tệp.  

```{r out.width = "90%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/4_progress.png"))
```



### Cách 2: Lệnh `render()` {.unnumbered}

Một cách khác để tạo đầu ra R Markdown của bạn là chạy hàm `render ()` (từ package **rmarkdown**). Bạn phải thực hiện lệnh này *bên ngoài* R Markdown script - vì vậy hoặc trong một tập lệnh R riêng biệt (thường được gọi là "run file") hoặc dưới dạng lệnh độc lập trong R Console.  

```{r, eval=F}
rmarkdown::render(input = "my_report.Rmd")
```

Như với "knit", cài đặt mặc định sẽ lưu đầu ra Rmd vào cùng thư mục với Rmd script, với cùng tên tệp (ngoài phần mở rộng tệp). Ví dụ: “my_report.Rmd” khi được knit sẽ tạo ra “my_report.docx” nếu bạn đang knit vào một tài liệu word. Tuy nhiên, bằng cách sử dụng `render ()`, bạn có tùy chọn sử dụng các cài đặt khác nhau. `render ()` có thể chấp nhận các đối số bao gồm:  

* `output_format = ` Đây là định dạng đầu ra để chuyển đổi (e.g. `"html_document"`, `"pdf_document"`, `"word_document"`, hoặc `"all"`). Bạn cũng có thể chỉ định điều này trong YAML bên trong R Markdown script.  
* `output_file = ` Đây là tên của tệp đầu ra (và đường dẫn tệp). Điều này có thể được tạo thông qua các hàm R như `here()` hoặc `str_glue()` như minh họa bên dưới.  
* `output_dir = ` Đây là thư mục đầu ra (thư mục) để lưu tệp. Điều này cho phép bạn chọn một thư mục khác với thư mục mà tệp Rmd được lưu vào.  
* `output_options = ` Bạn có thể cung cấp một danh sách các tùy chọn sẽ ghi đè các tùy chọn đó trong script YAML (ví dụ, )
* `output_yaml = `  Bạn có thể cung cấp đường dẫn đến tệp .yml chứa thông số kỹ thuật YAML  
* `params = ` Xem phần thông số bên dưới  
* Xem danh sách đầy đủ [tại đây](https://pkgs.rstudio.com/rmarkdown/reference/render.html)  

Ví dụ, để cải thiện kiểm soát phiên bản, lệnh sau sẽ lưu tệp đầu ra trong thư mục con 'đầu ra', với ngày hiện tại trong tên tệp. Để tạo tên tệp, hàm `str_glue ()` từ package **stringr** được sử dụng để 'dán' các chuỗi tĩnh lại với nhau (được viết đơn giản) với code R động (được viết trong dấu ngoặc nhọn). Ví dụ: nếu đó là ngày 10 tháng 4 năm 2021, tên tệp từ bên dưới sẽ là “Report_2021-04-10.docx”. Xem chương [Ký tự và chuỗi] để biết thêm chi tiết về `str_glue ()`.  


```{r, eval=F}
rmarkdown::render(
  input = "create_output.Rmd",
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx")) 
```

Khi file đang kết xuất, RStudio Console sẽ cho bạn thấy quá trình kết xuất tới 100%, và một thông báo cuối để báo rằng quá trình kết xuất đã hoàn thành.  


###  Cách 3: **reportfactory**  package {.unnumbered}  


R package **reportfactory** cung cấp một phương pháp thay thế để tổ chức và soạn báo cáo R Markdown *phù hợp với các tình huống mà bạn chạy báo cáo thường xuyên (ví dụ hàng ngày, hàng tuần ...).* Nó giúp giảm bớt việc soạn nhiều tệp R Markdown và tổ chức đầu ra của chúng. Về bản chất, nó cung cấp một "nhà máy" mà từ đó bạn có thể chạy báo cáo R Markdown, nhận các thư mục được đánh dấu ngày tháng và thời gian tự động cho kết quả đầu ra và có cách kiểm soát phiên bản "nhẹ nhàng".  

Đọc thêm về quy trình công việc này trong chương về [Tổ chức báo cáo định kỳ].  



<!-- ======================================================= -->
## Báo cáo được tham số hóa {  }

Bạn có thể sử dụng tham số hóa để tạo báo cáo động, sao cho báo cáo có thể được chạy với cài đặt cụ thể (ví dụ: ngày hoặc địa điểm cụ thể hoặc với các tùy chọn knit nhất định). Dưới đây, chúng tôi tập trung vào những điều cơ bản, nhưng có thêm các tài liệu [chi tiết trực tuyến](https://bookdown.org/yihui/rmarkdown/parameterized-reports.html) về các báo cáo được tham số hóa.  

Sử dụng bộ dữ liệu Ebola có tên linelist làm ví dụ, giả sử chúng ta muốn chạy một báo cáo giám sát tiêu chuẩn cho từng bệnh viện mỗi ngày. Chúng ta chỉ ra cách người ta có thể làm điều này bằng cách sử dụng các tham số.  

*Quan trọng: các báo cáo động cũng có thể thực hiện được mà không có cấu trúc tham số chính thức (không có `params:`), bằng cách sử dụng các đối tượng R đơn giản trong R script liền kề. Điều này được giải thích ở cuối phần này.*



### Cài đặt tham số {.unnumbered}

Bạn có nhiều cách để chỉ định giá trị tham số cho đầu ra R Markdown của mình.  

#### Cách 1: Đặt tham số trong YAML {.unnumbered}

Chỉnh sửa YAML để bao gồm tùy chọn `params:`, với các biểu thức được thụt lề cho mỗi tham số bạn muốn xác định. Trong ví dụ này, chúng tôi tạo các tham số `date` và` hospital`, với các giá trị mà chúng tôi chỉ định. Các giá trị này có thể thay đổi mỗi khi chạy báo cáo. Nếu bạn sử dụng nút "Knit" để tạo ra đầu ra, các tham số sẽ có các giá trị mặc định này. Tương tự như vậy, nếu bạn sử dụng `render ()`, các tham số sẽ có các giá trị mặc định này trừ khi được chỉ định khác trong lệnh `render ()`.  


```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: Central Hospital
---
```

Ở chế độ nền, các giá trị tham số này được chứa trong danh sách chỉ đọc được gọi là `params`. Do đó, bạn có thể chèn các giá trị tham số trong code R như cách bạn làm với một đối tượng/giá trị R khác trong môi trường của bạn. Chỉ cần gõ `params $` theo sau là tên tham số. Ví dụ: `params $ Hospital` để đại diện cho tên bệnh viện ("Central Hospital" theo mặc định).  

Lưu ý rằng các tham số cũng có thể giữ các giá trị `true` hoặc `false`, và vì vậy chúng có thể được đưa vào các tùy chọn **knitr** của bạn trong một đoạn code R. Ví dụ: bạn có thể đặt `{r, eval=params$run}` thay vì `{r, eval=FALSE}`, và bây giờ việc đoạn code chạy hay không phụ thuộc vào giá trị của tham số `run:`.  

Lưu ý rằng đối với các tham số là ngày tháng, chúng sẽ được nhập dưới dạng một chuỗi. Vì vậy, để `params$date` được diễn giải trong code R, nó có thể sẽ cần được bao bọc bằng `as.Date()` hoặc một hàm tương tự để chuyển đổi thành lớp Date.




#### Cách 2: Đặt tham số trong `render()` {.unnumbered}  

Như đã đề cập ở trên, thay thế cho việc nhấn nút "Knit" để tạo đầu ra là thực thi hàm `render()` từ một script riêng biệt. Trong trường hợp sau này, bạn có thể chỉ định các tham số được sử dụng trong việc hiển thị đó cho đối số `params = ` của `render ()`.  

Lưu ý rằng bất kỳ giá trị tham số nào được cung cấp ở đây sẽ *ghi đè* các giá trị mặc định của chúng nếu được viết trong YAML. Chúng tôi viết các giá trị trong dấu ngoặc kép vì trong trường hợp này chúng phải được định nghĩa là giá trị ký tự/chuỗi.  

Lệnh dưới đây kết xuất tệp "surveillance_report.Rmd", chỉ định tên và thư mục tệp đầu ra động, đồng thời cung cấp một `list()` gồm hai tham số và giá trị của chúng cho đối số `params = `.  

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = list(date = "2021-04-10", hospital  = "Central Hospital"))
```


#### Cách 3:  Đặt tham số sử Giao diện Người dùng (GUI) {.unnumbered}  

Để có cảm giác tương tác hơn, bạn cũng có thể sử dụng Giao diện Người dùng (Graphical User Interface - GUI) để chọn thủ công các giá trị cho các tham số. Để thực hiện việc này, chúng ta có thể nhấp vào menu thả xuống bên cạnh nút ‘Knit’ và chọn ‘Knit with parameter’.  

Một cửa sổ bật lên sẽ xuất hiện cho phép bạn nhập các giá trị cho các tham số được thiết lập trong YAML của tài liệu.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUI.png"))
```

Bạn có thể đạt được điều tương tự thông qua lệnh `render()` bằng cách chỉ định `params = "ask"`, như được minh họa bên dưới.  

```{r, eval=F}
rmarkdown::render(
  input = "surveillance_report.Rmd",  
  output_file = stringr::str_glue("outputs/Report_{Sys.Date()}.docx"),
  params = “ask”)
```


Tuy nhiên, việc nhập giá trị vào cửa sổ bật lên này có thể xảy ra lỗi và lỗi chính tả. Bạn có thể chọn thêm các hạn chế cho các giá trị có thể được nhập thông qua menu thả xuống. Bạn có thể làm điều này bằng cách thêm vào YAML một số thông số kỹ thuật cho mỗi mục nhập `params:`.  

* `label: ` là cách tiêu đề cho menu thả xuống cụ thể đó  
* `value: ` là giá trị mặc định (bắt đầu)  
* `input: ` đặt thành `select` cho menu thả xuống  
* `choices: ` cung cấp các giá trị đủ điều kiện trong menu thả xuống  

Dưới đây, các thông số kỹ thuật này được viết cho tham số `hospital`.  

```yaml
---
title: Surveillance report
output: html_document
params:
 date: 2021-04-10
 hospital: 
  label: “Town:”
  value: Central Hospital
  input: select
  choices: [Central Hospital, Military Hospital, Port Hospital, St. Mark's Maternity Hospital (SMMH)]
---
```

Khi knit (thông qua nút 'knit with parameters' hoặc bằng cách `render()`), cửa sổ bật lên sẽ có các tùy chọn thả xuống để bạn lựa chọn.  

```{r out.width = "50%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/5_parametersGUIB.png"))
```




### Ví dụ tham số hóa {.unnumbered} 

Đoạn mã sau đây tạo các tham số cho `date` và `hospital`, được sử dụng trong R Markdown tương ứng là `params$date` và `params$hospital`.

Trong kết quả đầu ra của báo cáo, hãy xem cách dữ liệu được lọc cho bệnh viện cụ thể và tiêu đề biểu đồ đề cập đến bệnh viện và ngày chính xác. Chúng tôi sử dụng tệp "linelist_cleaned.rds" ở đây, nhưng nó sẽ đặc biệt thích hợp nếu bản thân tệp linelist cũng có một dấu ngày tháng bên trong nó để căn chỉnh với ngày được tham số hóa.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_Rmdexample.png"))
```

Knit sẽ tạo ra kết quả cuối cùng với phông chữ và bố cục mặc định.  

```{r out.width = "80%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/6_RmdexampleB.png"))
```


### Tham số hóa không có `params` {.unnumbered}

Nếu bạn đang kết xuất tệp R Markdown với `render ()` từ một script riêng biệt, bạn thực sự có thể tạo ra tác động của tham số hóa mà không cần sử dụng chức năng `params:`.  

Ví dụ, trong *R script* có chứa lệnh `render ()`, bạn có thể chỉ cần xác định `hospital` và `date` là hai đối tượng R (giá trị) trước lệnh `render ()`. Trong R Markdown, bạn sẽ không cần phải có phần `params:` trong YAML, và chúng tôi sẽ đề cập đến đối tượng `date` hơn là `params$date` và `hospital` hơn là `params$hospital`.  


```{r, eval=F}
# This is a R script that is separate from the R Markdown

# define R objects
hospital <- "Central Hospital"
date <- "2021-04-10"

# Render the R markdown
rmarkdown::render(input = "create_output.Rmd") 
```

Làm theo cách này có nghĩa là bạn không thể “knit với các tham số”, sử dụng GUI hoặc bao gồm các tùy chọn knit trong các tham số. Tuy nhiên, điều này có thể có ích vì nó cho phép code đơn giản hơn.


<!-- ======================================================= -->

## Tạo vòng lặp nhiều báo cáo   {  }

Chúng ta có thể muốn chạy một báo cáo nhiều lần, thay đổi các thông số đầu vào, để tạo ra một báo cáo cho từng khu vực pháp lý/đơn vị. Điều này có thể được thực hiện bằng cách sử dụng các công cụ cho việc *lặp lại*, được giải thích chi tiết trong chương về [Lặp, vòng lặp và danh sách]. Các tùy chọn bao gồm package **purrr** hoặc sử dụng *vòng lặp for* như được giải thích bên dưới.  

Dưới đây, chúng tôi sử dụng  *vòng lặp for* đơn giản để tạo báo cáo giám sát cho tất cả các bệnh viện được chọn. Điều này được thực hiện bằng một lệnh (thay vì thay đổi từng thông số bệnh viện theo cách thủ công). Lệnh kết xuất báo cáo phải tồn tại trong một script riêng biệt *bên ngoài* báo cáo Rmd. Script này cũng sẽ chứa các đối tượng được xác định để "lặp qua" - ngày hôm nay và một vectơ tên bệnh viện để lặp qua.


```{r, eval=F}
hospitals <- c("Central Hospital",
                "Military Hospital", 
                "Port Hospital",
                "St. Mark's Maternity Hospital (SMMH)") 
```

Sau đó, chúng tôi cung cấp từng giá trị này vào lệnh `render()` bằng cách sử dụng một vòng lặp, lệnh này chạy lệnh một lần cho mỗi giá trị trong vectơ `hospitals`. Chữ cái `i` đại diện cho vị trí chỉ mục (từ 1 đến 4) của bệnh viện hiện đang được sử dụng trong lần lặp đó, như vậy `hospital_list[1]` sẽ là “Central Hospital”. Thông tin này được cung cấp ở hai nơi trong lệnh `render()`:  

1) Đối với tên tệp, sao cho tên tệp của lần lặp đầu tiên nếu được tạo vào ngày 10 tháng 4 năm 2021 sẽ là “Report_Central Hospital_2021-04-10.docx”, được lưu trong thư mục con ‘output’ của thư mục làm việc.  
2) Với `params =` sao cho Rmd sử dụng tên bệnh viện trong nội bộ bất cứ khi nào giá trị `params$hospital` được gọi (ví dụ: chỉ để lọc tập dữ liệu cho bệnh viện cụ thể). Trong ví dụ này, bốn tệp sẽ được tạo - mỗi tệp cho một bệnh viện.  

```{r, eval=F}
for(i in 1:length(hospitals)){
  rmarkdown::render(
    input = "surveillance_report.Rmd",
    output_file = str_glue("output/Report_{hospitals[i]}_{Sys.Date()}.docx"),
    params = list(hospital  = hospitals[i]))
}       
```



<!-- Trong trường hợp bạn không sử dụng hình thức tham số nghiêm ngặt này nhưng lưu các đối tượng vào môi trường, như đã thảo luận ở cuối phần tham số, hàm kết xuất sẽ giống như sau:  -->

<!-- ```md -->
<!-- for(i in 1:length(hospital_list)){ -->
<!-- rmarkdown::render("surveillance_report.Rmd", -->
<!--                   output_file = paste0("output/Report_", hospital_list[i], refdate, ".docx") -->
<!-- }        -->
<!-- ``` -->
<!-- Chữ trong phần đánh dấu sau đó sẽ cần tham chiếu đến `hospital_list[i]` và `refdate`.  -->






<!-- ======================================================= -->
## Mẫu  

Bằng cách sử dụng tài liệu mẫu có chứa bất kỳ định dạng mong muốn nào, bạn có thể điều chỉnh tính thẩm mỹ của đầu ra Rmd sẽ trông như thế nào. Ví dụ, bạn có thể tạo tệp MS Word hoặc Powerpoint chứa các trang/trang trình bày với kích thước, hình đóng dấu, hình nền và phông chữ mong muốn.  

### Tài liệu Word {.unnumbered}

Để tạo một mẫu, hãy bắt đầu một tài liệu word mới (hoặc sử dụng đầu ra hiện có với định dạng phù hợp với bạn) và chỉnh sửa phông chữ bằng cách xác định Kiểu. Trong Kiểu, Đầu mục 1, 2 và 3 đề cập đến các cấp đề mục markdown khác nhau (tương ứng `#Đề mục 1`, `##Đề mục 2` và `### Đề mục 3`). Nhấp chuột phải vào kiểu và nhấp vào 'sửa đổi' để thay đổi định dạng phông chữ cũng như đoạn văn (ví dụ: bạn có thể giới thiệu các ngắt trang trước các kiểu nhất định có thể giúp giãn cách). Các khía cạnh khác của tài liệu word như lề, kích thước trang, đề mục, v.v., có thể được thay đổi giống như một tài liệu word thông thường mà bạn đang làm việc trực tiếp bên trong.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/7_template.png"))
```

### Tài liệu Powerpoint {.unnumbered}

Như trên, hãy tạo một slide mới hoặc sử dụng một file powerpoint hiện có với định dạng mong muốn. Để chỉnh sửa thêm, hãy nhấp vào 'View' và 'Slide Master'. Từ đây, bạn có thể thay đổi giao diện trang chiếu 'master' bằng cách chỉnh sửa định dạng văn bản trong các hộp văn bản, cũng như kích thước nền/trang cho trang tổng thể.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/8_ppttemplate.png"))
```

Thật không may, việc chỉnh sửa tệp powerpoint hơi kém linh hoạt:  

* Đề mục cấp đầu tiên (`# Đề mục 1`) sẽ tự động trở thành tiêu đề của trang trình bày mới,  
* Chữ `## Đề mục 2` sẽ không xuất hiện dưới dạng phụ đề mà là chữ trong hộp văn bản chính của trang chiếu (trừ khi bạn tìm được cách để làm rộng chế độ xem Master).
* Các ô và bảng đã xuất sẽ tự động chuyển sang các trang trình bày mới. Bạn sẽ cần kết hợp chúng, chẳng hạn như hàm **patchwork** để kết hợp các ggplots, để chúng hiển thị trên cùng một trang. Xem [bài đăng trên blog](https://mattherman.info/blog/ppt-patchwork/) về cách sử dụng package **patchwork** để đặt nhiều hình ảnh trên một trang chiếu.  

Xem [**officer** package](https://davidgohel.github.io/officer/) để biết công cụ làm việc chuyên sâu hơn với các bài thuyết trình powerpoint.    




### Tích hợp các mẫu vào YAML {.unnumbered}

Khi một mẫu được chuẩn bị, chi tiết của mẫu này có thể được thêm vào YAML của Rmd bên dưới dòng 'đầu ra' và bên dưới nơi loại tài liệu được chỉ định (chính nó sẽ đi đến một dòng riêng). Lưu ý `reference_doc` có thể được sử dụng cho các mẫu slide powerpoint.  

Dễ dàng nhất là lưu mẫu trong cùng một thư mục với nơi chứa tệp Rmd (như trong ví dụ bên dưới) hoặc trong một thư mục con bên trong.  

```yaml
---
title: Surveillance report
output: 
 word_document:
  reference_docx: "template.docx"
params:
 date: 2021-04-10
 hospital: Central Hospital
template:
 
---
```

### Định dạng tệp HTML {.unnumbered}

Các tệp HTML không sử dụng các mẫu, nhưng có thể có các kiểu được định cấu hình trong YAML. HTML là tài liệu tương tác và đặc biệt linh hoạt. Chúng tôi đề cập đến một số tùy chọn cơ bản ở đây.  

* Mục lục: Chúng ta có thể thêm mục lục với `toc: true` bên dưới, và cũng chỉ định rằng nó vẫn có thể xem được ("float") khi bạn cuộn, với` toc_float: true`.  

* Chủ đề: Chúng ta có thể tham khảo một số chủ đề được tạo sẵn, lấy từ thư viện chủ đề của Bootswatch. Trong ví dụ dưới đây, chúng tôi sử dụng cerulean. Các tùy chọn khác bao gồm: journal, flatly, darkly, readable, spacelab, united, cosmo, lumen, paper, sandstone, simplex, và yeti.  

* Đánh dấu: Định cấu hình này sẽ thay đổi giao diện của chữ được đánh dấu (ví dụ: code trong các đoạn được hiển thị). Các kiểu được hỗ trợ bao gồm mặc định, tango, pygments, kate, monochrome, espresso, zenburn, hasdock, breezedark và textmate.  

Đây là một ví dụ về cách tích hợp các tùy chọn trên vào YAML.

```yaml
---
title: "HTML example"
output:
  html_document:
    toc: true
    toc_float: true
    theme: cerulean
    highlight: kate
    
---
```

Dưới đây là hai ví dụ về kết quả đầu ra HTML, cả hai đều có mục lục nổi, nhưng chủ đề và kiểu đánh dấu khác nhau được chọn:  


```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/9_html.png"))
```


## Nội dung động 

Trong đầu ra HTML, nội dung báo cáo của bạn có thể là động. Dưới đây là một số ví dụ:  

### Bảng {.unnumbered}  

Trong báo cáo HTML, bạn có thể in khung/ô dữ liệu sao cho nội dung là động, với các bộ lọc và thanh cuộn. Có một số packages cung cấp khả năng này.  

Để thực hiện việc này với package **DT**, như được sử dụng trong cuốn sổ tay này, bạn có thể chèn một đoạn code như sau:  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "markdown/10_dynamictable.png"))
```

Hàm `datatable()` sẽ in khung dữ liệu đã cung cấp dưới dạng bảng động cho trình đọc. Bạn có thể đặt `rownames = FALSE` để đơn giản hóa phần ngoài cùng bên trái của bảng. `filter = "top"` cung cấp một bộ lọc trên mỗi cột. Trong đối số `option()` cung cấp danh sách các thông số kỹ thuật khác. Dưới đây, chúng tôi bao gồm hai đối số: `pageLength = 5` đặt số hàng xuất hiện là 5 (các hàng còn lại có thể được xem bằng cách phân trang thông qua các mũi tên) và` scrollX = TRUE` bật thanh cuộn ở cuối bảng (đối với cột mở rộng quá xa sang bên phải).  

Nếu tập dữ liệu của bạn rất lớn, hãy xem xét chỉ hiển thị X hàng trên cùng bằng cách gói khung dữ liệu trong `head()`.  


### Tiện ích HTML {.unnumbered}

[Tiện ích HTML cho R](http://www.htmlwidgets.org/) là một lớp packages R đặc biệt cho phép tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào các đầu ra HTML R Markdown.  

Một số ví dụ phổ biến về các tiện ích này bao gồm:  

* Plotly (được sử dụng trong chương sổ tay này và trong chương [Biểu đồ tương tác])
* visNetwork (được sử dụng trong chương [Chuỗi lây nhiễm] của sổ tay này)  
* Leaflet (được sử dụng trong chương [GIS Cơ bản] của sổ tay này)  
* dygraphs ( hữu ích để hiển thị dữ liệu chuỗi thời gian tương tác)  
* DT (`datatable()`) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)  

Hàm `ggplotly()` từ **plotly** đặc biệt dễ sử dụng. Xem chương [Biểu đồ tương tác].  

## Tài nguyên {  }

Tìm thêm thông tin tại:  

* https://bookdown.org/yihui/rmarkdown/
* https://rmarkdown.rstudio.com/articles_intro.html

Một giải thích tốt về so sánh giữa markdown, knitr và Rmarkdown ở đây: https://stackoverflow.com/questions/40563479/relationship-between-r-markdown-knitr-pandoc-and-bookdown


```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/rmarkdown.Rmd-->


# Tổ chức báo cáo định kỳ {#reportfactory}  

Chương này bao gồm **reportfactory** package, là một *package hỗ trợ việc báo cáo sử dụng R Markdown*.  

Trong các tình huống mà bạn chạy báo cáo thường xuyên (hàng ngày, hàng tuần, v.v.), nó giúp giảm bớt việc soạn nhiều tệp R Markdown và tổ chức các kết quả đầu ra của chúng. Về bản chất, nó cung cấp một "nhà máy" mà từ đó bạn có thể chạy các báo cáo R Markdown, nhận các thư mục được đánh dấu ngày tháng và thời gian tự động cho kết quả đầu ra và có quyền kiểm soát phiên bản "nhẹ".  

**reportfactory** là một trong những packages được phát triển bởi RECON (R Epidemics Consortium). Đây là [website](https://www.repidemicsconsortium.org/) và [Github](https://github.com/reconverse) của họ.  


## Chuẩn bị

### Tải packages {.unnumbered}  

Từ trong RStudio, hãy cài đặt phiên bản mới nhất của **reportfactory** package từ Github.  

Bạn có thể thực hiện việc này thông qua **pacman** package với `p_load_current_gh()`, lệnh này sẽ buộc nhập phiên bản mới nhất từ Github. Cung cấp chuỗi ký tự "reconverse/reportfactory", trong đó chỉ định tổ chức Github (reconverse) và kho lưu trữ (reportfactory). Bạn cũng có thể sử dụng `install_github()` từ **remotes** package để thay thế.  

```{r, eval=FALSE}
# Install and load the latest version of the package from Github
pacman::p_load_current_gh("reconverse/reportfactory")
#remotes::install_github("reconverse/reportfactory") # alternative
```


## Nhà máy mới  

Để tạo một nhà máy mới, chạy hàm `new_factory()`. Thao tác này sẽ tạo một thư mục dự án R độc lập mới. Mặc định là:  

* Nhà máy sẽ được thêm vào thư mục làm việc của bạn  
* Tên của nhà máy dự án R sẽ được gọi là "new_factory.Rproj"  
* Phiên RStudio của bạn sẽ "chuyển sang" dự án R này  

```{r, eval=F}
# This will create the factory in the working directory
new_factory()
```

Nhìn vào bên trong nhà máy, bạn có thể thấy rằng các thư mục con và một số tệp đã được tạo tự động.  


```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_new2.png"))
```

* Thư mục *report_sources* sẽ chứa các scripts R Markdown của bạn, các scripts này sẽ tạo ra các báo cáo của bạn  
* Thư mục *outputs* sẽ chứa các kết quả đầu ra của báo cáo (ví dụ: HTML, Word, PDF, v.v.)  
* Thư mục *scripts* có thể được sử dụng để lưu trữ các scripts R khác (ví dụ: được lấy từ các scripts Rmd của bạn)  
* Thư mục *data* có thể được sử dụng để chứa dữ liệu của bạn (bao gồm các thư mục con "thô" và "sạch")  
* Tệp *.here*, vì vậy bạn có thể sử dụng **here** package để gọi các tệp trong thư mục con theo mối quan hệ của chúng với thư mục gốc này (xem chương [R projects] để biết thêm chi tiết)
* Tệp *gitignore* được tạo trong trường hợp bạn liên kết dự án R này với kho lưu trữ Github (xem [Version control and collaboration with Github])  
* Tệp README trống, nếu bạn sử dụng kho lưu trữ Github  


<span style="color: orange;">**_THẬN TRỌNG:_** tùy thuộc vào cài đặt máy tính của bạn, các tệp như ".here" có thể tồn tại nhưng ẩn.</span>  

Trong số các cài đặt mặc định, dưới đây là một số cài đặt mà bạn có thể điều chỉnh trong lệnh `new_factory()`:  

* `factory = ` - Đặt tên cho thư mục gốc (mặc định là "new_factory")  
* `path = ` - Chỉ định đường dẫn tệp cho nhà máy mới (mặc định là thư mục làm việc)  
* `report_sources = ` Đặt tên thay thế cho thư mục con chứa các R Markdown scripts (mặc định là "report_sources")  
* `outputs = ` Đặt tên thay thế cho thư mục chứa kết quả đầu ra báo cáo (mặc định là "outputs")  

Xem `?new_factory` để biết danh sách đầy đủ các đối số.   


Khi bạn tạo nhà máy mới, phiên R của bạn được chuyển sang dự án R mới, vì vậy bạn nên tải lại package **reportfactory**.

```{r, eval=FALSE}
pacman::p_load(reportfactory)
```

Bây giờ bạn có thể chạy lệnh `factory_overview()` để xem cấu trúc bên trong (tất cả các thư mục và tệp) trong nhà máy.  

```{r, eval=F}
factory_overview()            # print overview of the factory to console
```

"Cây" các thư mục và tệp của nhà sản xuất được in ra R console. Lưu ý rằng trong thư mục "data" có các thư mục con cho dữ liệu "raw" (thô) và "clean" (sạch) cũng như dữ liệu CSV mẫu. Ngoài ra còn có "example_report.Rmd" trong thư mục "report_sources".    

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview.png"))
```


## Tạo báo cáo  

Từ bên trong dự án R của nhà máy, hãy tạo báo cáo R Markdown giống như bạn thường làm và lưu nó vào thư mục "report_sources". Xem chương [R Markdown][Reports with R Markdown] để biết hướng dẫn. Để ví dụ, chúng tôi đã thêm những thứ sau vào nhà máy:  

* R markdown script mới có tên "daily_sitrep.Rmd", được lưu trong thư mục "report_sources"  
* Dữ liệu cho báo cáo ("linelist_cleaned.rds"), được lưu vào thư mục con "clean" trong thư mục "data"   

Chúng ta có thể thấy bằng cách sử dụng `factory_overview()` R Markdown trong thư mục "report_sources" và tệp dữ liệu trong thư mục dữ liệu "clean" (được đánh dấu):  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview2.png"))
```

Dưới đây là ảnh chụp phần đầu của R Markdown "daily_sitrep.Rmd". Bạn có thể thấy rằng định dạng đầu ra được đặt là HTML, thông qua tiêu đề YAML `output: html_document`.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_new_rmd.png"))
```

Trong script đơn giản này, có các lệnh để:  

* Tải các packages cần thiết  
* Nhập dữ liệu danh sách dòng bằng đường dẫn tệp từ package **here** (đọc thêm trong chương [Import and export])  

```{r, eval=F}
linelist <- import(here("data", "clean", "linelist_cleaned.rds"))
```

* In bảng tóm tắt các trường hợp và xuất nó với `export()` dưới dạng tệp .csv  
* In một đường cong dịch tễ và xuất nó bằng `ggsave ()` dưới dạng tệp .png  

Bạn chỉ có thể xem lại danh sách các báo cáo R Markdown trong thư mục "report_sources" bằng lệnh này:  

```{r, eval=F}
list_reports()
```



## Biên soạn

Trong nhà máy báo cáo, để "biên soạn" báo cáo R Markdown có nghĩa là .Rmd script sẽ được chạy và đầu ra sẽ được tạo (như được chỉ định trong script YAML, ví dụ như HTML, Word, PDF, v.v.).  

*Nhà máy sẽ tự động tạo một thư mục được đánh dấu ngày tháng và thời gian cho các kết quả đầu ra trong thư mục "outputs".*  

Bản thân báo cáo và mọi tệp đã xuất do script tạo ra (ví dụ: csv, png, xlsx) sẽ được lưu vào thư mục này. Ngoài ra, bản thân script Rmd sẽ được lưu trong thư mục này, vì vậy bạn có bản ghi của phiên bản script đó.

Điều này trái ngược với hoạt động bình thường của R Markdown "knitted" (kết hợp), lưu kết quả đầu ra vào vị trí của script Rmd. Hành vi mặc định này có thể dẫn đến các thư mục đông đúc, lộn xộn. Nhà máy nhằm mục đích cải thiện tổ chức khi một người cần chạy báo cáo thường xuyên.  

### Biên soạn theo tên {.unnumbered}  

Bạn có thể biên dịch một báo cáo cụ thể bằng cách chạy `compile_reports()` và đặt tên Rmd script (không có phần mở rộng .Rmd) cho `reports = `. Để đơn giản hơn, bạn có thể bỏ qua `reports = ` và chỉ cần viết tên R Markdown trong dấu ngoặc kép, như bên dưới.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile1.png"))
```


Lệnh này sẽ chỉ biên dịch báo cáo "daily_sitrep.Rmd", lưu báo cáo HTML, xuất bảng .csv và đường cong dịch bệnh .png vào một thư mục con được đóng dấu ngày và giờ cụ thể cho báo cáo, trong thư mục "outputs" .  

Lưu ý rằng nếu bạn chọn cung cấp phần mở rộng .Rmd, bạn phải nhập chính xác phần mở rộng vì nó được lưu trong tên tệp (.rmd so với .Rmd).  

Cũng lưu ý rằng khi biên soạn, bạn có thể thấy một số tệp tạm thời xuất hiện trong thư mục "report_sources" - nhưng chúng sẽ sớm biến mất khi chúng được chuyển đến đúng thư mục "output".  

### Biên soạn theo số {.unnumbered}

Bạn cũng có thể chỉ định Rmd script để biên dịch bằng cách cung cấp một số hoặc vectơ số cho `reports = `. Các con số phải phù hợp với thứ tự các báo cáo xuất hiện khi bạn chạy `list_reports()`.  

```{r, eval=F}
# Compile the second and fourth Rmds in the "report_sources" folder
compile_reports(reports = c(2, 4))
```



### Biên soạn tất cả {.unnumbered}

Bạn có thể biên soạn *tất cả* báo cáo R Markdown trong thư mục "report_sources" bằng cách đặt đối số `report =` thành TRUE.

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile_all.png"))
```


### Biên soạn từ thư mục con {.unnumbered}  

Bạn có thể thêm các thư mục con vào thư mục "report_sources". Để chạy báo cáo R Markdown từ một thư mục con, chỉ cần cung cấp tên của thư mục cho `subfolder =`. Dưới đây là ví dụ về code để biên soạn báo cáo Rmd nằm trong thư mục con của "report_sources".  

```{r, eval=F}
compile_reports(
     reports = "summary_for_partners.Rmd",
     subfolder = "for_partners")
```

Bạn có thể biên soạn tất cả các báo cáo Rmd trong một thư mục con bằng cách cung cấp tên thư mục con cho `reports = `, với một dấu gạch chéo ở cuối, như bên dưới.  

```{r, eval=F}
compile_reports(reports = "for_partners/")
```


### Tham số hóa {.unnumbered}

Như đã lưu ý trong chương về [Reports with R Markdown], bạn có thể chạy báo cáo với các thông số được chỉ định. Bạn có thể chuyển các tham số này dưới dạng danh sách tới `compile_reports ()` thông qua đối số `params =`. Ví dụ, trong báo cáo hư cấu này, có ba tham số được cung cấp cho báo cáo R Markdown.  

```{r, eval=F}
compile_reports(
  reports = "daily_sitrep.Rmd",
  params = list(most_recent_data = TRUE,
                region = "NORTHERN",
                rates_denominator = 10000),
  subfolder = "regional"
)
```


### Dùng "run-file" {.unnumbered}  

Nếu bạn có nhiều báo cáo cần chạy, hãy cân nhắc tạo R script chứa tất cả các lệnh `compile_reports()`. Người dùng có thể chỉ cần chạy tất cả các lệnh trong R script này và tất cả các báo cáo sẽ được biên soạn. Bạn có thể lưu "run-file" này vào thư mục "scripts".  


## Kết quả đầu ra 

Sau khi chúng ta đã biên soạn các báo cáo một vài lần, thư mục "outputs" có thể trông giống như sau (các điểm nổi bật được thêm vào để rõ ràng):  


```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_overview_all.png"))
```


* Trong "outputs", các thư mục con đã được tạo cho mỗi báo cáo Rmd  
* Trong đó, các thư mục con khác đã được tạo cho mỗi lần biên soạn duy nhất  
  * Đây là những ngày tháng và thời gian được đóng dấu ("2021-04-23_T11-07-36" có nghĩa là ngày 23 tháng 4 năm 2021 lúc 11:07:36)
  * Bạn có thể chỉnh sửa định dạng dấu ngày/giờ. Xem `?compile_reports`  
* Trong mỗi thư mục ngày/giờ được biên soạn, kết quả báo cáo được lưu trữ (ví dụ: HTML, PDF, Word) cùng với tập lệnh Rmd (kiểm soát phiên bản!) Và bất kỳ tệp nào được xuất khác (ví dụ: table.csv, translate_curve.png)

Đây là chế độ xem bên trong một trong các thư mục được đánh dấu ngày/giờ cho báo cáo "daily_sitrep". Đường dẫn tệp được đánh dấu bằng màu vàng để nhấn mạnh.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_compile_folder.png"))
```


Cuối cùng, bên dưới là ảnh chụp màn hình của kết quả báo cáo HTML.  


```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "factory_html.png"))
```

Bạn có thể sử dụng `list_outputs()` để xem lại danh sách các kết quả đầu ra.  




## Mục khác  

### Knit {.unnumbered} 

Bạn vẫn có thể "knit" một trong các báo cáo R Markdown của mình bằng cách nhấn nút "Knit" nếu muốn. Nếu bạn làm điều này, theo mặc định, kết quả đầu ra sẽ xuất hiện trong thư mục lưu Rmd - thư mục "report_sources". Trong các phiên bản trước của **reportfactory**, việc có bất kỳ tệp nào không phải Rmd trong "report_sources" sẽ ngăn việc biên dịch, nhưng trường hợp này không còn nữa. Bạn có thể chạy `compile_reports()` và không có lỗi nào xảy ra.

### Scripts {.unnumbered}  

Chúng tôi khuyến khích bạn sử dụng thư mục "scripts" để lưu trữ "runfiles" hoặc các .R scripts được lấy từ các .R scripts của bạn. Xem trang trên [R Markdown][Reports with R Markdown] để biết các mẹo về cách cấu trúc code của bạn trên một số tệp.  


### Thêm {.unnumbered} 

* Với **reportfactory**, bạn có thể sử dụng hàm `list_deps()` để liệt kê tất cả các packages được yêu cầu trên tất cả các báo cáo trong toàn bộ nhà máy.  

* Có một package đi kèm trong quá trình phát triển được gọi là **rfextras** cung cấp nhiều chức năng trợ giúp hơn để hỗ trợ bạn trong việc xây dựng báo cáo, chẳng hạn như:  
  * `load_scripts()` - dẫn nguồn/tải tất cả các .R scripts trong một thư mục nhất định (thư mục "scripts" theo mặc định)
  * `find_latest()` - tìm phiên bản mới nhất của tệp (ví dụ: tập dữ liệu mới nhất)  




<!-- ======================================================= -->
## Tài nguyên {  }

Xem [Github page](https://github.com/reconverse/reportfactory) của **reportfactory** package  

Xem [Github page](https://github.com/reconhub/rfextras) của **rfextras** package  

```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/reportfactory.Rmd-->


# Dashboards với R Markdown {#flexdashboard}

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_output.png"))
```

Chương này sẽ trình bày cách sử dụng cơ bản của package **flexdashboard**. Package này cho phép bạn dễ dàng định dạng đầu ra R Markdown dưới dạng dashboard với các ô điều khiển và trang. Nội dung dashboard có thể là văn bản, số liệu/bảng tĩnh hoặc đồ họa tương tác.  

Ưu điểm của **flexdashboard**:  

* Yêu cầu việc viết code R không chuẩn hóa là ít nhất - với rất ít thực hành, bạn có thể nhanh chóng tạo một dashboard  
* Dashboard thường có thể được gửi qua email cho đồng nghiệp dưới dạng tệp HTML độc lập - không cần máy chủ  
* Bạn có thể kết hợp **flexdashboard** với **shiny**, **ggplotly** và *"html widgets"* khác để thêm tính tương tác  

Nhược điểm của **flexdashboard**:  

* Ít tùy chỉnh hơn so với việc chỉ sử dụng **shiny** để tạo dashboard  


Bạn có thể tìm thấy các hướng dẫn toàn diện về cách sử dụng **flexdashboard** được mô tả ở chương này trong phần Tài nguyên. Dưới đây, chúng tôi mô tả các tính năng cốt lõi và đưa ra ví dụ về việc xây dựng dashboard để khám phá một đợt bùng dịch, sử dụng dữ liệu `linelist`.    


## Chuẩn bị  

### Gọi các packages {.unnumbered}  

Trong sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` từ package **pacman**, cài đặt package nếu cần *và* gọi nó để sử dụng. Bạn cũng có thể gọi các package đã cài đặt với hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thông tin về các R packages.  

```{r}
pacman::p_load(
  rio,             # nhập/xuất dữ liệu     
  here,            # định vị tệp
  tidyverse,       # quản lý và trực quan hóa dữ liệu 
  flexdashboard,   # phiên bản dashboard của báo cáo R Markdown
  shiny,           # biểu đồ tương tác
  plotly           # biểu đồ tương tác
)
```

### Nhập dữ liệu {.unnumbered}  

Chúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn theo dõi, hãy <a href='https://github.com/appliedepi/epirhandbook_eng/raw/master/data/case_linelists/linelist_cleaned.rds' class='download-button'> nhấp để tải xuống linelist "sạch"</a> (dưới dạng tệp .rds). Nhập dữ liệu bằng hàm `import()` từ package **rio** (nó xử lý nhiều loại tệp như .xlsx, .csv, .rds - xem chương [Nhập xuất dữ liệu] để biết chi tiết).  

```{r, echo=F}
# nhập linelist vào R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, eval=F}
# nhập linelist
linelist <- import("linelist_cleaned.rds")
```

50 hàng đầu tiên của linelist được hiển thị bên dưới.  

```{r, message=FALSE, echo=F}
# hiển thị dữ liệu linelist như bảng
DT::datatable(head(linelist, 50), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```


## Tạo R Markdown mới  

Sau khi bạn đã cài đặt package, hãy tạo một tệp R Markdown mới bằng cách nhấp qua *File > New file > R Markdown*.  

```{r out.width = "100%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new1.png"))
```


Trong cửa sổ mở ra, chọn "From Template" và chọn mẫu "Flex Dashboard". Sau đó, bạn sẽ được nhắc đặt tên cho tài liệu. Trong ví dụ của chương này, chúng tôi sẽ đặt tên R Markdown của chúng tôi là "outbreak_dashboard.Rmd".  
  

```{r out.width = "100%", out.height="75%", fig.align = "center", echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_new2.png"))
```




## Script  

Script là một script R Markdown và do đó có các thành phần và tổ chức tương tự như được mô tả trong chương [Báo cáo với R Markdown]. Chúng ta sẽ xem lại một cách ngắn gọn định dạng này và nêu rõ sự khác biệt so với các định dạng đầu ra R Markdown khác.  

### YAML {.unnumbered}  

Ở đầu script là tiêu đề "YAML". Mục này phải bắt đầu bằng ba dấu gạch ngang `---` và phải kết thúc bằng ba dấu gạch ngang `---`. Tham số YAML có trong cặp `key:value`. **Thụt lề và đặt dấu hai chấm trong YAML là việc quan trọng** - các cặp `key:value` được phân tách bằng dấu hai chấm (không phải dấu bằng!).  

YAML phải bắt đầu bằng metadata cho tài liệu. Thứ tự của các tham số YAML chính này (không thụt lề) không quan trọng. Ví dụ:  

```{r, eval=F}
title: "My document"
author: "Me"
date: "`r Sys.Date()`"
```

Bạn có thể sử dụng code R trong các giá trị YAML bằng cách đặt nó giống như code nội dòng (bắt dầu bằng `r` trong dấu nháy đơn ngược) nhưng cũng trong dấu ngoặc kép (xem phần Ngày ở trên).  

Tham số YAML bắt buộc là `output:`, chỉ định loại tệp sẽ được tạo (ví dụ: `html_document`, `pdf_document`, `word_document` hoặc` powerpoint_presentation`). Đối với **flexdashboard** giá trị tham số này hơi khó hiểu - nó phải được đặt là `output:flexdashboard::flex_dashboard`. Lưu ý dấu hai chấm đơn, dấu hai chấm đôi và dấu gạch dưới. Tham số đầu ra YAML này thường được theo sau bởi *một dấu hai chấm nữa* và các tham số phụ được thụt lề (xem các tham số `orientation: ` và `vertical_layout: ` bên dưới).

```{r, eval=F}
title: "My dashboard"
author: "Me"
date: "`r Sys.Date()`"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: scroll
```

Như hình trên, thụt lề (2 dấu cách) được sử dụng cho các tham số phụ. Trong trường hợp này, đừng quên đặt thêm một dấu hai chấm sau dấu chính, như `key:value:`.  

Nếu thích hợp, các giá trị logic phải được đưa ra trong YAML ở dạng chữ thường (`true`, `false`, `null`). Nếu dấu hai chấm là một phần giá trị của bạn (ví dụ: trong tiêu đề), hãy đặt giá trị trong dấu ngoặc kép. Xem các ví dụ trong các phần bên dưới.  


### Đoạn Code {.unnumbered}  

Một script R Markdown có thể chứa nhiều "đoạn" code - đây là những vùng của script mà bạn có thể viết code R nhiều dòng và chúng hoạt động giống như các scripts R nhỏ.  

Các đoạn code được tạo bằng ba dấu nháy đơn ngược và dấu ngoặc nhọn với chữ "r" viết thường bên trong. Đoạn code được đóng bằng ba dấu nháy đơn ngược. Bạn có thể tạo một đoạn code mới bằng cách tự gõ nó ra, bằng cách sử dụng phím tắt "Ctrl + Alt + i" (hoặc Cmd + Shift + r trong Mac) hoặc bằng cách nhấp vào biểu tượng 'insert a new code chunk' màu xanh lục ở đầu trình chỉnh sửa script của bạn. Nhiều ví dụ được đưa ra dưới đây.  


### Văn bản tường thuật {.unnumbered}  

Bên ngoài "đoạn" code R, bạn có thể viết văn bản tường thuật. Như được mô tả trong chương [Báo cáo với R Markdown], bạn có thể in nghiêng văn bản bằng cách bao quanh nó bằng một dấu hoa thị (*) hoặc in đậm bằng cách bao quanh nó bằng hai dấu hoa thị (**). Nhớ lại rằng dấu đầu dòng và lược đồ đánh số nhạy cảm với dòng mới, thụt đầu dòng và kết thúc một dòng có hai dấu cách.  

Bạn cũng có thể chèn code R nội dòng vào văn bản như được mô tả trong chương [Báo cáo với R Markdown], bằng cách bao quanh code bằng dấu nháy đơn ngược và bắt đầu lệnh bằng "r": `` ` 1+1` `` (xem ví dụ với ngày ở trên).  



### Đầu mục {.unnumbered}  

Các cấp đầu mục khác nhau được thiết lập với số lượng ký hiệu thăng khác nhau, như được mô tả trong chương [Báo cáo với R Markdown].  

Trong **flexdashboard**, đầu mục chính (#) tạo một "trang" của dashboard. Đầu mục cấp hai (##) tạo một cột hoặc một hàng tùy thuộc vào thông số `orientation:` của bạn (xem chi tiết bên dưới). Đầu mục cấp ba (###) tạo bảng điều khiển cho các đồ thị, biểu đồ, bảng, văn bản, v.v.

```md
# Đầu mục cấp một (trang)

## Đầu mục cấp hai (hàng hoặc cột)  

### Đầu mục cấp ba (bảng điều khiển cho đồ thị, biểu đồ, v.v.)
```





## Thuộc tính mục  

Như trong R markdown bình thường, bạn có thể chỉ định các thuộc tính để áp dụng cho các phần của dashboard của mình bằng cách bao gồm các tùy chọn `key=value` sau một đầu mục, trong dấu ngoặc nhọn `{ }`. Ví dụ: trong một báo cáo HTML R Markdown điển hình, bạn có thể sắp xếp các tiêu đề phụ thành các tab với `## Đầu mục của tôi {.tabset}`.  

Lưu ý rằng các thuộc tính này được viết sau một *đầu mục* trong một phần văn bản của script. Các tùy chọn này khác với các tùy chọn  **knitr** được chèn bên trong ở đầu các đoạn code R, chẳng hạn như `out.height = `.  

Các thuộc tính mục dành riêng cho **flexdashboard** bao gồm:  

* `{data-orientation=}` Đặt thành `rows` (hàng) hoặc `columns` (cột). Nếu dashboard của bạn có nhiều trang, hãy thêm thuộc tính này vào mỗi trang để biểu thị hướng (được giải thích thêm trong [layout section](#layout)).  
* `{data-width=}` và `{data-height=}` đặt kích thước tương đối của biểu đồ, cột, hàng được bố trí theo cùng một chiều (ngang hoặc dọc). Kích thước tuyệt đối được điều chỉnh để lấp đầy không gian tốt nhất trên bất kỳ thiết bị hiển thị nào nhờ công cụ [flexbox](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Using_CSS_flexible_boxes).  
     * Độ cao của biểu đồ cũng phụ thuộc vào việc bạn đặt tham số YAML `vertical_layout: fill` hay `vertical_layout: scroll`. Nếu được đặt thành cuộn, độ cao biểu đồ sẽ phản ánh tùy chọn `fig.height = ` truyền thống trong đoạn code R.  
     * Xem tài liệu về kích thước đầy đủ tại [flexdashboard website](https://rmarkdown.rstudio.com/flexdashboard/using.html#sizing)  
* `{.hidden}` Sử dụng tùy chọn này để loại trừ một trang cụ thể khỏi thanh điều hướng
* `{data-navbar =}` Sử dụng điều này trong đầu mục cấp trang để lồng nó vào menu thả xuống của thanh điều hướng. Cung cấp tên (trong dấu ngoặc kép) của menu thả xuống. Xem ví dụ bên dưới.  


## Bố cục {#layout}  

Điều chỉnh bố cục dashboard của bạn theo những cách sau:  

* Thêm trang, cột/hàng và biểu đồ với đầu mục R Markdown (ví dụ: #, ## hoặc ###)
* Điều chỉnh tham số YAML `orientation:` thành `rows` hoặc `columns`
* Chỉ định xem bố cục lấp đầy trình duyệt hay cho phép cuộn
* Thêm các tab vào một đầu mục phần cụ thể  


### Trang {.unnumbered}  

Các đầu mục cấp đầu tiên (#) trong R Markdown sẽ đại diện cho "các trang" của dashboard. Theo mặc định, các trang sẽ xuất hiện trong thanh điều hướng dọc theo đầu dashboard.  

```{r, out.height = c('100%'), out.width = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_script.png"))
```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_pages_top_view.png"))
```



Bạn có thể nhóm các trang thành một "menu" trong thanh điều hướng trên cùng bằng cách thêm thuộc tính `{data-navmenu=}` vào đầu mục trang. Hãy cẩn thận - không bao gồm dấu cách xung quanh dấu bằng nếu không nó sẽ không hoạt động!  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_script.png"))
```


Đây là những gì script tạo ra:  


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_navmenu_view.png"))
```

Bạn cũng có thể chuyển đổi một trang hoặc một cột thành "thanh bên" ở phía bên trái của dashboard bằng cách thêm thuộc tính `{.sidebar}`. Nó có thể giữ văn bản (có thể xem từ bất kỳ trang nào) hoặc nếu bạn đã tích hợp tính năng tương tác **shiny**, nó có thể hữu ích để giữ các điều khiển nhập của người dùng như thanh trượt hoặc menu thả xuống.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_sidebar_view.png"))
```




### Hướng {.unnumbered}  

Đặt thông số `orientation:` yaml để cho biết cách hiểu các đầu mục cấp hai R Markdown (##) của bạn - dưới dạng `orientation: columns` hoặc `orientation: rows`.  

Đầu mục cấp hai (##) sẽ được hiểu là các cột hoặc hàng mới dựa trên cài đặt `orientation` này.  

Nếu bạn đặt `orientation: columns`, đầu mục cấp hai sẽ tạo cột mới trong dashboard. Dashboard bên dưới có một trang, chứa hai cột, với tổng số ba bảng. Bạn có thể điều chỉnh độ rộng tương đối của các cột với `{data-width=}` như hình dưới đây.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_columns_view.png"))
```

Nếu bạn đặt `orientation: rows`, đầu mục cấp hai sẽ tạo hàng mới thay vì cột. Dưới đây là script tương tự như trên, nhưng `orientation: rows` để các đầu mục cấp hai tạo ra hàng thay vì cột. Bạn có thể điều chỉnh *chiều cao* tương đối của các hàng với `{data-height=}` như hình dưới đây.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_rows_view.png"))
```

Nếu dashboard của bạn có nhiều trang, bạn có thể chỉ định hướng cho từng trang cụ thể bằng cách thêm thuộc tính `{data-orientation=}` vào tiêu đề của mỗi trang (chỉ định `rows` hoặc `columns` mà không có dấu ngoặc kép).  

### Tabs {.unnumbered} 

Bạn có thể chia nội dung thành các tab bằng thuộc tính `{.tabset}`, như trong các đầu ra HTML R Markdown khác.  

Chỉ cần thêm thuộc tính này sau đầu mục mong muốn. Các đầu mục con dưới đầu mục đó sẽ được hiển thị dưới dạng tab. Ví dụ: trong script ví dụ bên dưới, cột 2 bên phải (##) được sửa đổi để đường cong dịch bệnh và ngăn bảng (###) được hiển thị trong các tab.  

Bạn có thể làm tương tự với các hàng nếu hướng của bạn là các hàng.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tabs_view.png"))
```


## Thêm nội dung  

Hãy bắt đầu xây dựng một dashboard. Dashboard đơn giản của chúng tôi sẽ có 1 trang, 2 cột và 4 ô điều khiển. Chúng tôi sẽ xây dựng từng ô điều khiển một để minh họa.  

Bạn có thể dễ dàng bao gồm các đầu ra R tiêu chuẩn như văn bản, ggplots và bảng (xem chương [Trình bày bảng]). Đơn giản chỉ cần code chúng trong một đoạn code R như bạn làm đối với bất kỳ script R Markdown nào khác.

Lưu ý: bạn có thể tải xuống script Rmd hoàn chỉnh và đầu ra dashboard HTML - xem chương [Tải sách và dữ liệu].  


### Chữ {.unnumbered}  

Bạn có thể nhập văn bản Markdown và bao gồm code *nội dòng* như đối với bất kỳ đầu ra R Markdown nào khác. Xem chương [Báo cáo với R Markdown] để biết chi tiết.  

Trong dashboard này, chúng tôi bao gồm một ô điều khiển văn bản tóm tắt bao gồm văn bản động cho thấy ngày nhập viện mới nhất và số trường hợp được báo cáo trong các ổ dịch.  

### Bảng {.unnumbered}  

Bạn có thể bao gồm các đoạn code R in kết quả đầu ra chẳng hạn như bảng. Nhưng kết quả đầu ra sẽ trông đẹp nhất và đáp ứng với kích thước cửa sổ nếu bạn sử dụng hàm `kable()` từ **knitr** để hiển thị các bảng của mình. Các hàm **flextable** có thể tạo ra các bảng được rút ngắn/cắt bỏ.  

Ví dụ: bên dưới chúng tôi cung cấp `linelist()` thông qua lệnh `count()` để tạo ra một bảng tóm tắt các trường hợp theo bệnh viện. Cuối cùng, bảng này được chuyển đến `knitr::kable()` và kết quả có một thanh cuộn ở bên phải. Bạn có thể đọc thêm về cách tùy chỉnh bảng của mình với `kable()` và **kableExtra** [tại đây](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html).  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_tables_view.png"))
```


Nếu bạn muốn hiển thị một bảng động cho phép người dùng lọc, sắp xếp và/hoặc nhấp qua "các trang" của dataframe, hãy sử dụng package **DT** và đó là hàm `datatable()`, như trong code bên dưới.  

Trong code ví dụ dưới đây, dataframe `linelist` được in. Bạn có thể đặt `rownames = FALSE` để tiết kiệm không gian theo chiều ngang và `filter = "top"` để có bộ lọc ở đầu mỗi cột. Danh sách các thông số kỹ thuật khác có thể được cung cấp cho `options = `. Dưới đây, chúng tôi đặt `pageLength =` để 5 hàng xuất hiện và `scrollX = ` để người dùng có thể sử dụng thanh cuộn ở dưới cùng để cuộn theo chiều ngang. Đối số `class = 'white-space: nowrap'` đảm bảo rằng mỗi hàng chỉ là một dòng (không phải nhiều dòng). Bạn có thể đọc về các đối số và giá trị có thể có khác [tại đây](https://rstudio.github.io/DT/?_ga=2.2810736.1321860763.1619286819-369061888.1601594705) hoặc bằng cách nhập `?datatable`    

```{r, eval=F}
DT::datatable(linelist, 
              rownames = FALSE, 
              options = list(pageLength = 5, scrollX = TRUE), 
              class = 'white-space: nowrap' )
```

### Đồ thị {.unnumbered}  

Bạn có thể in các đồ thị vào cửa sổ dashboard như bạn làm trong script R. Trong ví dụ của chúng tôi, chúng tôi sử dụng package **incidence2** để tạo một "epicurve" theo nhóm tuổi bằng hai lệnh đơn giản (xem trang [Đường cong dịch bệnh]). Tuy nhiên, bạn có thể sử dụng `ggplot()` và in một đồ thị theo cách tương tự.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_plots_view.png"))
```


### Đồ thị tương tác {.unnumbered}  

Bạn cũng có thể chuyển một ggplot tiêu chuẩn hoặc đối tượng đồ thị khác vào `ggplotly()` từ package **plotly** (xem chương [Đồ thị tương tác]). Điều này sẽ làm cho đồ thị của bạn có tính tương tác, cho phép người đọc "phóng to" và hiển thị khi di chuột qua giá trị của mọi điểm dữ liệu (trong trường hợp này là số trường hợp mỗi tuần và nhóm tuổi trong đường cong).  


```{r, eval=F}
age_outbreak <- incidence(linelist, date_onset, "week", groups = age_cat)
plot(age_outbreak, fill = age_cat, col_pal = muted, title = "") %>% 
  plotly::ggplotly()
```

Đây là những gì hiển thị trong dashboard (gif). Chức năng tương tác này sẽ vẫn hoạt động ngay cả khi bạn gửi email dashboard dưới dạng tệp tĩnh (không trực tuyến trên máy chủ).  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_ggplotly.gif"))
```

### Tiện ích HTML {.unnumbered}

[Tiện ích HTML cho R](http://www.htmlwidgets.org/) là một loại package R đặc biệt giúp tăng tính tương tác bằng cách sử dụng các thư viện JavaScript. Bạn có thể nhúng chúng vào đầu ra R Markdown (chẳng hạn như flexdashboard) và trong dashboard Shiny.  

Một số ví dụ phổ biến về các tiện ích này bao gồm:  

* Plotly (được sử dụng trong chương sổ tay này và trong chương [Đồ thị tương tác])
* visNetwork (được sử dụng trong chương [Chuỗi lây nhiễm] của sổ tay này)
* Leaflet (được sử dụng trong chương [GIS cơ bản] của sổ tay này)
* dygraph (hữu ích để hiển thị dữ liệu chuỗi thời gian một cách tương tác)
* DT (`datatable()`) (được sử dụng để hiển thị các bảng động với bộ lọc, sắp xếp, v.v.)  

Dưới đây, chúng tôi biểu diễn thêm một chuỗi lây nhiễm dịch sử dụng visNetwork vào dashboard. Script chỉ hiển thị code mới được thêm vào phần "Cột 2" của script R Markdown. Bạn có thể tìm thấy code trong chương [Chuỗi lây nhiễm] của sổ tay này.  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain_script.png"))
```

Đây là những gì script tạo ra:  

```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "flexdashboard_chain.gif"))
```



## Tổ chức Code 

Bạn có thể chọn có tất cả code trong script R Markdown **flexdashboard**. Ngoài ra, để có một script dashboard rõ ràng và ngắn gọn hơn, bạn có thể chọn gọi code/biểu đồ được lưu trữ hoặc tạo trong các scripts R bên ngoài. Điều này được mô tả chi tiết hơn trong chương [Báo cáo với R Markdown].


## Shiny  

Việc tích hợp package R **shiny** có thể giúp dashboards của bạn phản ứng mạnh hơn với thông tin nhập của người dùng. Ví dụ: bạn có thể yêu cầu người dùng chọn một khu vực pháp lý hoặc một phạm vi ngày và để các bảng phản ứng với lựa chọn của họ (ví dụ: lọc dữ liệu được hiển thị). Để nhúng phản ứng **shiny** vào **flexdashboard**, bạn chỉ cần thực hiện một số thay đổi đối với R Markdown script **flexdashboard** của mình.  

Bạn có thể sử dụng **shiny** để tạo ứng dụng/dashboards *mà không cần đến* flexdashboard (bảng điều khiển linh hoạt). Chương [Dashboards với Shiny] trong sổ tay cung cấp thông tin tổng quan về cách tiếp cận này, bao gồm phần bổ sung về cú pháp **shiny**, cấu trúc tệp ứng dụng và các tùy chọn chia sẻ/xuất bản (bao gồm cả tùy chọn máy chủ miễn phí). Cú pháp và các mẹo chung này cũng chuyển sang ngữ cảnh **flexdashboard**.  

Tuy nhiên, nhúng **shiny** vào **flexdashboard** là một thay đổi cơ bản đối với flexdashboard của bạn. Nó sẽ không còn tạo ra một đầu ra HTML mà bạn có thể gửi qua email và bất kỳ ai cũng có thể mở và xem. Thay vào đó, nó sẽ là một "ứng dụng". Nút "Knit" ở đầu script sẽ được thay thế bằng biểu tượng "Run document", biểu tượng này sẽ mở ra một phiên bản của dashboard tương tác cục bộ trên máy tính của bạn.

Chia sẻ dashboard của bạn bây giờ sẽ yêu cầu bạn:  

* Gửi script Rmd cho người xem, họ mở nó trên máy tính của họ và chạy ứng dụng, hoặc  
* Ứng dụng/dashboard được lưu trữ trên máy chủ mà người xem có thể truy cập  

Do đó, có những lợi ích khi tích hợp **shiny**, nhưng cũng có những rắc rối. Nếu ưu tiên chia sẻ dễ dàng qua email và bạn không cần các khả năng phản ứng  **shiny**, hãy xem xét khả năng tương tác giảm do `ggplotly()` cung cấp như đã trình bày ở trên.  

Dưới đây, chúng tôi đưa ra một ví dụ rất đơn giản bằng cách sử dụng cùng một "outbreak_dashboard.Rmd" như trên. Tài liệu mở rộng về tích hợp Shiny vào **flexdashboard** có sẵn trực tuyến [here](https://rmarkdown.rstudio.com/flexdashboard/shiny.html).  



### Cài đặt {.unnumbered}  

Kích hoạt **shiny** trong **flexdashboard** bằng cách thêm thông số YAML ``runtime: shiny` ở cùng mức thụt lề như `output: `, như bên dưới:  

```md
---
title: "Outbreak dashboard (Shiny demo)"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
runtime: shiny
---

```

Nó cũng thuận tiện để kích hoạt một "thanh bên" để giữ các công cụ shiny đầu vào sẽ thu thập thông tin từ người dùng. Như đã giải thích ở trên, hãy tạo một cột và chỉ ra tùy chọn `{.sidebar}` để tạo một thanh bên ở phía bên trái. Bạn có thể thêm các đoạn văn bản và R chứa các lệnh **shiny** `input` trong cột này.  

Nếu ứng dụng/dashboard của bạn được lưu trữ trên một máy chủ và có thể có nhiều người dùng đồng thời, hãy đặt tên cho đoạn code R đầu tiên là `global`. Bao gồm các lệnh để nhập/tải dữ liệu của bạn trong đoạn này. Đoạn code có tên đặc biệt này được xử lý theo cách khác và dữ liệu được nhập trong nó chỉ được nhập một lần (không liên tục) và có sẵn cho tất cả người dùng. Điều này cải thiện tốc độ khởi động của ứng dụng.  

### Ví dụ đã làm việc {.unnumbered}  

Ở đây chúng tôi điều chỉnh script flexdashboard "outbreak_dashboard.Rmd" để bao gồm **shiny**. Chúng tôi sẽ thêm khả năng để người dùng chọn bệnh viện từ menu thả xuống và để đường cong dịch bệnh chỉ phản ánh các trường hợp từ bệnh viện đó, với tiêu đề đồ thị động. Chúng tôi làm như sau:  

* Thêm `runtime: shiny` vào YAML  
* Đặt lại tên cho đoạn code thiết lập là `global`  
* Tạo một thanh bên chứa:  
  * Code để tạo vectơ tên bệnh viện duy nhất  
  * Lệnh `selectInput()` (menu thả xuống **shiny**) với sự lựa chọn tên bệnh viện. Lựa chọn được lưu dưới dạng `hospital_choice`, có thể được tham chiếu trong mã sau này dưới dạng `input$hospital_choice`  
* Code đường cong dịch bệnh (cột 2) được đặt trong `renderPlot({ })`, gồm:  
  * Bộ lọc trên tập dữ liệu giới hạn cột `hospital` thành giá trị hiện tại của `input$hospital_choice`  
  * Tiêu đề đồ thị động kết hợp `input$hospital_choice`  
  
Lưu ý rằng bất kỳ code nào tham chiếu đến giá trị `input$` phải nằm trong một hàm `render({})` (là hàm phản ứng).

Đây là phần trên cùng của script, bao gồm YAML, global chunk và sidebar:  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script1.png"))
```
  
Đây là Cột 2, với đồ thi epicurve phản ứng:  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_script2.png"))
```

Và đây là dashboard:  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "flexdashboard_shiny_view.gif"))
```




### Các ví dụ khác {.unnumbered}  

Để đọc một ví dụ liên quan đến sức khỏe về Shiny-**flexdashboard** bằng cách sử dụng tính năng tương tác **shiny** và tiện ích vẽ bản đồ **leaflet**, hãy xem chương này của sách trực tuyến [Geospatial Health Data: Modeling and Visualization with R-INLA and Shiny](https://www.paulamoraga.com/book-geospatial/sec-dashboardswithshiny.html).  




## Chia sẻ  

Dashboards không chứa các phần tử Shiny sẽ xuất ra tệp HTML (.html), tệp này có thể được gửi qua email (nếu kích thước cho phép). Điều này rất hữu ích, vì bạn có thể gửi báo cáo "dashboard" và không phải thiết lập máy chủ để lưu trữ báo cáo đó dưới dạng trang web.  

Nếu bạn đã nhúng **shiny**, bạn sẽ không thể gửi đầu ra qua email, nhưng bạn có thể gửi chính script cho người dùng R hoặc lưu trữ dashboard trên một máy chủ như đã giải thích ở trên.


## Tài nguyên học liệu  

Bạn có thể tìm thấy các hướng dẫn đầy đủ cho chương này bên dưới. Nếu bạn xem lại chúng, rất có thể trong vòng một giờ, bạn có thể có dashboard của riêng mình.  

https://bookdown.org/yihui/rmarkdown/dashboards.html

https://rmarkdown.rstudio.com/flexdashboard/

https://rmarkdown.rstudio.com/flexdashboard/using.html

https://rmarkdown.rstudio.com/flexdashboard/examples.html
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/flexdashboard.Rmd-->


# Dashboards với Shiny {#shiny-basics}  

Dashboards thường là một cách tuyệt vời để chia sẻ kết quả từ các phân tích với những người khác. Tạo ra một dashboard với **shiny** đòi hỏi kiến thức tương đối nâng cao về ngôn ngữ R, nhưng cũng cung cấp cho bạn khả năng tùy chỉnh đáng kinh ngạc.  

<!-- One of the largest drawbacks of `R` is its usability for people who are new to or have no experience with programming languages. While these skills are very valuable, most people will find that this represents a barrier to sharing analyses, especially in multidisciplinary environments. It requires some work to maintain an `R` installation, and not everyone will be comfortable running shared code, even if it's well documented and easy to read. This is *especially* true when users have to change parameters of code!  -->

<!-- R based dashboards are also advantageous in that they centralise how code is run - when the same code is run on different machines, often people will have to deal with differing file paths, different R versions, and different package installations. For this reason, dashboards are a great way to share code with others in a user friendly way! -->

Chúng tôi khuyến nghị rằng ai đó đang học dashboards với **shiny** phải có kiến thức tốt về biến đổi và trực quan hóa dữ liệu, đồng thời có thể tự tin gỡ lỗi code và viết hàm. Làm việc với dashboards không dễ khi bạn mới bắt đầu và đôi khi khó hiểu, nhưng là một kỹ năng tuyệt vời để học và trở nên dễ dàng hơn nhiều khi thực hành!  

Chương này sẽ cung cấp tổng quan ngắn gọn về cách tạo dashboards với **shiny** và các tiện ích mở rộng của nó.  
Để biết một phương pháp thay thế tạo dashboards nhanh hơn, dễ dàng hơn nhưng có thể ít tùy chỉnh hơn, hãy xem thêm về **flextable** trong chương ([Dashboards với R Markdown]).  



## Chuẩn bị  


### Gọi packages {.unnumbered}  

Trong cuốn sách này, chúng tôi nhấn mạnh việc sử dụng hàm `p_load()` từ package **pacman**, giúp cài đặt các package cần thiết *và* gọi chúng ra để sử dụng. Bạn cũng có thể gọi các packages đã cài đặt với hàm `library()` của **base** R. Xem thêm chương [R cơ bản] để có thêm thông tin về các packages trong R. 

Chúng ta bắt đầu bằng cách cài đặt package **shiny**:  

```{r, eval = FALSE}
pacman::p_load("shiny")
```


### Nhập dữ liệu {.unnumbered}  

Nếu bạn muốn theo dõi chương này, hãy xem phần này trong chương [Tải sách và dữ liệu](#data_shiny). Có các liên kết để tải xuống scripts R và các tệp dữ liệu tạo ra ứng dụng Shiny cuối cùng.  

Nếu bạn cố gắng xây dựng lại app bằng các tệp này, hãy lưu ý về cấu trúc thư mục dự án R được tạo trong quá trình thực hiện (ví dụ: thư mục cho "data" và "funcs").  



<!-- ======================================================= -->
## Cấu trúc của một ứng dụng shiny {  }

### Cấu trúc tệp cơ bản {.unnumbered}  

Để hiểu về `shiny`, trước tiên chúng ta cần hiểu cấu trúc tệp của một ứng dụng hoạt động như thế nào! Chúng ta nên tạo một thư mục hoàn toàn mới trước khi bắt đầu. Điều này thực sự có thể được thực hiện dễ dàng hơn bằng cách chọn _New project_ trong _Rstudio_ và chọn _Shiny Web Application_. Điều này sẽ giúp tạo ra cấu trúc cơ bản của một ứng dụng shiny cho bạn.  

Khi mở dự án này, bạn sẽ nhận thấy có một tệp `.R` có tên là _app.R_. *Điều cần thiết* là chúng ta có một trong hai cấu trúc tệp cơ bản:  

1. Một tệp có tên là _app.R_, *hoặc*  
2. Hai tệp, một tệp có tên là _ui.R_ và tệp còn lại là _server.R_    

Trong chương này, chúng tôi sẽ sử dụng cách tiếp cận đầu tiên là có một tệp có tên là *app.R*. Đây là một script ví dụ:  

```{r, eval = FALSE}
# an example of app.R

library(shiny)

ui <- fluidPage(

    # Application title
    titlePanel("My app"),

    # Sidebar with a slider input widget
    sidebarLayout(
        sidebarPanel(
            sliderInput("input_1")
        ),

        # Show a plot 
        mainPanel(
           plotOutput("my_plot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {
     
     plot_1 <- reactive({
          plot_func(param = input_1)
     })
     
    output$my_plot <- renderPlot({
       plot_1()
    })
}


# Run the application 
shinyApp(ui = ui, server = server)


```


Nếu bạn mở tệp này, bạn sẽ nhận thấy rằng hai đối tượng được xác định - một đối tượng được gọi là `ui` và đối tượng khác được gọi là `server`. Các đối tượng này *phải* được xác định trong *mọi* ứng dụng shiny và là trung tâm cấu trúc của chính ứng dụng đó! Trên thực tế, sự khác biệt duy nhất giữa hai cấu trúc tệp được mô tả ở trên là trong cấu trúc 1, cả `ui` và `server` đều được xác định trong một tệp, trong khi ở cấu trúc 2, chúng được định nghĩa trong các tệp riêng biệt. Lưu ý: chúng ta cũng có thể (và nên có nếu chúng ta có một ứng dụng lớn hơn) có các tệp .R khác trong cấu trúc để chúng ta có thể nhúng `source()` vào ứng dụng của mình.  


### Máy chủ và giao diện người dùng {.unnumbered}

Tiếp theo, chúng ta cần hiểu các đối tượng `server` và `ui` thực sự _làm gì_. *Nói một cách đơn giản, đây là hai đối tượng tương tác với nhau bất cứ khi nào người dùng tương tác với ứng dụng shiny.*  

Phần tử UI (giao diện người dùng) của một ứng dụng shiny, ở cấp độ cơ bản, là code R tạo ra giao diện HTML. Điều này có nghĩa là mọi thứ *được hiển thị* trong giao diện người dùng của một ứng dụng. Điều này thường bao gồm:  

* "Widgets (thành phần điều khiển)" - menu thả xuống, hộp kiểm, thanh trượt, v.v. mà người dùng có thể tương tác
* Đồ thị, bảng, v.v. - kết quả đầu ra được tạo bằng code R
* Các khía cạnh điều hướng của một ứng dụng - tab, cửa sổ, v.v.
* Văn bản chung, đường liên kết, v.v.
* Các phần tử HTML và CSS  

Điều quan trọng nhất cần hiểu về UI là nó *nhận đầu vào* từ người dùng và *hiển thị đầu ra* từ máy chủ. Không có code *hoạt động* chạy trong ui *tại bất kỳ thời điểm nào* - tất cả các thay đổi được nhìn thấy trong UI đều được chuyển qua máy chủ (nhiều hơn hoặc ít hơn). Vì vậy, chúng ta phải tạo các đồ thị, tải xuống, v.v. trong máy chủ  

Máy chủ của ứng dụng shiny là nơi tất cả code đang được chạy khi ứng dụng khởi động. Cách nó hoạt động hơi khó hiểu một chút. Chức năng máy chủ sẽ _phản hồi_ một cách hiệu quả đối theo những gì người dùng giao tiếp với UI và chạy các đoạn code phản hồi tương ứng. Nếu mọi thứ thay đổi trong máy chủ, những thứ này sẽ được chuyển trở lại ui, nơi có thể nhìn thấy những thay đổi. Quan trọng là code trong máy chủ sẽ được thực thi *không liên tiếp* (hoặc tốt nhất là bạn nên nghĩ theo cách này). Về cơ bản, bất cứ khi nào đầu vào ui ảnh hưởng đến một đoạn code trong máy chủ, nó sẽ tự động chạy và đầu ra đó sẽ được tạo ra và hiển thị.  


Tất cả điều này bây giờ có vẻ rất trừu tượng, vì vậy chúng ta sẽ phải đi sâu vào một số ví dụ để có một ý tưởng rõ ràng về cách nó thực sự hoạt động.  


### Trước khi bạn bắt đầu tạo một ứng dụng {.unnumbered}

Trước khi bạn bắt đầu xây dựng một ứng dụng, việc biết *những gì* bạn muốn tạo sẽ vô cùng hữu ích. Vì UI của bạn sẽ được viết bằng code, bạn không thể thực sự hình dung những gì bạn đang tạo trừ khi bạn đang nhắm đến một cái gì đó cụ thể. Vì lý do này, sẽ vô cùng hữu ích khi xem xét rất nhiều ví dụ về các ứng dụng shiny để biết được những gì bạn có thể tạo ra - thậm chí còn tốt hơn nếu bạn có thể xem code gốc đằng sau các ứng dụng này! Một số tài nguyên tuyệt vời cho việc này là:  

* [Thư viện ứng dụng của Rstudio](https://shiny.rstudio.com/gallery/)  

Khi bạn có ý tưởng về những gì có thể thực hiện, sẽ rất hữu ích nếu bạn phác thảo ra diện mạo sản phẩm - bạn có thể thực hiện việc này trên giấy hoặc trong bất kỳ phần mềm vẽ nào (PowerPoint, MS paint, v.v.). Sẽ hữu ích khi bắt đầu đơn giản cho ứng dụng đầu tiên của bạn! Cũng không có gì phải xấu hổ nếu bạn sử dụng code có sẵn trên mạng của một ứng dụng mẫu phục vụ cho công việc của bạn - việc này dễ dàng hơn nhiều so với việc xây dựng thứ gì đó từ đầu!  



## Tạo một UI 

Khi xây dựng ứng dụng, trước tiên, bạn nên làm việc trên UI để chúng ta có thể thấy những gì đang làm và không có nguy cơ ứng dụng bị lỗi do bất kỳ lỗi máy chủ nào. Như đã đề cập trước đây, bạn nên sử dụng một mẫu có sẵn khi tạo UI. Bạn có thể tìm thấy một số bố cục tiêu chuẩn có sẵn trong package shiny, ngoài ra là ở các package mở rộng khác, chằng hạn như `shinydashboard`. Chúng tôi sẽ sử dụng một ví dụ từ package shiny cơ sở để bắt đầu.  

Một shiny UI thường được định nghĩa là một loạt các hàm lồng nhau, theo thứ tự sau  

1. Một hàm xác định bố cục chung (cơ bản nhất là `fluidPage()`, nhưng có nhiều hàm khác)  
2. Các ô điều khiển trong bố cục như:
     - một thanh bên (`sidebarPanel()`)
     - một bảng điều khiển "chính" (`mainPanel()`)
     - một tab (`tabPanel()`)
     - một "cột" chung (`column()`)
3. Các widget và đầu ra - những thứ này có thể đưa đầu vào cho máy chủ (tiện ích) hoặc đưa ra từ máy chủ (đầu ra)  
     - Các widget thường được thiết kế kiểu như `xxxInput()`, ví dụ: `selectInput()`   
     - Kết quả đầu ra thường được thiết kế kiểu như `xxxOutput()`, ví dụ: `plotOutput()`  

Cần phải nói lại rằng những thứ này không thể được hình dung một cách dễ dàng theo cách trừu tượng, vì vậy tốt nhất hãy xem một ví dụ! Hãy xem xét tạo một ứng dụng cơ bản hiển thị dữ liệu số lượng cơ sở sốt rét theo quận. Dữ liệu này có rất nhiều tham số khác nhau, vì vậy sẽ thật tuyệt nếu cuối cùng người dùng có thể áp dụng một số bộ lọc để xem dữ liệu theo nhóm tuổi/quận khi họ thấy phù hợp! Chúng ta có thể sử dụng một bố cục shiny rất đơn giản để bắt đầu - bố cục thanh bên. Đây là một bố cục trong đó các widget được đặt trong một thanh bên ở bên trái và đồ thị được đặt ở bên phải.  

Hãy lập kế hoạch cho ứng dụng của chúng ta - chúng ta có thể bắt đầu với một bộ chọn cho phép chúng ta chọn quận nơi chúng ta muốn trực quan hóa dữ liệu và một bộ chọn khác để biểu diễn nhóm tuổi quan tâm. Chúng ta sẽ sử dụng các bộ lọc này để hiển thị một đường cong dịch bệnh phản ánh các tham số này. Vì vậy, chúng ta cần:  

1. Hai menu thả xuống cho phép chúng ta chọn quận chúng ta muốn và nhóm tuổi quan tâm.  
2. Một khu vực mà chúng ta có thể hiển thị đường cong dịch bệnh kết quả.  

Code minh họa có thể trông giống như sau:  

```{r, eval = FALSE}

library(shiny)

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```


Khi app.R được chạy với code UI ở trên (không có code đang hoạt động trong phần `server` của app.R), bố cục sẽ xuất hiện như thế này - lưu ý rằng sẽ không có đồ thị nếu không có máy chủ để hiển thị nó, nhưng đầu vào của chúng ta đang hoạt động!  

```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "simple_UI_view.png"))
```

Đây là cơ hội tốt để thảo luận về cách mà các widget hoạt động - lưu ý rằng mỗi widget đang chấp nhận một `inputId`, một `label` và một loạt các tùy chọn khác dành riêng cho loại widget. `InputId` này cực kỳ quan trọng - đây là những ID được sử dụng để truyền thông tin từ UI đến máy chủ. Vì lý do này, chúng *phải là duy nhất*. Bạn nên cố gắng đặt cho chúng một cái tên gì đó hợp lý và cụ thể theo chức năng của chúng trong các trường hợp thiết kế một ứng dụng lớn.  

Bạn nên đọc kỹ tài liệu để biết chi tiết đầy đủ về chức năng của mỗi widget này. Các widget sẽ chuyển các loại dữ liệu cụ thể đến máy chủ tùy thuộc vào loại widget và điều này cần được hiểu đầy đủ. Ví dụ: `selectInput()` sẽ chuyển dữ liệu dạng ký tự cho máy chủ:  

- Nếu chúng ta chọn _Spring_ cho widget đầu tiên ở đây, nó sẽ chuyển đối tượng ký tự `"Spring"` đến máy chủ.  
- Nếu chúng ta chọn hai mục từ menu thả xuống, chúng sẽ đi qua dưới dạng vectơ ký tự (ví dụ: `c("Spring", "Bolo")`).  

Các widget khác sẽ chuyển các loại đối tượng khác nhau đến máy chủ! Ví dụ:  

- `numericInput()` sẽ chuyển một đối tượng dạng số đến máy chủ  
- `checkboxInput()` sẽ chuyển một đối tượng kiểu logic đến máy chủ (`TRUE` hoặc `FALSE`)

Cũng cần lưu ý *vectơ được đặt tên* mà chúng ta đã sử dụng cho dữ liệu độ tuổi ở đây. Đối với nhiều widget, việc sử dụng vectơ được đặt tên làm các lựa chọn sẽ hiển thị *tên* của vectơ dưới dạng các lựa chọn hiển thị, nhưng chuyển *giá trị* thực của lựa chọn từ vectơ đến máy chủ. Ví dụng chúng ta chọn "15+" từ menu thả xuống và UI sẽ chuyển `"malaria_rdt_15"` đến máy chủ - đây chính là tên của cột mà chúng ta quan tâm!  


Có rất nhiều widget mà bạn có thể sử dụng để làm nhiều việc với ứng dụng của mình. Các widget cũng cho phép bạn tải tệp lên ứng dụng của mình và tải xuống kết quả đầu ra. Ngoài ra còn có một số gói shiny mở rộng tuyệt vời cho phép bạn truy cập vào nhiều widget hơn so với shiny cơ bản - package **shinyWidgets** là một ví dụ tuyệt vời về điều này. Để xem một số ví dụ, bạn có thể xem các liên kết sau:  

- [base shiny widget gallery](https://shiny.rstudio.com/gallery/widget-gallery.html)
- [shinyWidgets gallery](https://github.com/dreamRs/shinyWidgets)



## Tải dữ liệu vào ứng dụng  

Bước tiếp theo trong quá trình phát triển ứng dụng là thiết lập và chạy máy chủ. Tuy nhiên, để làm điều này, chúng ta cần đưa một số dữ liệu vào ứng dụng của mình và tìm ra tất cả các phép tính mà chúng ta sẽ thực hiện. Một ứng dụng shiny không dễ để gỡ lỗi, vì thường không rõ lỗi đến từ đâu, do đó, lý tưởng nhất là hãy chắc chắn tất cả code dùng để trực quan và xử lý dữ liệu của chúng ta hoạt động tốt trước khi chúng ta bắt đầu tự tạo máy chủ.  

Bây giờ chúng ta muốn tạo một ứng dụng hiển thị các đường cong dịch bệnh thay đổi dựa trên đầu vào của người dùng, chúng ta nên nghĩ về code chúng ta sẽ cần để chạy chúng trong một R script bình thường. Chúng ta sẽ cần:  

1. Gọi các packages 
2. Tải dữ liệu 
3. Chuyển đổi dữ liệu 
4. Phát triển một _hàm_ để trực quan hóa dữ liệu của chúng ta dựa trên đầu vào của người dùng  

Danh sách này khá đơn giản và không quá khó để thực hiện. Bây giờ, điều quan trọng là phải nghĩ về những phần nào của quy trình này *chỉ được thực hiện một lần* và những phần nào cần *chạy dựa theo các đầu vào của người dùng*. Điều này là do các ứng dụng shiny thường chạy một số code trước khi chạy, code này chỉ được thực hiện một lần. Nó sẽ giúp cải thiện hiệu suất ứng dụng của chúng ta nếu có thể chuyển nhiều code đến phần này. Đối với ví dụ này, chúng ta chỉ cần tải dữ liệu/packages của mình và thực hiện các phép biến đổi cơ bản một lần, vì vậy chúng ta có thể đặt code đó *bên ngoài máy chủ*. Điều này có nghĩa là thứ duy nhất chúng ta cần trong máy chủ là code để trực quan hóa dữ liệu của chúng ta. Trước tiên, hãy phát triển tất cả các thành phần này trong một script. Tuy nhiên, vì chúng ta đang trực quan hóa dữ liệu của mình bằng một hàm, chúng ta cũng có thể đặt code _cho hàm_ bên ngoài máy chủ để hàm của chúng ta ở trong môi trường khi ứng dụng chạy!  

Đầu tiên, hãy tải dữ liệu của chúng ta. Vì chúng ta đang làm việc với một dự án mới và chúng ta cần làm sạch số liệu, chúng ta có thể tạo một thư mục mới có tên là data và thêm bộ dữ liệu sốt rét vào đó. Chúng ta có thể chạy code bên dưới trong một script thử nghiệm mà cuối cùng chúng ta sẽ xóa khi chúng ta dọn cấu trúc ứng dụng của mình.  

```{r, echo = TRUE}
pacman::p_load("tidyverse", "lubridate")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

print(malaria_data)


```


Sẽ dễ dàng hơn để làm việc với dữ liệu này nếu chúng ta sử dụng các tiêu chuẩn dữ liệu tidy, vì vậy chúng ta cũng nên chuyển đổi dữ liệu sang định dạng dài hơn, trong đó nhóm tuổi là một cột và các trường hợp là một cột khác. Chúng ta có thể thực hiện việc này một cách dễ dàng bằng cách sử dụng những gì chúng ta đã học được trong chương [Xoay trục dữ liệu].  


```{r, echo = TRUE}

malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")

print(malaria_data)

```

Và cùng với đó, chúng ta đã chuẩn bị xong dữ liệu của mình! Chúng ta đã hoàn thành các mục 1, 2 và 3 trong danh sách những thứ cần phát triển cho một "script R thử nghiệm". Nhiệm vụ cuối cùng và khó khăn nhất sẽ là xây dựng một hàm để tạo ra một đường cong dịch bệnh dựa trên các thông số do người dùng xác định. Như đã đề cập trước đây, chúng tôi *rất khuyến khích* bất kỳ ai học shiny trước tiên hãy xem phần về lập trình hướng chức năng ([Viết hàm]) để hiểu cách thức hoạt động của nó!    

Khi định nghĩa một hàm, có thể khó khăn khi nghĩ về những tham số chúng ta muốn đưa vào. Đối với lập trình hướng chức năng với shiny, mọi tham số liên quan thường sẽ có một widget liên kết với nó, vì vậy việc suy nghĩ về điều này thường khá dễ dàng! Ví dụ: trong ứng dụng hiện tại, chúng ta muốn có thể lọc theo quận và có một widget cho việc này, vì vậy chúng ta có thể thêm thông số quận để phản ánh điều này. Chúng ta (hiện tại) *không* có bất kỳ chức năng ứng dụng nào để lọc theo cơ sở, vì vậy chúng ta không cần thêm thông số này làm tham số. Hãy bắt đầu bằng cách tạo một hàm với ba tham số:  

1. Bộ dữ liệu cốt lõi  
2. Quận được lựa chọn  
3. Nhóm tuổi được lựa chọn  

```{r}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}

```


Chúng ta sẽ không đi sâu vào chi tiết về hàm này, vì nó tương đối đơn giản về cách hoạt động. Tuy nhiên, một điều cần lưu ý là chúng ta xử lý lỗi bằng cách trả về `NULL` khi nó sẽ xuất hiện lỗi. Lý do là khi một máy chủ shiny tạo ra một đối tượng `NULL` thay vì một đối tượng đồ thị, sẽ không có gì được hiển thị trong ui! Điều này rất quan trọng, vì nếu không, các lỗi thường sẽ khiến ứng dụng của bạn ngừng hoạt động.  

Một điều khác cần lưu ý là việc sử dụng toán tử `%in%` khi đánh giá đầu vào `district`. Như đã đề cập ở trên, toán tử này có thể đến dưới dạng một vectơ ký tự có nhiều giá trị, vì vậy việc sử dụng `%in%` sẽ linh hoạt hơn so với nói,`==`.  

Hãy kiểm tra hàm này!  

```{r, echo = TRUE, warning = FALSE}

plot_epicurve(malaria_data, district = "Bolo", agegroup = "malaria_rdt_0-4")

```

Với một hàm hoạt động được, bây giờ chúng ta phải hiểu cách mà tất cả những thứ này sẽ được fit vào một ứng dụng shiny như thế nào. Chúng ta đã đề cập đến khái niệm _code khởi động (startup code)_ trước đây, nhưng hãy xem cách chúng ta thực sự có thể kết hợp nó vào cấu trúc ứng dụng của chúng ta. Có hai cách chúng ta có thể làm điều này!  

1. Đặt code này vào tệp _app.R_ của bạn ở phần đầu script (phía trên UI) hoặc
2. Tạo một tệp mới trong thư mục của ứng dụng có tên _global.R_ và đặt code khởi động vào tệp này.  

Có một lưu ý ở điểm này đó là nó sẽ thường dễ dàng hơn, đặc biệt là với các ứng dụng lớn, khi bạn sử dụng cấu trúc tệp thứ hai, vì nó cho phép bạn tách cấu trúc tệp của mình theo cách đơn giản. Hãy phát triển đầy đủ script global.R này ngay bây giờ. Đây là những gì nó có thể hiển thị:  


```{r, eval = F}
# global.R script

pacman::p_load("tidyverse", "lubridate", "shiny")

# read data
malaria_data <- rio::import(here::here("data", "malaria_facility_count_data.rds")) %>% 
  as_tibble()

# clean data and pivot longer
malaria_data <- malaria_data %>%
  select(-newid) %>%
  pivot_longer(cols = starts_with("malaria_"), names_to = "age_group", values_to = "cases_reported")


# define plotting function
plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot") {
  
  # create plot title
  if (!("All" %in% district)) {            
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  # filter to age group
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}"),
      subtitle = agegroup_title
    )
  
  
  
}



```


Thật đơn giản! Một tính năng tuyệt vời của shiny là nó sẽ hiểu các tệp có tên _app.R_, _server.R_, _ui.R_ và _global.R_ dùng để làm gì, vì vậy không cần phải kết nối chúng với nhau thông qua bất kỳ code nào. Vì vậy, chỉ cần có code này trong _global.R_ trong thư mục, nó sẽ chạy trước khi chúng ta khởi động ứng dụng của mình!  

Chúng ta cũng nên lưu ý rằng có thể cải thiện tổ chức ứng dụng nếu chúng ta chuyển hàm vẽ biểu đồ sang tệp riêng của nó - điều này sẽ đặc biệt hữu ích khi các ứng dụng trở nên lớn hơn. Để làm điều này, chúng ta có thể tạo một thư mục khác có tên _funcs_ và đặt hàm này dưới một tệp có tên _plot_epicurve.R_. Sau đó, chúng ta có thể đọc hàm này thông qua lệnh sau trong _global.R_  

```{r, eval = F}

source(here("funcs", "plot_epicurve.R"), local = TRUE)

```

Lưu ý rằng bạn nên *luôn* chỉ định `local = TRUE` trong các ứng dụng shiny, vì nó sẽ ảnh hưởng đến việc tìm nguồn khi/nếu ứng dụng được xuất bản trên máy chủ.  

## Phát triển một máy chủ ứng dụng  

Bây giờ chúng ta đã có hầu hết code cần thiết, chúng ta chỉ cần phát triển thêm máy chủ. Đây là phần cuối cùng của ứng dụng và có lẽ là phần khó hiểu nhất. Máy chủ là một hàm R lớn, nhưng sẽ hữu ích nếu coi nó như một chuỗi các hàm hoặc nhiệm vụ nhỏ hơn mà ứng dụng có thể thực hiện. Điều quan trọng là phải hiểu rằng các hàm này không được thực thi theo thứ tự tuyến tính. Nghĩa là có một thứ tự cho chúng, nhưng không cần phải hiểu đầy đủ khi bắt đầu với shiny. Ở cấp độ rất cơ bản, các tác vụ hoặc chức năng này sẽ kích hoạt khi có thay đổi về đầu vào của người dùng ảnh hưởng đến chúng, *trừ khi nhà phát triển đã thiết lập chúng để chúng hoạt động khác biệt*. Một lần nữa, nó khá trừu tượng, nhưng trước tiên hãy xem qua ba loại cơ bản của _đối tượng_ shiny  

1. Nguồn phản hồi (Reactive sources) - đây là một thuật ngữ khác của đầu vào người dùng. Máy chủ shiny có quyền truy cập vào các đầu ra từ UI thông qua các widget mà chúng ta đã lập trình. Mỗi khi các giá trị được thay đổi, chúng được chuyển đến máy chủ.  

2. Vật dẫn phản hồi (Reactive conductors) - đây là những đối tượng tồn tại *chỉ* bên trong máy chủ shiny. Chúng ta không thực sự cần những thứ này cho các ứng dụng đơn giản, nhưng chúng tạo ra các đối tượng chỉ có thể được nhìn thấy bên trong máy chủ và được sử dụng trong các hoạt động khác. Chúng thường phụ thuộc vào các nguồn phản ứng.  

3. Điểm cuối (Endpoints) - đây là các đầu ra được chuyển từ máy chủ đến UI. Trong ví dụ của chúng ta, đây sẽ là đường cong dịch bệnh mà chúng ta đang tạo.    

Với các khái niệm này, chúng ta hãy xây dựng máy chủ theo từng bước. Chúng tôi hiển thị lại code UI một lần nữa ở đây để bạn tham khảo:  

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve")
    )
    
  )
)


```

Từ UI code này, chúng ta có:  

- Hai đầu vào:  
  - Bộ chọn quận (với inputId là `select_district`)  
  - Bộ chọn nhóm tuổi (với inputId là `select_agegroup`)  
- Một đầu ra:
  - Đường cong dịch bệnh (với outputId là `malaria_epicurve`)  

Như đã nói ở trên, những tên riêng mà chúng ta đã gán cho các đầu vào và đầu ra là rất quan trọng. Chúng *phải là duy nhất* và được sử dụng để chuyển thông tin giữa ui và máy chủ. Trong máy chủ, chúng ta truy cập tới các đầu vào thông qua cú pháp `input$inputID` và các đầu ra, và chuyển đến ui thông qua cú pháp `output$output_name` Hãy cùng xem xét một ví dụ, bởi vì điều này rất khó hiểu!

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
}


```


Máy chủ cho một ứng dụng đơn giản như thế này thực sự khá dễ dàng! Bạn sẽ nhận thấy rằng máy chủ là một hàm có ba tham số - `input`, `output` và `session` - điều này không quan trọng để hiểu ngay bây giờ, nhưng điều quan trọng là phải tuân theo thiết lập này! Trong máy chủ bên trên, chúng ta chỉ có một nhiệm vụ - đó là kết xuất một biểu đồ dựa trên hàm mà chúng ta đã thực hiện trước đó và các đầu vào từ máy chủ. Lưu ý cách tên của các đối tượng đầu vào và đầu ra tương ứng chính xác với các đối tượng trong ui.  

Để hiểu những điều cơ bản về cách máy chủ phản hồi với thông tin đầu vào của người dùng, bạn cần lưu ý rằng đầu ra sẽ biết (thông qua package nhầm) khi đầu vào thay đổi và chạy lại hàm này để tạo biểu đồ mỗi khi chúng thay đổi. Lưu ý rằng chúng tôi cũng sử dụng hàm `renderPlot()` ở đây - đây là một trong số họ các hàm dành riêng cho lớp truyền các đối tượng đó đến đầu ra ui. Có một số hàm hoạt động tương tự, nhưng bạn cần đảm bảo hàm được sử dụng khớp với lớp đối tượng mà bạn đang chuyển tới ui! Ví dụ:  

- `renderText()` - gửi văn bản tới ui  
- `renderDataTable` - gửi bảng tương tác tới ui.  

Hãy nhớ rằng chúng cũng cần phải khớp với *hàm* đầu ra được sử dụng trong ui - vì vậy `renderPlot()` được ghép cặp với `plotOutput()` và `renderText()` được kết hợp với `textOutput()`.    

Cuối cùng chúng ta đã tạo ra một ứng dụng hoạt động! Chúng ta có thể chạy ứng dùng bằng cách nhấn nút Run App ở trên cùng bên phải của cửa sổ script trong Rstudio. Bạn nên lưu ý rằng bạn có thể chọn chạy ứng dụng của mình trong trình duyệt mặc định (thay vì Rstudio), điều này sẽ phản ánh chính xác hơn giao diện của ứng dụng đối với những người dùng khác.  


```{r, out.width = c('100%'), out.height = c('100%'), echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_simple_view.gif"))
```


Lưu ý vui rằng trong R console, ứng dụng đang "lắng nghe"! Hãy nói về sự phản hồi!

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "listening.png"))
```


<!-- TO DO: *ADD SOMETHING ON DOWNLOADING A ZIP FILE OF THE APP?*  -->



## Thêm nhiều chức năng hơn  

Tại thời điểm này, cuối cùng chúng ta đã có một ứng dụng đang chạy, nhưng chúng ta có rất ít chức năng. Chúng ta cũng không thực sự khai thác hết những gì shiny có thể làm, vì vậy có nhiều thứ để tìm hiểu thêm! Hãy tiếp tục xây dựng ứng dụng hiện có của chúng ta bằng cách thêm một số tính năng bổ sung. Một số thứ hay bạn có thể thêm vào là:  

1. Một văn bản giải thích
2. Nút tải đồ thị xuống - Cung cấp cho người dùng phiên bản chất lượng cao của hình ảnh mà họ đang tạo trong ứng dụng
3. Một bộ chọn cho các cơ sở cụ thể
4. Một trang dashboard khác - Có thể hiển thị một bảng cho dữ liệu của chúng ta.  

Có rất nhiều thứ để thêm, nhưng chúng ta có thể sử dụng nó để tìm hiểu về một loạt các tính năng shiny khác nhau sau này. Có rất nhiều thứ để tìm hiểu về Shiny (nó có thể trở nên *rất* nâng cao, nhưng hy vọng nó là trường hợp một khi người dùng có ý tưởng tốt hơn về cách sử dụng nó, họ có thể trở nên thoải mái hơn khi sử dụng các nguồn học tập bên ngoài).  


### Thêm văn bản tĩnh {.unnumbered}  

Trước tiên hãy thảo luận về việc thêm văn bản tĩnh vào ứng dụng shiny. Thêm văn bản vào ứng dụng của chúng ta cực kỳ dễ dàng khi bạn có kiến thức cơ bản về nó. Vì văn bản tĩnh không thay đổi trong ứng dụng shiny (nếu bạn muốn thay đổi, bạn có thể sử dụng hàm *kết xuất văn bản (text rendering)* trong máy chủ!), Tất cả văn bản tĩnh của Shiny thường được thêm vào UI của ứng dụng. Chúng tôi sẽ không đi vào chi tiết cho điều này, nhưng bạn có thể thêm nhiều yếu tố khác nhau vào giao diện UI (và thậm chí cả tùy chỉnh) bằng cách giao tiếp R với *HTML* và *css*.  

HTML và css là các ngôn ngữ có liên quan mật thiết trong thiết kế giao diện người dùng. Chúng ta không cần phải hiểu quá rõ những thứ này, nhưng *HTML* tạo các đối tượng trong UI (như hộp văn bản hoặc bảng) và *css* thường được sử dụng để thay đổi kiểu và tính thẩm mỹ của các đối tượng đó. Shiny có quyền truy cập vào một mảng lớn của _các thẻ HTML_ - các thẻ này trình bày các đối tượng hoạt động theo một cách cụ thể, chẳng hạn như các tiêu đề, đoạn văn bản, ngắt dòng, bảng, v.v. Chúng ta có thể sử dụng một số ví dụ này như sau:    

- `h1()` - đây là một thẻ *đầu mục*, sẽ tự động tạo văn bản lớn hơn và thay đổi mặc định khi chúng liên quan đến mặt phông chữ, màu v.v (tùy thuộc vào theme tổng thể ứng dụng của bạn). Bạn có thể truy cập tiêu đề phụ _nhỏ hơn và nhỏ hơn_ với `h2()` xuống tới cả `h6()`. Cách sử dụng sẽ trông như sau:  
  * `h1("my header - section 1")`

- `p()` - đây là thẻ *đoạn*, sẽ khiến văn bản được chọn tương tự như văn bản trong một thân văn bản. Văn bản này sẽ tự động bao quanh, và có kích thước tương đối nhỏ (footers có thể còn nhỏ hơn). Hãy nghĩ về nó như phần thân văn bản của tài liệu Word. Cách sử dụng trông như sau  

  * `p("This is a larger body of text where I am explaining the function of my app")`
  
- `tags$b()` và `tags$i()` - chúng được sử dụng để tạo in đậm `tags$b()` và in nghiêng `tags$i()` với bất kỳ văn bản nào được chọn!  

- `tags$ul()`, `tags$ol()` và `tags$li()` - đây là các thẻ được sử dụng trong việc tạo *danh sách*. Tất cả đều được sử dụng trong cú pháp bên dưới và cho phép người dùng tạo một danh sách theo thứ tự (`tags$ol()`; nghĩa là được đánh số) hoặc danh sách không có thứ tự (`tags$ul()`, nghĩa là tạo gạch đầu dòng). `tags$li()` được sử dụng để biểu thị các mục trong danh sách, bất kể loại danh sách nào được sử dụng. ví dụ:  

```{r, eval = F}

tags$ol(
  
  tags$li("Item 1"),
  
  tags$li("Item 2"),
  
  tags$li("Item 3")
  
)

```

- `br()` và `hr()` - các thẻ này tương ứng tạo *ngắt dòng* và *dòng ngang* (với một ngắt dòng). Sử dụng chúng để tách riêng các phần của ứng dụng và văn bản của bạn! Không cần phải chuyền bất kỳ đối tượng nào vào các thẻ này (dấu ngoặc đơn có thể vẫn trống).  


- `div()` - Đây là thẻ *chung* có thể *chứa bất cứ thứ gì* và có thể *có bất cứ tên gì*. Khi bạn tiến bộ với thiết kế UI, bạn có thể sử dụng chúng để phân các UI ra từng loại, cung cấp các style cho từng phần cụ thể và tạo các tương tác giữa các phần tử máy chủ và UI. Chúng tôi sẽ không đi sâu vào những chi tiết này, nhưng quan trọng để biết qua về chúng!  

Lưu ý rằng mỗi đối tượng này có thể được truy cập thông qua các thẻ `tags$...` hoặc chỉ qua hàm với một số khác. Chúng có hiệu quả như nhau, nhưng nó có thể giúp sử dụng kiểu `tags$...` nếu bạn thích rõ ràng hơn và không vô tình ghi đè các hàm. Điều này cũng không có nghĩa là có sẵn một danh sách thẻ đầy đủ. Có một danh sách khá đầy đủ tất cả các thẻ có sẵn trong shiny [ở đây](https://shiny.rstudio.com/articles/tag-glossary.html) và thậm chí nhiều thẻ có thể được sử dụng hơn nếu bạn biết cách chèn HTML trực tiếp vào UI của bạn!  


Nếu bạn cảm thấy tự tin, bạn cũng có thể thêm bất kỳ *phần tử tạo kiểu css* nào vào các thẻ HTML của mình với đối số `style` trong bất kỳ phần tử nào. Chúng ta sẽ không đi vào chi tiết cách thức hoạt động, nhưng một mẹo để thử nghiệm các thay đổi thẩm mỹ đối với UI đang sử dụng chế độ HTML inspector trong Chrome (bên trong ứng dụng shiny của bạn khi bạn đang chạy trong trình duyệt) và tự chỉnh sửa style của các đối tượng!  

Hãy thêm một số văn bản vào ứng dụng của chúng ta  

```{r, eval = F}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         h4("Options"),
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = TRUE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
    tags$ul(
      tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
      tags$li(tags$b("data_date"), " - the date the data were collected at"),
      tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
      tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
      tags$li(tags$b("District"), " - the district the data were collected at"),
      tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
      tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
    )
    
  )
)
)



```

```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "app_text_view.png"))
```


### Thêm liên kết {.unnumbered}

Để thêm một liên kết đến một trang web, hãy sử dụng `tags$a()` với liên kết và  văn bản hiển thị như bên dưới. Để có một đoạn độc lập, hãy đặt nó trong `p()`. Để chỉ có một vài từ của một câu được gắn liên kết, hãy chia câu thành các phần và sử dụng `tags$a()` cho thành phần gắn hyperlink. Để đảm bảo liên kết được mở trong một cửa sổ trình duyệt *mới*, hãy thêm `target = "_blank"` dưới dạng một đối số.  

```{r, eval=F}
tags$a(href = "www.epiRhandbook.com", "Visit our website!")
```



### Thêm nút tải về {.unnumbered}

Hãy cùng chuyển sang tính năng thứ hai. Nút tải xuống là một điều khá phổ biến để thêm vào một ứng dụng và khá dễ thực hiện. Chúng ta cần thêm một Widget khác vào giao diện người dùng và thêm một đầu ra khác tới máy chủ của chúng ta để đính kèm vào Widget đó. Chúng tôi cũng có thể giới thiệu về *vật dẫn phản hồi* trong ví dụ này!   


Hãy cập nhật giao diện người dùng của chúng ta trước - Điều này dễ dàng khi Shiny đi kèm với một widget có tên là `downloadButton()` - cho phép đặt inputId và nhãn.  

```{r, eval = FALSE}

ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = c(
                   "All",
                   "Spring",
                   "Bolo",
                   "Dingo",
                   "Barnard"
              ),
              selected = "All",
              multiple = FALSE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # horizontal line
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```
 
Lưu ý rằng chúng ta cũng đã thêm vào thẻ `hr()` - Điều này thêm một đường ngang ngăn cách các widget điều khiển với các widget tải xuống của chúng ta. Đây là một trong những thẻ HTML khác mà chúng ta đã thảo luận trước đây.  

Bây giờ khi giao diện người dùng của chúng ta đã sẵn sàng, chúng ta cần thêm thành phần máy chủ. Việc thiết kế tải xuống đã được hoàn thành trong máy chủ với hàm `downloadHandler()`. Tương tự như đồ thị, chúng ta cần đính kèm nó vào một đầu ra có cùng inputId như là nút tải xuống. Hàm này có hai đối số - `filename` và `content` - cả hai đều là các hàm. Như bạn có thể đoán, `fileName` được sử dụng để chỉ định tên của tệp đã tải xuống và `content` được sử dụng để chỉ định những gì nên tải xuống. `content` chứa một hàm mà bạn sẽ sử dụng để lưu dữ liệu cục bộ - vì vậy nếu bạn đang tải xuống tệp CSV, bạn có thể sử dụng hàm `rio::export()`. Bởi vì chúng ta đang tải xuống một đồ thị, chúng ta sẽ sử dụng hàm `ggplot2::ggsave()`. Hãy xem cách chúng ta sẽ lập trình nó như sau (chúng ta sẽ không thêm nó vào máy chủ).  

```{r, eval = FALSE}

server <- function(input, output, session) {
  
  output$malaria_epicurve <- renderPlot(
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  )
  
  output$download_epicurve <- downloadHandler(
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```


Lưu ý rằng hàm `content` luôn có đối số `file`, đối số giúp chúng ta chỉ định tên tệp đầu ra. Bạn cũng có thể nhận thấy rằng chúng ta đang lặp lại code tại đây - chúng ta đang sử dụng hàm `plot_epicurve()` hai lần trong máy chủ, một lần để tải xuống và một lần cho hình ảnh được hiển thị trong ứng dụng. Trong khi điều này sẽ không ảnh hưởng lớn đến hiệu suất, nghĩa là code để tạo ra đồ thị này sẽ phải chạy khi người dùng thay đổi các widget xác định nhóm quận và tuổi, *và* một lần nữa khi bạn muốn tải xuống đồ thị. Trong các ứng dụng lớn hơn, các quyết định làm giảm hiệu quả tối ưu như thế này sẽ càng ngày càng làm chậm mọi thứ, vì vậy sẽ tốt khi bạn học cách làm cho ứng dụng của chúng ta hiệu quả hơn theo nghĩa này. Sẽ hợp lý hơn nếu chúng ta có cách chạy code epicurve khi các nhóm quận/tuổi thay đổi, *và để chúng được sử dụng bởi* các hàm renderPlot() và downloadHandler(). Đây là khi mà các vật dẫn phản hồi có tác dụng!  

Vật dẫn phản hồi là các đối tượng được tạo trong máy chủ shiny theo cơ chế *tương tác*, nhưng không xuất hiện - chúng chỉ có thể được sử dụng bởi các phần khác của máy chủ. Có một số loại *vật dẫn phản hồi* khác nhau, nhưng chúng ta sẽ đi qua hai loại cơ bản.  

1.`reactive()` - đây là vật dẫn phản hồi cơ bản nhất - nó sẽ phản hồi bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong bởi nó thay đổi (các widget nhóm/nhóm tuổi)  
2. `eventReactive()` - vật dẫn phản hồi này hoạt động giống với `reactive()`, ngoại trừ người dùng có thể quy định các đầu vào nào khiến nó tiến hành chạy lại. Cách này rất hữu ích nếu vật dẫn phản hồi của bạn mất nhiều thời gian để xử lý, nhưng chúng tôi sẽ giải thích rõ hơn ở phần sau  

Hãy xem hai ví dụ:  

```{r, eval = FALSE}

malaria_plot_r <- reactive({
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})


# only runs when the district selector changes!
malaria_plot_er <- eventReactive(input$select_district, {
  
  plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  
})



```

Khi chúng ta sử dụng thiết lập `eventReactive()`, chúng ta có thể chỉ định các đầu vào nào chạy đoạn code này - điều này không hữu ích với chúng ta vào lúc này, nên chúng ta có thể bỏ qua nó. Lưu ý rằng bạn có thể bao gồm nhiều đầu vào với `c()`  

Hãy xem cách chúng ta có thể tích hợp vào code máy chủ:  


```{r, eval = FALSE}

server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup)
  })
  
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
}


```

Bạn có thể thấy chúng ta chỉ cần gọi đầu ra của phản hồi mà chúng ta đã xác định trong cả hai hàm tải xuống và tạo biểu đồ. Một điều cần lưu ý là bạn phải sử dụng các đầu ra của các phản hồi như thể chúng là các hàm - vì vậy bạn *phải thêm dấu đơn ngoặc trống ở cuối chúng* (tức là `malaria_plot()` là chính xác, còn `malaria_plot` thì không). Bây giờ khi chúng ta đã thêm giải pháp này, ứng dụng của chúng ta trở nên gọn gẽ hơn, nhanh hơn và dễ thay đổi hơn vì tất cả các code chạy hàm epicurve đều ở một nơi.  


```{r, echo=F}
knitr::include_graphics(here::here("images", "shiny", "download_button_view.png"))
```


### Thêm bộ chọn cơ sở y tế {.unnumbered}  

Hãy chuyển sang tính năng tiếp theo của chúng ta - một bộ chọn cho các cơ sở cụ thể. Chúng ta sẽ thêm một tham số khác vào hàm của mình để có thể biến nó thành đối số từ code của chúng ta. Trước tiên, hãy xem việc thực hiện điều này - nó chỉ hoạt động theo các nguyên tắc tương tự như các tham số khác mà chúng ta đã thiết lập. Hãy cập nhật và kiểm tra hàm của chúng ta.  


```{r, echo = TRUE}

plot_epicurve <- function(data, district = "All", agegroup = "malaria_tot", facility = "All") {
  
  if (!("All" %in% district)) {
    data <- data %>%
      filter(District %in% district)
    
    plot_title_district <- stringr::str_glue("{paste0(district, collapse = ', ')} districts")
    
  } else {
    
    plot_title_district <- "all districts"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  data <- data %>%
    filter(age_group == agegroup)
  
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }
  
  if (agegroup == "malaria_tot") {
      agegroup_title <- "All ages"
  } else {
    agegroup_title <- stringr::str_glue("{str_remove(agegroup, 'malaria_rdt')} years")
  }
  
    if (!("All" %in% facility)) {
    data <- data %>%
      filter(location_name == facility)
    
    plot_title_facility <- facility
    
  } else {
    
    plot_title_facility <- "all facilities"
    
  }
  
  # if no remaining data, return NULL
  if (nrow(data) == 0) {
    
    return(NULL)
  }

  
  
  ggplot(data, aes(x = data_date, y = cases_reported)) +
    geom_col(width = 1, fill = "darkred") +
    theme_minimal() +
    labs(
      x = "date",
      y = "number of cases",
      title = stringr::str_glue("Malaria cases - {plot_title_district}; {plot_title_facility}"),
      subtitle = agegroup_title
    )
  
  
  
}
```

Hãy kiểm tra nó:  

```{r, warning=F, message=F}

plot_epicurve(malaria_data, district = "Spring", agegroup = "malaria_rdt_0-4", facility = "Facility 1")

```


Với tất cả các cơ sở trong dữ liệu của chúng ta, sẽ khó để biết cơ sở nào tương ứng với các quận nào - và người dùng cuối cũng sẽ không biết. Điều này có thể làm cho việc sử dụng ứng dụng trở nên không trực quan. Vì lý do này, chúng ta nên làm cho các tùy chọn cơ sở trong UI thay đổi động khi người dùng thay đổi khu vực - để cái này lọc cái kia! Vì chúng ta có rất nhiều biến đang sử dụng trong các tùy chọn, chúng ta cũng có thể muốn tạo một số tùy chọn cho ui trong tệp _global.R_ _từ số liệu_. Ví dụ: chúng ta có thể thêm đoạn code này vào _global.R_ sau khi đọc dữ liệu của mình:  



```{r, , message =  FALSE}

all_districts <- c("All", unique(malaria_data$District))

# data frame of location names by district
facility_list <- malaria_data %>%
  group_by(location_name, District) %>%
  summarise() %>% 
  ungroup()

```

Hãy xem chúng:  

```{r}
all_districts
```


```{r}
facility_list
```


Chúng ta có thể chuyển các biến mới này tới giao diện người dùng mà không gặp bất kỳ vấn đề gì, vì chúng được hiển thị trên toàn bộ cả server và ui! Hãy cập nhật UI của chúng ta:  


```{r, eval = FALSE}


ui <- fluidPage(

  titlePanel("Malaria facility visualisation app"),

  sidebarLayout(

    sidebarPanel(
         # selector for district
         selectInput(
              inputId = "select_district",
              label = "Select district",
              choices = all_districts,
              selected = "All",
              multiple = FALSE
         ),
         # selector for age group
         selectInput(
              inputId = "select_agegroup",
              label = "Select age group",
              choices = c(
                   "All ages" = "malaria_tot",
                   "0-4 yrs" = "malaria_rdt_0-4",
                   "5-14 yrs" = "malaria_rdt_5-14",
                   "15+ yrs" = "malaria_rdt_15"
              ), 
              selected = "All",
              multiple = FALSE
         ),
         # selector for facility
         selectInput(
           inputId = "select_facility",
           label = "Select Facility",
           choices = c("All", facility_list$location_name),
           selected = "All"
         ),
         
         # horizontal line
         hr(),
         downloadButton(
           outputId = "download_epicurve",
           label = "Download plot"
         )

    ),

    mainPanel(
      # epicurve goes here
      plotOutput("malaria_epicurve"),
      br(),
      hr(),
      p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
      tags$ul(
        tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
        tags$li(tags$b("data_date"), " - the date the data were collected at"),
        tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
        tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
        tags$li(tags$b("District"), " - the district the data were collected at"),
        tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
        tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
      )
      
    )
    
  )
)


```


Lưu ý cách chúng ta hiện đang chuyển các biến cho các lựa chọn thay vì mã hóa cứng chúng trong ui! Điều này cũng có thể làm cho code của chúng ta nhỏ gọn hơn! Cuối cùng, chúng ta sẽ phải cập nhật máy chủ. Sẽ dễ dàng cập nhật hàm của chúng ta để kết hợp với đầu vào mới (chúng ta chỉ cần chuyển nó làm đối số cho tham số mới), nhưng nên nhớ rằng chúng ta cũng muốn ui cập nhật khi người dùng thay đổi khu vực đã chọn. Điều quan trọng cần hiểu ở đây là chúng ta *có thể thay đổi các tham số và đặc tính của widget* trong khi ứng dụng đang chạy, nhưng điều này cần được thực hiện *trên máy chủ*. Chúng ta cần tìm hiểu một cách mới để xuất ra máy chủ.  

Các hàm chúng ta cần hiểu cách thực hiện điều này được gọi là các hàm *observer (trình quan sát)* và tương tự như các hàm *reactive (phản ứng)* về cách chúng hoạt động. Tuy nhiên, chúng có một điểm khác biệt chính:  

- Các hàm phản ứng không ảnh hưởng trực tiếp đến kết quả đầu ra và tạo ra các đối tượng có thể được nhìn thấy ở các vị trí khác trong máy chủ  
- Các hàm quan sát *có thể* ảnh hưởng đến kết quả đầu ra của máy chủ, nhưng làm như vậy thông qua các hiệu ứng bên ngoài của các hàm khác. (Chúng cũng có thể làm những việc khác, nhưng đây là chức năng chính của chúng trong thực tế)  

Tương tự như các hàm phản ứng, có hai loại của các hàm quan sát và chúng được phân chia theo cùng một logic phân chia các hàm phản ứng:  

1. `observe()` - hàm này chạy bất cứ khi nào bất kỳ đầu vào nào được sử dụng bên trong nó thay đổi  
2. `observeEvent()` - hàm này chạy khi đầu vào *do người dùng chỉ định* thay đổi  

Chúng ta cũng cần hiểu các hàm được shiny cung cấp giúp cập nhật các widget. Chúng khá đơn giản để chạy - trước tiên chúng lấy đối tượng `session` từ hàm máy chủ (tại thời điểm này bạn chưa cần phải hiểu), và sau đó thay đổi `inputId` của hàm. Sau đó, chúng ta chuyển các phiên bản mới của tất cả các tham số đã được lấy bởi `selectInput()` - những tham số này sẽ được cập nhật tự động trong widget.  

Hãy xem một ví dụ riêng lẻ về cách chúng ta có thể sử dụng điều này trong máy chủ của mình. Khi người dùng thay đổi quận, chúng ta muốn lọc các cơ sở theo quận và cập nhật các lựa chọn để *chỉ hiển thị những cơ sở có sẵn trong quận đó* (và một tùy chọn cho tất cả các cơ sở)  

```{r, eval = FALSE}

observe({
  
  if (input$select_district == "All") {
    new_choices <- facility_list$location_name
  } else {
    new_choices <- facility_list %>%
      filter(District == input$select_district) %>%
      pull(location_name)
  }
  
  new_choices <- c("All", new_choices)
  
  updateSelectInput(session, inputId = "select_facility",
                    choices = new_choices)
  
})


```

Vậy đó! Chúng ta có thể thêm nó vào máy chủ và đặc tính đó bây giờ sẽ hoạt động. Đây là giao diện máy chủ mới của chúng ta:  

```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  
  
}

```


```{r, out.width=c('100%', '100%'), echo=F, fig.show='hold', fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_menu_view.gif"))
```







### Thêm một bảng vào một tab khác {.unnumbered}

Bây giờ chúng ta sẽ chuyển sang thành phần cuối cùng mà chúng ta muốn thêm vào ứng dụng của mình. Chúng ta sẽ muốn tách giao diện thành hai tab, trong đó 1 tab sẽ hiện thị một bảng tương tác nơi người dùng có thể xem dữ liệu mà họ đang tạo đường cong dịch bệnh. Để làm điều này, chúng ta có thể sử dụng các phần tử giao diện được đóng gói sẵn đi kèm với các tab shiny có liên quan. Ở cấp độ cơ bản, chúng ta có thể bao gồm hầu hết cửa sổ chính trong cấu trúc chung này:  

```{r, eval = FALSE}


# ... the rest of ui

mainPanel(
  
  tabsetPanel(
    type = "tabs",
    tabPanel(
      "Epidemic Curves",
      ...
    ),
    tabPanel(
      "Data",
      ...
    )
  )
)


```

Bây giờ hãy áp dụng nó vào giao diện. Chúng ta sẽ sử dụng package **DT** ở đây - đây là một package tuyệt vời để tạo bảng tương tác từ dữ liệu có sẵn. Chúng ta có thể thấy nó được sử dụng cho `DT::datatableOutput()` trong ví dụ này.  

```{r, echo = FALSE}
library(DT)
```

```{r, eval = FALSE}
ui <- fluidPage(
     
     titlePanel("Malaria facility visualisation app"),
     
     sidebarLayout(
          
          sidebarPanel(
               # selector for district
               selectInput(
                    inputId = "select_district",
                    label = "Select district",
                    choices = all_districts,
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for age group
               selectInput(
                    inputId = "select_agegroup",
                    label = "Select age group",
                    choices = c(
                         "All ages" = "malaria_tot",
                         "0-4 yrs" = "malaria_rdt_0-4",
                         "5-14 yrs" = "malaria_rdt_5-14",
                         "15+ yrs" = "malaria_rdt_15"
                    ), 
                    selected = "All",
                    multiple = FALSE
               ),
               # selector for facility
               selectInput(
                    inputId = "select_facility",
                    label = "Select Facility",
                    choices = c("All", facility_list$location_name),
                    selected = "All"
               ),
               
               # horizontal line
               hr(),
               downloadButton(
                    outputId = "download_epicurve",
                    label = "Download plot"
               )
               
          ),
          
          mainPanel(
               tabsetPanel(
                    type = "tabs",
                    tabPanel(
                         "Epidemic Curves",
                         plotOutput("malaria_epicurve")
                    ),
                    tabPanel(
                         "Data",
                         DT::dataTableOutput("raw_data")
                    )
               ),
               br(),
               hr(),
               p("Welcome to the malaria facility visualisation app! To use this app, manipulate the widgets on the side to change the epidemic curve according to your preferences! To download a high quality image of the plot you've created, you can also download it with the download button. To see the raw data, use the raw data tab for an interactive form of the table. The data dictionary is as follows:"),
               tags$ul(
                    tags$li(tags$b("location_name"), " - the facility that the data were collected at"),
                    tags$li(tags$b("data_date"), " - the date the data were collected at"),
                    tags$li(tags$b("submitted_daate"), " - the date the data were submitted at"),
                    tags$li(tags$b("Province"), " - the province the data were collected at (all 'North' for this dataset)"),
                    tags$li(tags$b("District"), " - the district the data were collected at"),
                    tags$li(tags$b("age_group"), " - the age group the data were collected for (0-5, 5-14, 15+, and all ages)"),
                    tags$li(tags$b("cases_reported"), " - the number of cases reported for the facility/age group on the given date")
               )
               
               
          )
     )
)


```


Bây giờ ứng dụng của chúng ta được sắp xếp thành các tab! Hãy thực hiện các chỉnh sửa cần thiết đối với máy chủ. Vì chúng ta không cần phải thao tác với dữ liệu trước khi kết xuất nên điều này thực sự rất đơn giản - chúng ta chỉ cần kết xuất bộ dữ liệu malaria_data qua DT::renderDT() tới ui!  


```{r, eval = FALSE}
server <- function(input, output, session) {
  
  malaria_plot <- reactive({
    plot_epicurve(malaria_data, district = input$select_district, agegroup = input$select_agegroup, facility = input$select_facility)
  })
  
  
  
  observe({
    
    if (input$select_district == "All") {
      new_choices <- facility_list$location_name
    } else {
      new_choices <- facility_list %>%
        filter(District == input$select_district) %>%
        pull(location_name)
    }
    
    new_choices <- c("All", new_choices)
    
    updateSelectInput(session, inputId = "select_facility",
                      choices = new_choices)
    
  })
  
  
  output$malaria_epicurve <- renderPlot(
    malaria_plot()
  )
  
  output$download_epicurve <- downloadHandler(
    
    filename = function() {
      stringr::str_glue("malaria_epicurve_{input$select_district}.png")
    },
    
    content = function(file) {
      ggsave(file, 
             malaria_plot(),
             width = 8, height = 5, dpi = 300)
    }
    
  )
  
  # render data table to ui
  output$raw_data <- DT::renderDT(
    malaria_data
  )
  
  
}


```


```{r, out.width=c('100%', '100%'), fig.show='hold', echo = F, fig.width = 12, fig.height = 9, message=F, warning=F}
knitr::include_graphics(here::here("images", "shiny", "app_table_view.gif"))
```


## Chia sẻ các ứng dụng shiny

Sau khi bạn đã phát triển ứng dụng của riêng mình, bạn có thể muốn chia sẻ nó với những người khác - đây là lợi thế lớn nhất của shiny! Chúng ta có thể làm điều này bằng cách chia sẻ trực tiếp code hoặc chúng ta có thể xuất bản nó trên một máy chủ. Nếu chúng ta chia sẻ code, những người khác sẽ có thể thấy những gì bạn đã làm và xây dựng trên nó, nhưng điều này sẽ làm mất đi một trong những lợi thế chính của shiny - *loại bỏ nhu cầu của người dùng cuối việc phải duy trì cài đặt R* . Vì lý do này, nếu bạn đang chia sẻ ứng dụng của mình với những người dùng không cảm thấy thoải mái với R, thì việc chia sẻ ứng dụng đã được xuất bản trên máy chủ sẽ dễ dàng hơn nhiều.  

Nếu muốn chia sẻ code, bạn có thể tạo tệp .zip của ứng dụng hoặc tốt hơn, *xuất bản ứng dụng của bạn trên github và thêm cộng tác viên.* Bạn có thể tham khảo thêm cách thực hiện trên github tại đây.  

Tuy nhiên, nếu chúng ta xuất bản ứng dụng trực tuyến, chúng ta cần phải làm thêm một số bước nữa. Mục đích cuối cùng là bạn muốn ứng dụng của bạn có thể được truy cập qua URL web để những người khác có thể truy cập nhanh chóng và dễ dàng. Thật không may, để xuất bản ứng dụng của bạn trên một máy chủ, bạn cần có quyền truy cập vào một máy chủ để xuất bản nó! Có một số tùy chọn lưu trữ khi nói đến điều này:  

- _shinyapps.io_: đây là nơi dễ dàng nhất để xuất bản các ứng dụng shiny, vì bạn không cần thực hiện nhiều các tinh chỉnh cấu hình cần thiết và có một số giấy phép miễn phí nhưng có giới hạn.  

- _RStudio Connect_: đây là phiên bản mạnh hơn nhiều của máy chủ R, có thể thực hiện nhiều hoạt động, bao gồm cả xuất bản các ứng dụng shiny. Tuy nhiên, nó khó sử dụng hơn và ít được khuyến khích cho người dùng lần đầu. 

Đối với mục đích của tài liệu này, chúng tôi sẽ sử dụng _shinyapps.io_, vì nó dễ dàng hơn cho người dùng mới. Bạn có thể tạo một tài khoản miễn phí tại đây để bắt đầu - cũng có các gói giá khác nhau cho giấy phép máy chủ nếu cần. Nếu bạn mong đợi có nhiều người sử dụng ứng dụng của bạn, gói giá sẽ đắt hơn, vì vậy hãy cân nhắc kỹ điều này. Nếu bạn đang muốn tạo thứ gì đó cho một nhóm nhỏ cá nhân sử dụng, một giấy phép miễn phí có thể hoàn toàn phù hợp, nhưng một ứng dụng công khai có thể cần nhiều giấy phép hơn.  

Trước hết nên đảm bảo rằng ứng dụng của chúng ta phù hợp để xuất bản trên máy chủ. Bên trong ứng dụng, bạn nên khởi động lại phiên R và đảm bảo rằng nó chạy tốt mà không cần chạy thêm bất kỳ code nào. Điều này rất quan trọng vì một ứng dụng yêu cầu tải package hoặc đọc dữ liệu không được xác định sẽ không chạy được trên máy chủ. Bạn cũng cần lưu ý rằng bạn không thể sử dụng các đường dẫn tệp *đặc trưng* trong ứng dụng của mình - những đường dẫn này sẽ không hợp lệ trong cài đặt máy chủ - sử dụng package `here` sẽ giải quyết vấn đề này một cách triệt để. Cuối cùng, nếu bạn đang đọc dữ liệu từ một nguồn yêu cầu xác thực người dùng, chẳng hạn như máy chủ của tổ chức của bạn, thông thường nó sẽ không hoạt động trên máy chủ. Bạn sẽ cần phải làm việc với bộ phận IT (Công nghệ Thông tin) của mình để tìm ra cách đưa máy chủ shiny vào whitelist tại đây.  

*đăng ký tài khoản*

Sau khi có tài khoản của mình, bạn có thể điều hướng đến trang mã đăng nhập (tokens) trong _Accounts_. Tại đây, bạn sẽ thêm mã đăng nhập mới - mã này sẽ được sử dụng để triển khai ứng dụng của bạn.  

Từ đây, bạn nên lưu ý rằng url của tài khoản sẽ hiển thị tên ứng dụng của bạn - vì vậy nếu ứng dụng của bạn có tên là _my_app_, url sẽ được thêm vào là _xxx.io/my_app/_. Hãy chọn tên ứng dụng của bạn một cách khôn ngoan! Khi bạn đã sẵn sàng, hãy nhấp vào triển khai (deploy) - nếu thành công, điều này sẽ chạy ứng dụng của bạn trên url web bạn đã chọn!  

*something on making apps in documents?*

## Đọc thêm

Cho tới đây, chúng tôi đã đề cập rất nhiều khía cạnh của shiny, và hầu như không đi sâu vào những gì được cung cấp bởi shiny. Hướng dẫn này có chức năng như một phần giới thiệu, còn rất nhiều thứ nữa bạn phải học để hiểu đầy đủ về shiny. Bạn nên bắt đầu bằng cách tạo một ứng dụng cơ bản và dần dần thêm các chức năng cho nó.  


## Các packages mở rộng được đề xuất  

Những đề xuất dưới đây đại diện cho một số shiny extension chất lượng cao. Chúng tôi không sắp xếp chúng theo thứ tự đặc biệt nào cả:  

- **shinyWidgets** - package này cung cấp cho bạn rất nhiều widget có thể được sử dụng trong ứng dụng của bạn. Chạy `shinyWidgets::shinyWidgetsGallery()` để xem một số lựa chọn các tiện ích có sẵn với package này. Xem các ví dụ [ở đây](https://github.com/dreamrs/shinywidgets)  

- **shinyjs** - Đây là một package tuyệt vời mang đến cho người dùng khả năng mở rộng tiện ích của Shiny thông qua JavaScript. Các ứng dụng của package này từ rất đơn giản đến cực kỳ chuyên sâu, nhưng trước hết bạn sẽ muốn sử dụng nó để thao tác với giao diện người dùng theo những cách đơn giản, như ẩn/hiển thị các yếu tố hoặc bật/tắt các nút. Tìm hiểu thêm [ở đây](https://deanattali.com/shinyjs/basic)  

- **shinydashboard** - package này mở rộng UI có sẵn có thể được sử dụng trong shiny, đặc biệt để người dùng tạo dashboard phức tạp với nhiều bố cục phức tạp. Xem thêm [ở đây](https://rstudio.github.io/shinydashboard/)  

- **shinydashboardPlus** - Nhận nhiều tính năng hơn nữa so với **shinydashboard**! Xem thêm [ở đây](https://rinterface.github.io/shinydashboardplus/articles/shinydashboardplus.html)  

- **shinythemes** - Thay đổi chủ đề css mặc định cho ứng dụng shiny của bạn với một loạt các mẫu có sẵn! Xem thêm [ở đây](https://rstudio.github.io/shinytheme/)  


Ngoài ra còn có một số packages có thể được sử dụng để tạo các đầu ra tương tác tương thích với shiny.  

- **DT** được bán liên kết hóa vào bản shiny cơ sở, cung cấp một tập hợp các hàm tuyệt vời để tạo các bảng tương tác.  

- **plotly** là một package để tạo các đồ thị tương tác mà người dùng có thể thao tác trong ứng dụng. Bạn cũng có thể chuyển đổi đồ thị của mình sang các phiên bản tương tác thông qua `plotly::ggplotly()`! Các lựa chọn thay thế như **dygraphs** và **highcharter** cũng rất tuyệt vời.  


## Tài nguyên đề xuất  



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/shiny_basics.Rmd-->

# (PART) Tổng hợp {.unnumbered}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/cat_misc.Rmd-->

# Viết hàm {#writing-functions} 


<!-- ======================================================= -->
## Chuẩn bị {  }


### Gọi packages {-}

Đoạn code này hiển thị việc tải các gói lệnh cần thiết cho phân tích. Trong cuốn sổ tay này, chúng tôi nhấn mạnh đến hàm `p_load()` trong package **pacman**, giúp cài đặt package nếu cần thiết *và* gọi chúng ra để sử dụng. Các package đã cài đặt cũng có thể được gọi ra bằng hàm `library()` từ **base** R. Xem chương [R cơ bản] để biết thêm thong tin về các packages trong R.  

```{r, echo=F, warning=F, message=F}
pacman::p_load(
  rio,          # File import
  here,         # File locator
  skimr,        # get overview of data
  tidyverse,    # data management + ggplot2 graphics, 
  gtsummary,    # summary statistics and tests
  janitor,      # adding totals and percents to tables
  scales,       # easily convert proportions to percents  
  flextable,     # converting tables to HTML
  purrr,          #makes functional programming easier
  readr,          #to read csv files
  highcharter     #to create highchart object and draw particular plot

  )
```

### Nhập dữ liệu {-}

Chúng tôi nhập bộ số liệu của các ca bệnh được mô phỏng từ một vụ dịch Ebola. Nếu muốn tải số liệu để làm theo từng bước, xem hướng dẫn trong chương [Tải sách và dữ liệu]. Bộ số liệu được nhập vào bằng hàm `import()` từ package **rio**. Xem chương [Nhập xuất số liệu] để biết các cách nhập dữ liệu khác.

Chúng tôi cũng sẽ sử dụng một vài số liệu về bệnh cúm do H7N9 xảy ra năm 2013 ở phần cuối của chương này.

```{r, echo=F}
# import the linelists into R
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

flu_china <- rio::import(here::here("data", "case_linelists", "fluH7N9_China_2013.csv"))

```


## Hàm  

Các hàm rất hữu ích trong lập trình vì chúng cho phép tạo ra các code dễ hiểu hơn, ngắn hơn và ít bị lỗi hơn (vì không có lỗi trong chính hàm này).

Nếu bạn đã xem đến chương này, có nghĩa là bạn đã đi qua vô số các hàm bởi vì trong R, mỗi toán tử là một lần gọi hàm
`+, for, if, [, $, { …`. Ví dụ, `x + y` là tương đương với`'+'(x, y)`

R là một ngôn ngữ cung cấp nhiều khả năng nhất để thực hiện các hàm và cung cấp đầy đủ các công cụ để người dùng dễ dàng viết chúng. Chúng ta không nên nghĩ các hàm là cố định ở đầu hay ở cuối chuỗi lập trình, R cung cấp các khả năng sử dụng chúng như thể chúng là các véc tơ và thậm chí sử dụng chúng bên trong các hàm, danh sách...

Có rất nhiều nguồn nâng cao về lập trình hướng chức năng và chúng tôi sẽ chỉ cung cấp cho bạn một cái nhìn bao quát để giúp bạn bắt đầu với lập trình hướng chức năng với các ví dụ thực tế, ngắn gọn. Sau đó, bạn có thể truy cập thêm các tài liệu tham khảo ở phía dưới.





## Tại sao chúng ta sử dụng hàm? 

Trước khi trả lời câu hỏi này, điều quan trọng cần lưu ý là chúng ta đã biết các mẹo để viết các hàm đầu tiên trong R trong chương [Lặp, vòng lặp và danh sách] trong cuốn sổ tay này. Nói tóm lại, việc sử dụng “if/else” và vòng lặp thường là một phần cốt lõi trong nhiều hàm vì chúng dễ dàng giúp mở rộng tính ứng dụng code của chúng ta, cho phép nhiều điều kiện hoặc lặp lại code cho các tác vụ lặp lại.

- Tôi có đang lặp lại nhiều lần cùng một đoạn code để áp dụng nó cho một biến hoặc số liệu khác không?

- Loại bỏ nó có rút ngắn đáng kể số dòng code tổng thể và giúp việc thực hiện nhanh hơn không?

- Đoạn code có thể sử dụng lại với giá trị khác ở nhiều vị trí trong code không?

Nếu một trong những trả lời cho các câu hỏi bên trên là “CÓ”, bạn có thể sẽ cần phải viết hàm

## Cách viết hàm trong R

Các hàm trong R có ba thành phần chính:

- phần hình thức `formals()` là danh sách các đối số mà kiểm soát cách chúng ta có thể gọi hàm

- phần thân `body()` là đoạn code bên trong hàm, vd: bên trong hoặc theo sau các dấu ngoặc, tùy thuộc vào cách chúng ta viết nó

và,

- phần môi trường thực hiện `environment()` để giúp chúng ta xác định vị trí các biến trong hàm và xác định cách các hàm tìm giá trị.
 
Một khi đã tạo hàm, chúng ta cần kiểm tra mỗi thành phần này bằng cách gọi các hàm liên kết.
 

## Cấu trúc và cú pháp cơ bản

- Một hàm cần được đặt tên cẩn thận theo đúng công việc của nó để có thể hiểu được khi chúng ta đọc tên hàm. A Thực tế, điều này đã được sử dụng trong phần lớn các kiến trúc của base R. Các hàm như  `mean()`, `print()`, `summary()` có những cái tên đúng như nhiệm vụ của nó 

- Một hàm cần các đối số như là số liệu để thực hiện và các đối tượng khác mà có thể là các giá trị tĩnh trong một danh sách các tùy chọn khác  

- Và cuối cùng, một hàm sẽ cho kết quả đầu ra dựa trên nhiệm vụ cốt lõi của nó và các đối số đã được đưa ra. Thông thường, chúng ta sẽ sử dụng các hàm có sẵn như `print()`, `return()`... để tạo ra kết quả đầu ra. Kết quả đầu ra có thể là giá trị logic, một số, một ký tự, một data frame...mà gọi ngắn gọn là đối tượng của R.

Về cơ bản, đây là thành phần của một hàm:

```{r, eval=FALSE}

function_name <- function(argument_1, argument_2, argument_3){
  
           function_task
  
           return(output)
}


```

Chúng ta tạo hàm đầu tiên với tên gọi là `contain_covid19()`. 

```{r}

contain_covid19 <- function(barrier_gest, wear_mask, get_vaccine){
  
                            if(barrier_gest == "yes" & wear_mask == "yes" & get_vaccine == "yes" ) 
       
                            return("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


```

Sau đó, chúng ta kiểm tra các thành phần của hàm vừa mới được tạo ra.

```{r}

formals(contain_covid19)
body(contain_covid19)
environment(contain_covid19)

```


Bây giờ, chúng ta sẽ kiểm tra hàm này. Để gọi hàm đã biết, chúng ta sử dụng nó như sử dụng tất cả các hàm trong R, tức là bằng cách viết tên hàm và thêm các đối số cần phải có.

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "yes")

```

Chúng ta có thể viết lại tên của mỗi đối số cho cẩn thận. Nhưng kể cả khi không cụ thể chúng, code cũng sẽ thực hiện vì R đã nhớ vị trí của mỗi đối số. Vì thế, miễn là chúng ta đặt các giá trị của các đối số theo đúng thứ tự, chúng ta có thể bỏ qua việc viết tên các đối số khi gọi hàm.

```{r}

contain_covid19("yes", "yes", "yes")

```

Sau đó, hãy xem điều gì sẽ xảy ra nếu một trong các giá trị là `"no"` hoặc **not** `"yes"`.

```{r}

contain_covid19(barrier_gest = "yes", wear_mask = "yes", get_vaccine = "no")
```

Nếu chúng ta cung cấp các đối số không nhận diện được, chúng ta sẽ gặp lỗi: 

```{r, eval=F}
contain_covid19(barrier_gest = "sometimes", wear_mask = "yes", get_vaccine = "no")
```

`Error in contain_covid19(barrier_gest = "sometimes", wear_mask = "yes",  :  could not find function "contain_covid19"`


<span style="color: black;">**_LƯU Ý:_** Một số hàm (hầu hết là rất ngắn và không phức tạp) có thể không cần tên và có thể sử dụng trực tiếp trên một dòng code hoặc bên trong một hàm khác để thực hiện tác vụ nhanh chóng. Các hàm này được gọi là **hàm ẩn danh** .</span>

Ví dụ bên dưới là một hàm ẩn danh đầu tiên mà chỉ giữ các biến ký tự trong bộ số liệu.

```{r, eval=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #equivalent to R base "head" function and that return first n observation of the  dataset
  select(function(x) is.character(x)) 
```
  
```{r, echo=F}
linelist %>% 
  dplyr::slice_head(n=10) %>%  #equivalent to R base "head" function and that return first n observation of the  dataset
  select(function(x) is.character(x)) %>%  
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )
```


Sau đó, một hàm khác chọn mỗi quan sát thứ hai của bộ số liệu (có thể thích hợp khi chúng ta có số liệu dọc với nhiều bản ghi cho một bệnh nhân, ví dụ như ngày đặt lịch khám hoặc lần khám). Trong trường hợp này, việc viết hàm thích hợp bên ngoài gói lệnh dplyr sẽ là `function (x) (x%%2 == 0)` để áp dụng đối với véc tơ chứa tất cả các số hàng.


```{r, eval=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>% # add indices of each obs as rownames to clearly see the final selection
   filter(row_number() %%2 == 0)
```

```{r, echo=F}
linelist %>%   
   slice_head(n=20) %>% 
   tibble::rownames_to_column() %>%    # add indices of each obs as rownames to clearly see the final selection
   filter(row_number() %%2 == 0) %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```


Một code trong base R có thể thực hiện tác vụ tương đương:

```{r, eval = F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),]
```

```{r, echo=F}

linelist_firstobs <- head(linelist, 20)

linelist_firstobs[base::Filter(function(x) (x%%2 == 0), seq(nrow(linelist_firstobs))),] %>% 
DT::datatable(rownames = FALSE, filter="top", options = list(pageLength = 10, scrollX=T), class = 'white-space: nowrap' )

```


<span style="color: orange;">**_THẬN TRỌNG:_** Mặc dù đúng là việc sử dụng hàm có thể giúp chúng ta viết code, tuy nhiên, việc viết một số hàm hay sửa hàm có thể tốn thời gian nếu chưa được suy nghĩ thấu đáo, viết đầy đủ và kết quả là báo lỗi. Vì lý do này, đầu tiên chúng ta nên viết code trước, chạy thử và đảm bảo nó thực hiện những gì chúng ta mong muốn và sau đó chuyển nó vào trong một hàm với ba thành phần chính như đã liệt kê bên trên. </span>

## Các ví dụ  

### Trả về các bảng tỷ lệ cho một số cột {.unnumbered}  

Đúng vậy, chúng ta đã có các hàm trong nhiều package mà cho phép tóm tắt thông tin một cách dễ dàng và đẹp mắt. Nhưng chúng ta vẫn cố gắng thử tạo ra hàm riêng trong những bước đầu tiên để làm quen với việc viết hàm.

Trong ví dụ này, chúng tôi muốn chỉ ra cách viết một hàm đơn giản để tránh việc sao chép và dán cùng một code nhiều lần.

```{r}

proptab_multiple <- function(my_data, var_to_tab){
  
  #print the name of each variable of interest before doing the tabulation
  print(var_to_tab)

  with(my_data,
       rbind( #bind the results of the two following function by row
        #tabulate the variable of interest: gives only numbers
          table(my_data[[var_to_tab]], useNA = "no"),
          #calculate the proportions for each variable of interest and round the value to 2 decimals
         round(prop.table(table(my_data[[var_to_tab]]))*100,2)
         )
       )
}


proptab_multiple(linelist, "gender")

proptab_multiple(linelist, "age_cat")

proptab_multiple(linelist, "outcome")


```

<span style="color: darkgreen;">**_MẸO:_** Như đã trình bày bên trên, việc chú thích cho các hàm là rất quan trọng, là một thói quen lập trình nói chung. BHãy nhớ rằng mục đích của một hàm là làm cho code sẵn sàng để đọc, ngắn hơn và hiệu quả hơn. Sau đó, người đọc có thể hiểu được hàm này sẽ làm gì chỉ bằng cách đọc tên nó và có thêm thông tin chi tiết khi đọc các chú thích.</span>


Cách thứ hai là sử dụng hàm này trong một hàm khác thông qua vòng lặp để thực hiện quá trình một cách đồng thời:

```{r}


for(var_to_tab in c("gender","age_cat",  "outcome")){
  
  print(proptab_multiple(linelist, var_to_tab))
  
}

```

Một cách đơn giản hơn có thể là sử dụng “apply” trong base R thay vì dùng “for loop” như được trình bày bên dưới:

```{r, include= FALSE, eval=FALSE}

base::lapply(linelist[,c("gender","age_cat", "outcome")], table)

```


<span style="color: darkgreen;">**_MẸO:_** R thường được định nghĩa như một ngôn ngữ lập trình hướng chức năng và hầu như bất cứ lúc nào chúng ta thực hiện một dòng code, chúng ta đang sử dụng một số hàm có sẵn. Một thói quen tốt để cảm thấy thoải mái hơn với việc viết hàm là thường xuyên nhìn bên trong cách các hàm cơ bản được viết mà chúng ta sử dụng hàng ngày. Phím tắt để làm như vậy là chọn tên hàm và sau đó bấm `Ctrl+F2` hoặc `fn+F2` hoặc `Cmd+F2` (tùy thuộc vào máy tính của bạn) .</span>

## Sử dụng **purrr**: viết các hàm với vòng lặp

### Sửa đổi kiểu biến trên nhiều cột trong một bộ số liệu {.unnumbered}  

Giả sử nhiều biến kiểu ký tự trong bộ số liệu gốc `linelist` cần được thay đổi thành “factor” nhằm mục đích phân tích và vẽ biểu đồ. Thay vì lặp lại bước nhiều lần, chúng ta có thể sử dụng hàm  `lapply()` để chuyển đổi tất cả các biến có liên quan trong một dòng code.


<span style="color: orange;">**_THẬN TRỌNG:_** hàm `lapply()` trả về một danh sách, vì thế, sử dụng danh sách này có thể đòi hỏi một sửa đổi bổ sung như là một bước cuối cùng.</span>


```{r, include=FALSE}

linelist_factor1 <- linelist %>%
      lapply(
          function(x) if(is.character(x)) as.factor(x) else x) %>%
      as.data.frame() %>% 
      glimpse()

```


Bước tương tự có thể được thực hiện bằng cách sử dụng hàm `map_if()` từ package **purrr**

```{r}

linelist_factor2 <- linelist %>%
  purrr::map_if(is.character, as.factor)


linelist_factor2 %>%
        glimpse()

```


### Vòng lặp tạo biểu đồ cho nhiều giá trị khác nhau của biến {.unnumbered}

Ở đây, chúng ta sẽ tạo biểu đồ tròn để xem phân bố outcome của bệnh nhân trong đợt dịch H7N9 cho từng tỉnh tại Trung Quốc. Thay vì lặp lại code cho từng tỉnh, chúng ta chỉ áp dụng một hàm mà chúng ta sẽ tạo ra.

```{r}

#precising options for the use of highchart
options(highcharter.theme =   highcharter::hc_theme_smpl(tooltip = list(valueDecimals = 2)))


#create a function called "chart_outcome_province" that takes as argument the dataset and the name of the province for which to plot the distribution of the outcome.

chart_outcome_province <- function(data_used, prov){
  
  tab_prov <- data_used %>% 
    filter(province == prov,
           !is.na(outcome))%>% 
    group_by(outcome) %>% 
    count() %>%
    adorn_totals(where = "row") %>% 
    adorn_percentages(denominator = "col", )%>%
    mutate(
        perc_outcome= round(n*100,2))
  
  
  tab_prov %>%
    filter(outcome != "Total") %>% 
  highcharter::hchart(
    "pie", hcaes(x = outcome, y = perc_outcome),
    name = paste0("Distibution of the outcome in:", prov)
    )
  
}

chart_outcome_province(flu_china, "Shanghai")
chart_outcome_province(flu_china,"Zhejiang")
chart_outcome_province(flu_china,"Jiangsu")


```



### Vòng lặp tạo bảng cho nhiều giá trị khác nhau của biến {.unnumbered}

Ở đây, chúng ta sẽ tạo ba chỉ số để tóm tắt một bảng và chúng ta muốn tạo bảng này theo từng tỉnh. Các chỉ số của chúng ta là khoảng thời gian từ lúc khởi phát bệnh đến lúc nhập viện, tỷ lệ hồi phục và tuổi trung vị của các ca bệnh.

```{r}


indic_1 <- flu_china %>% 
  group_by(province) %>% 
  mutate(
    date_hosp= strptime(date_of_hospitalisation, format = "%m/%d/%Y"),
    date_ons= strptime(date_of_onset, format = "%m/%d/%Y"), 
    delay_onset_hosp= as.numeric(date_hosp - date_ons)/86400,
    mean_delay_onset_hosp = round(mean(delay_onset_hosp, na.rm=TRUE ), 0)) %>%
  select(province, mean_delay_onset_hosp)  %>% 
  distinct()
     

indic_2 <-  flu_china %>% 
            filter(!is.na(outcome)) %>% 
            group_by(province, outcome) %>% 
            count() %>%
            pivot_wider(names_from = outcome, values_from = n) %>% 
    adorn_totals(where = "col") %>% 
    mutate(
        perc_recovery= round((Recover/Total)*100,2))%>% 
  select(province, perc_recovery)
    
    
    
indic_3 <-  flu_china %>% 
            group_by(province) %>% 
            mutate(
                    median_age_cases = median(as.numeric(age), na.rm = TRUE)
            ) %>% 
  select(province, median_age_cases)  %>% 
  distinct()

#join the three indicator datasets

table_indic_all <- indic_1 %>% 
  dplyr::left_join(indic_2, by = "province") %>% 
        left_join(indic_3, by = "province")


#print the indicators in a flextable


print_indic_prov <-  function(table_used, prov){
  
  #first transform a bit the dataframe for printing ease
  indic_prov <- table_used %>%
    filter(province==prov) %>%
    pivot_longer(names_to = "Indicateurs", cols = 2:4) %>% 
   mutate( indic_label = factor(Indicateurs,
   levels= c("mean_delay_onset_hosp","perc_recovery","median_age_cases"),
   labels=c("Mean delay onset-hosp","Percentage of recovery", "Median age of the cases"))
   ) %>% 
    ungroup(province) %>% 
    select(indic_label, value)
  

    tab_print <- flextable(indic_prov)  %>%
    theme_vanilla() %>% 
    flextable::fontsize(part = "body", size = 10) 
    
    
     tab_print <- tab_print %>% 
                  autofit()   %>%
                  set_header_labels( 
                indic_label= "Indicateurs", value= "Estimation") %>%
    flextable::bg( bg = "darkblue", part = "header") %>%
    flextable::bold(part = "header") %>%
    flextable::color(color = "white", part = "header") %>% 
    add_header_lines(values = paste0("Indicateurs pour la province de: ", prov)) %>% 
bold(part = "header")
 
 tab_print <- set_formatter_type(tab_print,
   fmt_double = "%.2f",
   na_str = "-")

tab_print 
    
}




print_indic_prov(table_indic_all, "Shanghai")
print_indic_prov(table_indic_all, "Jiangsu")


```


## Mẹo và thực hành tốt để các hàm hoạt động tốt

Lập trình hàm có nghĩa là để dễ dàng viết và đọc code. Tuy nhiên, điều ngược lại có thể xảy ra. Những mẹo dưới đây sẽ giúp bạn có một đoạn code gọn gàng và dễ đọc. 


### Đặt tên và cú pháp {.unnumbered}

- Tránh sử dụng ký tự có thể đã được sử dụng bởi các hàm khác trong hàm của chúng ta

- Nên đặt tên hàm ngắn gọn và dễ hiểu cho người đọc

- Ưu tiên sử dụng động từ làm tên hàm và danh từ làm tên các đối số.


### Tên cột và lượng giá tính gọn gàng {.unnumbered}  

Nếu bạn muốn biết cách tham chiếu *tên cột* để đưa vào code của bạn như một đối số, hãy đọc [hướng dẫn lập trình của tidyverse](https://dplyr.tidyverse.org/articles/programming.html) này. Trong số các chủ đề, nên đọc về *tidy evaluation* và sử dụng *embrace* `{{ }}` "hai dấu ngoặc nhọn"

Ví dụ: đây là đoạn code mẫu từ trang hướng dẫn được đề cập bên trên:  

```{r, eval=F}

var_summary <- function(data, var) {
  data %>%
    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))
}
mtcars %>% 
  group_by(cyl) %>% 
  var_summary(mpg)

```


### Kiểm tra và xử lý lỗi {.unnumbered}

Công việc của hàm càng phức tạp thì khả năng xảy ra lỗi càng cao. Vì thế, đôi khi cần phải thêm một vài kiểm tra bên trong hàm để giúp nhanh chóng biết được lỗi ở đâu và tìm cách sửa nó.

- Rất nên đưa một hàm kiểm tra tính thiếu sót của một đối số bằng cách sử dụng `missing(argument)`. Việc kiểm tra đơn giản này trả về giá trị "TRUE" hoặc "FALSE".

```{r , error=TRUE}

contain_covid19_missing <- function(barrier_gest, wear_mask, get_vaccine){
  
  if (missing(barrier_gest)) (print("please provide arg1"))
  if (missing(wear_mask)) print("please provide arg2")
  if (missing(get_vaccine)) print("please provide arg3")


  if (!barrier_gest == "yes" | wear_mask =="yes" | get_vaccine == "yes" ) 
       
       return ("you can do better")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_missing(get_vaccine = "yes")

```


- Sử dụng hàm `stop()` để dễ phát hiện lỗi hơn.

```{r, error=TRUE}

contain_covid19_stop <- function(barrier_gest, wear_mask, get_vaccine){
  
  if(!is.character(barrier_gest)) (stop("arg1 should be a character, please enter the value with `yes`, `no` or `sometimes"))
  
  if (barrier_gest == "yes" & wear_mask =="yes" & get_vaccine == "yes" ) 
       
       return ("success")
  
  else("please make sure all are yes, this pandemic has to end!")
}


contain_covid19_stop(barrier_gest=1, wear_mask="yes", get_vaccine = "no")

```

- Như đã thấy khi chúng ta thực hiện hầu hết các hàm có sẵn, có các thông báo và cảnh báo có thể xuất hiện trong một số điều kiện nhất định. Chúng ta có thể tích hợp chúng trong các hàm đã viết bằng cách sử dụng hàm `message()` và `warning()`.

- Chúng ta cũng có thể xử lý lỗi bằng cách sử dụng hàm `safely()` để lấy một hàm làm đối số và thực hiện nó một cách an toàn. Trên thực tế, hàm sẽ thực hiện mà không dừng lại nếu nó gặp lỗi. Hàm `safely()` trả về kết quả đầu ra dưới dạng một **list** với hai đối tượng là kết quả và lỗi mà nó đã “bỏ qua”.

Chúng ta có thể kiểm tra bằng cách thực hiện hàm `mean()` trước, sau đó thực hiện nó với hàm `safely()`.


```{r, warning=FALSE}

map(linelist, mean)
```


```{r, warning=FALSE}
safe_mean <- safely(mean)
linelist %>% 
  map(safe_mean)

```


Như đã nói trước đây, chú thích rõ ràng trong các đoạn mã là một cách tốt để có tư liệu cho các công việc đã thực hiện.  


<!-- ======================================================= -->
## Nguồn


[R for Data Science link](https://r4ds.had.co.nz/functions.html)   

[Cheatsheet advance R programming](https://www.rstudio.com/wp-content/uploads/2016/02/advancedR.pdf)

[Cheatsheet purr Package](https://purrr.tidyverse.org/)

[Video-ACM talk by Hadley Wickham: The joy of functional programming (how does map_dbl work)](https://youtube.videoken.com/embed/bzUmK0Y07ck)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/writing_functions.Rmd-->


# Tương tác với thư mục làm việc {#directories}  

Trong chương này, chúng tôi sẽ bao gồm các tình huống phổ biến, nơi chúng ta sẽ tạo, tương tác, lưu và nhập với thư mục.  


## Chuẩn bị  

### **fs** package {.unnumbered}  

Package **fs** thuộc hệ sinh thái **tidyverse** giúp thuận tiện cho việc tương tác với thư mục, cải thiện một số hàm trong **base** R. Trong các phần bên dưới, chúng ta sẽ dùng các hàm từ **fs**.  

```{r}
pacman::p_load(
  fs,             # file/directory interactions
  rio,            # import/export
  here,           # relative file pathways
  tidyverse)      # data management and visualization
```


### In thư mục dưới dạng cây biểu đồ dendrogram {.unnumbered}  

Sử dụng hàm `dir_tree()` từ package **fs**.  

Cung cấp đường dẫn thư mục cho đối số `path = ` và quyết định xem có hay không chúng ta muốn hiển thị chỉ ở một cấp độ (`recurse = FALSE`) hay tất cả các tập tin trong tất cả các thư mục con (`recurse = TRUE`). Bên dưới chúng ta sử dụng hàm `here()` để hiển thị kết quả dưới dạng viết tốc ký trong dự án R và cụ thể thư mục con "data" của nó, mà chứa tất các số liệu được sử dụng cho cuốn sổ tay này. Chúng ta thiết lập nó để hiện thị tất cả các tệp bên trong thư mục "data" và các thư mục con của nó (vd: "cache", "epidemic models", "population", "shp", và "weather").  


```{r}
fs::dir_tree(path = here("data"), recurse = TRUE)
```


## Liệt kê các tập tin trong một thư mục 

Để chỉ liệt kê các tên tập tin trong một thư mục, chúng ta có thể sử dụng hàm `dir()` từ **base** Ví dụ, lệnh này liệt kê tên các tập tin của các tập tin trong thư mục con có tên "population" trong thư mục "data" của một dự án R. Đường dẫn tập tin tương đối được cung cấp bằng cách sử dụng hàm `here()` (đọc thêm trong chương [Nhập xuất dữ liệu]).  

```{r}
# file names
dir(here("data", "gis", "population"))
```

Để liệt kê đường dẫn đầy đủ của các tập tin trong thư mục, chúng ta có thể sử dụng hàm `dir_ls()` từ package **fs**. Một cách khác là dùng hàm `list.files()` trong **base** R.  

```{r}
# file paths
dir_ls(here("data", "gis", "population"))
```

Để lấy tất cả thông tin chi tiết của mỗi tập tin trong một thư mục (ví dụ: đường dẫn, ngày sửa đổi, .v.v.), chúng ta có thể sử dụng hàm `dir_info()` của package **fs**.  

Điều này có thể đặc biệt hữu ích nếu chúng ta muốn trích xuất thời gian sửa đổi sau cùng của tập tin, ví dụ như nếu chúng ta muốn nhập phiên bản mới nhất của tập tin. Ví dụ cho việc này, xem trong chương [Nhập xuất dữ liệu].     

```{r, eval=F}
# file info
dir_info(here("data", "gis", "population"))
```

Sau đây là data frame được trả về. Cuộn qua phải để xem tất cả các cột.  

```{r, echo=F}
DT::datatable(dir_info(here("data", "gis", "population")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

## Thông tin tệp  

Để trích xuất thông tin chi tiết của một tập tin cụ thể, chúng ta có thể sử dụng hàme `file_info()` từ package **fs** (hoặc `file.info()` từ **base** R).  

```{r, eval=F}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))
```

```{r, echo=F}
DT::datatable(file_info(here("data", "case_linelists", "linelist_cleaned.rds")), rownames = FALSE, options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Ở đây, chúng ta sử dụng ký hiệu `$` để chỉ rõ kết quả và xuất chỉ mỗi giá trị về thời gian sửa đổi `modification_time`.  

```{r}
file_info(here("data", "case_linelists", "linelist_cleaned.rds"))$modification_time
```




## Kiểm tra sự tồn tại  

### Đối tượng R {.unnumbered}  

Bạn có thể sử dụng hàm `exists()` trong **base** R để kiểm tra xem một đối tượng R có tồn tại *bên trong* môi trường R hay không (cung cấp tên đối tượng trong dấu ngoặc kép).  

```{r}
exists("linelist")
```

Lưu ý rằng một số gói lệnh trong **base** R sử dụng các tên chung làm tên cho các đối tượng như “data” trong môi trường R, mà kết quả kiểm tra sẽ là TRUE trừ khi chúng ta chỉ rõ `inherit = FALSE`. Đây là một lý do để không đặt tên cho bộ số liệu của chúng ta là “data”.  

```{r}
exists("data")
exists("data", inherit = FALSE)
```

Nếu bạn đang viết một hàm, bạn nên sử dụng hàm `missing()` từ **base** R để kiểm tra xem có một đối số hiện diện hay không, thay vì dùng hàm `exists()`.  



### Thư mục {.unnumbered}  

Để kiểm tra xem một thư mục có tồn tại không, cung cấp đường dẫn tập tin (và tên tập tin) đến hàm `is_dir()` của package **fs**. Cuộn qua bên phải để thấy thông báo `TRUE` được in ra.    

```{r}
is_dir(here("data"))
```

Một cách làm khác là dùng hàm `file.exists()` từ **base** R.  


### Tệp {.unnumbered}  

Để kiểm tra xem một tập tin cụ thể có tồn tại hay không, sử dụng hàm `is_file()` của package **fs**. Cuộn qua bên phải để thấy thông báo `TRUE` được in ra.  

```{r}
is_file(here("data", "case_linelists", "linelist_cleaned.rds"))
```

Một cách làm khác là dùng hàm `file.exists()` từ **base** R.  



## Tạo mới  

### Thư mục {.unnumbered}  

Để tạo một thư mục mới, bạn có thể sử dụng hàm `dir_create()` từ package **fs**. Nếu thư mục đã tồn tại, thư mục này sẽ không bị ghi đè và không bị trả lại lỗi. 

```{r, eval=F}
dir_create(here("data", "test"))
```

Một cách làm khác là dùng hàm `dir.create()` từ **base** R, mà sẽ hiển thị lỗi nếu thư mục đó đã tồn tại. Ngược lại, `dir_create()` sẽ không thông báo gì.  

### Tệp {.unnumbered}  

Chúng ta có thể tạo một tâp tin (rỗng) bằng hàm  `file_create()` từ package **fs**. Nếu tập tin này đã tồn tại, nó sẽ không bị ghi đè hoặc thay đổi.  

```{r, eval=F}
file_create(here("data", "test.rds"))
```

Một cách làm khác là dùng hàm `file.create()` từ **base** R. Nhưng nếu tập tin này đã tồn tại, tùy chọn này sẽ cắt xén tập tin đó. Nếu dùng hàm `file_create()` tập tin này sẽ được giữ nguyên.  


### Tạo nếu không tồn tại {.unnumbered}  

ĐANG XÂY DỰNG  


## Xóa

### Đối tượng R {.unnumbered}  

Dùng hàm `rm()` từ **base** R để loại bỏ một đối tượng R.  

### Thư mục {.unnumbered}  

Dùng hàm `dir_delete()` từ package **fs**. 


### Tệp {.unnumbered}  

Chúng ta có thể xóa các tệp bằng hàm `file_delete()` từ package **fs**.  



## Chạy các tệp khác  

### `source()` {.unnumbered}  

Để chạy một R script từ một R script khác, bạn có thể sử dụng hàm `source()` (trong **base** R).

```{r, eval=F}
source(here("scripts", "cleaning_scripts", "clean_testing_data.R"))
```

ở phía trên bên phải của tập lệnh. Điều này sẽ thực hiện tập lệnh này nhưng sẽ thực hiện một cách âm thầm (không có kết quả đầu ra trong bảng điều khiển R) trừ khi có chủ ý cụ thể. Xem các ví dụ ở chương [Bảng điều khiển tương tác] về cách sử dụng `source()` để tương tác với người dùng qua bảng điều khiên R ở chế độ hỏi và trả lời.  

```{r, fig.align = "center", out.height = '300%', echo=F}
knitr::include_graphics(here::here("images", "source_button.png"))
```


### `render()` {.unnumbered}  

Hàm `render()` là một biến thể của hàm `source()` mà thường được sử dụng nhất cho các tập lệnh của R markdown. Chúng ta cung cấp `input = ` tập tin R markdown, và cũng vậy  `output_format = ` (thường là “html_document”, “pdf_document”, “word_document”, "") 

Xem chương [Báo cáo với R Markdown] để biết thêm chi tiết. Ngoài ra, bạn có thể xem thêm tài liệu về `render()` [tại đây](https://rmarkdown.rstudio.com/docs/reference/render.html) hoặc bằng cách gõ `?render`.  



### Chạy các tệp trong một thư mục {.unnumbered}

Bạn có thể tạo một *vòng lặp for* và sử dụng nó để `source()` từng tệp trong một thư mục, đã được nhận dạng bởi hàm `dir()`. 

```{r, eval=F}
for(script in dir(here("scripts"), pattern = ".R$")) {   # for each script name in the R Project's "scripts" folder (with .R extension)
  source(here("scripts", script))                        # source the file with the matching name that exists in the scripts folder
}
```

Nếu chúng ta chỉ muốn thực hiện một vài scripts, chúng ta có thể xác định chúng bằng tên như sau:  

```{r, eval=F}

scripts_to_run <- c(
     "epicurves.R",
     "demographic_tables.R",
     "survival_curves.R"
)

for(script in scripts_to_run) {
  source(here("scripts", script))
}

```



Đây là một [so sánh](https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html) giữa các hàm của **fs** và **base** R.  

### Nhập tệp vào một thư mục  {.unnumbered}

Xem chương [Nhập xuất dữ liệu] để nhập và xuất các tập tin riêng lẻ.  

Ngoài ra cũng xem thêm chương [Nhập xuất dữ liệu] để biết các phương pháp nhập một cách tự động các tập tin gần đây nhất dựa trên ngày trong tên tập tin *hoặc* bằng cách xem các thông tin chi tiết của tập tin.  

Xem một ví dụ trong chương [Lặp, vòng lặp và danh sách] để thấy rõ cách sử dụng package **purrr**:  

* Để tách một data frame và lưu nó ra dưới dạng nhiều tập tin  
* Tách một data frame và lưu từng phần vào một trang tính riêng biệt trong một tập tin Excel  
* Nhập nhiều tập tin CSV và kết hợp chúng thành một dataframe  
* Nhập một tập tin Excel có nhiều trang tính riêng biệt và kết hợp chúng thành một dataframe  




## **base** R  

Xem bên dưới các hàm `list.files()` và `dir()`, thực hiện cùng một thao tác liệt kê các tập tin trong một thư mục cụ thể. Chúng ta có thể cụ thể cho đối số `ignore.case =` hoặc cụ thể một pattern để tìm kiếm. 

```{r, eval=F}
list.files(path = here("data"))

list.files(path = here("data"), pattern = ".csv")
# dir(path = here("data"), pattern = ".csv")

list.files(path = here("data"), pattern = "evd", ignore.case = TRUE)

```

Nếu một tập tin hiện tại đang “mở”, nó sẽ hiện thị trong thư mục với dấu ngã phía trước, chẳng hạn như "~$hospital_linelists.xlsx".  


<!-- ======================================================= -->
## Nguồn {  }

https://cran.r-project.org/web/packages/fs/vignettes/function-comparisons.html



```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/directories.Rmd-->

# Version control với Git và Github {#collaboration}

Chương này trình bày tổng quan về việc sử dụng Git để làm việc nhóm với những người khác. Bạn có thể tìm các hướng dẫn nâng cao hơn ở trong phần Tài nguyên học liệu.

## Git là gì?

Git là một phần mềm **kiểm soát phiên bản** cho phép theo dõi các thay đổi trong một thư mục. Nó có thể được sử dụng như tùy chọn "track change" trong Word, LibreOffice hoặc Google docs, nhưng dành cho tất cả các loại tệp. Nó là một trong những công cụ mạnh mẽ nhất và được sử dụng nhiều nhất để kiểm soát phiên bản.

**Tại sao tôi chưa bao giờ nghe nói về Git? -** Trong khi hầu hết những nhà lập trình thường xuyên phải học cách sử dụng phần mềm để kiểm soát phiên bản (Git, Mercurial, Subversion hoặc những phần mềm khác), ít người trong chúng ta xuất thân từ các ngành định lượng được dạy các kỹ năng này. Do đó, hầu hết các nhà dịch tễ học không bao giờ nghe nói về nó trong các nghiên cứu của họ, và phải tìm hiểu nó một cách nhanh chóng.

**Chờ đã, tôi có nghe nói về Github, chúng có giống nhau không?** - Không hoàn toàn, nhưng bạn thường sử dụng chúng cùng nhau và chúng tôi sẽ hướng dẫn bạn cách thực hiện. Nói ngắn gọn như sau:

-   **Git** là hệ thống kiểm soát phiên bản, là một phần của phần mềm. Bạn có thể tải phần mềm để sử dụng trên máy tính của mình hoặc để đồng bộ hóa một thư mục với một máy chủ trên **web**. Theo mặc định, bạn sử dụng terminal để đưa ra hướng dẫn cho Git thông qua các dòng lệnh.

-   Bạn có thể sử dụng **ứng dụng người dùng/giao diện Git** để không phải gõ lệnh và thực hiện các hành động tương tự (ít nhất là đối với những hành động đơn giản, rất thường dùng).

-   Nếu bạn muốn lưu trữ thư mục của mình trong một **host website** để cùng làm việc với những người khác, bạn có thể tạo một tài khoản tại Github, Gitlab, Bitbucket hoặc những nền tảng khác.

Vì vậy, bạn có thể sử dụng ứng dụng/giao diện **Github Desktop**, sử dụng **Git** trong nền để quản lý các tệp của bạn, cả cục bộ trên máy tính của bạn và từ xa trên máy chủ **Github**.

## Tại sao lại sử dụng combo Git và Github?

Sử dụng **Git** để:

1)  Lưu trữ các phiên bản của tài liệu với sự ghi nhận các thay đổi để bạn có thể dễ dàng chuyển lại về bất kỳ trạng thái nào trước đó
2)  Có các *nhánh (branches)* song song, tức là các phiên bản đang phát triển/"đang làm việc" hoạt động có cấu trúc để tích hợp các thay đổi sau khi đánh giá

Điều này có thể được thực hiện cục bộ trên máy tính của bạn, ngay cả khi bạn không cộng tác với những người khác. Bạn đã bao giờ từng:

-   hối tiếc vì đã xóa một đoạn mã, chỉ để nhận ra hai tháng sau bạn thực sự cần nó?

-   quay lại một dự án đã bị tạm dừng và cố gắng nhớ liệu bạn đã thực hiện một sửa đổi gì đó phức tạp ở một trong những mô hình?

-   có một tệp *model_1.R* và một tệp khác *model_1\_test.R* và một tệp *model_1\_not_working.R* để thử mọi thứ?

-   có một tệp *report.Rmd*, tệp *report_full.Rmd*, tệp *report_true_final.Rmd*, tệp *report_final_20210304.Rmd*, tệp *report_final_20210402.Rmd* và khó chịu với kỹ năng lưu trữ của bạn?

Git sẽ giúp bạn giải quyết tất cả vấn đề trên, và đây cũng là những thứ rất đáng để học.

Tuy nhiên, nó thậm chí còn trở nên mạnh mẽ hơn khi được sử dụng với kho lưu trữ trực tuyến chẳng hạn như Github để hỗ trợ **các dự án hợp tác**. Điều này tạo điều kiện cho việc:

-   Cộng tác: những người khác có thể đánh giá, nhận xét và chấp nhận/từ chối các thay đổi\

-   Chia sẻ mã, dữ liệu và kết quả đầu ra của bạn và mời phản hồi từ công chúng (hoặc riêng tư, với nhóm của bạn) và tránh:

-   "Rất tiếc, tôi đã quên gửi phiên bản cuối cùng và bây giờ bạn cần làm lại tệp mới này trong hai ngày làm việc"

-   Mina, Henry và Oumar đều làm việc cùng lúc trên một script và cần phải hợp nhất các thay đổi của họ theo cách thủ công

-   Hai người cố gắng sửa đổi cùng một tệp trên Dropbox và Sharepoint và điều này tạo ra một lỗi đồng bộ hóa.

### Điều này nghe có vẻ phức tạp, tôi không phải là một lập trình viên {.unnumbered}

Bạn hoàn toàn có thể. Ví dụ về cách sử dụng nâng cao có thể khá đáng sợ. Tuy nhiên, giống với như R, hoặc thậm chí là Excel, bạn không cần phải trở thành một chuyên gia để tận dụng lợi ích của công cụ. Học *một số nhỏ các hàm và khái niệm* cho phép bạn theo dõi các thay đổi của mình, đồng bộ hóa các tệp của bạn trên kho lưu trữ trực tuyến và cộng tác với đồng nghiệp của bạn với thời gian ngắn.

Do tiến trình học tập, khi bạn cần hoàn thiện một công viêc trong trường hợp khẩn cấp, đó có thể không phải là thời điểm tốt nhất để tìm hiểu các công cụ này. Nhưng việc học có thể đạt được theo từng bước. Một khi bạn có được một vài khái niệm, quy trình làm việc của bạn có thể khá hiệu quả và nhanh chóng. Nếu bạn chưa làm việc trong một dự án cộng tác với mọi người và buộc phải sử dụng qua Git, **đó thực sự là thời điểm tốt để có được sự tự tin khi sử dụng Git** trước khi bắt tay vào cộng tác với người khác.

## Cài đặt

### Cài đặt Git {.unnumbered}

*Git* là công cụ phía sau hậu trường trên máy tính của bạn, theo dõi các thay đổi, các nhánh (phiên bản), hợp nhất và hoàn nguyên. **Đầu tiên bạn phải cài đặt *Git* từ đường link sau <https://git-scm.com/downloads>.**

### Cài đặt giao diện (tùy chọn nhưng được khuyến nghị) {.unnumbered}

Git có ngôn ngữ lệnh riêng, có thể được nhập vào terminal. Tuy nhiên, có nhiều phần mềm/giao diện và với tư cách không phải là một lập trình viên, trong quá trình sử dụng hàng ngày, bạn sẽ hiếm khi *cần* tương tác trực tiếp với Git và giao diện người dùng thường cung cấp các công cụ trực quan đẹp mắt để sửa đổi tệp hoặc các nhánh.

Có nhiều tùy chọn, trên tất cả các hệ điều hành, từ thân thiện với người mới bắt đầu đến những tùy chọn phức tạp hơn. Các tùy chọn tốt cho người mới bắt đầu bao gồm cửa sổ RStudio Git và [Github Desktop](https://desktop.github.com/), mà chúng tôi sẽ giới thiệu trong chương này. Các tùy chọn trung gian (tiện ích hơn nhưng phức tạp hơn) bao gồm Source Tree, Gitkracken, Smart Git và những tùy chọn khác.

Giải thích ngắn gọn về [Git clients](-%09https:/happygitwithr.com/git-client.html#git-client) ở đây.

*Lưu ý: vì thực tế tất cả các giao diện đều sử dụng Git nội bộ, bạn có thể thử một số trong đó, chuyển từ dạng này sang dạng khác trong một dự án nhất định, sử dụng console đối với một hành động mà giao diện của bạn không hỗ trợ hoặc thậm chí thực hiện bất kỳ hành động nào trực tuyến trên Github.*

Như đã lưu ý bên dưới, đôi khi bạn có thể phải viết các lệnh Git trong termial chẳng hạn như cửa sổ Ternmial trong RStudio (một tab liền kề với R Console) hoặc terminal của Git Bash.

### Tài khoản Github {.unnumbered}

Đăng ký tài khoản miễn phí tại [github.com](github.com).

Bạn có thể được đề nghị thiết lập xác thực hai yếu tố với một ứng dụng trên điện thoại của bạn. Đọc thêm trong [tài liệu trợ giúp](https://docs.github.com/en/github/authenticating-to-github/securing-your-account-with-two-factor-authentication-2fa) của Github .

Nếu bạn sử dụng Github Desktop, bạn có thể nhập thông tin đăng nhập Gitub của mình sau khi cài đặt [các bước sau](https://docs.github.com/en/desktop/installing-and-configuring-github-desktop/authenticating-to-github). Nếu bạn không biết, thông tin đăng nhập sẽ được hỏi sau khi bạn cố gắng clone một dự án từ Github.

## Thuật ngữ, khái niệm và các hàm cơ bản

Giống như khi học R, bạn cần nhớ một chút thuật ngữ để hiểu Git. Đây là [những điều cơ bản giúp bạn làm việc](https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/) / [hướng dẫn tương tác](learningngitbranching.js.org). Ở phần tiếp theo, chúng tôi sẽ chỉ ra cách sử dụng các giao diện, nhưng tốt hơn là bạn nên có một số thuật ngữ và khái niệm trong đầu, để xây dựng mô hình tinh thần của bạn, và vì bạn sẽ cần chúng khi sử dụng các giao diện.

### Kho lưu trữ (Repository) {.unnumbered}

Kho *lưu trữ Git* ("*repo*") là một thư mục chứa tất cả các thư mục con và tệp cho dự án của bạn (dữ liệu, mã code, hình ảnh, v.v.) và lịch sử sửa đổi của chúng. Khi bạn bắt đầu theo dõi những thay đổi trong kho lưu trữ, Git sẽ tạo một thư mục ẩn chứa tất cả các thông tin theo dõi. Một kho lưu trữ Git điển hình là thư mục *Dự án R* của bạn (xem thêm chương [Dự án R] để biết thêm chi tiết).

Chúng tôi sẽ hướng dẫn bạn cách tạo (*initialize*) một kho lưu trữ Git từ Github, Github Desktop hoặc Rstudio trong phần tiếp theo của chương này.

### Commits {.unnumbered}

Một *commit* là một **ảnh chụp nhanh** của dự án tại một thời điểm xác định. Khi bạn thực hiện một thay đổi đối với dự án, bạn sẽ tạo một commit mới để theo dõi những thay đổi (the delta) được thực hiện đối với các tập tin của bạn. Ví dụ: bạn đã chỉnh sửa một vài dòng lệnh và cập nhật bộ dữ liệu liên quan. Sau khi các thay đổi của bạn được lưu, bạn có đóng gói các thay đổi cùng nhau tạo thành một "commit".

Mỗi commit có một ID duy nhất (một *hash*). Đối với mục tiêu kiểm soát phiên bản, bạn có thể khôi phục dự án của mình theo thời gian dựa trên các commit, vì vậy tốt nhất là bạn nên tạo các commit tương đối nhỏ và mạch lạc. Bạn cũng sẽ đính kèm một bản tóm tắt mô tả về những thay đổi được gọi là "commit message".

*Tổ chức các thay đổi (Staged change)*? Tổ chức các thay đổi nghĩa là thêm chúng vào một *staging area - khu vực sân khẩu* để chuẩn bị cho lần commit tiếp theo. Ý tưởng là bạn có thể quyết định rõ ràng những thay đổi nào sẽ bao gồm trong một commit cụ thể. Ví dụ, nếu bạn đã làm việc với mô hình trong một script và sau đó làm việc với một biểu đồ trong một script khác, sẽ hợp lý nếu có hai commit khác nhau (sẽ dễ dàng hơn trong trường hợp bạn muốn khôi phục các thay đổi trên biểu đồ nhưng không phải trên mô hình).

### Branches {.unnumbered}

Một nhánh (branch) đại diện cho một *con đường độc lập* chứa các thay đổi trong kho lưu trữ (repo) của bạn. Nó là một phiên bản song song của các tệp dự án của bạn.

Các nhánh rất hữu ích để thử nghiệm các thay đổi trước khi chúng được tích hợp vào nhánh *chính (main branch)*, thường là phiên bản chính/cuối cùng/"live" của dự án của bạn. Khi bạn hoàn thành việc thử nghiệm trên một nhánh, bạn có thể *hợp nhất* những thay đổi đó vào nhánh *chính* của bạn, hoặc xóa những thay đổi không thành công.

*Lưu ý: bạn không cần phải cộng tác với người khác để sử dụng các nhánh, cũng như không cần phải có một kho lưu trữ trực tuyến từ xa.*

### Kho lưu trữ cục bộ và từ xa {.unnumbered}

*Clone (Nhân bản)* là tạo một bản sao của kho lưu trữ Git ở một nơi khác.

Ví dụ: bạn có thể *clone* một kho lưu trữ trực tuyến *từ* Github xuống máy tính của bạn hoặc bắt đầu với một kho lưu trữ cục bộ (local repository) và clone nó *trực tuyến* lên Github.

Khi bạn đã clone một kho lưu trữ, các tệp dự án tồn tại ở hai nơi:

-   kho lưu trữ *CỤC BỘ (LOCAL)* trên máy tính của bạn. Đây là nơi bạn thực hiện các thay đổi thực tế đối với các tệp/code.

-   *TỪ XA (REMOTE)*, kho lưu trữ trực tuyến: các phiên bản của tệp dự án trên kho lưu trữ Github (hoặc trên bất kỳ nền tảng nào khác).

Để đồng bộ hóa các kho này, chúng ta sẽ sử dụng nhiều hàm hơn. Thật vậy, không giống như Sharepoint, Dropbox hoặc các phần mềm đồng bộ hóa khác, Git không thực hiện tự động cập nhật kho lưu trữ cục bộ của bạn dựa trên những gì có trên cloud, hoặc ngược lại. Tuy nhiên, bạn có thể chọn thời điểm và cách thức đồng bộ hóa.

-   `git fetch` tải xuống các thay đổi mới từ kho lưu trữ từ xa nhưng không làm thay đổi kho lưu trữ cục bộ của bạn. Hãy coi như nó giống như việc kiểm tra trạng thái của kho lưu trữ từ xa.

-   `git pull` tải xuống các thay đổi mới từ kho lưu trữ từ xa và cập nhật kho lưu trữ cục bộ của bạn.

-   Khi bạn đã thực hiện một hoặc một số commit cục bộ, bạn có thể `git push` để đẩy các commit đến kho lưu trữ từ xa. Điều này giúp gửi các thay đổi của bạn tới Github để người khác có thể xem và kéo về (pull) nếu họ muốn.

## Bắt đầu: tạo một kho lưu trữ mới

Có nhiều cách để tạo kho lưu trữ mới. Bạn có thể làm điều đó từ R console, từ Github, hoặc thông qua giao diện người dùng.

Hai cách tiếp cận thường dùng để tạo một kho lưu trữ là:

-   Tạo một Dự án R mới từ kho lưu trữ Github hiện có hoặc mới (*ưu tiên cho người mới bắt đầu*), hoặc
-   Tạo kho lưu trữ Github cho một dự án R hiện có

### Các tệp khởi động {.unnumbered}

Khi bạn tạo một kho lưu trữ mới, bạn có thể tùy chọn tạo tất cả các tệp bên dưới hoặc bạn có thể thêm chúng vào kho lưu trữ của mình ở giai đoạn sau. Chúng thường nằm trong thư mục "gốc" của kho lưu trữ.

-   Tệp *README* là tệp mà người khác có thể đọc để hiểu tại sao dự án của bạn tồn tại và những điều họ nên biết để sử dụng nó. Tệp này ban đầu sẽ trống, nhưng bạn có thể hoàn thiện nó sau đó.

-   Tệp *.gitignore* là tệp văn bản trong đó mỗi dòng sẽ chứa các thư mục hoặc tệp mà Git nên bỏ qua (không theo dõi các thay đổi). Đọc thêm về điều này và xem các ví dụ [tại đây](https://www.freecodecamp.org/news/gitignore-what-is-it-and-how-to-add-to-repo/).

-   Bạn có thể chọn *license* cho dự án của mình, để những người khác biết họ có thể sử dụng hoặc tái lập dự án của bạn trong những điều kiện nào. Để biết thêm thông tin, hãy xem [Creative Commons licenses](https://creativecommons.org/licenses/).

### Tạo một kho lưu trữ mới trong Github {.unnumbered}

Để tạo một kho lưu trữ mới, hãy đăng nhập vào Github và tìm một nút màu xanh lục để tạo một kho lưu trữ mới. Một kho lưu trữ trống được tạo ra và có thể được clone xuống máy tính của bạn (xem phần tiếp theo để biết thêm chi tiết).

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_new.png"))
```

Bạn phải chọn nếu bạn muốn kho lưu trữ của mình ở dạng **công khai** (hiển thị với mọi người trên internet) hoặc **riêng tư** (chỉ hiển thị với những người trong sự cho phép của bạn). Điều này có ý nghĩa quan trọng nếu dữ liệu của bạn nhạy cảm. Nếu kho lưu trữ của bạn là riêng tư, bạn sẽ gặp phải một số giới hạn trong các trường hợp đặc biệt, chẳng hạn như nếu bạn đang sử dụng *actions* trong Github để tự động chạy code trên cloud.

### Clone từ kho lưu trữ Github {.unnumbered}

Bạn có thể *clone* một kho lưu trữ Github có sẵn để tạo một dự án R mới cục bộ trên máy tính của bạn.

Kho lưu trữ Github có thể là một kho lưu trữ đã tồn tại và chứa nội dung, hoặc có thể là một kho lưu trữ trống mà bạn vừa tạo. Trong trường hợp thứ hai, về cơ bản bạn đang tạo một repo Github và dự án R cục bộ trên máy tính của bạn cùng một lúc (xem hướng dẫn ở trên)

*Lưu ý*: nếu bạn không có quyền đóng góp trên kho lưu trữ Github, trước tiên bạn có thể *fork* kho lưu trữ đó vào hồ sơ riêng của bạn, và sau đó tiếp tục với các hành động khác. Forking được giải thích ở phần cuối của chương này nhưng chúng tôi khuyên bạn nên đọc các phần khác trước.

Bước 1: Điều hướng trong Github đến kho lưu trữ, nhấp vào nút màu xanh lá cây "**Code**" và sao chép **HTTPS clone URL** (xem hình ảnh minh họa bên dưới)

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone.png"))
```

Bước tiếp theo có thể được thực hiện trong bất kỳ giao diện người dùng nào. Chúng tôi sẽ minh họa bằng Rstudio và Github desktop.

#### Trong Rstudio {.unnumbered}

Trong RStudio, để bắt đầu một dự án R mới, bạn cần nhấp vào *File \> New Project \> Version Control \> Git*

-   Khi được yêu cầu nhập "Repository URL", hãy dán URL HTTPS từ Github 
-   Gán cho dự án R một cái tên ngắn gọn, đầy đủ thông tin\
-   Chọn nơi Dự án R mới sẽ được lưu cục bộ trên máy tính của bạn\
-   Chọn "Open in new session" và nhấp vào mục "Create project"

Bạn hiện đang trong một dự án RStudio mới, cục bộ trên máy tính của bạn, là một bản sao của kho lưu trữ online trên Github. Dự án cục bộ này và kho lưu trữ Github hiện đã được liên kết.

#### Trong Github Desktop {.unnumbered}

-   Nhấn vào *File \> Clone a repository*

-   Chọn tab URL

-   Dán đường dẫn HTTPS URL từ Github vào hộp đầu tiên

-   Chọn thư mục mà bạn muốn lưu kho lưu trữ cục bộ của mình

-   Nhấn vào "CLONE"

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_clone_desktop.png"))
```

### Tạo một Github repo mới từ dự án R đã có sẵn {.unnumbered}

Một kịch bản khác là bạn có một dự án R đã tồn tại với các nội dung và bạn muốn tạo một kho lưu trữ Github cho nó.

1)  Tạo một kho lưu trữ Github mới, trống cho dự án (Xem hướng dẫn ở trên)\
2)  Clone cục bộ kho lưu trữ này (Xem hướng dẫn về HTTPS ở trên)\
3)  Sao chép tất cả nội dung từ dự án R đã có từ trước của bạn (mã, dữ liệu, v.v.) vào kho lưu trữ trống, cục bộ, mới này (ví dụ: sử dụng sao chép và dán).\
4)  Mở dự án mới của bạn trong RStudio và chuyển đến cửa sổ Git. Các tệp mới sẽ được đăng ký dưới dạng tệp có thay đổi, và hiện được theo dõi bởi Git. Do đó, bạn có thể đóng gói những thay đổi này dưới dạng một *commit* và *push* chúng lên Github. Sau khi *được push*, kho lưu trữ trên Github của bạn sẽ theo dõi sự thay đổi của tất cả các tệp.

Xem phần quy trình làm việc Github bên dưới để biết chi tiết về quy trình này.

### Bây giờ, nó trông như thế nào? {.unnumbered}

#### Trong RStudio {.unnumbered}

Khi bạn đã clone kho lưu trữ Github sang một dự án R mới, bây giờ bạn sẽ thấy trong RStudio có một tab "Git". Tab này xuất hiện bên cạnh cửa sổ RStudio Environment của bạn:

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "Git_console.png"))
```

Lưu ý các nút được khoanh tròn trong hình trên, vì chúng sẽ được giới thiệu dưới đây (từ trái sang phải):

-   Nút để *commit* những tệp có thay đổi đã được lưu tới nhánh cục bộ "local branch" (sẽ mở ra một cửa sổ mới)
-   Mũi lên màu xanh lam hướng lên để *pull* (cập nhật phiên bản của nhánh cục bộ với bất kỳ các thay đổi được thực hiện trên phiên bản từ xa/Github của nhánh đó)
-   Mũi tên màu xanh lục hướng xuống *push* (gửi bất kỳ các commits/thay đổi nào trong phiên bản cục bộ lên phiên bản từ xa/Github của nhánh đó)
-   Tab Git trong RStudio
-   Nút để tạo một nhánh MỚI bằng cách sử dụng bất kỳ nhánh cục bộ nào được hiển thị bên phải làm cơ sở. *Bạn hầu như luôn muốn tách khỏi nhánh chính (sau khi bạn pull lần đầu tiên để cập nhật nhánh chính)*
-   Nhánh bạn hiện đang làm việc
-   Những thay đổi bạn đã thực hiện đối với code hoặc các tệp khác sẽ xuất hiện bên dưới

#### Trong Github Desktop {.unnumbered}

Github Desktop là một ứng dụng độc lập trong máy tính cho phép bạn quản lý tất cả các kho lưu trữ của bạn. Khi bạn mở nó, giao diện của nó cho phép bạn chọn kho lưu trữ bạn muốn làm việc và sau đó thực hiện các thao tác Git cơ bản tại đây.

```{r echo=F, out.width = "75%", out.height="75%", fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_interface.png"))
```

## Quy trình làm việc với Git + Github

### Tổng quan về quy trình {.unnumbered}

Khi bạn đã hoàn tất các bước thiết lập (được mô tả ở trên), bạn sẽ có một Github repo được kết nối (*cloned*) với một dự án R cục bộ. Nhánh *chính* (được tạo theo mặc định) còn được gọi là phiên bản "live" của *tất cả* các tệp tin. Khi bạn muốn sửa đổi, một thực hành tốt đó là tạo một *nhánh mới* từ nhánh *chính* (giống như "Tạo một bản sao"). Đây là quy trình làm việc điển hình trong Git vì việc tạo một nhánh là dễ dàng và nhanh chóng.

Quy trình làm việc điển hình như sau:

1.  Đảm bảo rằng kho lưu trữ cục bộ của bạn được cập nhật, hãy cập nhật nó nếu nó chưa phải bản mới nhất

2.  Chuyển đến nhánh mà bạn đã làm việc trước đây hoặc tạo một nhánh làm việc mới để thử một số thứ

3.  Làm việc với các tệp trực tiếp trên máy tính của bạn, tạo một hoặc nhiều commit với nhánh làm việc này

4.  Cập nhật phiên bản từ xa của nhánh làm việc với các thay đổi của bạn (push)

5.  Khi bạn hài lòng với nhánh làm việc này, bạn có thể hợp nhất phiên bản trực tuyến vào nhánh "chính" trực tuyến để chuyển tiếp các thay đổi

Các thành viên khác trong nhóm có thể đang làm điều tương tự với các nhánh của riêng họ, hoặc cũng có thể đóng góp các commits vào nhánh làm việc của bạn.

Chúng ta sẽ đi qua một cách chi tiết hơn từng bước của quá trình trên ở phần sau. Đây là một giản đồ mà chúng tôi đã phát triển - nó ở định dạng bảng hai chiều vì vậy nó sẽ giúp các nhà dịch tễ học dễ dàng hiểu được.

```{r echo=F, out.height='150%', out.width='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_table.png"))
```

Dây là [một sơ đồ khác](https://build5nines.com/introduction-to-git-version-control-workflow/).

*Lưu ý: cho đến gần đây, thuật ngữ nhánh "master" vẫn được sử dụng, nhưng bây giờ thuật ngữ này được gọi là nhánh "main (chính)".*

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "GitHub-Flow.png"))
```

Nguồn [hình ảnh](https://build5nines.com/introduction-to-git-version-control-workflow/)

## Tạo một nhánh mới

Khi bạn chọn một nhánh để làm việc, **Git đặt lại trạng thái thư mục làm việc của bạn trở lại lần cuối cùng bạn ở trên nhánh này**.

### Trong cửa sổ Rstudio Git {.unnumbered}

Đảm bảo bạn đang ở trong nhánh "chính", sau đó nhấp vào biểu tượng màu tím để tạo một nhánh mới (xem hình trên).

-   Bạn sẽ được yêu cầu đặt tên nhánh của mình trong một từ (có thể sử dụng dấu gạch dưới nếu cần).
-   Bạn sẽ thấy rằng bạn vẫn đang ở trong cùng một dự án R, nhưng bạn không còn làm việc trên nhánh "chính" nữa.
-   Sau khi được tạo, nhánh mới cũng sẽ xuất hiện trên trang web Github dưới dạng một nhánh.

Bạn có thể xem các nhánh tại cửa sổ Git trong Rstudio bằng cách nhấp vào "History"

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_rstudio_branchs.png"))
```

### Trong Github Desktop {.unnumbered}

Quy trình tương tự bên trên, bạn được yêu cầu đặt tên cho nhánh làm việc của mình. Sau đó, bạn sẽ được yeu cầu "Publish your branch to Github - Xuất bản nhánh làm việc của bạn lên Github" để làm cho nhánh mới cũng xuất hiện trong kho lưu trữ từ xa.

```{r echo=F, out.width = '100%', out.height='100%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_new_branch.png"))
```

### Trong console {.unnumbered}

Điều thực sự đang xảy ra ẩn phía sau là bạn tạo ra một nhánh với lệnh `git branch`, sau đó chuyển đến nhánh đó bằng lệnh `git checkout` (*vd:* nói cho Git biết rằng các commit tiếp theo của bạn sẽ xảy ra trên nhánh đó). Từ kho lưu trữ git của bạn, hãy gõ:

```{bash, eval = FALSE}
git branch my-new-branch  # Create the new branch branch
git checkout my-new-branch # Go to the branch
git checkout -b my-new-branch # Both at once (shortcut)
```

Để biết thêm thông tin về cách sử dụng bảng console, hãy xem phần Lệnh Git ở cuối.

## Commit các thay đổi

Giờ đây, bạn có thể chỉnh sửa code, thêm tệp mới, cập nhật bộ dữ liệu, v.v.

Mọi thay đổi của bạn đều được theo dõi, *sau khi tệp tương ứng được lưu*. Các tệp đã thay đổi sẽ xuất hiện trong tab RStudio Git, trong Github Desktop hoặc sử dụng lệnh `git status` trong terminal (xem bên dưới).

Bất cứ khi nào bạn thực hiện các thay đổi quan trọng (ví dụ: thêm hoặc cập nhật một phần của code), bạn hãy tạm dừng việc thay đổi và *commit* những thay đổi đó. Hãy tưởng tượng mỗi một commit là một "lô (batch)" của các thay đổi cùng hướng tới một mục đích chung. Bạn sẽ luôn có thể tiếp tục sửa đổi tệp sau khi đã commit các thay đổi trên đó.

*Lời khuyên về cách commit*: nói chung, tốt hơn là bạn nên tạo các commit nhỏ để có thể dễ dàng khôi phục các chỉnh sửa nếu có vấn đề phát sinh, sau đó commit chúng cùng nhau. Để làm được điều này, *bạn sẽ cần phải commit thường xuyên*. Khi mới bắt đầu, bạn có thể sẽ quên commit thường xuyên, nhưng sau đó thói quen commit thường xuyên bắt đầu xuất hiện.

### Trong Rstudio {.unnumbered}

Ví dụ dưới đây cho thấy rằng, kể từ lần commit cuối cùng, tập lệnh R Markdown "collab.Rmd" đã thay đổi, và một số hình ảnh PNG đã được thêm vào.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking2.png"))
```

Bạn có thể tự hỏi những hình vuông màu vàng, xanh lam, xanh lá cây và đỏ bên cạnh tên tệp có ý nghĩa gì. Đây là ảnh chụp nhanh từ [RStudio cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) trong đó giải thích ý nghĩa của chúng. Lưu ý rằng các thay đổi với màu vàng "?" có thể hoặc là staged, commited và pushed.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_tracking.png"))
```

-   Nhấn vào nút "Commit" trong cửa sổ Git, nút này sẽ mở ra một cửa sổ mới (hiển thị bên dưới)

-   Nhấp vào tên tệp trong hộp phía trên bên trái

-   Xem lại những thay đổi bạn đã thực hiện đối với tệp đó (được đánh dấu màu xanh lá cây hoặc đỏ)

-   "Trình bày - Stage" các tệp, sẽ bao gồm những thay đổi có trong commit. Bạn có thể thực hiện việc này bằng cách chọn hộp bên cạnh tên tệp. Ngoài ra, bạn có thể đánh dấu nhiều tên tệp và sau đó nhấp vào "Stage"

-   Viết một thông điệp commit mô tả ngắn gọn những thay đổi (bắt buộc)

-   Ấn vào nút "Commit". Một hộp thoại xuất hiện cho biết lệnh commit được thực hiện thành công hoặc một thông báo về thực hiện lỗi.

Giờ đây, bạn có thể thực hiện nhiều thay đổi hơn và nhiều lần commit hơn, bao nhiêu lần tùy ý

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_commit.png"))
```

### Trong Github Desktop {.unnumbered}

Bạn có thể xem danh sách các tệp đã được thay đổi ở bên trái. Nếu như bạn chọn một tệp văn bản, bạn sẽ thấy một bản tóm tắt về các sửa đổi đã được thực hiện trong ngăn bên phải (chế độ xem sẽ không hoạt động trên các tệp phức tạp hơn như .docs hoặc .xlsx).

Để stage các thay đổi, chỉ cần đánh dấu vào ô nhỏ gần tên tệp. Khi bạn đã chọn các tệp bạn muốn thêm vào lần commit này, hãy đặt một cái tên cho commit và mô tả (tùy chọn) và sau đó nhấp vào nút **commit**.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_commit.png"))
```

### Trong console {.unnumbered}

Hai hàm thực sự thực hiện các thao tác trên là `git add` để chọn/stage tệp và `git commit` để thực hiện commit.

```{bash, eval = FALSE}
git status # see the changes 

git add new_pages/collaboration.Rmd  # select files to commit (= stage the changes)

git commit -m "Describe commit from Github Desktop" # commit the changes with a message

git log  # view information on past commits
```

### Thêm vào một commit trước đó {.unnumbered}

Điều gì sẽ xảy ra nếu bạn đã commit một số thay đổi, tiếp tục làm việc và nhận ra rằng bạn đã thực hiện các thay đổi mà lẽ ra "thuộc về" lần commit trước đó (theo ý kiến của bạn). Đừng sợ! Bạn có thể nối những thay đổi này vào lần commit trước đó của mình.

Trong Rstudio, nó sẽ khá rõ ràng vì có một hộp kiểm "Thêm vào commit trước - Amend previous commit" trên cùng dòng với nút COMMIT.

Vì một số lý do không rõ ràng, chức năng này không có sẵn trong Github Desktop, nhưng vẫn có cách (khó hiểu về mặt khái niệm nhưng dễ dàng). Nếu bạn đã commit **nhưng chưa đẩy** các thay đổi của bạn lên nhánh chính, nút "UNDO" xuất hiện ngay dưới nút COMMIT. Nhấp vào nó và nó sẽ khôi phục commit của bạn (nhưng vẫn giữ các staged files và thông điệp commit). Lưu các thay đổi của bạn, thêm tệp mới vào commit nếu cần và commit lại.

Trong cửa số console:

```{bash, eval = FALSE}
git add [YOUR FILES] # Stage your new changes

git commit --amend  # Amend the previous commit

git commit --amend -m "An updated commit message"  # Amend the previous commit AND update the commit message
```

*Lưu ý: hãy suy nghĩ trước khi sửa đổi các commit đã được công khai và chia sẻ với các cộng tác viên của bạn*.

## Pull và push các thay đổi lên Github

"PULL trước, PUSH sau"

Một thực hành tốt đố là *fetch* và *pull* trước khi bạn bắt đầu làm việc dự án của bạn, để cập nhật phiên bản nhánh trên máy tính của bạn với bất kỳ thay đổi nào đã được thực hiện trên nhanh đó ở phiên bản từ xa/Github.

Đừng ngần ngại PULL thường xuyên. *Luôn nhớ pull trước khi push*.

Khi các thay đổi của bạn được thực hiện và được commit, cũng như bạn hài lòng với chúng, bạn có thể *push* (đẩy) commit của mình lên sang phiên bản từ xa/Github nhánh làm việc của bạn.

Kiểm tra và lặp lại trong khi bạn đang làm việc trên kho lưu trữ.

**Lưu ý:** việc khôi phục các thay đổi đã được commit nhưng chưa push lên Github (tức là vẫn còn ở local) dễ dàng hơn nhiều so với các commit đã được push lên kho lưu trữ từ xa (và có thể đã được ai đó pull xuống), vì vậy tốt nhất là bạn nên push những thay đổi khi bạn hoàn thành nó và giới thiệu về các thay đổi mà bạn đã thực hiện.

#### Trong Rstudio {.unnumbered}

*PULL* - Đầu tiên, ấn vào biểu tượng "Pull" (mũi tên hướng xuống) để fetch và pull cùng một lúc.

*PUSH* - Ấn vào icon màu xanh "Push" (mũi tên hướng lên). Bạn có thể được yêu cầu nhập tên người dùng và mật khẩu Github của bạn. Trong lần đầu tiên được hỏi, bạn có thể cần nhập hai dòng lệnh Git sau vào *Terminal*:

-   **git config --global user.email "[you\@example.com](mailto:you@example.com){.email}"** (Địa chỉ email Github của bạn), và\
-   **git config --global user.name "Tên đăng nhập Github của bạn"**

Để tìm hiểu thêm về cách nhập các lệnh này, hãy xem phần bên dưới về các lệnh Git.

***MẸO:*** Bị yêu cầu cung cấp mật khẩu quá nhiều? Xem các chương 10 & 11 trong [hướng dẫn này](https://happygitwithr.com/credential-caching.html#credential-caching) để kết nối với kho lưu trữ bằng khóa SSH (phức tạp hơn)

#### Trong Github Desktop {.unnumbered}

Nhấp vào nút "Fetch origin" để kiểm tra xem có commit mới nào trên kho lưu trữ từ xa hay không.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_fetch_button.png"))
```

Nếu Git tìm thấy các commit mới trên kho lưu trữ từ xa, nút commit sẽ thay đổi thành nút "Push". Bởi vì cùng một nút được sử dụng để push và pull, bạn không thể push các thay đổi của mình nếu bạn không pull trước đó.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_pull_button.png"))
```

Bạn có thể chuyển đến tab "History" (gần tab "Changes") để xem tất cả các commits (của bạn và những người khác). Đây là một cách tốt để tự làm quen với những gì những người cộng tác với bạn đã làm. Bạn có thể đọc các thông điệp commit, các mô tả nếu có và so sánh code của hai tệp bằng cách sử dụng cửa sổ *diff*.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_history.png"))
```

Khi tất cả các thay đổi từ xa đã được pull và ít nhất một thay đổi cục bộ đã được commit, bạn có thể push bằng cách nhấp trên cùng một nút.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_push_button.png"))
```

#### Console {.unnumbered}

Không có gì ngạc nhiên, các lệnh là *fetch*, *pull* và *push*.

```{bash, eval = FALSE}
git fetch  # are there new commits in the remote directory?
git pull   # Bring remote commits into your local branch
git push   # Puch local commits of this branch to the remote branch
```

### Tôi muốn pull nhưng tôi cũng có các chỉnh sửa trong local {.unnumbered}

Điều này đôi khi có thể xảy ra: khi bạn đã thực hiện một số thay đổi trên kho lưu trữ cục bộ của mình, nhưng kho lưu trữ từ xa có các commit mà bạn đã không pull.

Git sẽ từ chối pull vì nó có thể ghi đè các thay đổi của bạn. Có một số chiến lược để giữ các thay đổi của bạn, được mô tả tốt trong trang [Happy Git with R](https://happygitwithr.com/pull-tricky.html), trong đó có hai điểm chính sau:

-   commit các thay đổi của bạn, fetch các thay đổi từ xa, pull chúng xuống, giải quyết các xung đột nếu có (xem phần bên dưới) và push mọi thứ lên

-   `stash` các thay đổi của bạn, tức là lưu trữ chúng sang một bên, sau đó pull và unstash (khôi phục), sau đó commit, giải quyết các xung đột và push.

Nếu các tệp có thay đổi từ remote và hay đổi bởi local không trùng lặp, Git có thể tự động giải quyết các xung đột.

Trong Github Desktop, việc này có thể được thực hiện với các nút bấm. Để stash, hãy truy cập *Branch \> Stash all changes*.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_stash.png"))
```

## Hợp nhất nhánh vào Nhánh chính

Nếu bạn đã thực hiện xong các thay đổi, bạn có thể bắt đầu quá trình hợp nhất những thay đổi đó vào nhánh chính. Tùy thuộc vào tình huống của bạn, việc này có thể nhanh hoặc bạn có thể cần sự xem xét và phê duyệt của các thành viên trong nhóm.

### Hợp nhất cục bộ bằng Github Desktop {.unnumbered}

Bạn có thể hợp nhất các nhánh bằng Github Desktop. Đầu tiên, hãy truy cập (checkout) nhánh sẽ là nơi tiếp nhận các commit, nói cách khác, nhánh bạn muốn cập nhật. Sau đó vào menu và lựa chọn *Branch \> Merge into current branch*. Một hộp thoại sẽ cho phép bạn chọn nhánh bạn muốn nhập vào.

```{r echo=F, fig.align = "center"}
knitr::include_graphics(here::here("images", "github_desktop_merge.png"))
```

### Trong console {.unnumbered}

Đầu tiên hãy quay lại nhánh sẽ nhận các thay đổi. Nó thường là nhánh có tên *master*, nhưng nó cũng có thể là một nhánh khác. Sau đó hợp nhất nhánh làm việc của bạn vào master.

```{bash, eval = FALSE}
git checkout master  # Go back to master (or to the branch you want to move your )
git merge this_fancy_new_branch
```

[Trang này](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging) trình bày một ví dụ nâng cao hơn về phân nhánh và giải thích sơ bộ về cơ chế của nó.

### Trong Github: gửi một pull requests {.unnumbered}

Mặc dù hoàn toàn có thể hợp nhất hai nhánh một cách cục bộ, hoặc không thông báo cho bất kỳ ai, thì việc hợp nhất có thể được thảo luận hoặc kiểm tra bởi một số người trước khi được tích hợp vào nhánh master. Để giúp đỡ quá trình này, Github cung cấp một số tính năng thảo luận cho việc hợp nhất có tên là: **pull request**.

Một pull request (một "PR") là một yêu cầu hợp nhất một nhánh vào một nhánh khác (nói cách khác, một yêu cầu *nhánh làm việc của bạn được pull vào nhánh "chính"*). Một pull request thường bao gồm nhiều lần commit. Một pull request thường bắt đầu một cuộc thảo luận và quá trình review trước khi nó được chấp nhận và được hợp nhất vào nhánh chính. Ví dụ, bạn có thể đọc các cuộc thảo luận về pull request trên [trang github của package dplyr](https://github.com/tidyverse/dplyr/pulls).

Bạn có thể gửi một pull request (PR) trực tiếp từ trang web (như minh họa bên dưới) hoặc từ Github Desktop.

-   Đi tới kho lưu trữ Github (trực tuyến)
-   Xem tab "Pull Requests" và ấn vào nút "New pull request"
-   Chọn nhánh cần hợp nhất từ menu thả xuống để hợp nhất vào nhánh chính
-   Viết chi tiết bình luận cho Pull Request và ấn vào "Create Pull Request".

Trong ảnh dưới đây, nhánh "forest" được chọn để hợp nhất vào nhánh "chính" (main):

```{r echo=F, out.width = '100%', out.height='150%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request2.png"))
```

Bây giờ bạn đã có thể xem một pull request (ảnh minh họa bên dưới):

-   Kiểm tra tab "Files changed" để xem nhánh "chính" sẽ thay đổi như thế nào nếu được hợp nhất.\
-   Ở phía bên phải, bạn có thể yêu cầu một thành viên trong nhóm review bằng cách gắn thẻ (tag) ID Github của họ. Nếu bạn muốn, bạn có thể thiết lập các cài đặt cho repository để yêu cầu một ai đó chấp thuận trước khi hợp nhất vào nhánh chính.\
-   Khi pull request được chấp thuận, nút "Merge pull request" sẽ được active. Hãy ấn vào đó.\
-   Khi hợp nhất thành công, xóa nhánh của bạn như được giải thích bên dưới.

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_pull_request.png"))
```

### Giải quyết xung đột {.unnumbered}

Khi hai người cùng thay đổi code trên cùng một (hoặc nhiều) dòng, thì xung đột khi hợp nhất sẽ xảy ra. Thực tế là Git sẽ từ chối việc đưa ra quyết định phiên bản nào sẽ được giữ, nhưng nó cho phép bạn tìm kiếm nơi xảy ra xung đột. **ĐỪNG HOẢNG LẠN**. Hầu hết các trường hợp khá dễ dàng để giải quyết.

Ví dụ, trên Github:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict2.png"))
```

Sau khi việc hợp nhất nhắc nhở về có xung đột, hãy mở tệp trong trình chỉnh sửa ưa thích của bạn. Xung đột sẽ được đánh dấu bằng một chuỗi các ký tự như sau:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_conflict3.png"))
```

Đoạn văn bản nằm giữa *\<\<\<\<\<\<\< HEAD* và *=======* đến từ local repository của bạn, và đoạn văn bản nằm giữa *=======* và *\>\>\>\>\>\>\>* đến từ một nhánh khác (có thể là bản gốc, master hoặc bất kỳ nhánh nào theo lựa chọn của bạn).

Bạn phải quyết định phiên bản nào của code bạn muốn giữ (hoặc thậm chí viết một phiên bản thứ ba, bao gồm các thay đổi từ cả hai phía), xóa phần còn lại và loại bỏ tất cả các ký tự đánh dấu mà Git đã thêm vào *(\<\<\<\<\<\<\< HEAD, =======, \>\>\>\>\>\>\> origin/master/your_branch_name*).

Sau đó, lưu tệp, stage và commit nó: Đây là commit để tạo phiên bản hợp nhất "chính thức". Đừng quên push sau đó.

Nếu bạn và những người cộng tác với bạn thường xuyên pull và push, thì các xung đột lớn hiếm khi xảy ra.

*Lưu ý: Nếu bạn tự tin tương tác với console, có nhiều [lựa chọn hợp nhất nâng cao](https://git-scm.com/book/en/v2/Git-Tools-Advanced-Merging) (ví dụ: bỏ qua khoảng trống, cho người cộng tác quyền ưu tiên, v.v.).*

### Xóa nhánh của bạn {.unnumbered}

Khi một nhánh đã được hợp nhất vào master và bạn không cần đến nó nữa, bạn có thể xóa nó.

#### Github + Rstudio

Đi tới thư mục lưu trữ trên Github và nhấn nút để xem toàn bộ các nhánh hiện có (cạnh mũi tên trỏ xuống để lựa chọn nhánh). Bây giờ tìm nhánh của bạn và nhấn biểu tượng thúng rác bên cạnh nó. Đọc thêm về cách xóa một nhánh [tại đây](https://docs.github.com/en/free-pro-team@latest/github/collaborating-with-issues-and-pull-requests/creating-and-deleting-branches-within-your-repository#deleting-a-branch).

Hãy chắc chắn là bạn cũng đã xóa nhánh trong máy tính của mình bởi vì quá trình này không được diễn ra một cách tự động.

-   Trong RStudio, hãy chắc chắn bạn đang ở nhánh chính (Main branch)
-   Chuyển sang cửa sổ "Terminal" của RStudio (bên cạnh cửa sổR console), và gõ: **git branch -d branch_name**, trong đó "branch_name" là tên của nhánh mà bạn muốn xóa
-   Refresh lại cửa sổ Git và nhánh đó sẽ biến mất

#### Trong Github Desktop

Đơn giản chỉ cần checkout tới nhánh bạn muốn xóa, và đi tới menu *Branch \> Delete*.

### Forking {.unnumbered}

Bạn có thể fork một dự án nếu bạn muốn đóng góp cho nó nhưng không có quyền để thực hiện, hoặc chỉ là bạn muốn chỉnh sửa cho mục đích sử dụng cá nhân. Một mô tả ngắn về forking có thể xem [tại đây](https://guides.github.com/activities/forking/).

Trong Github, nhấp vào nút "Fork":

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_1.png"))
```

Thao tác này sẽ clone kho lưu trữ gốc, nhưng được lưu trong hồ sơ của bạn. Do đó, bây giờ có hai phiển bản của kho lưu trữ **trong Github**: phiên bản gốc mà bạn không thể chỉnh sửa, và phiên bản clone trong hồ sơ của bạn.

Sau đó, bạn có thể tiếp tục clone phiên bản trực tuyến xuống máy tính của bạn, sử dụng bất kỳ phương pháp nào đã được mô tả bên trên. Tiếp theo, bạn có thể tạo một nhánh mới, tạo các thay đổi, commit và push chúng *lên kho lưu trữ từ xa của bạn*.

Khi bạn hài lòng với các kết quả, bạn có thể tạo một Pull Request từ Github hoặc Github Desktop để bắt đầu một cuộc thảo luận với chủ sở hữu/người bảo trì của kho lưu trữ gốc.

**Nếu bạn muốn lấy những commits mới hơn từ kho lưu trữ gốc thì sao?**

hãy tưởng tượng ai đó đã tạo một thay đổi quan trọng trong kho lưu trữ gốc, và bạn muốn thêm những thay đổi đó vào kho lưu trữ của mình. Điều này là khả thi để đồng bộ hóa kho lưu trữ bạn đã fork với kho lưu trữ gốc. Nó yêu cầu sử dụng terminal, nhưng không quá phức tạp. Bạn chỉ cần nhớ rằng: - *upstream (thượng nguồn)* = kho lưu trữ gốc, là cái mà bạn không thể chỉnh sửa - *origin (bản gốc)* = phiên bản kho lưu trữ trong hồ sơ Github của bạn

Bạn có thể đọc [tutorial này](https://docs.github.com/en/github/collaborating-with-issues-and-pull-requests/syncing-a-fork) hoặc theo dõi các bước dưới đây:

Đầu tiên, gõ vào Git terminal (bên trong repo của bạn):

```{bash, eval = FALSE}
git remote -v
```

Nếu bạn chưa từng cấu hình upstream repository (kho lưu trữ gốc), bạn sẽ thấy hai dòng, bắt đầu bởi từ *origin*. Chúng hiển thị kho lưu trữ từ xa để `fetch` và `push` các điểm vào. Hãy nhớ, *origin* là biệt danh thường dùng cho phiên bản kho lưu trữ của chính bạn trên Github. Ví dụ:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_2.png"))
```

Bây giờ, thêm một kho lưu trữ từ xa:

```{bash, eval = FALSE}
git remote add upstream https://github.com/appliedepi/epirhandbook_eng.git
```

Địa chỉ ở đây là địa chỉ mà Github tạo ra khi bạn clone một repository (xem mục về cloning). Bây giờ bạn sẽ có bốn điểm từ xa:

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_3.png"))
```

Quá trình thiết lập đã xong. Bất cứ khi nào bạn muốn lấy các sự thay đổi từ kho lưu trữ gốc (*upstream*), bạn chỉ cần đi tới (*checkout*) nhánh bạn muốn cập nhật và gõ:

```{bash, eval = FALSE}
git fetch upstream # Get the new commits from the remote repository
git checkout the_branch_you_want_to_update
git merge upstream/the_branch_you_want_to_update  # Merge the upstream branch into your branch.
git push # Update your own version of the remote repo
```

Nếu có xung đột, bạn sẽ phải giải quyết chúng như đã trình bày ở bên trên.

**Tổng kết**: forking là cloning, nhưng chỉ trên phía máy chủ của Github. Các hành động còn lại là điển hình của mô quy trình cộng tác(clone, push, pull, commit, merge, gửi pull requests...).

*Lưu ý: trong khi forking là một khái niệm, không phải là một lệnh Git, nó cũng tồn tại ở các nền tảng khác, chẳng hạn như [Bitbucket](https://www.atlassian.com/git/tutorials/comparing-workflows/forking-workflow).*

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_fork_4.png"))
```

## Chúng ta đã học được những gì

Bạn đã học được cách:

-   thiết lập Git để theo dõi sự thay đổi trong thư mục của bạn,\
-   kết nối kho lưu trữ cục bộ và từ xa,\
-   commit các thay đổi,\
-   đồng bộ kho lưu trữ cục bộ và từ xa.

Tất cả chúng là khá đầy đủ cho những nhu cầu của một nhà dịch tễ học. Chúng ta thường không cần sử dụng những chức năng nâng cao như những lập trình viên.

Tuy nhiên, nếu bạn muốn (hoặc cần) đi xa hơn, Git cung cấp nhiều tính năng để đơn giản hóa lịch sử commit, khôi phục một hoặc nhiều commits, cherry-pick commits (chỉ lấy một vài commit trong PR), v.v. Một số chúng nghe thực sự rất thần thánh, nhưng không sao vì bạn đã có cơ bản rồi, sẽ dễ dàng để bổ sung kiến thức trên nền tảng đó.

Lưu ý là trong khi cửa sổ Git trong Rstudio và Github Desktop tốt cho những người mới bắt đầu / sử dụng trong các công việc hàng này, thì chúng không cung cấp giao diện cho những hàm Git trung cấp / cao cấp. Các giao diện đầy đủ hơn cho phép bạn phải sử dụng những tính năng nâng cao chỉ với các thao tác chuột (thông thường phải trả phí).

Hãy nhớ là bạn có thể sử dụng bất kỳ công cụ nào tại mọi thời điểm để theo dõi kho lưu trữ của mình, do đó bạn có thể cài đặt một giao diện để thỉnh thoảng sử dụng, hoặc thực hiện những tác vụ không phiỉ biến, trong khi lựa chọn một giao diện đơn giản hầu hết thời gian (vd: sử dụng Github Desktop phần lớn thời gian, và chuyển qua phần mềm SourceTree hoặc Gitbash cho những tác vụ cụ thể).

## Các lệnh Git {#git}

### Được khuyến khích học {.unnumbered}

Để học các lệnh Git một cách tương tác, xem [trang web này](https://learngitbranching.js.org/).

### Gõ lệnh vào đâu {.unnumbered}

Bạn gõ lệnh vào Git shell.

*Lựa chọn 1* Bạn mở một Terminal mới trong RStudio. Tab này ở bên cạnh R Console. Nếu bạn không thể gõ trên đó, nhấp vào menu thả xuống ở dưới chữ "Terminal" và chọn "New terminal". Gõ lệnh ở khoảng trống phía sau ký tự dollar "\$".

```{r echo=F, out.width = '100%', out.height='200%', fig.align = "center"}
knitr::include_graphics(here::here("images", "github_terminal.png"))
```

*Lựa chọn 2* Bạn cũng có thể mở một *shell* (một terminal để gõ lệnh) bằng cách nhấp vào biểu tượng "bánh răng" màu xanh trong cửa sổ Git (bên cạnh cửa sổ RStudio Environment). Chọn "Shell" từ menu thả xuống. Một cửa sổ mới sẽ mở ra nơi mà bạn có thể gõ các lệnh sau ký tự dollar "\$".

*Lựa chọn 3* Nháy chuột phải để mở "Git Bash here", cho phép mở một cửa sổ terminal tương tự, hoặc mở *Git Bash* từ danh sách ứng dụng của bạn. [Các thông tin về Git Bash cho người mới bắt đầu](https://happygitwithr.com/shell.html), cách tìm nó và một số lệnh bash bạn sẽ cần.

### Một số lệnh mẫu {.unnumbered}

Sau đây chúng tôi sẽ trình bày một số lệnh git phổ biến. Khi bạn sử dụng chúng, hãy chú ý nhánh nào đang được active (checked-out), bởi vì điều này sẽ quyết định hành động nào được thực hiện!

Trong các lệnh dưới đây, <name> đại diện cho tên nhánh. <commit_hash> đại diện cho hash ID của một commit cụ thể. <num> đại diện cho một số. Bạn không cần gõ ký tự \< hoặc \>.

+---------------------------+--------------------------------------------------------------+
| Lệnh Git                  | Hành động                                                    |
+===========================+==============================================================+
| `git branch <name>`       | Tạo một nhánh mới có tên <name>                              |
+---------------------------+--------------------------------------------------------------+
| `git checkout <name>`     | Chuyển từ nhánh hiện tại sang nhánh có tên <name>            |
+---------------------------+--------------------------------------------------------------+
| `git checkout -b <name>`  | Lối tắt để tạo nhánh mới *và* chuyển qua nó                  |
+---------------------------+--------------------------------------------------------------+
| `git status`              | Xem những thay đổi không được theo dõ                        |
+---------------------------+--------------------------------------------------------------+
| `git add <file>`          | Stage một tệp                                                |
+---------------------------+--------------------------------------------------------------+
| `git commit -m <message>` | Commit những thay đổi tới nhánh hiện tại kèm một thông điệp  |
+---------------------------+--------------------------------------------------------------+
| `git fetch`               | Fetch các commit từ kho lưu trữ trực tuyến                   |
+---------------------------+--------------------------------------------------------------+
| `git pull`                | Pull các commit từ kho lưu trữ trực tuyến tới nhánh hiện tại |
+---------------------------+--------------------------------------------------------------+
| `git push`                | Push các commits trong local lên thư mục trực tuyến          |
+---------------------------+--------------------------------------------------------------+
| `git switch`              | Cách khác của `git checkout`                                 |
+---------------------------+--------------------------------------------------------------+
| `git merge <name>`        | Hợp nhất nhánh có tên <name> vào nhánh hiện tại              |
+---------------------------+--------------------------------------------------------------+
| `git rebase <name>`       | Thêm các commit từ nhánh hiện tại vào nhánh có tên <name>    |
+---------------------------+--------------------------------------------------------------+

<!-- ======================================================= -->

## Tài nguyên học liệu

Phần lớn chương này lấy thông tin từ [trang web "Happy Git with R"](https://happygitwithr.com/) viết bởi Jenny Bryan. Có một chuyên mục rất hữu ích trong trang web đó có thể giúp bạn giải quyết những lỗi phổ biến về Git và các lỗi liên quan tới R.

Tài liệu [Github.com documentation and start guide](https://docs.github.com/en/github).

RStudio ["IDE" cheatsheet](https://www.rstudio.com/wp-content/uploads/2016/01/rstudio-IDE-cheatsheet.pdf) bao gồm các mẹo về Git với RStudio.

<https://ohi-science.org/news/github-going-back-in-time>

**Lệnh Git cho người mới**

Một [hướng dẫn tương tác](learngitbranching.js.org) để học các lệnh Git.

<https://www.freecodecamp.org/news/an-introduction-to-git-for-absolute-beginners-86fa1d32ff71/>: tốt cho việc học những thứ cơ bản để theo dõi các thay đổi trong một thư mục của máy tính của bạn

Lược đồ để hiểu về nhánh: <https://speakerdeck.com/alicebartlett/git-for-humans>

**Hướng dẫn bao gồm các chủ đề cơ bản và nâng cao**

<https://tutorialzine.com/2016/06/learn-git-in-30-minutes>

<https://dzone.com/articles/git-tutorial-commands-and-operations-in-git> <https://swcarpentry.github.io/git-novice/> (khóa ngắn hạn) <https://rsjakob.gitbooks.io/git/content/chapter1.html>

Sách [Pro Git](https://git-scm.com/book/en/v2) được xem là tài liệu tham khảo chính thức. Trong khi một số chương khá ổn, đa số khá nặng *tính kỹ thuật*. Nó có thể là một nguồn tốt khi bạn đã sử dụng Git một thời gian và muốn học thêm những kiến thức nâng cao.
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/collaboration.Rmd-->


# Các lỗi thường gặp {#errors}  

Chương này bao gồm một danh sách các lỗi phổ biến và các giải pháp đề xuất để khắc phục chúng.  


## Phiên giải thông báo lỗi  

Các lỗi trong R đôi khi có thể khó hiểu, vì vậy Google là bạn của bạn. Tìm kiếm thông báo lỗi với “R” và tìm các bài đăng gần đây trong [StackExchange.com](StackExchange.com), [stackoverflow.com](stackoverflow.com), [community.rstudio.com](community.rstudio.com), twitter (#rstats), và các diễn đàn khác được lập trình viên sử dụng để gửi câu hỏi và câu trả lời. Hãy cố gắng tìm các bài đăng gần đây đã giải quyết các vấn đề tương tự.  

Nếu sau nhiều lần tìm kiếm, bạn không thể tìm thấy câu trả lời cho vấn đề của mình, hãy cân nhắc tạo một *ví dụ có thể tái tạo* ("reprex") và tự đăng câu hỏi. Xem chương [Nhờ sự trợ giúp] để biết các mẹo về cách tạo và đăng một ví dụ có thể tái tạo lên diễn đàn. 


## Các lỗi thường gặp 

Dưới đây, chúng tôi liệt kê một số lỗi phổ biến và các giải thích/giải pháp tiềm năng. Một số trong số này được mượn từ Noam Ross, người đã phân tích các bài đăng phổ biến nhất trên diễn đàn Stack Overflow về các thông báo lỗi trên R (xem bài phân tích [tại đây](https://github.com/noamross/zero-dependency-problems/blob/master/misc/stack-overflow-common-r-errors.md))  


### Lỗi đánh máy {.unnumbered}  

```
Error: unexpected symbol in:
"  geom_histogram(stat = "identity")+
  tidyquant::geom_ma(n=7, size = 2, color = "red" lty"
```
Nếu bạn thấy lỗi "unexpected symbol", kiểm tra xem có thiếu dấu phẩy không  



### Các lỗi liên quan đến Package {.unnumbered}  

```
could not find function "x"...
```
Điều này có thể có nghĩa là bạn đã nhập sai tên hàm hoặc quên cài đặt hoặc gọi một package.


```
Error in select(data, var) : unused argument (var)
```
Bạn nghĩ rằng bạn đang sử dụng `dplyr::select()` nhưng thực tế là hàm `select()` đã bị đè bởi hàm `MASS::select()` - hãy ghi rõ `dplyr::` hoặc sắp xếp lại thứ tự các package được gọi để dplyr đứng sau tất cả các package khác.

Các lỗi hàm bị đè phổ biến khác bắt nguồn từ: `plyr::summarise()` và `stats::filter()`. Cân nhắc sử dụng [**conflicted** package](https://www.tidyverse.org/blog/2018/06/conflicted/).




```
Error in install.packages : ERROR: failed to lock directory ‘C:\Users\Name\Documents\R\win-library\4.0’ for modifying
Try removing ‘C:\Users\Name\Documents\R\win-library\4.0/00LOCK’
```

Nếu bạn gặp lỗi thông báo rằng bạn cần xóa tệp "00LOCK", go to your "R" library in your computer directory (e.g. R/win-library/) and look for a folder called "00LOCK". Delete this manually, and try installing the package again. A previous install process was probably interrupted, which led to this.  




### Các lỗi liên quan tới đối tượng {.unnumbered}  

```
No such file or directory:
```
Nếu bạn gặp lỗi như thế này khi cố gắng xuất hoặc nhập: Hãy kiểm tra lỗi chính tả của tệp và đường dẫn tệp và nếu đường dẫn chứa dấu gạch chéo, hãy đảm bảo rằng bạn đang dùng dấu gạch chéo xuôi `/` chứ không phải dấu gạch chéo ngược `\`. Ngoài ra, hãy đảm bảo rằng bạn đã sử dụng đúng phần mở rộng tệp (ví dụ: .csv, .xlsx).  


```
object 'x' not found 
```
Điều này có nghĩa là một đối tượng bạn đang tham chiếu không tồn tại. Có lẽ code trên đã không chạy đúng cách? 


```
Error in 'x': subscript out of bounds
```
Điều này có nghĩa là bạn đã cố gắng truy cập vào thứ gì đó (một phần tử của vectơ hoặc danh sách) không có ở đó. 




### Các lỗi liên quan tới cú pháp hàm {.unnumbered}

```
# ran recode without re-stating the x variable in mutate(x = recode(x, OLD = NEW)
Error: Problem with `mutate()` input `hospital`.
x argument ".x" is missing, with no default
i Input `hospital` is `recode(...)`.
```
Lỗi bên trên (`argument .x is missing, with no default`) thường gặp với hàm `mutate()` nếu bạn đang cung cấp một hàm như `recode()` hoặc `replace_na()` trong đó nó yêu cầu bạn cung cấp tên cột làm đối số đầu tiên. Điều này rất dễ quên.  



### Các lỗi logic {.unnumbered}  

```
Error in if
```

Điều này có thể có nghĩa là một mệnh đề `if` đã được áp dụng cho một cái gì đó không phải là TRUE hoặc FALSE.  


### Các lỗi liên quan tới Factor {.unnumbered}  

```
#Tried to add a value ("Missing") to a factor (with replace_na operating on a factor)
Problem with `mutate()` input `age_cat`.
i invalid factor level, NA generated
i Input `age_cat` is `replace_na(age_cat, "Missing")`.invalid factor level, NA generated
```
Nếu bạn nhìn thấy lỗi liên quan tới thứ bậc kiểu factor không hợp lệ, có thể bạn đang có một cột kiểu Factor(chứa các thứ bậc đã được xác định) và bạn đang cố gắng thêm một giá trị mới vào nó. Chuyển nó thành kiểu ký tự trước khi thêm giá trị mới.  


### Lỗi khi vẽ biểu đồ {.unnumbered}  

`Error: Insufficient values in manual scale. 3 needed but only 2 provided.`
Đây có thể là lỗi khi bạn vẽ biểu đồ bằng ggplot, sử dụng scale_fill_manual() values = c("orange", "purple"), trong đó bạn chưa cung cấp đủ số lượng màu cho hàm. Nếu cột này dạng factor, hãy cân nhắc liệu NA có phải là một bậc của factor hay không.

```
Can't add x object
```
Bạn có thể thừa dấu `+` ở cuối lệnh ggplot mà bạn cần xóa.


### Lỗi R Markdown {.unnumbered}  

Nếu thông báo lỗi là `Error in options[[sprintf("fig.%s", i)]]`, kiểm tra xem các tùy chọn của knitr ở đầu mỗi đoạn code có sử dụng chính xác `out.width = ` hoặc `out.height = ` và *không phải* `fig.width=` và `fig.height=` hay không.

### Tổng hợp {.unnumbered}  

Cân nhắc liệu bạn có đã sắp xếp lại các hàm đã được pipe trong package **dplyr** và đã không thay thế một pipe ở giữa, hoặc đã không xóa một pipe ở cuối sau khi sắp xếp lại.

 


<!-- ======================================================= -->
## Nguồn { }

Đây là một bài đăng trên blog khác liệt kê [Các lỗi lập trình R phổ biến mà người mới bắt đầu gặp phải](https://www.r-bloggers.com/2016/06/common-r-programming-errors-faced-by-beginners/)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/errors.Rmd-->


# Nhờ sự trợ giúp {#help}

Chương này hướng dẫn cách nhận trợ giúp bằng cách đăng vấn đề mà bạn gặp phải lên Github hoặc đưa ra một ví dụ giả lập ("reprex") lên các diễn đàn trực tuyến. 



## Đăng vấn đề lên Github 

Nhiều packages và dự án trong R được lưu trữ mã code của chúng trên trang web Github.com. Bạn có thể trao đổi trực tiếp với các tác giả của các package hoặc dự án này bằng cách đăng một "Issue" qua trang web Github.com..

Tìm hiểu thêm về cách lưu trữ các tệp của bạn trên Github trong chương [Version control với Git và Github].

Trên Github, mỗi dự án được chứa trong một *kho lưu trữ*. Mỗi kho chứa code, dữ liệu, kết quả đầu ra, tài liệu trợ giúp, v.v. Ngoài ra còn có một cách để trao đổi với các tác giả được gọi là "Issues". 

Xem các ảnh bên dưới về Github để hiểu thêm về package **incidence2** (được sử dụng để tạo đường cong dịch bệnh). Trong ảnh dưới, bạn có thể thấy mục "Issues" được tô màu vàng. Số 5 bên cạnh chữ "Issues" có nghĩa là có 5 vấn đề đang được mở.  

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_Github_issues.png"))
```

Ấn vào mục Issues, bạn có thể thấy các vấn đề đang mở được hiện ra. Hãy xem lại chúng để đảm bảo những vấn đề này chưa được giải quyết. Bạn có thể mở một vấn đề mới bằng cách nhấp vào nút màu xanh lá cây "New issue" ở bên phải. Để thực hiện những thao tác này, bạn sẽ cần mở một tài khoản Github. 

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_Github_issues2.png"))
```


Để đọc các tài liệu nâng cao hơn về cách xử lý các vấn đề trong kho lưu trữ Github của riêng bạn, hãy xem [Tài liệu về Issues](https://guides.github.com/features/issues/) trong Github.  



## Ví dụ giả lập 

Cung cấp một ví dụ giả lập ("reprex") là chìa khóa để nhận được giúp đỡ khi đăng bài thảo luận trên các diễn đàn hoặc trong vấn đề Github issue. Để người khác có thể giúp bạn, bạn phải cho họ một ví dụ cụ thể để họ có thể xử ý vấn dề của bạn trên máy tính của chính họ. Ví dụ của bạn cần phải:

* Trình bày sự cố bạn gặp phải 
* Hãy nhớ *ngắn gọn nhất có thể*, bạn chi cân ghi dữ liệu và đoạn code cần thiết để giả lập lại sự cố của bạn
* Đủ thông tin để *giả lập* lại tình huống của bạn, ví dụ như các thông tin như các đối tượng (ví dụ: dữ liệu), tất cả package được gọi (ví dụ:  `library()` hoặc `p_load()`).

*Ngoài ra, hãy đảm bảo rằng bạn không đăng bất kỳ dữ liệu nhạy cảm nào với reprex!* Bạn có thể tạo các data frames mẫu hoặc sử dụng một trong các data frames có sẵn trong R (nhập `data()`để mở danh sách các tập dữ liệu này). 



### Package **reprex**  {.unnumbered}  

Package **reprex** có thể hỗ trợ bạn tạo một ví dụ giả lập 

1) Package **reprex** được cài đặt với package **tidyverse**, vì vậy hãy gọi một trong hai package: 

```{r, eval=F}
# install/load tidyverse (which includes reprex)
pacman::p_load(tidyverse)
```

2) Bắt đầu một đoạn R script tạo ra vấn đề của bạn, hãy làm từng từng bước một, bắt đầu từ việc tải các package và dữ liệu. 

```{r, eval=F}
# load packages
pacman::p_load(
     tidyverse,  # data mgmt and vizualization
     outbreaks)  # example outbreak datasets

# flu epidemic case linelist
outbreak_raw <- outbreaks::fluH7N9_china_2013  # retrieve dataset from outbreaks package

# Clean dataset
outbreak <- outbreak_raw %>% 
     mutate(across(contains("date"), as.Date))

# Plot epidemic

ggplot(data = outbreak)+
     geom_histogram(
          mapping = aes(x = date_of_onset),
          binwidth = 7
     )+
  scale_x_date(
    date_format = "%d %m"
  )

```

*Sao chép* tất cả code vào bộ nhớ tạm của bạn và chạy lệnh sau: 

```{r, eval=F}
reprex::reprex()
```

Bạn sẽ thấy một tệp HTML xuất hiện trong cửa sổ RStudio Viewer. Nó sẽ chứa tất cả code của bạn và bất kỳ cảnh báo, lỗi hoặc biểu đồ nào. Tệp này cũng được sao chép vào bộ nhớ tạm của bạn, vì vậy bạn có thể đăng trực tiếp nó lên một vấn đề trên Github hoặc một bài đăng trên diễn đàn. 

```{r, out.width=c('100%', '100%'), warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "errors_reprex_RStudio1.png"))
```


* Nếu bạn đặt `session_info = TRUE`, thì kết quả đầu ra của lệnh `sessioninfo::session_info()` sẽ được bao gồm với các phiên bản R và package R của bạn. 
* Bạn có thể cung cấp một thư mục làm việc cho `wd = `  
* Bạn có thể đọc thêm về các đối số và các biến số có thể có tại [Tài liệu này]() hoặc bằng cách nhập `?reprex`

Trong ví dụ trên, lệnh `ggplot()` không chạy vì đối số `date_format =` không đúng. Nó phải là `date_labels = `. 


### Bộ dữ liệu tối giản {.unnumbered}  

Những người giúp bạn cần sử dụng dữ liệu của bạn - lý tưởng nhất là họ có thể tạo ra nó *bằng code*.  

Để tạo một tập dữ liệu tối giản, hãy xem xét việc ẩn danh và chỉ sử dụng một tập con của các quan sát. 

ĐANG ĐƯỢC PHÁT TRIỂN - Bạn có thể sử dụng lệnh `dput()` để tạo một bộ dữ liệu tối giản.  




## Đăng lên diễn đàn   

Bạn cần đọc nhiều bài viết trên diễn đàn. Hiểu được bài đăng nào được viết tốt và bài nào thì không.  

1) Đầu tiên, bạn hãy quyết định xem có nên đặt câu hỏi hay không. Bạn đã *kỹ lưỡng* tìm kiếm câu trả lời trên các trang web diễn đàn, thử các cụm từ tìm kiếm khác nhau, để xem liệu câu hỏi của bạn đã được đặt ra chưa? 
2) Đặt cho câu hỏi của bạn với một tiêu đề thông tin đầy đủ (không phải "Trợ giúp! Điều này không hoạt động").
3) Viết câu hỏi của bạn:  

* Giới thiệu hoàn cảnh và vấn đề của bạn
* Liên kết đến các bài đăng về các vấn đề tương tự và giải thích cách họ không trả lời câu hỏi của bạn
* Ghi bất kỳ thông tin liên quan nào để giúp những người không rõ bối cảnh công việc của bạn
* Đưa ra một ví dụ giả lập với thông tin tối thiểu về phiên làm việc R của bạn
* Sử dụng đúng chính tả, ngữ pháp, dấu câu và ngắt câu hỏi của bạn thành các đoạn văn để dễ đọc hơn 

4) Theo dõi câu hỏi của bạn sau khi được đăng để trả lời bất kỳ yêu cầu làm rõ nào. Lịch sự và nhã nhặn - thường những người trả lời đều tình nguyện dành thời gian của họ để giúp bạn. Nếu bạn có một câu hỏi tiếp theo, hãy cân nhắc xem nó có nên là một câu hỏi được đăng riêng hay không. 

5) Đánh dấu câu hỏi là đã trả lời, *nếu* bạn đã nhận được câu trả lời đáp ứng yêu cầu *ban đầu* của bạn. Điều này giúp những người truy cập sau nhanh chóng nhận ra giải pháp cho vấn đề tương tự với bạn. 


Đọc những bài đăng này trong các tài liệu [Cách đặt một câu hỏi tốt](https://stackoverflow.com/help/how-to-ask) và [Bộ quy tắc ứng xử](https://stackoverflow.com/conduct).  


<!-- ======================================================= -->
## Tài liệu tham khảo { }


Package Tidyverse về cách [nhận trợ giúp!](https://www.tidyverse.org/help/#:~:text=When%20you%20want%20to%20make,to%20load%20the%20reprex%20package.&text=Enter%20reprex()%20in%20the,preview%20of%20your%20rendered%20reprex.)

Lời khuyên về [tạo ra một tập dữ liệu tối thiểu](https://xiangxing98.github.io/R_Learning/R_Reproducible.nb.html#producing-a-minimal-dataset)

Tài liệu về [Hàm dput](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/dput)
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/help.Rmd-->


# R trên ổ cứng mạng {#network-drives}  

 


<!-- ======================================================= -->
## Tổng quan {  }

Việc sử dụng R trên một ổ cứng mạng dùng chung tại “công ty” hoặc một nhóm có thể gây ra một số vấn đề phát sinh. Chương này sẽ giới thiệu các phương pháp tiếp cận, các lỗi phổ biến và các đề xuất về cách khắc phục sự cố từ những bài học kinh nghiệm của chúng tôi khi giải quyết các vấn đề này. Chúng bao gồm các mẹo cho các tình huống khó liên quan đến R Markdown. 


**Sử dụng R trên ổ cứng mạng: Một số nguyên tắc chính**  

1) Bạn phải có quyền truy cập quản trị đối với máy tính của mình. Thiết lập RStudio đặc biệt để chạy với tư cách quản trị viên (run as administrator). 
2) Hãy lưu các packages trong thư viện trên một ổ cứng vật lý (ví dụ: "C:"). Hạn chế tối đa Sử dụng package thư viện có đường dẫn bắt đầu bằng "\\\".  
3) Package **rmarkdown** **không được** nằm trong thư viện package "\\\", vì khi đó nó không thể kết nối với TinyTex hoặc Pandoc. 




## RStudio với tư cách quản trị viên  

Bạn cần nhấp vào biểu tượng RStudio để mở RStudio, sau đó bấm chuột phải. Tùy thuộc vào máy của bạn, bạn có thể thấy tùy chọn "Run as Administrator". Nếu không, bạn có thể thấy một tùy chọn để chọn Properties (sau đó sẽ xuất hiện một cửa sổ có tùy chọn "Compatibility" và bạn có thể chọn hộp kiểm "Run as Administrator"). 



## Các lệnh hữu ích  

Dưới đây là một số lệnh hữu ích trong việc khắc phục sự cố khi sử dụng R trên ổ đĩa mạng. 

Bạn có thể trả về (các) đường dẫn đến các thư thư mục lưu trữ package mà R đang sử dụng. Chúng sẽ được liệt kê theo thứ tự mà R đang sử dụng để cài đặt/tải/tìm kiếm các packages. Vì vậy, nếu bạn muốn R sử dụng một thư viện mặc định khác, bạn có thể chuyển đổi thứ tự của các đường dẫn này (xem bên dưới). 

```{r, eval=F}
# Find libraries
.libPaths()                   # Your library paths, listed in order that R installs/searches. 
                              # Note: all libraries will be listed, but to install to some (e.g. C:) you 
                              # may need to be running RStudio as an administrator (it won't appear in the 
                              # install packages library drop-down menu) 
```

 
Bạn có thể muốn chuyển đổi thứ tự của các thư viện package được sử dụng bởi R. Ví dụ: nếu R đang chọn một vị trí thư viện với đường dẫn bắt đầu bằng "\\\" và một đường dẫn bắt đầu bằng chữ cái, ví dụ: "D:". Bạn có thể điều chỉnh thứ tự của `.libPaths()` bằng đoạn mã code dưới đây.  

````{r, eval=F}
# Switch order of libraries
# this can effect the priority of R finding a package. E.g. you may want your C: library to be listed first
myPaths <- .libPaths() # get the paths
myPaths <- c(myPaths[2], myPaths[1]) # switch them
.libPaths(myPaths) # reassign them
```

Nếu bạn gặp khó khăn với R Markdown kết nối với Pandoc, hãy bắt đầu với đoạn code mã này để tìm hiểu RStudio cài đặt Pandoc của bạn ở đâu. 

```{r, eval=F}
# Find Pandoc
Sys.getenv("RSTUDIO_PANDOC")  # Find where RStudio thinks your Pandoc installation is
```

Nếu bạn muốn xem package đang được tải từ thư viện ở đâu, hãy thử đoạn code dưới đây: 

```{r, eval=F}
# Find a package
# gives first location of package (note order of your libraries)
find.package("rmarkdown", lib.loc = NULL, quiet = FALSE, verbose = getOption("verbose")) 
```



<!-- ======================================================= -->
## Khắc phục các lỗi thường gặp {  }


**"Failed to compile…tex in rmarkdown"**  

* Kiểm tra cài đặt TinyTex hoặc cài đặt TinyTex vào ổ C:. Xem thêm chương [R cơ bản] để biết về cách cài đặt TinyTex 

```{r, eval=F}
# check/install tinytex, to C: location
tinytex::install_tinytex()
tinytex:::is_tinytex() # should return TRUE (note three colons)
```


**Internet routines cannot be loaded**  

Ví dụ, `Error in tools::startDynamicHelp() : internet routines cannot be loaded`  

* Thử chọn phiên bản 32-bit từ RStudio qua Tools/Global Options .  
  * Chú ý: nếu phiên bản 32-bit không xuất hiện trong menu, hãy đảm bảo rằng bạn không sử dụng RStudio phiên bản 1.2.  
* Ngoài ra, hãy thử gỡ cài đặt R và cài đặt lại với phiên bản bit khác (32 thay vì 64) 


**C: library does not appear as an option when I try to install packages manually**

* Chạy RStudio với tư cách quản trị viên, sau đó tùy chọn này sẽ xuất hiện.  
* Để thiết lập R Studio luôn chạy với tư cách quản trị viên (thuận tiện khi sử dụng dự án R mà bạn không nhấp vào biểu tượng R Studio để mở) ... nhấp chuột phải vào biểu tượng R studio 

Hình ảnh bên dưới cho thấy cách bạn có thể chọn thủ công thư viện để cài đặt một gói. Cửa sổ này xuất hiện khi bạn mở ngăn Packages RStudio và nhấp vào "Install". 

```{r, warning=F, message=F, echo=F}
knitr::include_graphics(here::here("images", "network_install.png"))
```

**Pandoc 1 error**  

Nếu bạn gặp phải "pandoc error 1" khi knitting tập lệnh R Markdowns trên ổ đĩa mạng:

* Trong số nhiều vị trí thư viện đặt lưu trữ, hãy chọn một vị trí ổ cứng bắt đầu bằng một chữ cái (xem lại ở trên)
* Giải pháp trên có thể thực hiện được khi knitting trên ổ đĩa cá nhân trong khi máy tính có kết nối internet
* Xem thêm các mẹo khác tại đây: https://ciser.cornell.edu/rmarkdown-knit-to-html-word-pdf/ 

**Pandoc Error 83**  

Lỗi sẽ có dạng như sau: `can't find file...rmarkdown...lua...`. Điều này có nghĩa là nó không thể tìm thấy tệp này. 

Xem thêm tại đây: https://stackoverflow.com/questions/58830927/rmarkdown-unable-to-locate-lua-filter-when-knitting-to-word  

Các khả năng có thể xảy ra:

1) Package Rmarkdown chưa được cài đặt
2) Package Rmarkdown không thể tìm thấy
3) Vấn đề về quyền quản trị. 

Có thể R không thể tìm thấy các package sử dụng trong file **rmarkdown**, vì vậy hãy kiểm tra thư viện nào mà package trong **rmarkdown**  đang được lưu trữ (xem đoạn code để thực hiện thao tác này ở trên). Nếu package được cài đặt vào một thư viện không thể truy cập được (ví dụ: bắt đầu bằng "\\\") hãy xem xét việc di chuyển nó sang C: hoặc thư viện ổ cứng theo cách thủ công. Lưu ý rằng package **rmarkdown** phải có thể kết nối với cài đặt TinyTex, vì vậy không thể tồn tại trong thư viện trên ổ đĩa mạng. 

**Lỗi Pandoc 61**  

Vú dụ: `Error: pandoc document conversion failed with error 61`  hoặc `Could not fetch...`  

* Thử chạy RStudio với tư cách quản trị viên (nhấp chuột phải vào biểu tượng, chọn chạy với tư cách quản trị viên, xem hướng dẫn ở trên)
* Ngoài ra, hãy xem nếu có package cụ thể nào không thể truy cập được có thể được chuyển đến ổ C: library. 

**Lỗi LaTex (xem bên dưới)**

Một lỗi như:  `! Package pdftex.def Error: File 'cict_qm2_2020-06-29_files/figure-latex/unnamed-chunk-5-1.png' not found: using draft setting.` hoặc `Error: LaTeX failed to compile file_name.tex.`  

* Xem thêm tại đây https://yihui.org/tinytex/r/#debugging để biết các mẹo debug.  
* Xem thêm file_name.log để biết thêm chi tiết.


**Lỗi Pandoc 127**  

Đây có thể là vấn đề về RAM (dung lượng). Hãy bắt đầu lại phiên làm việc R của bạn và thử lại. 

**Định vị các ổ đĩa mạng**

Định vị ổ đĩa mạng có thể gặp một số rủi ro. Hãy tham khảo ý kiến với bộ phận CNTT của bạn trước khi làm!

Bạn có thể xem thêm các [thảo luận trên diễn đàn này ](https://stackoverflow.com/questions/48161177/r-markdown-openbinaryfile-does-not-exist-no-such-file-or-directory/55616529?noredirect=1#comment97966859_55616529): 

Làm cách nào để mở một tệp "thông qua một ổ đĩa mạng đã được đinh vị"? 

* Trước tiên, bạn cần biết vị trí ổ mạng mà bạn đang cố gắng truy cập.
* Tiếp theo, trong trình quản lý tệp của Windows, bạn sẽ cần phải nhấp chuột phải vào "Máy tính này" ở ngăn bên phải và chọn "Map a network drive".
* Đi qua hộp thoại để xác định vị trí mạng trước đó dưới dạng ổ đĩa có tên bắt đầu chữ cái.
* Bây giờ bạn có hai cách để truy cập tệp bạn đang mở. Sử dụng đường dẫn ổ đĩa bắt đầu bằng ký tự có thể hoạt động. 

**Lỗi khi cài đặt install.packages()**  

Nếu bạn gặp lỗi bao gồm đề cập đến thư mục "khóa", ví dụ:  `Error in install.packages : ERROR: failed to lock directory...`

Tìm trong thư viện package của bạn và bạn sẽ thấy một thư mục có tên bắt đầu bằng "00LOCK". Hãy thử các mẹo sau: 

* Xóa thủ công thư mục thư mục "00LOCK" khỏi thư viện package của bạn. Thử cài đặt lại package này. 
* Bạn cũng có thể thử lệnh `pacman::p_unlock()` (bạn cũng có thể đặt lệnh này trong Rprofile để nó chạy mỗi khi mở dự án). Sau đó, hãy thử cài đặt lại package. Bạn có thể cần thử một vìa lần. 
* Thử chạy RStudio ở chế độ Quản trị viên và thử cài đặt từng package một.
* Nếu vẫn không thành công, hãy cài đặt packge vào thư viện hoặc thư mục khác (ví dụ: Temp) và sau đó sao chép thủ công thư mục của package vào thư viện mong muốn. 




```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/network_drives.Rmd-->

# Data Table {#data-table}

Cuốn sổ tay này tập trung vào các hàm của **dplyr** và toán tử pipe của **magrittr** `%>%` như một phương pháp để làm sạch và nhóm dữ liệu, tuy nhiên package **data.table** cũng cung cấp một giải pháp thay thế mà bạn có thể sử dụng trong quá trình làm việc với R của mình.

<!-- ======================================================= -->

## Giới thiệu về data table

Một data table là một cấu trúc dữ liệu 2-chiều giống như một data frame mà cho phép thực hiện các thao tác phân nhóm phức tạp. Cú pháp data.table được cấu trúc để có thể thực hiện các thao tác trên hàng, cột và nhóm.

Cấu trúc là **DT[i, j, by]**, được chia thành 3 phần; đối số **i, j** và **by**. Đối số **i** cho phép tạo tập con trên các hàng được yêu cầu, đối số **j** cho phép bạn vận hành trên cột và đối số **by** cho phép bạn vận hành theo nhóm.

Chương này sẽ giải quyết các chủ đề sau:

-   Nhập dữ liệu và sử dụng `fread()` và `fwrite()`
-   Chọn và lọc các hàng bằng cách sử dụng đối số **i**
-   Sử dụng các hàm trợ giúp `%like%`, `%chin%`, `%between%`
-   Chọn và tính toán trên các cột bằng cách sử dụng đối số **j**
-   Tính toán theo nhóm bằng cách sử dụng đối số **by**
-   Thêm và cập nhật dữ liệu vào data table bằng cách sử dụng `:=`

<!-- ======================================================= -->

## Gọi package và nhập dữ liệu

### Gọi package {.unnumbered}

Sử dụng hàm `p_load()` từ **pacman**, chúng ta sẽ gọi (và cài đặt nếu cần) các package cần thiết cho phân tích này.

```{r}
pacman::p_load(
  rio,        # to import data
  data.table, # to group and clean data
  tidyverse,  # allows use of pipe (%>%) function in this chapter
  here 
  ) 
```

### Nhập dữ liệu {.unnumbered}

Chương này sẽ khám phá một số hàm cốt lõi của **data.table** thông qua bộ số liệu linelist đã được nhắc đền nhiều lần trong sổ tay này.

Chúng ta nhập bộ dữ liệu về các trường hợp từ một vụ dịch Ebola mô phỏng. Nếu bạn muốn tải dữ liệu để làm theo từng bước, hãy xem hướng dẫn trong chương [Tải sách và dữ liệu]. Bộ dữ liệu được nhập bằng hàm `import()` từ package **rio**. Xem chương về [Nhập xuất dữ liệu] để biết các cách nhập dữ liệu khác nhau. Từ đây chúng tôi sử dụng `data.table()` để chuyển data frame thành data table.

```{r}
linelist <- rio::import(here("data", "linelist_cleaned.xlsx")) %>% data.table()
```

Hàm `fread()` được sử dụng để nhập trực tiếp các delimited files phổ biến, chẳng hạn như tệp .csv, trực tiếp sang định dạng data table. Hàm này và đối tác của nó, `fwrite()`, được sử dụng để ghi data.table dưới dạng các delimited files phổ biến, là các tùy chọn rất nhanh và hiệu quả về mặt tính toán đối với cơ sở dữ liệu lớn.

20 hàng đầu tiên của `linelist`:

```{r message=FALSE, echo=F, eval=FALSE}
DT::datatable(head(linelist,20), rownames = FALSE, filter="top", options = list(pageLength = 5, scrollX=T), class = 'white-space: nowrap' )
```

Các lệnh base R như `dim()` được sử dụng cho data frame cũng có thể được sử dụng cho data table

```{r}
dim(linelist) #gives the number of rows and columns in the data table
```

<!-- ======================================================= -->

## Đối số i: chọn và lọc hàng

Nhắc lại cấu trúc **DT[i, j, by]**, chúng ta có thể lọc các hàng bằng cách sử dụng số hàng hoặc biểu thức logic. Đối số i là đối số đầu tiên; do đó, cú pháp **DT[i]** hoặc **DT[i,]** có thể được sử dụng.

Ví dụ đầu là việc truy xuất 5 hàng đầu tiên của data table, ví dụ thứ hai là tập hợp các trường hợp từ 18 tuổi trở lên và ví dụ thứ ba là tập hợp các trường hợp từ 18 tuổi trở lên nhưng không được chẩn đoán tại Bệnh viện Trung tâm (Central Hospital):

```{r, eval=F}
linelist[1:5] #returns the 1st to 5th row
linelist[age >= 18] #subsets cases are equal to or over 18 years
linelist[age >= 18 & hospital != "Central Hospital"] #subsets cases equal to or over 18 years old but not diagnosed at the Central Hospital

```

Sử dụng .N trong đối số i đại diện cho tổng số hàng trong data table. Điều này có thể được sử dụng để subset dữ liệu dựa trên số thứ tự hàng:

```{r, eval=F}
linelist[.N] #returns the last row
linelist[15:.N] #returns the 15th to the last row
```

### Sử dụng hàm trợ giúp để lọc {.unnumbered}

Data table sử dụng các hàm trợ giúp để việc subset các hàng trở nên dễ dàng. Hàm `%like%` được sử dụng để khớp với một pattern trong cột, `%chin%` được sử dụng để khớp với một ký tự cụ thể và hàm trợ giúp `%between%` được sử dụng để khớp các cột theo số thứ tự trong một phạm vi xác định trước.

Trong các ví dụ dưới đây, chúng ta: \* lọc các hàng mà biến hospital có chứa "Hospital" \* lọc các hàng có kết quả là "Recover" hoặc "Death" \* lọc các hàng trong độ tuổi 40-60

```{r, eval=F}
linelist[hospital %like% "Hospital"] #filter rows where the hospital variable contains “Hospital”
linelist[outcome %chin% c("Recover", "Death")] #filter rows where the outcome is “Recover” or “Death”
linelist[age %between% c(40, 60)] #filter rows in the age range 40-60

#%between% must take a vector of length 2, whereas %chin% can take vectors of length >= 1

```

## Đối số j: chọn và tính toán trên cột

Sử dụng cấu trúc **DT[i, j, by]**, chúng ta có thể chọn cột bằng cách sử dụng số hoặc tên. Đối số **j** là đối số thứ hai; do đó, cú pháp **DT[, j]** được sử dụng. Để tạo điều kiện tính toán trên đối số **j**, cột được bao quanh bằng cách sử dụng `list()` hoặc `.()`.

### Chọn cột {.unnumbered}

Ví dụ đầu tiên lấy các cột thứ nhất, thứ ba và thứ năm của data table, ví dụ thứ hai chọn tất cả các cột ngoại trừ các cột height, weight và gender. Ví dụ thứ ba sử dụng `.()` phía trước để chọn cột **case_id** và **outcome**.

```{r, eval=F}
linelist[ , c(1,3,5)]
linelist[ , -c("gender", "age", "wt_kg", "ht_cm")]
linelist[ , list(case_id, outcome)] #linelist[ , .(case_id, outcome)] works just as well

```

### Tính toán trên cột {.unnumbered}

Bằng cách kết hợp các đối số **i** và **j**, có thể lọc các hàng và tính toán trên các cột. Sử dụng **.N** trong đối số **j** cũng thể hiện cho tổng số hàng trong data table và có thể hữu ích để trả về số hàng sau khi lọc.

Trong các ví dụ dưới đây, chúng tôi: \* Đếm số trường hợp nằm viện trên 7 ngày \* Tính tuổi trung bình của các trường hợp tử vong tại military hospital  \* Tính toán độ lệch chuẩn, trung vị, tuổi trung bình của các trường hợp đã khỏi bệnh tại Central Hospital

```{r}
linelist[days_onset_hosp > 7 , .N]
linelist[hospital %like% "Military" & outcome %chin% "Death", .(mean(age, na.rm = T))] #na.rm = T removes N/A values
linelist[hospital == "Central Hospital" & outcome == "Recover", 
                 .(mean_age = mean(age, na.rm = T),
                   median_age = median(age, na.rm = T),
                   sd_age = sd(age, na.rm = T))] #this syntax does not use the helper functions but works just as well

```

Hãy nhớ rằng việc sử dụng .() bao quanh đối số j sẽ tạo điều kiện thuận lợi cho việc tính toán, trả về data table và cho phép đặt tên cột.

## Đối số by: tính toán theo nhóm

Đối số **by** là đối số thứ ba trong cấu trúc **DT[i, j, by]**. Đối số **by** chấp nhận cả vectơ ký tự và cú pháp `list()` hoặc `.()`. Sử dụng cú pháp `.()` trong đối số **by** cho phép đổi tên cột một cách nhanh chóng.

Trong các ví dụ dưới đây, chúng ta:\
\* nhóm số trường hợp theo bệnh viện \* trường hợp từ 18 tuổi trở lên, tính chiều cao và cân nặng trung bình theo giới tính và theo tình trạng hồi phục hay tử vong \* trong những lần nhập viện kéo dài trên 7 ngày, đếm số trường hợp theo tháng họ nhập viện và theo bệnh viện họ nằm

```{r}
linelist[, .N, .(hospital)] #the number of cases by hospital
linelist[age > 18, .(mean_wt = mean(wt_kg, na.rm = T),
                             mean_ht = mean(ht_cm, na.rm = T)), .(gender, outcome)] #NAs represent the categories where the data is missing
linelist[days_onset_hosp > 7, .N, .(month = month(date_hospitalisation), hospital)]

```

Data.table cũng cho phép các biểu thức chuỗi như sau:

```{r}

linelist[, .N, .(hospital)][order(-N)][1:3] #1st selects all cases by hospital, 2nd orders the cases in descending order, 3rd subsets the 3 hospitals with the largest caseload


```

Trong các ví dụ này, chúng ta đang tuân theo giả định rằng một hàng trong data table tương đương với một trường hợp mới, vì vậy chúng ta có thể sử dụng **.N** để thể hiện số hàng trong data table. Một hàm hữu ích khác thể hiện số lượng các trường hợp duy nhất là `uniqueN()`, hàm này trả về số lượng các giá trị duy nhất trong một đầu vào nhất định.

```{r}

linelist[, .(uniqueN(gender))] #remember .() in the j argument returns a data table

```

Đáp án là 3, vì các giá trị duy nhất trong cột gender là m, f và N/A. So sánh với hàm base R là `unique()`, trả về tất cả các giá trị duy nhất trong một đầu vào nhất định:

```{r}

linelist[, .(unique(gender))]
```

Để tìm số trường hợp duy nhất trong một tháng (month) nhất định, chúng tôi sẽ viết như sau:

```{r}

linelist[, .(uniqueN(case_id)), .(month = month(date_hospitalisation))]

```

## Thêm và cập nhật dữ liệu vào data table

Toán tử `:=` được sử dụng để thêm hoặc cập nhật dữ liệu trong data table. Việc thêm cột vào data table của bạn có thể được thực hiện theo những cách dưới đây:

```{r}

linelist[, adult := age >= 18] #adds one column
linelist[, c("child", "wt_lbs") := .(age < 18, wt_kg*2.204)] #to add multiple columns requires c("") and list() or .() syntax
linelist[, `:=` (bmi_in_range = (bmi > 16 & bmi < 40),
                         no_infector_source_data = is.na(infector) | is.na(source))] #this method uses := as a functional operator `:=`
linelist[, adult := NULL] #deletes the column

```

Các tổ hợp phức tạp hơn nằm ngoài phạm vi của chương giới thiệu này, nhưng ý tưởng của chương này là cung cấp một giải pháp thay thế phổ biến và khả thi cho **dplyr** để phân nhóm và làm sạch dữ liệu. Package **data.table** là một package tốt giúp code gọn gàng và dễ đọc.

## Tài nguyên học liệu

Để có thêm thông tin, dưới đây là một số tài nguyên hữu ích: \* <https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html> \* <https://github.com/Rdatatable/data.table> \* <https://s3.amazonaws.com/assets.datacamp.com/img/blog/data+table+cheat+sheet.pdf> \* <https://www.machinelearningplus.com/data-manipulation/datatable-in-r-complete-guide/> \* <https://www.datacamp.com/community/tutorials/data-table-r-tutorial>

Bạn có thể thực hiện bất kỳ chức năng tóm tắt nào trên dữ liệu được nhóm; xem Cheat Sheet tại đây để có thêm thông tin: [https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Shgiteet_R.pdf](https://s3.amazonaws.com/assets.datacamp.com/blog_assets/datatable_Cheat_Sheet_R.pdf){.uri}
```{r include=FALSE, cache=FALSE}

# clear workspace
rm(list = ls(all = TRUE))

# clear all packages except base
#lapply(names(sessionInfo()$loadedOnly), require, character.only = TRUE)
#invisible(lapply(paste0('package:', names(sessionInfo()$otherPkgs)), detach, character.only=TRUE, unload=TRUE, force=TRUE))

# to ensure that tidyverse packages prevail
filter <- dplyr::filter
select <- dplyr::select
summarise <- dplyr::summarise
summary <- base::summary
incidence <- incidence2::incidence

#load core packages
pacman::p_load(
     rio,
     here,
     DT,
     stringr,
     lubridate,
     tidyverse
)

# import the cleaned ebola linelist
linelist <- rio::import(here::here("data", "case_linelists", "linelist_cleaned.rds"))

# import the count data - facility level
#count_data <- rio::import(here::here("data", "facility_count_data.rds"))

# Settings

options(scipen=1, digits=7)

# print only text (not code)
#library(knitr)
#opts_chunk$set(list(echo = FALSE, eval = FALSE))
```

<!--chapter:end:new_pages/data_table.Rmd-->

